<!-- layout page -->
<!DOCTYPE html>
<html lang="zh">
  <!-- 头部信息 head&meta -->
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="X-UA-Compatible" content="ie=edge" />
  
  <title>「 设计模式学习 」 L00 开坑贴 &amp; 设计模式概览 | blog [ YOG WANG ]</title>
  <meta name="keywords" content="YogWang,blog,web-frontend" />
  <meta name="description" content="Here is my blog, my notes and some thoughts" />
  <meta name="author" content="YogWang" />
  
  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css">

<meta name="generator" content="Hexo 5.4.0"><link rel="stylesheet" href="/css/prism-base16-ateliersulphurpool.light.css" type="text/css"></head>

  <body>
    <!-- 页头 page header -->
<header id="header">
  <!-- 左侧图标 left logo -->
  <a class="header-sign" href="/">
    <img src="/favicon.png" alt="logo" />
    <span>YOG<br />WANG</span>
  </a>
  <!-- 头部菜单 header menu -->
  <nav class="header-navbar">
    
    <a class="nav-link" href="/archives">文章</a>
    
    <a class="nav-link" href="/about">我</a>
    
    <a class="nav-link" target="_blank" rel="noopener" href="https://github.com/yogwang">GitHub</a>
    
  </nav>
</header>

    <div id="wrap">
      <!-- 文章页 post detail page -->
<main id="container">
  <!-- 文章详情 Post Detail -->
<div
  id="post-design-pattern-learning-L00"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
>
  <div class="article-inner">
    <div class="article-meta">
      <div>
        
  <div class="article-category">
    <ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/">踩坑日记</a></li></ul>
  </div>

        
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag">学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8C%96%E5%9D%91/" rel="tag">挖坑</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>

      </div>
       
<div class="article-date">
  <time datetime="2020-11-24T16:10:59.000Z" itemprop="datePublished">2020-11-25</time>
</div>
    </div>
    
    <header class="article-header">
      
  
    <h1 class="article-title" itemprop="name">
      「 设计模式学习 」 L00 开坑贴 &amp; 设计模式概览
    </h1>
  

      <div class="article-updated">
        
        latest update：<time datetime="2021-05-29T03:30:09.609Z" itemprop="datePublished">2021-05-29 11:30</time>
        
      </div>
    </header>
    
    <div class="article-entry" itemprop="articleBody">
      <!-- 文章内容 article body -->
 
  <article class="article-content">
    <p>设计模式是我在2018年在成都工作的时候听 <a target="_blank" rel="noopener" href="https://blog.meathill.com/">肉山老师</a> 的直播<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1mW411Y71x">JavaScript 设计模式 导言</a>的时候就想学习的一个东西，但是一直拖拖拖，虽然后来买了肉老师的 Chat <a target="_blank" rel="noopener" href="https://gitbook.cn/gitchat/activity/5ccedbcfe5bb505613f45186">从 jQuery 里学习设计模式</a>，但是看了一头雾水，后来同样买了肉老师推荐的书《设计模式：可复用面向对象软件的基础》，也是在家里吃灰了半年多。<br>一直想把整个设计模式都了解一下，不用吃透大概明了就可以，但是每次都提不起开坑的念头，如果再写成学习笔记的话，学习周期会大大拉长。</p>
<p>这次在项目的不断迭代中，我遇到了一个问题，就是 <a href="/2020/JS-type-and-status-management-dictionary/">项目中的类型和状态管理</a>，所以就想着是否有一个合适的设计模式来解决问题，所以就被逼迫着捡起来了……</p>
<span id="more"></span>
<p>肉老师谈论如何学习设计模式的方法，和我的学习想法是类似的，不管是学习设计模式还是学习一个框架/库，先了解一个大概心里有一个底，然后在实际遇到问题的时候再去找文档来炒冷饭，我觉得这样会更清晰一些，但是他不推荐了解的那么多设计模式，只需要过一遍，等遇到了差不多的场景再去具体看适合哪一个。</p>
<p>《设计模式：可复用面向对象软件的基础》这本书是 1995 出版的，可能会有一些问题，或者有一些新的设计模式出现，但都不是问题，咱先把这本书内的 <code>23</code> 个设计模式了解，之后再看情况去了解新的内容。</p>
<p>所以这篇文章应该会陆陆续续的更新一些新内容，好了，在这篇标号 00 的笔记中我就以前端开发者的视角按照设计模式名称+概括+简单示例，来大概描述一下每种设计模式，如果有遇到可用场景时再深入的去记录。</p>
<p>这本书内把设计模式分成 <strong><code>三种类型</code>（ 创建型、结构形、行为型） 和 <code>二十三个模式</code></strong></p>
<h1 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h1><hr>
<h2 id="1-工厂方法-Factory-Method"><a href="#1-工厂方法-Factory-Method" class="headerlink" title="1. 工厂方法 Factory Method"></a>1. 工厂方法 <code>Factory Method</code></h2><blockquote>
<p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂模式使一个类的实例化延迟到其子类。</p>
</blockquote>
<p>工厂模式在实际应用中有很多，比如前端er最了解的 jQuery 中的 <code>$()</code> 方法<sub><a target="_blank" rel="noopener" href="https://api.jquery.com/jQuery/">查看文档</a></sub>，传入一个类名或者ID或者其它的值，返回回来一个DOM实例。中间的一些过程就不需要关注了，直接使用 <code>$()</code> 方法就会必定返回一个DOM实例。<br>讲人话，就是传入一些值，返回一个符合预期的结果。</p>
<h2 id="2-抽象工厂-Abstract-Factory"><a href="#2-抽象工厂-Abstract-Factory" class="headerlink" title="2. 抽象工厂 Abstract Factory"></a>2. 抽象工厂 <code>Abstract Factory</code></h2><blockquote>
<p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p>
</blockquote>
<p>抽象工厂模式是一个比较复杂的创建型模式，如果用最简单的话来说，可以描述成基于一组工厂方法，传入数据之后返回一个复杂对象，中间的步骤不需要关注。<br>有点类似于Vue中的高阶组件中包含了很多子组件和一些其它元素最后展现出一个渲染结果。<br>用廖雪峰老师的例子来举例就很容易让人明白 <a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1281319134822433">我们希望为用户提供一个Markdown文本转换为HTML和Word的服务 - 抽象工厂</a>，虽然示例是Java，但是不影响理解。</p>
<h2 id="3-生成器-Builder"><a href="#3-生成器-Builder" class="headerlink" title="3. 生成器 Builder"></a>3. 生成器 <code>Builder</code></h2><blockquote>
<p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
</blockquote>
<p>生成器模式，有些地方也叫建造者模式，用简单的话来概括就是传入一个或者一组数据，最后拼接返回一个结果，用Vue来举例的话就有点像 <code>Reander</code> 函数。<br>乍一看可能和抽象工厂很像，对确实很像，他们都是基于工厂模式的扩展，主要的区别就是抽象工厂模式对于中间的数据没有要求，而生成器重点关注如何分步生成复杂对象。</p>
<p><code>争议</code> 这边的具体区别我还没有彻底弄明白确实需要整理之后来区别一下。具体得等这篇文章最后了。</p>
<h2 id="4-原型模式-Prototype"><a href="#4-原型模式-Prototype" class="headerlink" title="4. 原型模式 Prototype"></a>4. 原型模式 <code>Prototype</code></h2><blockquote>
<p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
</blockquote>
<p>这个在Javascript中并不需要多理解，因为Js中每个数据类型都是对象，都拥有一个 <code>prototype</code> 属性，当然你也可以自己用代码来实现自己得原型模式其实显得很奇怪。大概可以用构造函数的视角来理解，只不过<strong>构造函数生成的实例对象</strong>的属性都是独立的，所以引入了 <code>prototype</code> 属性，来做到<strong>数据共享</strong>(修改其中一个，影响到其它所有)。<br>同样JS有提供一个原生的实现 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create">Object.create()</a></p>
<h2 id="5-单例模式-Singleton"><a href="#5-单例模式-Singleton" class="headerlink" title="5. 单例模式 Singleton"></a>5. 单例模式 <code>Singleton</code></h2><blockquote>
<p>保证一个类仅有一个实例，并提供一个访问它的全局访问点</p>
</blockquote>
<p>类似于 <code>window</code> 对象，<strong>全局确保只有一个</strong>我们可以使用的 <code>window</code> 实例。<br>具体业务使用场景中，<code>Vuex</code> 也是单例模式，全局只会有一个Store实例来供用户去读取和修改。</p>
<p>我在查阅资料的时候稍微看到了还有人提到 <code>惰性单例模式</code>，这个之后再去了解</p>
<h1 id="结构形"><a href="#结构形" class="headerlink" title="结构形"></a>结构形</h1><hr>
<h2 id="1-适配器-Adapter"><a href="#1-适配器-Adapter" class="headerlink" title="1. 适配器 Adapter"></a>1. 适配器 <code>Adapter</code></h2><blockquote>
<p>将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
</blockquote>
<p>适配器模式的话，我们可以这样来理解，很多时候我们不确定客户端浏览器是否支持我们所使用的API，这个时候就会写兼容，大概来写一个伪代码段来举例</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> <span class="token function-variable function">getByClass</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">className</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
  <span class="token keyword">if</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span>querySelector<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span>className<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> document<span class="token punctuation">.</span><span class="token function">getElementsByClassName</span><span class="token punctuation">(</span>className<span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>就是那么简单，虽然有点强行解释，但这个就是适配器….</p>
<h2 id="2-桥接-Bridge"><a href="#2-桥接-Bridge" class="headerlink" title="2. 桥接 Bridge"></a>2. 桥接 <code>Bridge</code></h2><blockquote>
<p>将抽象部分与它的实现部分分离，使它们都可以独立地变化</p>
</blockquote>
<p>这个我本来想用 UI 库中的 <code>Notification</code> 组件来举例的，因为只需要调用 <code>notification[type].open(&#123;config&#125;)</code> 函数传入几个参数就可以展现出不同的消息通知栏了，</p>
<p>但是隔了一天之后发现拿这个例子来讲好像不是很的能解释<code>抽象</code>和<code>实现</code>的分离，所以我用系统中的画图附件来举例会好理解很多。</p>
<p>在画版中会有很多不同的 <code>工具</code>，比如说<strong>画笔</strong>，<strong>图形</strong>和<strong>文字</strong>等，同样他们都有<strong>颜色</strong>、<strong>大小</strong>这些个 <code>属性</code>，<br>我们在使用的时候只需要选择 <code>工具</code> ，然后选择 <code>属性</code> 就可以绘制出我们所需要的结果了。</p>
<p>我们可以 <strong>单独</strong> 的去 <strong>变化组合</strong> 工具、属性，并不会出现红色画笔和黑色画笔这种 <strong>带有属性的工具</strong>（没有强耦合），<br>如果后期扩展了新得工具只要单独增加新工具的业务逻辑就行，不需要去关注它的大小和颜色这些属性，同样增加新属性的时候也同理。</p>
<h2 id="3-组合-Composite"><a href="#3-组合-Composite" class="headerlink" title="3. 组合 Composite"></a>3. 组合 <code>Composite</code></h2><blockquote>
<p>将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</p>
</blockquote>
<p>组合模式简单来说具有统一接口的一组树形结构。父级和子级拥有相同的接口，比如系统的文件管理，<br>每个文件夹都可以包含具体文件和文件夹，并且每个文件/文件夹都有类似的功能，比如说创建/删除/重命名。<br>在执行删除功能的时候开始递归执行子级的删除操作，每个子级都被删除后执行父级的删除操作。</p>
<h2 id="4-装饰-Decorator"><a href="#4-装饰-Decorator" class="headerlink" title="4. 装饰 Decorator"></a>4. 装饰 <code>Decorator</code></h2><blockquote>
<p>动态地给一个对象添加一些额外的职责。就增加功能来说，相比生成子类更为灵活。</p>
</blockquote>
<p>一般来说我们都会直接想到使用类的继承，然后在子类上附加新的功能，但是继承为类引入静态特征，并且随着扩展功能的增多，子类就会爆炸式增长。所以我们不想增加很多子类的情况下扩展类，就会用到装饰器模式。</p>
<p>看到一个很形象的比喻，现在UI库中的表单组件的表单验证，在不同的表单组件上使用不同的校验规则，而且并不影响组件本身，只是在提交之前额外调用了传入的校验函数。</p>
<h2 id="5-外观-Facade"><a href="#5-外观-Facade" class="headerlink" title="5. 外观 Facade"></a>5. 外观 <code>Facade</code></h2><blockquote>
<p>为子系统中的一组接口提供一个一致的界面。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p>
</blockquote>
<p>简单概括就是，在日常工作中会编辑出来很多子功能，这些子功能只有你清楚，如果你想给同事使用，就可以l考虑外观模式，整合起来并且开放一个相对统一的调用接口。</p>
<h2 id="6-享元-Flyweight"><a href="#6-享元-Flyweight" class="headerlink" title="6. 享元 Flyweight"></a>6. 享元 <code>Flyweight</code></h2><blockquote>
<p>运用共享技术有效地支持大量细粒度的对象。</p>
</blockquote>
<p>享元模式的话，我描述一个场景来帮助理解，比如说现在有一个气球里边装了几千个小球，这些小球材质大小一致，并且有三种颜色，如果我们为每一个气球都船舰一个对象，就会浪费大量的内存，这个时候我们就可以把相同的材质和大小和颜色提取出来，通过外部引用或者继承的方式来共享这些属性。</p>
<h2 id="7-代理-Proxy"><a href="#7-代理-Proxy" class="headerlink" title="7. 代理 Proxy"></a>7. 代理 <code>Proxy</code></h2><blockquote>
<p>为其他对象提供一种代理以控制对这个对象的访问。</p>
</blockquote>
<p>这个的话，学习过Vue的前端就很清晰了，Vue对一些数据的操作进行了代理，去检查是否需要更新视图。<br>ES6中也新增了 <a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/proxy">Proxy</a> 这个API，并且Vue3中使用 <code>Proxy</code> 代替了 <code>defineProperty</code>。</p>
<h1 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h1><hr>
<h2 id="1-职责链-Chain-of-Responsibility"><a href="#1-职责链-Chain-of-Responsibility" class="headerlink" title="1. 职责链 Chain of Responsibility"></a>1. 职责链 <code>Chain of Responsibility</code></h2><blockquote>
<p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p>
</blockquote>
<p>简短的来说就是分工合作，比如说工厂的流水线，每一个工作站都有自己的工作，完成自己的工作（加工/质检）之后通过传输带到下一个工作站进行处理，最后出厂一个成品的手机。 </p>
<h2 id="2-命令-Command"><a href="#2-命令-Command" class="headerlink" title="2. 命令 Command"></a>2. 命令 <code>Command</code></h2><blockquote>
<p>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。</p>
</blockquote>
<p>设计思想是把命令拆分开来，创建和执行分离，使得调用者无需关心具体的执行过程，大概是，每天中午点餐的时候只要和老板娘喊一嗓子炒年糕，一会老板就会端出来一盆炒年糕。</p>
<h2 id="3-解释器-Interpreter"><a href="#3-解释器-Interpreter" class="headerlink" title="3. 解释器 Interpreter"></a>3. 解释器 <code>Interpreter</code></h2><blockquote>
<p>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p>
</blockquote>
<p>快速的话可以理解成 正则，把一系列复杂的规则判断用简单的语句实现。</p>
<h2 id="4-迭代器-Iterator"><a href="#4-迭代器-Iterator" class="headerlink" title="4. 迭代器 Iterator"></a>4. 迭代器 <code>Iterator</code></h2><blockquote>
<p>提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。</p>
</blockquote>
<p>这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。可以用对象的 <code>Object.entries()</code> 方法来理解。每一个对象都有它自己的迭代方法，你不需要知道它具体有哪些属性，它可以按照顺序去输出对象的内部元素。</p>
<h2 id="5-中介者-Mediator"><a href="#5-中介者-Mediator" class="headerlink" title="5. 中介者 Mediator"></a>5. 中介者 <code>Mediator</code></h2><blockquote>
<p>用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p>
</blockquote>
<p><code>MVC</code> 框架中的 <code>C</code>（控制器），它就是用来控制 M（模型）和 V（视图）的中介者。</p>
<h2 id="6-备忘录-Memento"><a href="#6-备忘录-Memento" class="headerlink" title="6. 备忘录 Memento"></a>6. 备忘录 <code>Memento</code></h2><blockquote>
<p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</p>
</blockquote>
<p>一般来描述这个模式都是举例文本编辑器的撤销功能，并且可以一直退回到空白文本的状态，其它的类似还有，浏览器的后退前进，数据库的事务回滚等等。<br>保持对象的状态，并且可以在调用组件生命周期内持久保存这些快照。</p>
<h2 id="7-观察者-Observer"><a href="#7-观察者-Observer" class="headerlink" title="7. 观察者 Observer"></a>7. 观察者 <code>Observer</code></h2><blockquote>
<p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>
</blockquote>
<p>这个直接用Vue来举例吧，<code>data</code> 内 <strong>声明</strong> 的变量被修改时，会自动通知UI更新。<br>最直接可以看到的就是每一个在<code>data</code>内声明的变量都会有一个 <code>__ob__</code> 对象。<br>观察者模式和中介者模式其实非常的相似，只不过这里的 “中介者/订阅者” 就是观察者</p>
<h2 id="8-状态-State"><a href="#8-状态-State" class="headerlink" title="8. 状态 State"></a>8. 状态 <code>State</code></h2><blockquote>
<p>允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。</p>
</blockquote>
<p>可以描述一个应用场景，在一个后台管理系统中，一定会有审核相关的部分，每一条不同状态的记录都会对应不同的操作，这边就会适合状态模式的应用。</p>
<h2 id="9-策略-Strategy"><a href="#9-策略-Strategy" class="headerlink" title="9. 策略 Strategy"></a>9. 策略 <code>Strategy</code></h2><blockquote>
<p>定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。</p>
</blockquote>
<p>也描述一个应用场景吧，比如你现在老板给你一个任务，让你做一个根据职位、绩效、考勤和工资自动计算奖金的程序，不同的职务有不同的标准，不同的绩效等级也会影响奖金系数。<br>一开始你可以使用 <code>if...else</code>，去判断不同的场景，随着需求变化，代码不断调整，越来越臃肿。代码几乎不能维护，因为你根本不知道这里的一处改动会对后面造成什么样的影响。<br>这时候可以使用策略模式来更具不同的条件执行不同的业务逻辑。</p>
<h2 id="10-模板方法-Template-Method"><a href="#10-模板方法-Template-Method" class="headerlink" title="10. 模板方法 Template Method"></a>10. 模板方法 <code>Template Method</code></h2><blockquote>
<p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
</blockquote>
<p><small><em>在面向对象程序设计过程中，程序员常常会遇到这种情况：设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但某些步骤的具体实现还未知，或者说某些步骤的实现与具体的环境相关。</em></small></p>
<p>这个很容易解释，我们所熟悉的 <code>Ajax</code> 函数就是，基本流程都确定，只需要接受 <strong>URL 地址</strong> 和 <strong>Settings 对象</strong> 就可以，再把需要执行的操作放在回调函数里。<br>它封装了不变部分，扩展可变部分。在父类中提取了公共的部分代码，便于代码复用，而把可变部分算法由子类继承实现，便于子类继续扩展。</p>
<h2 id="11-访问者-Visitor"><a href="#11-访问者-Visitor" class="headerlink" title="11. 访问者 Visitor"></a>11. 访问者 <code>Visitor</code></h2><blockquote>
<p>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p>
</blockquote>
<p><small><em>核心思想是为了访问比较复杂的数据结构，不去改变数据结构，而是把对数据的操作抽象出来，在“访问”的过程中以回调形式在访问者中处理操作逻辑。</em></small></p>
<p>这个还没有想到合适的场景，大概就是说 有一个稳定的数据结构，但是需要实现的功能并不确定，针对不同的访问者有不同的行为职责。<br>感觉有点类似命令模式，命令模式Plus？</p>
<hr>
<br>
<br>
<br>



<p>不断了解各种设计模式的的时候，发现其实不同的设计模式之间可能并没有很明确的界限，并且这些传统的设计模式在前端工作中很多都使用不上，应该可以简略成几个模式即可，不需要每一个都了解，反而可能影响自己的认知。</p>
<h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><p><a target="_blank" rel="noopener" href="http://product.dangdang.com/27875838.html">《设计模式：可复用面向对象软件的基础》</a><br><a target="_blank" rel="noopener" href="https://refactoringguru.cn/design-patterns">《深入设计模式》一本关于设计模式及其背后原则的电子书籍</a><br><a target="_blank" rel="noopener" href="https://weread.qq.com/web/reader/6bf3215071a123016bf0b74kc81322c012c81e728d9d180">JavaScript设计模式与开发实践 - 曾探</a><br><a target="_blank" rel="noopener" href="https://www.runoob.com/design-pattern/design-pattern-tutorial.html">设计模式 | 菜鸟教程</a><br><a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1264742167474528">设计模式 - 廖雪峰</a><br><a target="_blank" rel="noopener" href="https://gitbook.cn/gitchat/activity/5ccedbcfe5bb505613f45186">从 jQuery 里学习设计模式 - Meathill</a><br><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html">Javascript继承机制的设计思想 - 阮一峰</a><br><a target="_blank" rel="noopener" href="https://www.bookstack.cn/books/design-pattern-in-javascript">JavaScript中的设计模式</a></p>
 
  </article>


    </div>
  </div>
   
<nav id="article-nav">
  
    <a href="/2021/about-emotional-blackmail/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">关于情感勒索与关系依存自尊者</div>
    </a>
  
  
    <a href="/2020/JS-type-and-status-management-dictionary/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">项目中的类型和状态管理</div>
    </a>
  
</nav>
 
</div>
</main>
<!-- 侧边栏 sidebar -->
<aside id="sidebar">
  
    
<!-- 个人信息 author -->
<section class="widget-wrap author-info">
    <img class="author-info-avatar" src="https://yogwang.site/img/userimg.jpg" alt="陟上晴明">
    <h2 class="author-info-nickname">陟上晴明</h2>
    <span class="author-info-bio">久之须自见得</span>
    <p class="author-info-txt">ODIN.INC</p>
    <p class="author-info-txt">Jiaxing,China</p>
    <div class="author-info-follow">
      
      <a class="fa fa-github author-info-follow-item" href="https://github.com/yogwang" target="_blank"></a>
      
      <a class="fa fa-weibo author-info-follow-item" href="http://weibo.com/yooooooge" target="_blank"></a>
      
    </div>
</section>

  
    
  <!-- 分类菜单 category menu -->
  <section class="widget-wrap shortcut-menu">
    
      <a href="/categories/前端分享/" class="shortcut-menu-item" >前端分享</a>
    
      <a href="/categories/工作延伸/" class="shortcut-menu-item" >工作延伸</a>
    
      <a href="/categories/踩坑日记/" class="shortcut-menu-item active" >踩坑日记</a>
    
      <a href="/categories/生活杂谈/" class="shortcut-menu-item" >生活杂谈</a>
    
  </section>


  
    
<!-- 最近发布 recent posts -->
  <section class="widget-wrap shadow">
    <h3 class="widget-title">Recent posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/use-gap-in-flex-layout/">在 Flex 布局中使用 gap 属性</a>
          </li>
        
          <li>
            <a href="/2021/hexo-theme-edit/">Hexo 主题开发</a>
          </li>
        
          <li>
            <a href="/2021/JS-proto-and-prototype/">原型链！ __proto__ 与 prototype</a>
          </li>
        
          <li>
            <a href="/2021/JS-what-dose-new-operators-do/">JS中的 new 关键字做了什么？</a>
          </li>
        
          <li>
            <a href="/2021/miniprogram-devDiary-05-authorize/">微信小程序学习日记 L05 拉起授权</a>
          </li>
        
      </ul>
    </div>
  </section>

  
    
  <!-- 标签列表 tags list -->
  <section class="widget-wrap shadow">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ant-Design-Vue/" rel="tag">Ant-Design-Vue</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Apache/" rel="tag">Apache</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Axios/" rel="tag">Axios</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BetterScrol-js/" rel="tag">BetterScrol.js</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a><span class="tag-list-count">14</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Caddy/" rel="tag">Caddy</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Canvas/" rel="tag">Canvas</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Chrome/" rel="tag">Chrome</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Coding/" rel="tag">Coding</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DigitalOcean/" rel="tag">DigitalOcean</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ECMAScript-6/" rel="tag">ECMAScript 6</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ESlint/" rel="tag">ESlint</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Electron/" rel="tag">Electron</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Github/" rel="tag">Github</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gulp/" rel="tag">Gulp</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a><span class="tag-list-count">24</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jeecg-boot/" rel="tag">Jeecg-boot</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NVM/" rel="tag">NVM</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/" rel="tag">Node.js</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PHP/" rel="tag">PHP</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PHPOK/" rel="tag">PHPOK</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RaspberryPi/" rel="tag">RaspberryPi</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ReactJS/" rel="tag">ReactJS</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Server/" rel="tag">Server</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Three-js/" rel="tag">Three.js</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TypeScript/" rel="tag">TypeScript</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue-Router/" rel="tag">Vue-Router</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VueJS/" rel="tag">VueJS</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebSocket/" rel="tag">WebSocket</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Webpack/" rel="tag">Webpack</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tinyMCE/" rel="tag">tinyMCE</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web/" rel="tag">web</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag">学习</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/" rel="tag">小程序</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B4%E4%BC%9A%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0/" rel="tag">年会开发日记</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%BB%E7%BB%93/" rel="tag">总结</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%83%85%E6%84%9F/" rel="tag">情感</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8C%96%E5%9D%91/" rel="tag">挖坑</a><span class="tag-list-count">16</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%AA%E5%AE%8C%E6%88%90/" rel="tag">未完成</a><span class="tag-list-count">12</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A4%BE%E7%BE%A4%E5%88%86%E4%BA%AB/" rel="tag">社群分享</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%97%AE%E9%A2%98/" rel="tag">问题</a><span class="tag-list-count">3</span></li></ul>
    </div>
  </section>

  
    
<!-- 文档归档 posts archives -->
  <section class="widget-wrap shadow">
    <h3 class="widget-title">Archive</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li></ul>
    </div>
  </section>


  
</aside>
    </div>
    <!-- 页尾 page foot -->
<footer id="footer">
  <!-- licensed -->
  <p>
    All articles in this blog are licensed under <a href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a> unless stating additionally.
  </p>
  <!-- copyright -->
  <p>
    &copy;2021 YogWang
    Powered By <a href="http://hexo.io/" target="_blank">Hexo</a>
    
  </p>
  <br />
  <!-- go top -->
  <a id="gotop" class="fa fa-level-up"></a>
</footer>

<script src="https://unpkg.com/jquery@3.4.1/dist/jquery.js"></script>


<script src="/js/common.js"></script>


  </body>
</html>
