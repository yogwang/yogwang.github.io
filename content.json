{"meta":{"title":"blog [ YOG WANG ]","subtitle":"blog","description":"Here is my blog, my notes and some thoughts","author":"YogWang","url":"https://yogwang.site","root":"/"},"pages":[{"title":"我","updated":"2021-05-27T10:15:09.325Z","comments":true,"path":"about/index.html","permalink":"https://yogwang.site/about/index.html","excerpt":"","text":"我是 王阳阳 ，英文名 YogWang （本来是叫 Yoge 阳，直到有天遇到一只狗子它叫 Yoge …） 准备在博客中记录我的日常学习和遇到的一些问题，希望不要烂尾 23333。 18，19 年在成都和重庆生活过，可惜没能学会四川话。 现在生活在党的诞生地 嘉兴 。 装过监控、修过电脑、烤过蛋糕，目前从事老本行 —— 前端工作，偶尔接受产品外包。 之前大部分时间钻研在 CSS 部分，偶尔用一用 PHP ，从 19 年初开始接触 SPA 项目，So 现在的主要技术栈为 VueJS 全家桶，并且使用 VS Code Coding，Git 作为个人项目版本管理，公司项目使用 SVN 2020 年正在计划学习 TypeScript 和 React ，并且希望在今年使用 React &amp; TypeScript （如果下半年能 Vue 3.0 能更新就用 VueJS 3.0 &amp; TypeScript）制作一个 SideProject。 也许你可以在这些地方看到我： SegmentFault 新浪微博 知乎 网易云音乐"}],"posts":[{"title":"分享会 只用CSS实现轮播图","slug":"CSS-only-carousel","date":"2021-08-06T07:22:36.000Z","updated":"2021-09-18T12:35:42.584Z","comments":true,"path":"2021/CSS-only-carousel/","link":"","permalink":"https://yogwang.site/2021/CSS-only-carousel/","excerpt":"早些时候有看到过一个 纯CSS轮播图 的文章，当时有研究过实现，大概是利用了 hash (锚标记) 和 scroll-snap 来实现的，但是具体实现已经回忆不起来了。 正好现在分享群组里边暂时没有主题了，就想着可以当成一个常驻的补位小环节，大家一起浏览 CodePen 之类的社区找一个大家都感兴趣的 Demo 来研究。在分享前还是需要自己重新研究一遍的，不然在讲述的时候出错可太 “甜蜜的” 尴尬了。","text":"早些时候有看到过一个 纯CSS轮播图 的文章，当时有研究过实现，大概是利用了 hash (锚标记) 和 scroll-snap 来实现的，但是具体实现已经回忆不起来了。 正好现在分享群组里边暂时没有主题了，就想着可以当成一个常驻的补位小环节，大家一起浏览 CodePen 之类的社区找一个大家都感兴趣的 Demo 来研究。在分享前还是需要自己重新研究一遍的，不然在讲述的时候出错可太 “甜蜜的” 尴尬了。 首先呢，先实现一个简易的的可控轮播示例 在样例的实现中我将会使用到一下技术栈，希望你可以稍微了解一下 Pug (HTML预处理器) Stylus (CSS预处理器) P.S. 以下笔记内容将逐步实现目标文章示例，会复原目标文章内的元素样式，稍微有点改动但变化不大，因为自己想的样式太丑了。 讲解：可以点开上方示例中的选项卡查看实现代码， 在 html 中书写了 5 个 &lt;div 并且声明了对应的 ID； 并且在后续添加了 &lt;a&gt; 标签来改变URL当中的 hash 值来控制卡片的切换； 在 css 利用 scroll-behavior:smooth 这个属性，来达到切换卡片的平滑滚动效果。 但是缺少了切换前进后退按钮，接下来我们就来实现这个功能 讲解:其实很憨，直接为每一个卡片添加了前进后退按钮的 &lt;a&gt; 标签而已。稍微有点麻烦的就是 如何让这两个按钮随着卡片的切换而改变，而不被后一个卡片的按钮所覆盖，因为这两个按钮是不会随着卡片切换所移动的，这里就需要脑洞大开了！ 正常思路来说，肯定是会尝试修改 前进后退按钮 的父级的定位方式。确实，会需要修改成 position:relative，但是这个其实是为了每次切换卡片后变更对应的锚链接的。 原示例是从轮播组件的最外层容器创建了 ::before 和 ::after 两个伪类，给他们设置的切换按钮的样式，并且设置为点击穿透，然后把轮播卡片内的 前进后退按钮 为 透明 底色。这样所展示的 “按钮” 就不会随卡片所以移动了，而实际的切换按钮会随着卡片所移动，只是不会被浏览者发现。 功能基本实现了，然后我们复原一下原示例的样式。 对照一下原示例，除了自动播放外还差了些什么呢？emmmm…..自动播放！ 💥 尾关BOSS 💥 自动轮播最后来看一下她是如何实现自动播放的，这里的实现方式如果他不讲我直接就蒙圈了，但是确实很赞！👍 First I slowly offset the scroll snap points to the right, making the scroll area follow along due to being snapped to them.首先我缓慢地将滚动捕捉点向右偏移，使滚动区域由于捕捉它们而跟随。 After having scrolled the width of a whole slide, I deactivate the snapping. The scroll area is now untied from the scroll snap points.在滚动整个幻灯片宽度后，我停用了捕捉。 滚动区域现在与滚动捕捉点解除绑定。 Now I let the scroll snap points jump back to their initial positions without them “snap-dragging” the scroll area back with them现在我让滚动捕捉点跳回到它们的初始位置，而不用它们 “捕捉拖动” 滚动区域 Then I re-engage the snapping which now lets the scroll area snap to a different snap point 🤯然后我重新启用捕捉，让滚动区域捕捉到不同的捕捉点 看起来有点不易懂，但是其实并不复杂的。 其实就是利用了 scroll-snap 会使滚动容器的捕捉点变更为你设定的元素对齐位置(scroll-snap-align)，然后通过修改 left 属性值使滚动容器向右滚动实现向后滚动的效果，然后通过修改当前元素的对齐位置为 none, 让滚动容器捕捉到下一个元素的对齐位置，以此来达到自动轮播的效果，那么让我们来实现一下吧！ 但是我还没有增加悬停停止自动轮播和一些其他的优化，有兴趣的可以自己实现一下，用到的CSS属性： @media (hover: hover) - CSS | MDN :focus-within - CSS | MDN prefers-reduced-motion - CSS | MDN 完整复现一下原示例吧！ 尾声其实一开始我是不知道他如何实现的视差滚动的，结果在研究自动轮播的时候，突然就通了，所以就加上来了 通过 transform:translate3d() 给中间的元素，增加了 Z轴 属性，使其脱离了平面 “悬浮” 在轮播卡片上，然后在最外层容器的 “轮播器” 设置了 perspective 指定了容器平面与 视窗 的 Z轴 距离。 但是有点问题，只有在自动播放动画执行时才会体现出来，手动控制切换是感觉不出来的，因为手动滚动时无法应用 scroll-snap。 ⚡ 兼容性 什么？你问我兼容性？友尽了啊！ 别想了，scroll-snap 属性都是 CR 阶段，也就是候选，具体正式上线还有2个阶段要走，并且scroll-behavior (平滑滚动)属性 Safari 是不支持的， “scroll-behavior” | Can I use“scroll-snap” | Can I use 所以移动端的兼容有很大问题，毕竟还有一个毒瘤 —— 微信内置浏览器，也是不支持这些属性的,我在制作的过程中都没有考虑过移动端的适配，直接放弃了，PC端还是可以玩玩的。 自动轮播实现不了，那么视差滚动也就没办法实现了， 闹这么大一圈，其实就是个图个乐子，不过尝一下鲜，学习到别人的脑洞就好了。 文档链接scroll-behavior - CSS | MDNperspective - CSS | MDNscroll-snap-type - CSS | MDNscroll-snap-align - CSS | MDNhover - CSS | MDN:focus-within - CSS | MDNprefers-reduced-motion - CSS | MDN CSS-Only Carousel | CSS-TricksYou can get pretty far in making a slider with just HTML and CSS | CSS-Tricks大侠，请留步，要不过来了解下CSS Scroll Snap？ « 张鑫旭-鑫空间-鑫生活1","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://yogwang.site/tags/CSS/"},{"name":"社群分享","slug":"社群分享","permalink":"https://yogwang.site/tags/%E7%A4%BE%E7%BE%A4%E5%88%86%E4%BA%AB/"}]},{"title":"网页链接里的 noopener、noreferrer 和 nofollow","slug":"rel-value-noopener-noreferrer-nofollow","date":"2021-08-05T09:39:56.000Z","updated":"2021-09-09T09:46:13.384Z","comments":true,"path":"2021/rel-value-noopener-noreferrer-nofollow/","link":"","permalink":"https://yogwang.site/2021/rel-value-noopener-noreferrer-nofollow/","excerpt":"之前在一篇 帖子 中看到了一个名词 【阻断权重传递】，进而去了解一下这个名词。 阅读相关资料的过程中，收集了3个 no 开头的关键词(noopener、noreferrer 和 nofollow)，并且作为相似内容整理成这篇笔记。 太长不看版： noopener: 使用target=&quot;_blank&quot;所打开的页面，将无法获取 window.opener 对象。 noreferrer: 使打开的页面无法获取 document.referrer 信息。 nofollow: 表明对该链接不认可，不传递权重。 如果有兴趣可以接着看下去","text":"之前在一篇 帖子 中看到了一个名词 【阻断权重传递】，进而去了解一下这个名词。 阅读相关资料的过程中，收集了3个 no 开头的关键词(noopener、noreferrer 和 nofollow)，并且作为相似内容整理成这篇笔记。 太长不看版： noopener: 使用target=&quot;_blank&quot;所打开的页面，将无法获取 window.opener 对象。 noreferrer: 使打开的页面无法获取 document.referrer 信息。 nofollow: 表明对该链接不认可，不传递权重。 如果有兴趣可以接着看下去 先顺着开头的 阻断权重传递 聊聊叭，老前端都知道，如果要做SEO，就会需要投放大量的站外链接到自己的站点，作为引流以及获得权重。在开发者社群中，也会相互交换友链来达到这个目的。但是在一些比较大型的社交平台中，他们并不希望这些链接被搜索引擎的 spider 所爬取，并且将权重传递给那些可能是低质量/违法的页面。 开头那篇帖子中提到的 “安全中心” 就是为了达到上述目的，我们可以从案例 “知乎” 当中看到 UGC 中的外链其实是这样的： &lt;a href=\"http://link.zhihu.com/?target=https%3A//yogwang.site\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\" data-za-detail-view-id=\"1234\">一个测试外链&lt;/a> 我们添加的外链其实已经变成了指向到 “安全中心” 页面，彻底就封死了权重传递的问题，并且避免了直接跳转链接导致的意外的安全问题，比如说钓鱼网站以及不合规内容的免责。 🔖 nofollow告知搜索引擎这是一个不被认可的链接，并且不想把权重传递给此页面。( P.S. 其实就算使用了 nofollow 其实也并不是完全没有排名影响，具体可以查看 这篇文章 其中有举了例子) 🔖 noreferrer这个值其实已经在上边的 “安全中心” 链接当中看到了这个属性的出现，起到的 目的 也就是为了去除头部中的 referrer (来源)信息，说是另外限制了部分 window.opener 的访问权限，但是我感觉和没有限制一样。 🔖 noopener声明在新页面中打开页面，并且不授权新页面对于源页面的访问权限，但是仍提供 referrer 头，所以一般来说会和 noreferrer 合用。 因为通过 target=&quot;_blank&quot; 打开的新页面可以通过修改 window.opener 的部分属性来造成安全问题。 Using the window.opener.location it navigates to the new site – say, a login form emulating the Facebook login screen with a message: “Your previous Facebook session expired. Please log in again to continue using Facebook”.使用 window.opener.location 导航到新站点 ———— 比如说，一个模拟 Facebook 登录屏幕的登录表单，其中包含一条消息：“您之前的 Facebook 会话已过期。 请重新登录以继续使用 Facebook”。 Explained: noopener, noreferrer, and nofollow Values 附 在 Chrome 78 最近的几个版本，如果A、B页面跨域，A页面中打开B页面，在B页面使用 console.log 在控制台打印 window.opener 会报跨域的错误。window.opener - Web API 接口参考 | MDN 并且我发现在 Chrome 93 中打开新页面中输出 window.opener 为 null，即使我没有使用 noopener，需要特意声明 rel=&quot;opener&quot; 才可以获取 opener 对象，但是我还没有找到明确的变更日志，只在后续的查阅的过程中找到一个疑似的工作组 PR。 Make target=_blank imply noopener; support opener by annevk · Pull Request #4330 · whatwg/html 参考资料HTML attribute: rel - HTML: HyperText Markup Language | MDNLink types: noopener - HTML: HyperText Markup Language | MDN What Is a Nofollow Link? Here’s A Simple Plain English AnswerExplained: noopener, noreferrer, and nofollow Values - Point Jupiter外链用了 target=”_blank” 结果悲剧了 | 1024译站The Hidden Dangers You Have Never Noticed: target = “_blank” and “opener” - TutorialDocsWhen to use target=”_blank” | CSS-TricksAbout rel=noopener","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://yogwang.site/tags/HTML/"},{"name":"SEO","slug":"SEO","permalink":"https://yogwang.site/tags/SEO/"}]},{"title":"使用属性选择器为 Markdown 里的图片添加样式","slug":"CSS-use-attribute-selector-add-style-to-the-image","date":"2021-08-03T07:23:58.000Z","updated":"2021-08-08T03:37:15.147Z","comments":true,"path":"2021/CSS-use-attribute-selector-add-style-to-the-image/","link":"","permalink":"https://yogwang.site/2021/CSS-use-attribute-selector-add-style-to-the-image/","excerpt":"在写 上一篇文章 的时，文章开头有一张示例图，为了节省空间，我用的图片一般都不会很大，并且那张图只是Google出来的，没有调整就直接放上来了。 在列表页看着图片居左就很难受，想要把它居中放置，但是不想用 HTML 的方式来写，就突然想起来早前有看到过 肉大的一篇分享，是通过 CSS 的 属性选择器 来实现的，就想着自己也可以整理一下，然后放到博客的主题当中使用，以后图片排版就会方便很多。","text":"在写 上一篇文章 的时，文章开头有一张示例图，为了节省空间，我用的图片一般都不会很大，并且那张图只是Google出来的，没有调整就直接放上来了。 在列表页看着图片居左就很难受，想要把它居中放置，但是不想用 HTML 的方式来写，就突然想起来早前有看到过 肉大的一篇分享，是通过 CSS 的 属性选择器 来实现的，就想着自己也可以整理一下，然后放到博客的主题当中使用，以后图片排版就会方便很多。 首先 就是讲述一下 Markdown 语法当中的图片标记： ![alt text](&#x2F;src&#x2F;of&#x2F;image.jpg &quot;title&quot;) 说实话，我在写这篇分享之前，完全不知道 图片标记 是有一个可选的 title 属性的，一直以为只有 path 和 alt 两个属性。(当然我是知道有一些 Markdown 扩展/转换器提供了一些额外的拓展属性，比如 Kramdown) 按照 肉大 以及 Baron Schwartz 的说法，可以使用 #hash、?query 或者直接使用 alt 和 title 属性的形式来实现。但使用 alt 和 title 来实现，我的想法与 Baron 一致并不赞同以及提倡滥用 alt 和 title 属性。 所以还是考虑使用 #hash 的方式来实现，为何不适用 ?query 的形式，因为我国内的镜像是放在 Aliyun OSS 当中，一些多余的 query 参数可能会影响资源的加载。 实现 img[src*=\"#center\"]{ margin-left: auto; margin-right: auto; } img[src*=\"#border\"] { border: 2px solid black } 实现的部分其实不用多说，其实就是在语法当中的 path 部分加上 #hash 值，然后使用 CSS 的属性选择起来匹配： ![test](&#x2F;test.jpg#center &quot;test&quot;) img[src$=\"#center\"]&#123; margin-left: auto; margin-right: auto; &#125; 结果预览 👉 但是如果想使用多个属性就会有一些问题，比如说我该怎么去 分隔 他们。 Baron 的想法是使用 空格分隔 (space-delimited)，并且修改 $ 使用 ~ 来匹配： ![test](&#x2F;test.jpg# center border &quot;test&quot;) img[src~=\"center\"]&#123; margin-left: auto; margin-right: auto; &#125; img[src~=\"border\"] &#123; border: 2px solid black &#125; 但是 Hexo 在编译时，会认为语法错误，直接输出成为文本内容。👉 ![test](/test.jpg# center border &quot;test&quot;) 所以需要改成转义后的 空格（%20）来书写，才可以被编译为图片，但是这样书写就不能被属性选择器的 ~ 符所匹配到。 而且我觉得 %20 也不便于记忆，所以我继续选择使用 # 来分隔，并且在每个样式之前都加上 #，例如： ![test](&#x2F;test.jpg#center#border &quot;test&quot;) 同样的，属性选择器也需要变更，因为多个样式，就不能使用 $ 或 ~ 来匹配了，需改成 * 来匹配。具体可以查看 属性选择器 | MDN img[src*=\"#center\"]&#123; margin-left: auto; margin-right: auto; &#125; img[src*=\"#border\"] &#123; border: 2px solid black &#125; 结果预览 👉 暂时还没有发现任何影响，如果你知道这样书写会有问题，那么请 📧 Mail 给我吧 ！ 尾声✨ 为什么不用书写 HTML 的方式来实现，不是更加自由吗？ 因为编译会有问题，如果在 markdown 中书写了，HTML 标签，那么在标签闭合之前，其中所有的内容都不会被处理，比如说 Baron Schwartz 在文中提到的： &lt;div style&#x3D;&quot;width:150px; height:100px&quot;&gt; ![Kitten](&#x2F;media&#x2F;2018&#x2F;08&#x2F;kitten.jpg) &lt;&#x2F;div&gt; 会被直接输出到页面中，所以结果如下，会直接输出 ![Kitten](/media/2018/08/kitten.jpg)，并不会把中间的 markdown 图片语法 转换成 &lt;img&gt; 标签 &lt;div style=\"width:150px; height:100px\"> ![Kitten](/media/2018/08/kitten.jpg) &lt;/div> 参考文档：给 Markdown 里的图片增加样式 – 山维空间How to Style Images With Markdown 属性选择器 - CSS | MDN","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://yogwang.site/tags/CSS/"},{"name":"Hexo","slug":"Hexo","permalink":"https://yogwang.site/tags/Hexo/"}]},{"title":"聊聊数据大屏 “炫酷” 容器边框的实现","slug":"border-style-of-special-border-box","date":"2021-07-29T03:07:29.000Z","updated":"2021-08-03T09:50:47.982Z","comments":true,"path":"2021/border-style-of-special-border-box/","link":"","permalink":"https://yogwang.site/2021/border-style-of-special-border-box/","excerpt":"最近大屏又开始火了，群里好多人又开始捡起来了数据可视化，我也一样遇到了新得是数据可视化项目，但是这次不是说 ECharts，而是数据大屏上的所谓 “科技感” 容器，比如下图： 可以看到很多的边框，虽然说可以直接让 UI 小姐姐 切给我们出来所有不同规格的背景图片来解决问题，但是就需要 UI 一份一份切给我们，就很麻烦，而且占用首屏加载的资源。我就想是否可以用一些精灵图来完成，或者一些简单的边框可以直接使用一些 CSS 的奇技淫巧来完成。 我从花瓣上找了一些示例，然后通过CSS复现，接下来上实例","text":"最近大屏又开始火了，群里好多人又开始捡起来了数据可视化，我也一样遇到了新得是数据可视化项目，但是这次不是说 ECharts，而是数据大屏上的所谓 “科技感” 容器，比如下图： 可以看到很多的边框，虽然说可以直接让 UI 小姐姐 切给我们出来所有不同规格的背景图片来解决问题，但是就需要 UI 一份一份切给我们，就很麻烦，而且占用首屏加载的资源。我就想是否可以用一些精灵图来完成，或者一些简单的边框可以直接使用一些 CSS 的奇技淫巧来完成。 我从花瓣上找了一些示例，然后通过CSS复现，接下来上实例 📊 实例 1 直线边框第一个示例就上最简单的好了，就是简简单单的直线容器边框，使用伪类来给容器增加4个发光包角 📊 实例 2 倾斜边框其实还好，使用 transform 来实现就可以了，只不过因为形变的问题，最好单独起一个边框容器来做。 📊 实例 3 断点直线线框这个的话，就比较麻烦了，一般都是用背景图片来实现，但是如果盒子大小固定的话，就需要切很多背景图，特别是宽高都不定的时候。所以这部分我只切了3块内容：左上角和右下角的图形 然后是 1px * 1px 的线框，搭配上多 background 就可以实现下边这个示例了。（需要了解一下background-position与background-size的混用） 📊 实例 4 内角边框这个就比较麻烦了，因为想要实现的是内发光的样式，如下图： 但是纯CSS来实现内凹角的话，就不能使用 box-shadow 来设置内发光了，会有断层（其实可以实现没有断层，但是需要一点一点的调整阴影的offset、模糊半径和透明度），如果使用 filter:drop-shadow() 则没办法实现内发光，而且扩散半径现在还没有浏览器支持。 filter:drop-shadow()-spread-radius | MDN。 奈何 filter:drop-shadow() 不支持扩散半径的设置，所以发光我真的没办法了（懒得调 box-shadow），暂时能想到的就是双层 mask 来模拟一个近似的，但是从中心发光了，而不是边框发光（内阴影） 其实可以用上一个例子的方式用背景图来实现，但是我觉得应该有其它更好的方式实现，容我再考虑考虑。 如果你有好的想法，📧 Mail给我吧！ 参考文档：background - CSS | MDNbackground-position - CSS | MDNbackground-size - CSS | MDNmask - CSS | MDNdrop-shadow() - CSS | MDNbox-shadow - CSS | MDN","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://yogwang.site/tags/CSS/"},{"name":"未完成","slug":"未完成","permalink":"https://yogwang.site/tags/%E6%9C%AA%E5%AE%8C%E6%88%90/"},{"name":"挖坑","slug":"挖坑","permalink":"https://yogwang.site/tags/%E6%8C%96%E5%9D%91/"}]},{"title":"CSS 中的遮罩属性 mask/masks","slug":"CSS-mask","date":"2021-07-08T09:15:38.000Z","updated":"2021-08-04T01:40:01.648Z","comments":true,"path":"2021/CSS-mask/","link":"","permalink":"https://yogwang.site/2021/CSS-mask/","excerpt":"最近有点忙，于是又停更了一个月😂，前两天在 V2 上看到 一个帖子，需求是要做一个镂空遮罩。 回答的过程中想起来有一个 mask 属性来着，好像可以试试，但是快下班了，也没有找到合适的遮罩图，也不想打开PS自己画一个再传图床，就还是用的 clip-path 做了一个 CodePen Demo。这两天稍微有点时间，可以考虑研究一下这个遮罩属性，以及能否搭配 filter:drop-shadow() 使用。","text":"最近有点忙，于是又停更了一个月😂，前两天在 V2 上看到 一个帖子，需求是要做一个镂空遮罩。 回答的过程中想起来有一个 mask 属性来着，好像可以试试，但是快下班了，也没有找到合适的遮罩图，也不想打开PS自己画一个再传图床，就还是用的 clip-path 做了一个 CodePen Demo。这两天稍微有点时间，可以考虑研究一下这个遮罩属性，以及能否搭配 filter:drop-shadow() 使用。 先来看一下 mask 属性的介绍 mask 属性允许使用者通过遮罩或者裁切特定区域的图片的方式来隐藏一个元素的部分或者全部可见区域。mask: [mask-image] [mask-repeat] [mask-position] / [ mask-size]; 最简单的直接使用 mask 然后配置一下 url 就可以应用上遮罩层了。 &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;title>Document&lt;/title> &lt;style> .mask&#123; width:100vw; height:100vh; -webkit-mask: url(./mask.png); mask: url(./mask.png); display: block; &#125; &lt;/style> &lt;/head> &lt;body> &lt;img class=\"mask\" src=\"./picture.jpg\"> &lt;/body> &lt;/html> 效果截图 👇 可以看到需要设置 -webkit- 私有前缀（Firefox不需要），然后遮罩图片的话，我尝试以下两张图，A:黑白JPG图片；B:黑色圆形透明底PNG图片。 只有透明底的PNG图片才可以应用上遮罩，图片A尝试多次都不可以应用上【测试时间：2021年7月9日】，因为是 chrome 通过遮罩层的 alpha (透明)通道来实现遮罩功能的，并不是通过亮度和颜色差值 ❓ 那么 SVG 图形呢？&lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"> &lt;circle cx=\"400\" cy=\"400\" r=\"300\" fill=\"black\"/> &lt;/svg> 也可以直接使用，截图就不加了，和上方的差不多只是没有 repeat，可能是因为绘制得太大了😂 - 追加：因为 &lt;svg&gt; 上没有设置 width 和 height 属性😐，设置上就会 repeat 了 然后是8个具体属性 mask-image: 遮罩图像; mask-mode: 遮罩图像的模式; mask-repeat: 遮罩图像的重复方式(同bg-repeat); mask-position: 遮罩图像的定位(同bg-position); mask-clip: 遮罩图像应用区域(同bg-clip); mask-origin: 遮罩图像应用原点(同bg-origin); mask-size: 遮罩图像尺寸大小(同bg-size); mask-composite: 遮罩图像的叠加方式。 基本上可以与 background 属性一样来理解并且语法相通，只有两个属性需要单独去尝试 mask-mode - 遮罩图像的模式; mask-composite - 遮罩图像的叠加方式。 因为只有 firefox 支持 mask-mode 和 mask-composite 属性，所以后边的示例都是在 firefox 下尝试的 Can I use results 2021年7月12日 🧷 1. 按顺序先来讲 mask-mode 属性直接读文档 mask-mode - CSS | MDN，可以看到： alpha: 使用遮罩层图像的透明度(alpha)值作为掩码值; luminance: 遮罩层图像的亮度值应用作掩码值; match-source: 资源的类型自动采用合适的遮罩模式。 如果 mask-image 属性是 &lt;mask-source&gt; 类型，遮罩层的亮度值会被作为掩码值; 如果它是类型 &lt;image&gt;，遮罩层的 alpha 值作为掩码值。 👇 MDN示例，在 CodePen 中打开 （记得使用FireFox打开） 嗯？？？为什么少了 mask-mode:match-source ?因为他只是 auto 的意思… 例如，如果我们的遮罩使用的是SVG中的&lt;defs&gt;中的&lt;mask&gt;元素，则此时的mask-mode属性的计算值是luminance，表示基于亮度遮罩。如果是其他场景，则计算值是alpha，表示基于透明度遮罩。张鑫旭 - 鑫空间 🧷 2. mask-composite 属性mask-composite 表示当同时使用多个图片进行遮罩时候的混合方式。 mask-composite: add; // 叠加(遮罩累加/并集) mask-composite: subtract; // 相减(遮罩相减/补集) mask-composite: intersect; // 相交(遮罩重叠部分/交集) mask-composite: exclude; // 排除（非重叠区域的合并/对称差） 还是使用MDN上的实例演示哈，在 CodePen 中打开 因为实例的star.svg是半透明的，所以mask-composite: subtract 和 mask-composite: exclude 看起来会有一些疑问，从现象来描述是： 相减：与后面遮罩图片重合的地方不显示，前一个遮罩结果之上继续应用后一个遮罩，遮罩互相应用。意味着遮罩图片越多，遮罩的区域越小。 排除：与后面遮罩图片重合的地方排除，也就是非重叠区域的合并，反向的相交 =&gt; 对称差 使用没有透明度的遮罩示例来对照以下应用后的结果 尾声可以看到就算是2021年了，浏览器对于 mask 属性的实现还是有一些争议，chrome 还需要加私有前缀（-webkit-）才可以应用上，而且部分属性也不支持，吐槽一下已经 CR 5年了….. 虽然可以用，但是毕竟是一个处于 候选标准(CR)阶段 的属性，MDN也给予了提示，尽量控制适用范围。 这是一个实验中的功能此功能某些浏览器尚在开发中，请参考浏览器兼容性表格以得到在不同浏览器中适合使用的前缀。由于该功能对应的标准文档可能被重新修订，所以在未来版本的浏览器中该功能的语法和行为可能随之改变。 然后文章开头所提到的提问，通过 mask 属性的实现： 和 clip-path 一样，使用了 mask 属性之后会对所有内容进行裁剪，所以 filter drop-shadow() 应用的投影会被隐藏，所以需要在父级应用投影效果。 追加本来写完上边之后就结束了这篇笔记，但是看到了一个使用 element(#id) 作为遮罩层的例子，例如： &lt;div class=\"wrap\"> &lt;img id=\"mask\" src=\"./mask.png\"> &lt;img id=\"picture\" src=\"./picture.jpg\"> &lt;/div> &lt;style> #picture &#123; width: 300px; mask-image: -moz-element(#mask); &#125; #mask &#123; display: none; &#125; &lt;/style> 可以使用文字等 DOM元素 作为遮罩元素，但如果不想要遮罩层展示的话，还需要隐藏遮罩的 DOM，而且这个特性只有 FireFox 才支持 Can I use，大概了解一下就好了。 附mask - CSS（层叠样式表） | MDNCSS Masks | Can I useCSS Masking Module Level 1 - W3C Candidate Recommendation 客栈说书：CSS遮罩CSS3 mask/masks详细介绍 - 张鑫旭mask-mode | CSS-Trickscss:mask浅析 - SegmentFaultJELLY | CSS3 Mask 安利报告 - JELLY element() - CSS: Cascading Style Sheets | MDN“-moz-element” | Can I useCSS Image Values and Replaced Content Module Level 4 - W3C Working Draft","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://yogwang.site/tags/CSS/"}]},{"title":"在 Flex 布局中使用 gap 属性","slug":"CSS-use-gap-in-flex-layout","date":"2021-05-29T07:02:19.000Z","updated":"2021-06-03T07:16:51.551Z","comments":true,"path":"2021/CSS-use-gap-in-flex-layout/","link":"","permalink":"https://yogwang.site/2021/CSS-use-gap-in-flex-layout/","excerpt":"最近在更新博客的样式，突然想到现在的flex布局已经可以定义间距了，所以大概整理了一下关于gap这个新属性资料。 gap 属性是用来设置网格行与列之间的间隙（gutters），该属性是 row-gap 与 column-gap 的简写形式。 起初是在 Grid 布局中用 grid-gap 来设置行间距和列间距的，后来意识到 Multi-column 布局中有一个 column-gap 属性，同时存在 grid-column-gap 和 column-gap 对于开发者来说是一个很疑惑的问题。并且在大范围应用的 Flex 布局中，并没有一个很好的方法来设置行间距和列间距。 于是CSS齐属属性规范开始调整，gap 代替了grid-gap 属性，并且规范对间隙属性进行了大统一，三种布局只需要使用 gap 属性就可以设置间距样式了。","text":"最近在更新博客的样式，突然想到现在的flex布局已经可以定义间距了，所以大概整理了一下关于gap这个新属性资料。 gap 属性是用来设置网格行与列之间的间隙（gutters），该属性是 row-gap 与 column-gap 的简写形式。 起初是在 Grid 布局中用 grid-gap 来设置行间距和列间距的，后来意识到 Multi-column 布局中有一个 column-gap 属性，同时存在 grid-column-gap 和 column-gap 对于开发者来说是一个很疑惑的问题。并且在大范围应用的 Flex 布局中，并没有一个很好的方法来设置行间距和列间距。 于是CSS齐属属性规范开始调整，gap 代替了grid-gap 属性，并且规范对间隙属性进行了大统一，三种布局只需要使用 gap 属性就可以设置间距样式了。 我一直觉得 Grid 布局的属性太多，而且早期的兼容性很差，相对于 Flex 布局 我觉得最好用的属性就是 grid-gap，因为 flex 只有 5 种对齐属性，如果需要做间距的话就很麻烦，只能使用 margin。今年年初的时候一大波的公众号在推送 flex 已经可以使用 gap 属性了，正好趁着这段时间博客主题改版，正好有用上。 🔨 使用方式在 grid 与 multi-column 种使用、表现形式是和原先是一样的 #grid-box &#123; display: grid; height: 200px; grid-template: repeat(3, 1fr) / repeat(3, 1fr); gap: 15px 20px; &#125; #column-box &#123; column-count: 3; gap: 20px; &#125; 在 flex 中用法与 grid 中一样，并且同时可以使用 justify-content 和 align-content #flex-box &#123; display: flex; flex-wrap: wrap; gap: 20px 20px; justify-content: space-between; &#125; ✨ gap 可接收的值： normal：默认值，默认为0px，在 multi-column-layout 中为 1em; &lt;length&gt;: 精确值，例如：px, em, rem, vw, vmin 之类的精确值； &lt;percentage&gt;: 百分比值，表示相对栅格容器的百分比； calc(): 计算值，经过计算函数来指定间距大小； inherit： 继承自父级； initial： 初始（或默认）值； unset： 设为未设定。 🚫 兼容性 Grid布局 还是支持 grid-gap 属性，但这是为了兼容那些不支持 gap 属性的浏览器，处于类似于私有前缀的状态了，MDN上是建议使用 gap 属性。 CSS property: gap: Supported in Grid Layout Flex布局 对于 gap 属性的支持，还处于草案阶段 [2021/6/3] ，如果需要在生产环境使用，可能需要进行考量，虽说主流浏览器全部都已经支持了。 CSS property: gap: Supported in Flex Layout Multi-column布局 已经支持了 gap 属性，但是只有列间距，没有行间距的概念，所以设置 row-gap 是没有效果的。 CSS property: gap: Supported in Multi-column Layout 🎃 一些疑惑 根据谁的大小来计算百分比？依据布局容器的 content-box 来确认百分比，与 padding/margin 的计算方式一致。 为何有时会失效？需要容器有对应确定的宽高值，否则为 0。 Safari 中已经支持了 gap 的 百分比值 和 calc()值2021年6月3日测试 资源gap (grid-gap) - CSS（层叠样式表） | MDNCSS Box Alignment Module Level 3 - W3C Editor’s Draft gap | CSS-TricksCSS gap属性进化史 « 张鑫旭-鑫空间-鑫生活","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://yogwang.site/tags/CSS/"}]},{"title":"Hexo 主题开发","slug":"hexo-theme-edit","date":"2021-05-27T06:01:41.000Z","updated":"2021-07-14T01:59:16.392Z","comments":true,"path":"2021/hexo-theme-edit/","link":"","permalink":"https://yogwang.site/2021/hexo-theme-edit/","excerpt":"去年就开始说要更新博客主题了，拖到现在终于有点空闲时间和动力了，相信大家已经使用过 Hexo 了，安装之类的我都不多废话了，直接开始。 想要自定义一个 Hexo 主题大概需要了解一个 模板引擎，Hexo 内置了 Swig，我所用的是默认安装的 EJS，反正都差不多，都提供了一些模板语法，书写还是按照Js的方法来的。然后先按照文档创建完主体目录结构和模板组件，就可以开始开发了，我比较偷懒没有使用 yeoman + generator-hexo-theme 来创建，直接复制了原先的 landscape 主题。 哦，对了！还要选择一个CSS预编译器，我还是没有选择适用了默认安装的 Stylus，你也可以按照习惯去安装，并且 install 对应的 Hexo 插件。","text":"去年就开始说要更新博客主题了，拖到现在终于有点空闲时间和动力了，相信大家已经使用过 Hexo 了，安装之类的我都不多废话了，直接开始。 想要自定义一个 Hexo 主题大概需要了解一个 模板引擎，Hexo 内置了 Swig，我所用的是默认安装的 EJS，反正都差不多，都提供了一些模板语法，书写还是按照Js的方法来的。然后先按照文档创建完主体目录结构和模板组件，就可以开始开发了，我比较偷懒没有使用 yeoman + generator-hexo-theme 来创建，直接复制了原先的 landscape 主题。 哦，对了！还要选择一个CSS预编译器，我还是没有选择适用了默认安装的 Stylus，你也可以按照习惯去安装，并且 install 对应的 Hexo 插件。 # Templates $ npm install --save hexo-renderer-ejs $ npm install --save hexo-renderer-pug $ npm install --save hexo-renderer-haml # Styles $ npm install --save hexo-renderer-less $ npm install --save hexo-renderer-sass $ npm install --save hexo-renderer-stylus 然后不需要配置，Hexo 会自动按照文件后缀名使用对应的拓展编译文件。 📚 前置学习 了解主题目录结构 👉 主题 | Hexo 模板页名称、局部变量的使用 👉 模版 | Hexo 全局变量和页面变量 👉 变量 | Hexo Hexo 内置辅助函数 👉 辅助函数（Helpers） | Hexo 以上四个文档希望你可以阅读完，特别是辅助函数，会在制作过程中反复用到，也是最关键的部分，我相信大家已经对 [html, css, js] 三剑客很熟悉了，所以就不提他们了。 完整目录如下： │ ├─ layout # 布局文件夹 │ ├─ partials # 局部模版 │ │ └─ recent-posts.ejs # 列表页文章Item │ ├─ index.ejs # 首页模板 │ ├─ layout.ejs # html结构 │ ├─ post.ejs # 文章列表模板 │ ├─ archive.ejs # 归档列表模板 │ ├─ category.ejs # 分类归档列表模板 │ ├─ tag.ejs # 标签归档列表模板 │ └─ page.ejs # 单页模板 │ ├─ scripts # 脚本文件夹 │ ├─ source # 资源文件夹 │ ├─ css │ ├─ js │ └─ favicon.ico │ ├─ .editorconfig # 编辑器配置文件 ├─ _config.yml # 主题配置文件 └─ package.json # 项目包管理文件 Part1. 主题模板开发首先会想到要着手的肯定是首页，但是直接开发首页肯定是不行的，还需要先把网页的结构搭完，好比现在 SPA 项目的 index.html 文件。那么就会先就需要调整 layout.ejs 这个模板文件，打开的话，可以看到一个简单的 html 结构，这个时候就是需要按照自己的想法来搭建主题的公共部分了，比如说 页首 与 页尾，然后使用 &lt;%- partial(path, [locals], [option]) %&gt; 来引入组件 locals和option的可接收参数文档。我把 meta 信息也提取成部件了，完成大概是这样的结构。 &lt;!-- layout page --> &lt;!DOCTYPE html> &lt;html lang=\"&lt;%= config.language =>\"> &lt;%- partial('_partial/meta') %> &lt;body> &lt;%- partial('_partial/header', null, &#123;cache: true&#125;) %> &lt;div id=\"wrap\"> &lt;%- body %>&lt;!-- body变量，用于输出页面内容 --> &lt;/div> &lt;%- partial('_partial/footer', null, &#123;cache: true&#125;) %> &lt;/body> &lt;/html> 然后开始编辑 index.ejs 这个文件，开始可以按照自己的喜好编辑首页了，记得使用 hexo s 命令开打开发模式查看效果。我是顺着上一版本的主页，只是展示文章，所以直接把文章卡片抽成组件了，从 page.posts 接收到文章列表，使用 forEach() 循环出列表，然后使用 paginator()函数 把分页组件也写好了 呃….好像也没有什么好说的，就是和过去 CMS 时代用模板语法来写 template 那样，只是以前是嵌入 php 的代码然后用 php 来执行渲染，而 Hexo 是用 JS 来编译成静态文件。 我这边大概完成主题之后的目录结构如下： layout ├─_partial # 小部件 │ │ archive.ejs # 文章分类列表组件 │ │ archive_post.ejs # 列表页文章卡片组件 │ │ article.ejs # 文章详情组件 │ │ footer.ejs # 页尾组件 │ │ header.ejs # 页头组件 │ │ meta.ejs # meta组件 │ │ sidebar.ejs # 侧边栏组件 │ │ soliloquy.ejs # 关于我组件 │ │ │ ├─_post # 文章组件 │ │ article_body.ejs # 文章内容部件 │ │ category.ejs # 文章分类部件 │ │ date.ejs # 文章日期部件 │ │ nav.ejs # 文章详情分页部件 │ │ tag.ejs # 文章标签部件 │ │ title.ejs # 文章标题部件 │ │ │ └─_widget # 侧边栏卡片组件 │ archive.ejs # 文章归档卡片 │ author.ejs # 个人信息卡片 │ category.ejs # 文章分类卡片 │ recent_posts.ejs # 最近发布卡片 │ shortcut_menu.ejs # 快捷分类菜单卡片 │ tag.ejs # 标签列表卡片 │ tag_cloud.ejs # 标签云卡片 │ │ about.ejs # 关于我模板 │ archive.ejs # 文章列表模板 │ category.ejs # 分类列表模板 │ index.ejs # 主页 │ layout.ejs # 布局模板 │ page.ejs # 单页模板 │ post.ejs # 文章详情模板 └─ tag.ejs # 标签页模板 需要注意的是一些默认的模板名称，hexo 会自动去寻找这些模板来生成对应的页面。模板文档 - Hexo 模板名 用途 回退 layout 布局 - index 首页 - post 文章 index page 分页 index archive 归档 index category 分类归档 archive tag 标签归档 archive 所以你的主题目录： 应包含一个 index 模板 如果要使用 layout 组件，必须要使用 &lt;%- body %&gt; 输出模板的内容。 Part2. 配置文件设置在开发主题的时候你会遇到一些属性可能全局会用到，比如说头部导航，页尾配置，侧边栏卡片显隐等，就可以配置 _config.yml 文件来实现全局变量 文档 Hexo的配置文件分为 站点配置文件 和 主题配置文件，分别位于 项目根目录 和 主题根目录 下。 一般来说，全局的一些配置项需要放到 站点配置文件 中，比如说：站点配置，静态页面生成规则，插件配置等，然后通过 config.xxx 来获取&amp;使用。和主题有关的配置则放到 主题配置文件 中，比如：侧边栏开关，社交账户信息，头部导航等控制主题内容的部分，通过 theme.xxx 来使用。 我的想法是尽量减少对于站点配置文件的控制，能放到主题配置文件中的就放到主题配置文件中。 🎉 尾声基本上关于主题开发的内容就那么多，整体来说只要你懂一些三剑客的基础很容易就可以自己开发出一个主题，只是有一些犄角旮旯需要你去查文档，有一些说明并不明显，需要耐心的从文档中检索出来。 如果需要发布到 Hexo 上，还需要通过 主题单元测试，确保每一项功能都能正常使用，发布步骤见文档 如果需要发布你的主题，那么我会在另一篇文章中来记录。我先挖一个坑，因为自己制作完主题之后还没有按照文档规范走完测试流程。 遇到的问题# 使用 is_current(path) 判断生成的 ‘active’ 类不会在对应分类添加，只会执行一次查看引入的部件 &lt;%- partial(&#39;partial/xxx&#39;,&#123; cache: &lt;Boolean&gt; &#125;) %&gt; 部分是否开启了缓存 👉 模版 | Hexo # orderby 有哪些可选参数? name 名称 length 文章数 random 随机排列 # 空白主题不支持 markdown 的 table 语法/看不到表格因为没有设置 &lt;table&gt; 的样式，自己使用CSS写一个表格样式就好。 # 使用 hexo-prism-plugin 进行代码高亮处理，但是在列表页的预览内容中的代码块不会被处理其实会被处理，只是我在用 hexo-theme-unit-test 测试的时候有使用 代码块标签插件 的测试文章，类似这样： &#123;% codeblock lang:js mark:1,7-8,10 %&#125; const http &#x3D; require(&#39;http&#39;); const hostname &#x3D; &#39;127.0.0.1&#39;; const port &#x3D; 1337; http.createServer((req, res) &#x3D;&gt; &#123; res.writeHead(200, &#123; &#39;Content-Type&#39;: &#39;text&#x2F;plain&#39; &#125;); res.end(&#39;Hello World\\n&#39;); &#125;).listen(port, hostname, () &#x3D;&gt; &#123; console.log(&#96;Server running at http:&#x2F;&#x2F;$&#123;hostname&#125;:$&#123;port&#125;&#x2F;&#96;); &#125;); &#123;% endcodeblock %&#125; 需要开启 prismjs，默认是关闭的，在 _config.yml 中开启即可。 资源 Swig - A Node.js and Browser JavaScript Template Engine EJS – Embedded JavaScript templates Pug - Getting Started Haml hexojs/site: The website for Hexo.","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://yogwang.site/tags/Hexo/"},{"name":"挖坑","slug":"挖坑","permalink":"https://yogwang.site/tags/%E6%8C%96%E5%9D%91/"}]},{"title":"原型链！ __proto__ 与 prototype","slug":"JS-proto-and-prototype","date":"2021-05-21T16:51:09.000Z","updated":"2021-05-29T03:25:25.185Z","comments":true,"path":"2021/JS-proto-and-prototype/","link":"","permalink":"https://yogwang.site/2021/JS-proto-and-prototype/","excerpt":"Every JavaScript object has a second JavaScript object (or null ,but this is rare) associated with it. This second object is known as a prototype, and the first object inherits properties from the prototype.每个 JavaScript 对象都会对应一个原型对象（除了 null），并从原型对象继承属性和方法。JavaScript 权威指南 一句话解释：对象 __proto__ 属性是JS内置的，它所对应值是原型对象的 prototype ；而 prototype 就是你自己写的原型属性、方法 加上 JS原型内置的属性、方法","text":"Every JavaScript object has a second JavaScript object (or null ,but this is rare) associated with it. This second object is known as a prototype, and the first object inherits properties from the prototype.每个 JavaScript 对象都会对应一个原型对象（除了 null），并从原型对象继承属性和方法。JavaScript 权威指南 一句话解释：对象 __proto__ 属性是JS内置的，它所对应值是原型对象的 prototype ；而 prototype 就是你自己写的原型属性、方法 加上 JS原型内置的属性、方法 var one = &#123;x: 1&#125;; var two = new Object(); one.__proto__ === Object.prototype // true Object.getPrototypeOf(one) === Object.prototype // true two.__proto__ === Object.prototype // true Object.getPrototypeOf(two) === Object.prototype // true one.toString === one.__proto__.toString // true two.toString === two.__proto__.toString // true two.toString === one.__proto__.toString // true 那现在的疑问就是 __proto__ 和 prototype 的使用 __proto__ 不是ES的标准，单纯是为了方便让用户可以直接获取，推荐通过 Object.getPrototypeOf() 来获取，并不推荐直接通过这方法来修改原型 prototype 是创建函数时，JS为这个函数自动添加的属性，通过手动配置 prototype 属性，或者指向现存的对象来继承该对象。 🎉 小结prototype 指向一块内存，这个内存里面有共用属性，__proto__ 指向同一块内存 prototype 和 __proto__ 的不同点在于： prototype 是构造函数的属性，而 __proto__ 是对象的属性 JavaScript 常被描述为一种 基于原型的语言 (prototype-based language) ——每个对象拥有一个 原型对象 ，对象以其原型为模板、从原型继承方法和属性。原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为 原型链 (prototype chain) ，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。 准确地说，这些属性和方法定义在 Object 的构造器函数(constructor functions)之上的 prototype 属性上，而非对象实例本身。 在传统的 OOP 中，首先定义“类”，此后创建对象实例时，类中定义的所有属性和方法都被复制到实例中。在 JavaScript 中并不如此复制 —— 而是在对象实例和它的构造器之间建立一个链接（它是 __proto__ 属性，是从构造函数的 prototype 属性派生的），之后通过上溯原型链，在构造器中找到这些属性和方法。 注意: 理解对象的原型（__proto__属性）与 构造函数的 prototype 属性之间的区别是很重要的。前者是每个实例上都有的属性，后者是构造函数的属性。 在JavaScript中，函数可以有属性。 每个函数都有一个特殊的属性叫作 prototype (原型)，通过给 prototype 添加属性和方法，来为以这个 函数 为 基础模型 的 实例对象 继承下来函数上所有的属性。 // 从函数里创建一个对象 function f() &#123; this.a = 1; this.b = 2; &#125; // 在f函数的原型上定义属性 f.prototype.b = 3; f.prototype.c = 4; // 通过new操作符来创建基于f()的对象实例 let o = new f(); // 输出一下 对象o console.log(o) /* log ƒ &#123; a:1, b:2 &#125; a: 1 b: 2 __proto__: b: 3 c: 4 constructor: ƒ f() arguments: null caller: null length: 0 name: \"f\" prototype: &#123;b: 3, c: 4, constructor: ƒ&#125; __proto__: ƒ () [[FunctionLocation]]: VM510:2 [[Scopes]]: Scopes[2] __proto__: Object */ // 更多熟悉调用demo console.log(o.a); // 1 // a是o的自身属性吗？是的，该属性的值为 1 console.log(o.b); // 2 // b是o的自身属性吗？是的，该属性的值为 2 // 原型上也有一个'b'属性，但是它不会被访问到。 // 这种情况被称为\"属性遮蔽 (property shadowing)\" console.log(o.c); // 4 // c是o的自身属性吗？不是，那看看它的原型上有没有 // c是o.[[Prototype]]的属性吗？是的，该属性的值为 4 console.log(o.d); // undefined // d 是 o 的自身属性吗？不是，那看看它的原型上有没有 // d 是 o.[[Prototype]] 的属性吗？不是，那看看它的原型上有没有 // o.[[Prototype]].[[Prototype]] 为 null，停止搜索 // 找不到 d 属性，返回 undefined // o.__proto__.__proto__.__proto__ => null // Object.getPrototypeOf(Object.getPrototypeOf(Object.getPrototypeOf(o))) => null 如果想知道 new 操作符做了那些事，可以查看这篇笔记 👉 JS中的 new 关键字做了什么？ 尾声- 使用不同的方法来创建对象和生成原型链？这个我就不多说了，直接看MDN上的示例就好 使用不同的方法来创建对象和生成原型链 - 继承与原型链 | MDN，知乎上也有，直接搜就好了。 - 简单的说，原型链 其实算是面向对象思想中的继承部分，以方便根据需求拆分功能，完成特定的工作职责 - ES6 提出了 类(Class) 这个概念让对象原型的写法更加清晰，更像面向对象编程的语法，并且同样有着 prototype 这个属性。 资源对象原型 - 学习 Web 开发 | MDN继承与原型链 - JavaScript | MDNObject.prototype.__proto__ - JavaScript | MDNObject.getPrototypeOf() - JavaScript | MDNJavascript Object Hierarchy JS 中 __proto__ 和 prototype 存在的意义是什么？ - 知乎傻傻分不清的__proto__与prototype - SegmentFault 思否从__proto__和prototype来深入理解JS对象和原型链 · Issue #9 · creeperyang/blog","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"}]},{"title":"JS中的 new 关键字做了什么？","slug":"JS-what-dose-new-operators-do","date":"2021-05-21T10:48:10.000Z","updated":"2021-05-29T03:25:15.807Z","comments":true,"path":"2021/JS-what-dose-new-operators-do/","link":"","permalink":"https://yogwang.site/2021/JS-what-dose-new-operators-do/","excerpt":"new 运算符 创建 一个用户定义的 对象类型 的实例或 具有构造函数的内置对象 的实例。 完整的了解 new 运算符你可能还需要了解一下 面向对象思想 以及 原型链，可以简单查看这篇笔记 👉 原型链！ __proto__ 与 prototype 如果快速的了解 new 关键字按照MDN的文档描述来说就是： new关键字会创建一个空的简单JavaScript对象（即 &#123;&#125;）； 链接该对象（设置该对象的 constructor）到另一个对象 （绑定原型）； 将 步骤1 新创建的对象作为 this 的上下文 ； 如果该函数没有返回对象，则返回 this。 可以简单理解成 new 关键字帮我们处理了书写构造函数时一些固定的步骤","text":"new 运算符 创建 一个用户定义的 对象类型 的实例或 具有构造函数的内置对象 的实例。 完整的了解 new 运算符你可能还需要了解一下 面向对象思想 以及 原型链，可以简单查看这篇笔记 👉 原型链！ __proto__ 与 prototype 如果快速的了解 new 关键字按照MDN的文档描述来说就是： new关键字会创建一个空的简单JavaScript对象（即 &#123;&#125;）； 链接该对象（设置该对象的 constructor）到另一个对象 （绑定原型）； 将 步骤1 新创建的对象作为 this 的上下文 ； 如果该函数没有返回对象，则返回 this。 可以简单理解成 new 关键字帮我们处理了书写构造函数时一些固定的步骤 创建临时对象； 绑定原型； return 这个临时对象 整个遍写构造函数的过程中，可以省略上面的步骤，直接使用 this 就可以指向这个临时对象，为他创建属性，直接为 prototype 赋值属性和方法就可以对公共（对象原型）增加属性、方法。 未完成 尾声ES6 为 new 引入了一个 new.target 属性，可以用来确定构造函数是怎么调用的。 附new 运算符 - JavaScript | MDNObject.prototype.constructor - JavaScript | MDNJS 的 new 到底是干什么的？ - 知乎§ 6.new.target 属性 - Class 的基本语法 - ECMAScript 6入门","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"未完成","slug":"未完成","permalink":"https://yogwang.site/tags/%E6%9C%AA%E5%AE%8C%E6%88%90/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"}]},{"title":"微信小程序学习日记 L05 拉起授权","slug":"miniprogram-devDiary-05-authorize","date":"2021-05-20T08:04:22.000Z","updated":"2021-05-29T03:31:56.703Z","comments":true,"path":"2021/miniprogram-devDiary-05-authorize/","link":"","permalink":"https://yogwang.site/2021/miniprogram-devDiary-05-authorize/","excerpt":"在实际业务场景中，最常接触到的就是拉取微信登陆了，但单纯的一个点击按钮直接微信登录的需要获取多少微信权限呢？ 最少的需要使用到1个微信开放接口：wx.login，如果需要获取用户头像和昵称，需要调用 wx.getUserProfile 方法 (wx.getUserInfo 已调整【尾声#1】)，并且需要在绑定在按钮上 ，并会唤起授权提示；如果需要获取用户手机号信息，需要在按钮上绑定 getPhoneNumber 事件。 一般来说非敏感信息可以直接调用，含有敏感信息的接口需要绑定在按钮上，在用户自行操作之后才可以调用。","text":"在实际业务场景中，最常接触到的就是拉取微信登陆了，但单纯的一个点击按钮直接微信登录的需要获取多少微信权限呢？ 最少的需要使用到1个微信开放接口：wx.login，如果需要获取用户头像和昵称，需要调用 wx.getUserProfile 方法 (wx.getUserInfo 已调整【尾声#1】)，并且需要在绑定在按钮上 ，并会唤起授权提示；如果需要获取用户手机号信息，需要在按钮上绑定 getPhoneNumber 事件。 一般来说非敏感信息可以直接调用，含有敏感信息的接口需要绑定在按钮上，在用户自行操作之后才可以调用。 开放接口1、 微信登陆如果只是单纯需要获取用户的微信 openId 来关联用户账户，则可以直接调用 wx.login() 方法，把获取的 code(登录凭证) 传递给后端就可以，后端可以根据 code 请求微信的服务器端Api来换取 [ openid, unionid, session_key ] 一个简单的示例： // login.js Page(&#123; onLoad()&#123; // 可以绑定在页面中的某个按钮上，也可以页面载入后就直接请求 this.onWechatLogin() &#125; // 微信登陆操作 onWechatLogin () &#123; // 请求微信登陆api wx.login(&#123; success: (wxRes) => &#123; const data = &#123; code: wxRes.code &#125; // 请求后端登陆API，这个方法是我自己封装的请求函数， // 具体请看 小程序学习日记 L04 网络请求 postAction(\"/pub/weChat/login\", data).then(res => &#123; // 服务器返回数据后的操作 &#125;) &#125; &#125;) &#125;, &#125;) 登陆接口文档 wx.login | 微信开放文档 小程序登陆流程 小程序登录 | 微信开放文档 服务器端文档 auth.code2Session | 微信开放文档 2、 获取用户资料在早些时候是调用微信的 wx.getUserInfo 接口，但是从我开始写小程序的时间，正好是 wx.getUserProfile() 更新替代的时候，所以我的获取用户资料的demo就直接使用 wx.getUserProfile() 接口。其实如果不需要保存用户头像和昵称，可以使用微信新提供的 &lt;open-data&gt; 组件直接在界面中展示 预览代码片段。 &lt;!-- 直接使用 open-data 组件展示用户头像和昵称 --> &lt;open-data type=\"userAvatarUrl\">&lt;/open-data> &lt;open-data type=\"userNickName\">&lt;/open-data> 然后需要做头像固定宽高圆角之类样式的，给 &lt;open-data&gt; 添加 className 就可以了。不过这不在拉取授权的范畴内，所以只是举例，如果需要获取用户资料的需要以下方式来唤起授权 &lt;!-- page.wxml --> &lt;view class=\"container\"> &lt;!-- 需要在按钮上绑定获取用户信息的事件来触发 wx.getUserProfile --> &lt;button bindtap=\"getUserProfile\" wx:if=\"&#123;&#123;!hasUserInfo&#125;&#125;\"> 获取头像昵称 &lt;/button> &lt;view wx:else> &lt;image src=\"&#123;&#123; userInfo.avatarUrl &#125;&#125;\" mode=\"cover\">&lt;/image> &lt;text>&#123;&#123; userInfo.nickName &#125;&#125;&lt;/text> &lt;/view> &lt;/view> // page.js Page(&#123; data: &#123; userInfo: &#123;&#125;, hasUserInfo: false, &#125;, getUserProfile() &#123; // 要直接在按钮绑定的方法内调用 wx.getUserProfile // 不能在 callback 或者在 promise.then 中调用 wx.getUserProfile(&#123; desc: '用于完善会员资料', success: (res) => &#123; this.setData(&#123; userInfo: res.userInfo, hasUserInfo: true &#125;) &#125; &#125;) &#125;, &#125;) 用户信息 | 微信开放文档 open-data | 微信开放文档 3、 获取用户手机号和以前的 wx.getUserInfo 获取微信用户个人信息一样，需要指定 open-type 的值为 getPhoneNumber，以及使用 bindgetphonenumber 绑定事件。在用户确认授权之后可以在 event 获取到加密后的 用户信息（encryptedData），以及加密向量（iv）等信息，最后就看需不需要回填到前台，如果不需要就直接在后端处理就可以了。 &lt;!-- page.wxml --> &lt;button open-type=\"getPhoneNumber\" bindgetphonenumber=\"getPhoneNumber\">获取手机号&lt;/button> // page.js Page(&#123; getPhoneNumber (e) &#123; // 检查服务器端 sessionKey 是否过期 wx.checkSession(&#123; success () &#123; // sessionKey 未过期 const &#123; iv, encryptedData &#125; = e.detail if(!iv) &#123; wx.showToast(&#123; title:'授权失败请重试' &#125;) return &#125; const data = &#123; iv:iv, // 加密算法的初始向量 encryptedData:encryptedData // 加密后的用户信息 &#125; // 请求服务端解密手机号 postAction(\"/user/weChat/getPhoneNumber\", data).then(res=>&#123; // 根据是否需要回填手机号做对应操作 &#125;) &#125;, fail () &#123; // sessionKey过期，重新做登录动作， // 让后端更新 sessionKey，并提示用户重新授权 &#125; &#125;) &#125; &#125;) 注意：在回调中调用 wx.login 登录，可能会刷新登录态。此时服务器使用 code 换取的 sessionKey 不是加密时使用的 sessionKey，导致解密失败。建议开发者提前进行 login；或者在回调中先使用 checkSession 进行登录态检查，避免 login 刷新登录态。 解密后的数据为： &#123; &quot;phoneNumber&quot;: &quot;13580006666&quot;, &#x2F;&#x2F; 用户绑定的手机号（国外手机号会有国际区号） &quot;purePhoneNumber&quot;: &quot;13580006666&quot;, &#x2F;&#x2F; 没有国际区号的手机号 &quot;countryCode&quot;: &quot;86&quot;, &#x2F;&#x2F; 国际区号 &quot;watermark&quot;: &#x2F;&#x2F; 数据水印 &#123; &quot;appid&quot;:&quot;APPID&quot;, &#x2F;&#x2F; 归属小程序appid &quot;timestamp&quot;: TIMESTAMP &#x2F;&#x2F; 数据获取的时间戳 &#125; &#125; 获取手机号 | 微信开放文档 wx.checkSession | 微信开放文档 服务端获取开放数据 | 微信开放文档 4、 调用微信支付支付 | 微信开放文档 5、 获取收货地址收货地址 | 微信开放文档 6、 获取微信运动微信运动 | 微信开放文档 7、 获取自定义权限wx.authorize | 微信开放文档授权 | 微信开放文档 ————– 未完成 —————🔊 尾声● 2021/04/15后（基础库2.10.4起） 微信调整了 wx.getUserInfo 接口现在已经只会返回匿名用户信息了，加密信息（encryptedData）中的 openID和unionID还可以获取，如果要获取用户个人信息，则需要使用 wx.getUserProfile 来代替，会唤起微信的授权窗口。调整说明 👉 小程序登录、用户信息相关接口调整说明 | 微信开放社区 资源 📚开放接口 | 微信开放文档服务端 | 微信开放文档","categories":[{"name":"踩坑日记","slug":"踩坑日记","permalink":"https://yogwang.site/categories/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"未完成","slug":"未完成","permalink":"https://yogwang.site/tags/%E6%9C%AA%E5%AE%8C%E6%88%90/"},{"name":"小程序","slug":"小程序","permalink":"https://yogwang.site/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"学习","slug":"学习","permalink":"https://yogwang.site/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"ES6 中的数组拓展方法 flat() & flatMap()","slug":"JS-flat&flatMap","date":"2021-05-17T06:14:01.000Z","updated":"2021-05-29T03:25:43.005Z","comments":true,"path":"2021/JS-flat&flatMap/","link":"","permalink":"https://yogwang.site/2021/JS-flat&flatMap/","excerpt":"之前有使用过 flat() 方法，但是一直不知道 flatMap() 方法，在使用 map() 方法组装集合的时候，在组装完成之后还要链式调用一下 flat()，如果可以知道 flatMap() 代码还能精简一点，也方便递归返回的数组内容。 本来是上个月发现的，但隔了一个月才有时间写，已经想不起来当时怎么发现的 flatMap() 这个方法了…就直接跳过前置场景，直接开始聊这两个扩展方法吧。","text":"之前有使用过 flat() 方法，但是一直不知道 flatMap() 方法，在使用 map() 方法组装集合的时候，在组装完成之后还要链式调用一下 flat()，如果可以知道 flatMap() 代码还能精简一点，也方便递归返回的数组内容。 本来是上个月发现的，但隔了一个月才有时间写，已经想不起来当时怎么发现的 flatMap() 这个方法了…就直接跳过前置场景，直接开始聊这两个扩展方法吧。 Array.prototype.flat([depth]) flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回，对原数据没有影响。 flat() 默认深度为 1，如果想要 “拉平” 多层的嵌套数组，可以将 flat() 方法的参数写成一个整数，表示想要拉平的层数。✨ 如果不管有多少层嵌套，都要转成一维数组，可以用 Infinity 关键字作为参数。✨ 如果原数组有空位，flat()方法会跳过空位(过滤掉空值) var arr1 = [1, 2, [3, 4]]; // 展开一层数组 arr1.flat(); // [1, 2, 3, 4] var arr2 = [1, 2, [3, 4, [5, 6]]]; arr2.flat(); // [1, 2, 3, 4, [5, 6]] // 展开两层数组 arr2.flat(2); // [1, 2, 3, 4, 5, 6] // 使用 Infinity，可展开任意深度的嵌套数组 var arr3 = [1, 2, [3, 4, [5, 6, [7, 8, [9, 10]]]]]; arr3.flat(Infinity); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] // flat() 方法会移除数组中的空项 var arr4 = [1, 2, , 4, 5]; arr4.flat(); // [1, 2, 4, 5] 很容易理解的一个方法，就是推平数组，其实成为自己想要的一维数组。不过可以接收一个 depth 参数，我是再写这篇笔记的时候才知道的，所以还是要多记笔记啊。 Array.prototype.flatMap(callback [, thisArg])) flatMap() 方法对原数组的每个成员执行一个函数（相当于执行 Array.prototype.map()），然后对返回值组成的数组执行 flat() 方法。该方法返回一个新数组，不改变原数组。 这个方法如果在知道 flat() 方法之后直接看，就还挺清楚作用是什么的，但是一看MDN上的说明，瞬间就被迷糊了….其实简单来说是先 map() 然后执行 flat() 的简化版（不能指定深度）。 ✨ flatMap() 只能展开一层数组 let arr = [\"it's Sunny in\", \"\", \"California\"]; arr.map(x => x.split(\" \")); // [[\"it's\",\"Sunny\",\"in\"],[\"\"],[\"California\"]] arr.map(x => x.split(\" \")).flat() // [\"it's\",\"Sunny\",\"in\", \"\", \"California\"] arr.flatMap(x => x.split(\" \")); // [\"it's\",\"Sunny\",\"in\", \"\", \"California\"] 尾声使用 reduce() 与 concat() 来替代 flat() 方法就不复述了，直接去看MDN上的实现就好。 替代方案 - flat 替代方案 - flatMap 是不是发现了一个 Infinity 关键字？这个关键字可以在哪些地方使用？Infinity 是一个全局变量(只读)，大于任何值，你也可以取反 -Infinity 使用基本上只要可以传入一个正整数来 比较 或者 迭代 的都可以使用它 📚 资源Array.prototype.flat() - JavaScript | MDNArray.prototype.flatMap() - JavaScript | MDN§ 9.数组实例的 flat()，flatMap() - 数组的扩展 - ECMAScript 6入门Infinity - JavaScript | MDN","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"},{"name":"ECMAScript 6","slug":"ECMAScript-6","permalink":"https://yogwang.site/tags/ECMAScript-6/"}]},{"title":"VueJS 的过滤器 filter API","slug":"vue-api-filter","date":"2021-05-17T03:23:49.000Z","updated":"2021-05-29T03:33:34.220Z","comments":true,"path":"2021/vue-api-filter/","link":"","permalink":"https://yogwang.site/2021/vue-api-filter/","excerpt":"一直没有怎么用过 Vue 的 过滤器 API，都是直接用 AntD Pro 当中提供的数字千分格式化、时间格式化之类的，没有自己去声明过，主要是因为 Array.prototype.filter 的先入为主，一直把 vue.filter 理解成为了筛选，而不是过滤器。 其实，vue.filter 是借鉴了 Linux 当中的 Pipe 符号 (|) 来处理数据 ，然后借用了 filter 这个名字： 利用 Linux 所提供的管道符 “|” 将两个命令隔开，管道符左边命令的输出就会作为管道符右边命令的输入 其实我觉得如果直接用 pipe 来命名其实就更好理解了，但是也许是因为前端圈子接触到 pipe 的人并不多，使用 filter 这个熟悉的单词可能更加容易让大众接受。 使用起来确实很方便，用 | 符号分隔就行，会按照 从前往后的顺序 依次 传入过滤器，然后返回转换后的值。 等到后来再遇到适合的场景想起来使用 filter ，但又因为项目的历史原因没有去使用，因为自己都是局部使用 computed计算 和 方法调用返回 来处理（也是Vue3所推荐的替代过滤器的方式）","text":"一直没有怎么用过 Vue 的 过滤器 API，都是直接用 AntD Pro 当中提供的数字千分格式化、时间格式化之类的，没有自己去声明过，主要是因为 Array.prototype.filter 的先入为主，一直把 vue.filter 理解成为了筛选，而不是过滤器。 其实，vue.filter 是借鉴了 Linux 当中的 Pipe 符号 (|) 来处理数据 ，然后借用了 filter 这个名字： 利用 Linux 所提供的管道符 “|” 将两个命令隔开，管道符左边命令的输出就会作为管道符右边命令的输入 其实我觉得如果直接用 pipe 来命名其实就更好理解了，但是也许是因为前端圈子接触到 pipe 的人并不多，使用 filter 这个熟悉的单词可能更加容易让大众接受。 使用起来确实很方便，用 | 符号分隔就行，会按照 从前往后的顺序 依次 传入过滤器，然后返回转换后的值。 等到后来再遇到适合的场景想起来使用 filter ，但又因为项目的历史原因没有去使用，因为自己都是局部使用 computed计算 和 方法调用返回 来处理（也是Vue3所推荐的替代过滤器的方式） 初步使用：在组件中使用过滤器过滤器可以用在两个地方（可以直接的使用方式有 2 种） 在双花括号中 &#123;&#123; message | filterName &#125;&#125;; 在 v-bind 中 &lt;div v-bind:id=&quot;message | filterName&quot;&gt;&lt;/div&gt;。 那如果说我要使用多个过滤器呢？例如：&#123;&#123; message | filterA | filterB &#125;&#125; 会先传入 filterA 去处理，filterA 返回的结果继续传入给 filterB 最后展示的值就是 filterB 返回的结果。 🌰 DEMO: &lt;template> &lt;div id=\"app\"> &lt;span>&#123;&#123; price | NumberFormat | FilterDollarSign &#125;&#125;&lt;/span> &lt;!-- 渲染结果是 $ 199,999,999 --> &lt;/div> &lt;/template> &lt;script> export default &#123; data() &#123; return &#123; price:199999999, &#125;; &#125;, filters:&#123; NumberFormat(value) &#123; if (!value) return '0' const intPartFormat = value.toString().replace(/(\\d)(?=(?:\\d&#123;3&#125;)+$)/g, '$1,') return intPartFormat &#125;, FilterDollarSign(price)&#123; return `$ $&#123;price&#125;` &#125; &#125;, &#125;; &lt;/script> ✨ 多参数 过滤器 的情况例如，需要传入 两个参数 的过滤器，刨开第一个默认传入的参数，键入第二个参数即可： &#123;&#123; price | NumberFormat(2) &#125;&#125; , 三个参数： &#123;&#123; price | NumberFormat(2, '$') &#125;&#125;，更多参数以此类推。 &lt;template> &lt;div id=\"app\"> &lt;span>&#123;&#123; price | NumberFormat(2, '$') &#125;&#125;&lt;/span> &lt;!-- 渲染结果是 $ 0.67 --> &lt;/div> &lt;/template> &lt;script> export default &#123; data() &#123; return &#123; price:0.6666, &#125;; &#125;, filters:&#123; NumberFormat(value, limit, sign) &#123; if (!value) return '0' const intPartFormat = value.toFixed(limit).toString() return `$&#123;sign&#125; $&#123;intPartFormat&#125;` &#125; &#125;, &#125;; &lt;/script> 更进一步：使用全局过滤器在项目的不断完善中，会有出现一些重复使用的过滤器，如果每次都重新声明就很麻烦，就可以注册 全局过滤器 vue.filter 🌰 栗子： // main.js Vue.filter('NumberFormat', function (value) &#123; if (!value) &#123; return '0' &#125; const intPartFormat = value.toString().replace(/(\\d)(?=(?:\\d&#123;3&#125;)+$)/g, '$1,') return intPartFormat &#125;) new Vue(&#123; // options &#125;).$mount('#app') 然后就可以在全局直接使用这个过滤器了，不需要单独再声明或者引入。 当然如果全部都直接在 main.js 当中书写很多过滤器就很容易让 main.js 内容过多，所以可以提取出来，例如 ant-design-vue-pro/filter.js，然后再 import 进来就可以了 ant-design-vue-pro/main.js ✨ 全局和局步同名冲突 当全局过滤器和局部过滤器重名时，会采用局部过滤器。 ✨ 以上说的都是在 &lt;template&gt; 当中使用过滤器，如果我想在 methods 当中使用呢?全局过滤器的话，可以直接使用文档中的 var myFilter = Vue.filter(&#39;my-filter&#39;) 来获取，然后就可以把 myFilter 当成一个函数使用了，如果时当前组件的过滤器的，可以使用 this.$options.filters[&#39;my-filter&#39;] 来获取，调用方式和上边一样。 🎐 尾声适合过滤器的场景一般是简单的字符串处理，例如上边提到的添加数字千分号、把 状态key 转换成 状态label 之类的。 过滤器中如何使用当前组件的 data 或者 methods 之类参看上条，如果需要使用 data、computed 和 methods 之类请使用 computed 替代 filter VueJS 3.x 当中的 filter 已删除 In 3.x, filters are removed and no longer supported. Instead, we recommend replacing them with method calls or computed properties.在 3.x 中，过滤器已删除，不再支持。相反地，我们建议用方法调用或计算属性替换它们。 🔗 资源Filters | Vue.js - v2.xFilters | Vue.js - v3.x","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"VueJS","slug":"VueJS","permalink":"https://yogwang.site/tags/VueJS/"}]},{"title":"微信小程序学习日记 L04 网络请求","slug":"miniprogram-devDiary-04-request","date":"2021-05-15T05:54:11.000Z","updated":"2021-05-29T03:31:54.523Z","comments":true,"path":"2021/miniprogram-devDiary-04-request/","link":"","permalink":"https://yogwang.site/2021/miniprogram-devDiary-04-request/","excerpt":"在小程序中发送网络请求，需要使用微信提供的API，提供了5种： 普通 HTTPS 请求（wx.request） 上传文件（wx.uploadFile） 下载文件（wx.downloadFile) WebSocket 通信（wx.connectSocket） UDP 通信（wx.createUDPSocket） 一般项目中使用频率最高的是 wx.request 和 wx.uploadFile 需要注意的是，小程序只可以跟指定的域名进行网络通信，需要事先设置通讯域名（服务器域名请在 「小程序后台-开发-开发设置-服务器域名」 中进行配置）。 可以查看 配置流程 了解一下具体注意项。","text":"在小程序中发送网络请求，需要使用微信提供的API，提供了5种： 普通 HTTPS 请求（wx.request） 上传文件（wx.uploadFile） 下载文件（wx.downloadFile) WebSocket 通信（wx.connectSocket） UDP 通信（wx.createUDPSocket） 一般项目中使用频率最高的是 wx.request 和 wx.uploadFile 需要注意的是，小程序只可以跟指定的域名进行网络通信，需要事先设置通讯域名（服务器域名请在 「小程序后台-开发-开发设置-服务器域名」 中进行配置）。 可以查看 配置流程 了解一下具体注意项。 #1 HTTPS 请求wx.request(options) 可以传入一个 options 对象，具体可以配置哪些参数可以查看 发起请求 - 参数 ，我就不一一例出来了。 简单的上一个登陆请求示例： wx.request(&#123; url: 'https://example.weixin.qq.com/login', // 接口地址 data: &#123; // 请求参数 uid: 'admin', pwd: '123456' &#125;, header: &#123; // 请求头 'content-type': 'application/json' // 默认json，为了举例我还是写上来了 &#125;, method:'POST', // 请求类型 success (res) &#123; // 接口调用成功的回调函数 &#125;, fail (err) &#123; // 接口调用失败的回调函数 &#125; &#125;) 需要注意的是： 不支持以 Promise 风格 调用。Promise 风格 是基础库版本 2.10.2 起开始支持的新调用方式，旧版本只能使用 callback 的形式来处理 最终发送给服务器的数据是 String 类型，如果传入的 data 不是 String 类型，会被转换成 String ，可以查看 data 参数说明 不过一般我会自己把请求函数 Promisify，如下 // request.js export function request (&#123; url, method, data, contentType = &#123;&#125; &#125;) &#123; const &#123; requestUrl &#125; = getApp().globalData // 在 app.js 设置的全局变量 const apiUrl = requestUrl + url // 拼接完整请求地址 const token = wx.getStorageSync(\"token\") const header = Object.assign(&#123; \"content-type\": \"application/json\", \"X-Access-Token\": token &#125;, contentType) console.info(\"请求接口: \", apiUrl); console.info(\"请求头部: \", header) console.info(\"请求参数: \", data) return new Promise((resolve, reject) => &#123; wx.request(&#123; url: apiUrl, data: data, method: method, header: header, success (res) &#123; console.info(`[$&#123;apiUrl&#125;]请求返回值:`); console.table(res.data) const &#123; success, result, message &#125; = res.data if(success) &#123; resolve(res.data) &#125; else &#123; reject(res.data) console.warn(\"ERROR_URL:\", url) return onErr(res.data) // 异常处理 &#125; &#125;, fail (err) &#123; reject(err) Toast(&#123; title: \"服务器异常，请重试！\" &#125;) // 封装的wx.showToast() console.warn(\"----------请求异常-----------\") console.warn(err) &#125; &#125;) &#125;) &#125; 然后再封装一下不同的请求方法，在使用的时候按需引入就好了 // manage.js import &#123; request &#125; from './request' export const FORM_DATA = &#123;\"content-type\": \"application/x-www-form-urlencoded;charset=UTF-8\"&#125; // post export function postAction (url, parameter, contentType = &#123;&#125;) &#123; return request(&#123; url: url, method: 'POST', data: parameter, contentType:contentType, &#125;) &#125; // http method= &#123;POST | PUT&#125; export function httpAction (url, parameter = &#123;&#125;, method, contentType = &#123;&#125;) &#123; return request(&#123; url: url, method: method, data: parameter, contentType:contentType, &#125;) &#125; // put export function putAction (url, parameter = &#123;&#125;, contentType = FORM_DATA) &#123; return request(&#123; url: url, method: 'PUT', data: parameter, contentType:contentType, &#125;) &#125; // get export function getAction (url, parameter = &#123;&#125;, contentType = &#123;&#125;) &#123; return request(&#123; url: url, method: 'GET', data: parameter, contentType:contentType, &#125;) &#125; // delete export function deleteAction (url, parameter = &#123;&#125;, contentType = &#123;&#125;) &#123; return request(&#123; url: url, method: 'DELETE', data: parameter, contentType:contentType, &#125;) &#125; 是不是有一股子 Ant Design Vue Pro 的味道 😂😂😂 #2 上传文件wx.uploadFile(options)，可以传入一个 options 对象，参数配置文档 注意：客户端发起一个 HTTPS POST 请求，其中 content-type 为 multipart/form-data。 示例代码： wx.chooseImage(&#123; success (res) &#123; const tempFilePaths = res.tempFilePaths // 获取的文件临时路径 wx.uploadFile(&#123; url: 'https://example.weixin.qq.com/upload', // 请求的网络接口 filePath: tempFilePaths[0], // 文件路径 name: 'file', // 文件key，服务端可以通过这个 key 获取文件二进制内容 formData: &#123; // 额外的 formData 可以不传 'user': 'test' &#125;, success (result)&#123; // 接口调用成功的回调函数 &#125;, fail (error)&#123; // 接口调用失败的回调函数 &#125; &#125;) &#125; &#125;) 同样也会封装成 Promise // request.js export function uploadFile (&#123; url, data &#125;) &#123; const &#123; requestUrl &#125; = getApp().globalData // 在 app.js 设置的全局变量 const apiUrl = requestUrl + url const token = wx.getStorageSync(\"token\") const header = &#123; \"X-Access-Token\": token &#125; console.info(\"请求接口: \", apiUrl); console.info(\"请求头部: \", header) console.info(\"文件地址: \", data) return new Promise((resolve, reject) => &#123; wx.uploadFile(&#123; url: apiUrl, filePath: data.filePath, name: 'file', header: header, success: (res) => &#123; console.info(`[$&#123;apiUrl&#125;]请求返回值:`); console.table(res.data) const &#123; data, statusCode &#125; = res if (statusCode !== 200)&#123; Toast(&#123; title: \"上传失败\" &#125;) reject(res.data) return &#125; // 这里需要注意是否返回的是JSON格式的 data const d = JSON.parse(data) const &#123; success, result, message &#125; = data if (success) &#123; resolve(d) &#125; else &#123; reject(res.data) console.warn(\"ERROR_URL:\", url) return onErr(d) // 异常处理 &#125; &#125;, fail (err) &#123; reject(err) Toast(&#123; title: \"服务器异常，请重试！\" &#125;) console.warn(\"-----------上传失败-----------\"); console.warn(err); &#125; &#125;) &#125;) &#125; #3 下载文件wx.downloadFile(options)，同样也可以传入一个 options 对象，配置文档 DownloadTask | 微信开放文档 发起一个 HTTPS GET 请求 返回文件的本地临时路径 (本地路径) 单次下载允许的最大文件为 200MB 注意：请在服务端响应的 header 中指定合理的 Content-Type 字段，以保证客户端正确处理文件类型。 示例代码 wx.downloadFile(&#123; url: 'https://example.com/audio/123', // 仅为示例，并非真实的资源 success (res) &#123; // 只要服务器有响应数据，就会把响应内容写入文件并进入 success 回调，业务需要自行判断是否下载到了想要的内容 if (res.statusCode === 200) &#123; wx.playVoice(&#123; filePath: res.tempFilePath &#125;) &#125; &#125; &#125;) 暂时还没有使用的场景，就暂时不描述了，WebSocket 也是还没有在小程序业务上使用过，就不细说了，简单的用文档中的示例 #4 WebSocket 通信首先需要使用 wx.connectSocket(options) 创建一个 WebSocket 连接。具体文档 SocketTask | 微信开放文档然后就和正常使用 WebSocket 一样了： 方法 wx.sendSocketMessage(Object object) 通过 WebSocket 连接发送数据。 wx.closeSocket(Object object) 关闭 WebSocket 连接 事件 全局事件 wx.onSocketOpen(callback) 监听 WebSocket 连接打开事件 wx.onSocketMessage(callback) 监听 WebSocket 接受到服务器的消息事件 wx.onSocketError(callback) 监听 WebSocket 错误事件 wx.onSocketClose(callback) 监听 WebSocket 连接关闭事件 当前Socket事件 通过 wx.connectSocket() 接口创建返回赋值给变量 SocketTask SocketTask.onSocketOpen(callback) 监听 WebSocket 连接打开事件 SocketTask.onSocketMessage(callback) 监听 WebSocket 接受到服务器的消息事件 SocketTask.onSocketError(callback) 监听 WebSocket 错误事件 SocketTask.onSocketClose(callback) 监听 WebSocket 连接关闭事件 #5 UDP 通信使用 wx.createUDPSocket() 创建一个 UDP Socket 实例，之后就可以和 WebSocket 通信类似的方式使用 UDPSocket API来通信了，具体文档 UDPSocket | 微信开放文档 方法 UDPSocket.bind(number port) 绑定一个可用端口号 UDPSocket.send() 向指定的 IP 和 port 发送消息 UDPSocket.connect(Object object) 预先连接到指定的 IP 和 port，需要配合 write 方法一起使用 UDPSocket.write() 用法与 send 方法相同，如果没有预先调用 connect 则与 send 无差异 UDPSocket.close() 关闭 UDP Socket 实例，相当于销毁 事件 UDPSocket.onClose(callback) 监听关闭事件 UDPSocket.offClose(callback) 取消监听关闭事件 UDPSocket.onError(callback) 监听错误事件 UDPSocket.offError(callback) 取消监听错误事件 UDPSocket.onListening(callback) 监听开始监听数据包消息的事件 UDPSocket.offListening(callback) 取消监听开始监听数据包消息的事件 UDPSocket.onMessage(callback) 监听收到消息的事件 UDPSocket.offMessage(callback) 取消监听收到消息的事件 错误码之类的直接看 文档 吧。这个API应该是和我无缘了，物联网和直播之类的场景我应该是很难遇到的。 其它📌 配置网络请求超时时间如果需要配置超时时间则需要去 app.json 中配置 networkTimeout，默认 60000 (单位：毫秒)，最大超时时间也是 60000。可以为4个网络请求单独配置超时时间，具体查看 👉 配置文档 &#x2F;&#x2F; app.json &#123; &#x2F;&#x2F; 其他配置项.... &quot;networkTimeout&quot;: &#123; &quot;request&quot;: 10000, &#x2F;&#x2F; wx.request 的超时时间 &quot;uploadFile&quot;: 10000 &#x2F;&#x2F; wx.uploadFile 的超时时间 &#125; &#125; 资源网络 | 微信开放文档RequestTask | 微信开放文档API Promise化 | 微信开放文档 WebSocket - Web API 接口参考 | MDN","categories":[{"name":"踩坑日记","slug":"踩坑日记","permalink":"https://yogwang.site/categories/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"未完成","slug":"未完成","permalink":"https://yogwang.site/tags/%E6%9C%AA%E5%AE%8C%E6%88%90/"},{"name":"小程序","slug":"小程序","permalink":"https://yogwang.site/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"学习","slug":"学习","permalink":"https://yogwang.site/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"挖坑","slug":"挖坑","permalink":"https://yogwang.site/tags/%E6%8C%96%E5%9D%91/"}]},{"title":"CSS 选择器权重和优先级","slug":"CSS-specificity-selectors-weight","date":"2021-05-14T03:03:15.000Z","updated":"2021-05-29T03:30:17.288Z","comments":true,"path":"2021/CSS-specificity-selectors-weight/","link":"","permalink":"https://yogwang.site/2021/CSS-specificity-selectors-weight/","excerpt":"群里突然又聊到了CSS样式的权重，这个话题每隔一段时间就会出现一次，但是每次都去搜索找选择器权重的文章分享有点太麻烦了，主要是配图，想要找到自己记忆里的那张图真的很麻烦😂，所以还是自己整理一篇，以后直接分享自己的笔记就好了。其实权重计算这个东西不麻烦，就是分 4 类: inlineStyle: 行内样式 #ID: ID选择器 .Class: 类,属性和伪类选择器 Element: 元素和伪类元素选择器 简单的权重比较 inline style &gt; ID &gt; Class &gt; Element &gt; * 这个应该不需要说了吧，主要是多个选择器混合使用时计算的问题。","text":"群里突然又聊到了CSS样式的权重，这个话题每隔一段时间就会出现一次，但是每次都去搜索找选择器权重的文章分享有点太麻烦了，主要是配图，想要找到自己记忆里的那张图真的很麻烦😂，所以还是自己整理一篇，以后直接分享自己的笔记就好了。其实权重计算这个东西不麻烦，就是分 4 类: inlineStyle: 行内样式 #ID: ID选择器 .Class: 类,属性和伪类选择器 Element: 元素和伪类元素选择器 简单的权重比较 inline style &gt; ID &gt; Class &gt; Element &gt; * 这个应该不需要说了吧，主要是多个选择器混合使用时计算的问题。 大部分人想到CSS权重应该会首先想到这个图 图片来源: 简明现代魔法 然后简单的按照这里的权重去计算出来结果去比较 例如： 但是！这样的计算会有一个问题，就是如果说某一项选择器超过了10个，那么是不是就会造成疑问，是否会晋级例如 // 1个ID选择器 #demo &#123; color:green &#125; // 11个class选择器 .demo1 .demo2 .demo3 .demo4 .demo5 .demo6 .demo7 .demo8 .demo9 .demo10 .demo11 &#123; color:red &#125; 按照上边的计算方式，得出的结果就是 100 ：110，但是实际并不会被11个类选择器所覆盖。 所以其实，是一个类似数组的形式，其计算结果为 [0, 1, 0, 0] 比上 [0, 0, 11, 0]， 这点可以从 W3C规范 上看到，其实是分为 [A, B, C, D] 四类，然后去一对一去比较，并不会被 进位 所影响。 ⭐ !important !important 是一个特殊的声明，W3C 将其与选择器权重计算区分开，但是很多文章中把他放置到 A 类之前作为 第0类 权重，确实在实际工作中观察到的效果也一致，只不过不能通过重复声明 !important 来达到提升权重的目的（Invalid property value） 但如果是继承下来的 !important 属性，则会被新的声明覆盖。 # 如果使用简写属性并且使用 !important 声明 Declaring a shorthand property (e.g., ‘background‘) to be “!important“ is equivalent to declaring all of its sub-properties to be “!important“. 将简写属性（例如’background‘）声明为 “!important“ 等同于将其所有子属性声明为 “!important“ 。 接下来看一个完整的例子 &lt;div class=&quot;demo-class1 demo-class2&quot;&gt;&lt;span&gt;测试文字ABC&lt;/span&gt;&lt;/div&gt; 的元素样式： .demo-class1 &#123; font: italic 12pt sans-serif !important; text-indent: 1em ! important; // 被覆盖 &#125; .demo-class2 &#123; font-weight: bold; // 未生效 font-size: 24pt; // 未生效 line-height: 1.2 !important; // 生效 text-indent: 1.5em !important; // 生效 &#125; .demo-class2 span &#123; font-style: normal // 生效 &#125; 尾声我所推荐的权重计算图 新版本中的选择器权重修改在 W3C 最新版的 选择器文档 中，行内样式已经从权重中移出了，权重变成了三类 [#ID, .Class, Element] 在阅读 W3C 规范中，发现有中有这样一句话 By default, rules in author style sheets have more weight than rules in user style sheets. Precedence is reversed, however, for “!important” rules. All user and author rules have more weight than rules in the UA’s default style sheet. 默认情况下，author style sheets(作者样式表) 中的规则比 user style sheets(用户样式表) 中的规则具有更大的权重。 但是，对于 “!important” 规则，优先级相反。 与 UA 的默认样式表中的规则相比，所有用户和作者规则的权重均更大。 其中的 Author Style sheets、User Style sheets 是我没有遇到过的名词，UA 当然是浏览器(用户代理)默认样式，从查阅到的结果来看： 作者样式表 (Author Style sheets)作为开发者的我们为项目所配置的样式表 用户样式表 (User Style sheets)浏览器为浏览站点的用户提供的一个修改当前站点样式的功能（一般都是浏览器插件实现）所生成的样式表 # 参考CSS2 - 6.4 The cascade - W3C RecommendationCSS2 - 6.4.2 !important rules - W3C RecommendationCSS2 - 6.4.3 Calculating a selector’s specificity - W3C RecommendationSelectors - 16. Calculating a selector’s specificity - W3C RecommendationDraft - 6.3. Important Declarations: the !important annotation - W3C Editor’s Draft CSS选择器的权重计算规则 - 简明现代魔法Day20：小事之 CSS 權重 (css specificity) - iT 邦幫忙Specifics on CSS Specificity | CSS-TricksUser style sheet vs Author style sheet | Treehouse Community","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://yogwang.site/tags/CSS/"}]},{"title":"微信小程序学习日记 L03 生命周期","slug":"miniprogram-devDiary-03-lifecycle","date":"2021-05-13T11:29:31.000Z","updated":"2021-05-29T03:31:52.431Z","comments":true,"path":"2021/miniprogram-devDiary-03-lifecycle/","link":"","permalink":"https://yogwang.site/2021/miniprogram-devDiary-03-lifecycle/","excerpt":"一开始按照 Vue 的思路下来，会认为生命周期很重要，需要完整的看一遍，但是其实整个小程序开发完之后，生命周期的概念其实并不是很重要，大概分成 小程序 的生命周期 和 页面/组件 的生命周期。这些生命周期函数中 主要就是使用 onShow 和 onLoad 两个，用来获取和设置初始参数，发起请求等等。其它的几个回调函数其实很少有用到，但是还是聊一聊吧。","text":"一开始按照 Vue 的思路下来，会认为生命周期很重要，需要完整的看一遍，但是其实整个小程序开发完之后，生命周期的概念其实并不是很重要，大概分成 小程序 的生命周期 和 页面/组件 的生命周期。这些生命周期函数中 主要就是使用 onShow 和 onLoad 两个，用来获取和设置初始参数，发起请求等等。其它的几个回调函数其实很少有用到，但是还是聊一聊吧。 📱 app.js 小程序的生命周期回调函数 App(Object object) | 微信开放文档1. onLaunch(options) 小程序初始化完成时触发 全局只触发一次 参数也可以使用 wx.getLaunchOptionsSync 获取 options参数和 wx.getLaunchOptionsSync 方法的回调参数一致 注意：部分版本在无 referrerInfo的时候会返回 undefined，建议使用 options.referrerInfo &amp;&amp; options.referrerInfo.appId 进行判断。 2. onShow(options) 小程序启动，或从后台进入前台显示时触发 可以使用 wx.onAppShow 绑定监听 options参数与 wx.onAppShow 方法的回调参数一致 3. onHide() 小程序从前台进入后台时触发 可以使用 wx.onAppHide 绑定监听 📄 页面中的生命周期回调函数 Page(Object object) | 微信开放文档1. onLoad(options) 页面加载时触发 一个页面在一个生命周期中只会调用一次 可以在 options 中获取打开当前页面路径中的参数。 2. onShow() 页面显示/切入前台时触发 一般的接口请求我会在这边调用 3. onReady() 页面初次渲染完成时触发 代表页面已经准备妥当，可以和视图层进行交互。 一个页面只会调用一次 注意：对界面内容进行设置的 API 如 wx.setNavigationBarTitle，请在 onReady 之后进行。 4. onHide() 页面隐藏/切入后台时触发 触发时机： 如 wx.navigateTo 或底部 tab 切换到其他页面，小程序切入后台等。 5. onUnload() 页面卸载时触发 触发时机：如 wx.redirectTo 或 wx.navigateBack 到其他页面时 示例代码： Page(&#123; data: &#123; text: \"This is page data.\" &#125;, onLoad: function(options) &#123; // Do some initialize when page load. &#125;, onShow: function() &#123; // Do something when page show. &#125;, onReady: function() &#123; // Do something when page ready. &#125;, onHide: function() &#123; // Do something when page hide. &#125;, onUnload: function() &#123; // Do something when page close. &#125;, onPullDownRefresh: function() &#123; // Do something when pull down. &#125;, onReachBottom: function() &#123; // Do something when page reach bottom. &#125;, onShareAppMessage: function () &#123; // return custom share data when user share. &#125;, onPageScroll: function() &#123; // Do something when page scroll &#125;, onResize: function() &#123; // Do something when page resize &#125;, // 自定义函数 onCustomMethod: function() &#123; this.setData(&#123; text: 'Set some data for updating view.' &#125;, function() &#123; // this is setData callback &#125;) &#125;, &#125;) 📑 组件中的生命周期回调函数 组件生命周期 | 微信开放文档1. created() 在组件实例刚刚被创建时执行 组件实例刚刚被创建好时， created 生命周期被触发。 此时还不能调用 setData 2. attached() 在组件实例进入页面节点树时执行 在组件完全初始化完毕、进入页面节点树后， attached 生命周期被触发。 绝大多数初始化工作可以在这个时机进行 3. ready() 在组件在视图层布局完成后执行 同页面组件的 onShow 4. moved() 在组件实例被移动到节点树另一个位置时执行 没有一个很合适的场景，在小程序中也有人提问这个函数的执行时机，我写了一个片段可以查看 🔖代码片段 5. detached() 在组件实例被从页面节点树移除时执行 退出一个页面时，如果组件还在页面节点树中，则 detached 会被触发。 🧷 组件所在页面的生命周期： 还有一些特殊的生命周期，它们并非与组件有很强的关联，但有时组件需要获知，以便组件内部处理。这样的生命周期称为“组件所在页面的生命周期”，在 pageLifetimes 定义段中定义。 1. show() 组件所在的页面被展示时执行2. hide() 组件所在的页面被隐藏时执行3. resize(size) 组件所在的页面尺寸变化时执行 可以接收一个 size 参数 自小程序基础库版本 2.2.3 起，组件的的生命周期也可以在 lifetimes 字段内进行声明（这是推荐的方式，其优先级最高）。 在 behaviors 中也可以编写生命周期方法，同时不会与其他 behaviors 中的同名生命周期相互覆盖。但要注意，如果一个组件多次直接或间接引用同一个 behavior ，这个 behavior 中的生命周期函数在一个执行时机内只会执行一次。 🌰 组件生命周期完整示例 Component(&#123; // 推荐组件生命周期函数定义方式 lifetimes: &#123; attached: function() &#123; // 在组件实例进入页面节点树时执行 &#125;, detached: function() &#123; // 在组件实例被从页面节点树移除时执行 &#125;, &#125;, // 以下是旧式的定义方式，可以保持对小于 2.2.3 版本基础库的兼容 attached: function() &#123; // 在组件实例进入页面节点树时执行 &#125;, detached: function() &#123; // 在组件实例被从页面节点树移除时执行 &#125;, // 组件所在页面的生命周期回调 pageLifetimes: &#123; show: function() &#123; // 页面被展示 &#125;, hide: function() &#123; // 页面被隐藏 &#125;, resize: function(size) &#123; // 页面尺寸变化 &#125; &#125; &#125;) 尾声🎇 在组件中有提到 behavior 这个东西的一些疑问behavior 直译过来就是行为，有点不是很明确，只能看 behaviors | 微信开放文档 上的解释： behaviors 是用于组件间代码共享的特性，类似于一些编程语言中的 “mixins” 或 “traits”。 再继续往下翻文档的时候看到 使用方法 和 同名字段的覆盖和组合规则 就基本能确定了，就是 VueJS 中的 mixins API 但是如果在 behavior 中也使用了生命周期函数，和当前组件的生命周期函数的谁先执行呢？是否和Vue一样？可以查看官方提供的 🔖代码片段实际操作得出的结果：先执行 behavior 的生命周期函数，然后再是执行组件本身的生命周期函数文档也给出了规则： 对于同种生命周期函数，遵循如下规则： behavior 优先于组件执行； 子 behavior 优先于 父 behavior 执行； 靠前的 behavior 优先于 靠后的 behavior 执行； 最后本文所描述小程序最新版本 v2.17.0 (2021-04-28)","categories":[{"name":"踩坑日记","slug":"踩坑日记","permalink":"https://yogwang.site/categories/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://yogwang.site/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"学习","slug":"学习","permalink":"https://yogwang.site/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"微信小程序学习日记 L02 路由跳转","slug":"miniprogram-devDiary-02-router","date":"2021-05-09T07:25:19.000Z","updated":"2021-05-29T03:31:50.437Z","comments":true,"path":"2021/miniprogram-devDiary-02-router/","link":"","permalink":"https://yogwang.site/2021/miniprogram-devDiary-02-router/","excerpt":"以前一直都是写的 Vue，所以在刚接触小程序的时候会疑惑，小程序是否也有和 Vue 一样有路由表，但是看完开放文档之后发现没有路由表，就很疑惑。那小程序怎么去做页面跳转的呢？ 首先，虽然小程序没有路由表，但是在全局配置文件(app.json)中有 pages 信息用于指定小程序由哪些页面组成，每一项都对应一个页面的 路径（含文件名） 信息。文件名不需要写文件后缀，框架会自动去寻找对应位置的文件进行处理。","text":"以前一直都是写的 Vue，所以在刚接触小程序的时候会疑惑，小程序是否也有和 Vue 一样有路由表，但是看完开放文档之后发现没有路由表，就很疑惑。那小程序怎么去做页面跳转的呢？ 首先，虽然小程序没有路由表，但是在全局配置文件(app.json)中有 pages 信息用于指定小程序由哪些页面组成，每一项都对应一个页面的 路径（含文件名） 信息。文件名不需要写文件后缀，框架会自动去寻找对应位置的文件进行处理。 例如默认项目中: &#123; &quot;pages&quot;: [ &quot;pages&#x2F;index&#x2F;index&quot;, &#x2F;&#x2F; 首页 &quot;pages&#x2F;logs&#x2F;logs&quot; &#x2F;&#x2F; 日志页 ], &quot;entryPagePath&quot;: &quot;pages&#x2F;index&#x2F;index&quot; &#x2F;&#x2F; 初始页面 &#125; 可以通过 entryPagePath 指定小程序的初始页面（首页），如果未配置则默认为 pages 数组的第一项。 📑 pages - 全局配置 | 微信开放文档 如果想要配置到底部的Tabs上，则需要在 tabBar 属性中配置例如： &#123; &quot;pages&quot;: [ &quot;pages&#x2F;index&#x2F;index&quot;, &quot;pages&#x2F;logs&#x2F;logs&quot; ], &quot;entryPagePath&quot;: &quot;pages&#x2F;index&#x2F;index&quot;, &quot;tabBar&quot;: &#123; &quot;color&quot;: &quot;#BBBBBD&quot;, &#x2F;&#x2F; 文字默认颜色 &quot;selectedColor&quot;: &quot;#040104&quot;, &#x2F;&#x2F; 文字选中时的颜色 &quot;list&quot;: [ &#x2F;&#x2F; tab 的列表 &#123; &quot;pagePath&quot;: &quot;pages&#x2F;index&#x2F;index&quot;, &#x2F;&#x2F; 页面路径，必须在 pages 中先定义 &quot;text&quot;: &quot;首页&quot;, &#x2F;&#x2F; tab 上按钮文字 &quot;iconPath&quot;: &quot;assets&#x2F;img&#x2F;tabbar_home.png&quot;, &#x2F;&#x2F; icon图片路径 &quot;selectedIconPath&quot;: &quot;assets&#x2F;img&#x2F;tabbar_home_active.png&quot; &#x2F;&#x2F; tab选中时icon图片路径 &#125;, &#123; &quot;pagePath&quot;: &quot;pages&#x2F;logs&#x2F;logs&quot;, &quot;text&quot;: &quot;日志&quot;, &quot;iconPath&quot;: &quot;assets&#x2F;img&#x2F;tabbar_logo.png&quot;, &quot;selectedIconPath&quot;: &quot;assets&#x2F;img&#x2F;tabbar_logo_active.png&quot; &#125; ] &#125;, &#125; 注意：只能配置最少 2 个、最多 5 个 tab，tab 按数组的顺序排序，每个项都是一个对象 📑 tabBar - 全局配置 | 微信开放文档📑 自定义 tabBar | 微信开放文档 页面信息配置完了，怎么进行路由呢？小程序提供了 5 种路由操作API： #1. wx.switchTab(Opts) 跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面 #2. wx.navigateTo(Opts) 保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面。 对应 vue-router 当中的 $router.push() #3. wx.redirectTo(Opts) 关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面。 对应 vue-router 当中的 $router.replace() #4. wx.navigateBack(Opts) 关闭当前页面，返回上一页面或多级页面，如果大于现有页面数，则返回到首页。 对应 vue-router 当中的 $router.back()、$router.forward()、$router.go(-1) 或者 $router.go(-n) #5. wx.reLaunch(Opts) 关闭所有页面，打开到应用内的某个页面 可以理解成 location.reload() ，刷新小程序并且打开指定页面 注意：小程序中页面栈最多十层 最后是疑问部分：🎇 路由是否可以像 vue-router 一样省略 index不可以，需要全路径 🎇 如何路由传参需要跳转的应用内非 tabBar 的页面路径后可以用 query 的形式传递参数，如 path?key=value&amp;key2=value2。页面中也可以在 onLoad 事件中接受参数 Page(&#123; onLoad: function(option)&#123; console.log(option.query) &#125; &#125;) 具体查看文档 wx.navigateTo(Object object) | 微信开放文档 🎇 清空路由历史没有单独的清空跳转历史API，可以直接使用 wx.reLaunch() 来跳转到目标页面，并且同时关闭所有已经打开过的页面，就不能用 wx.navigateBack() 返回了，左上角的按钮也会变成 🏠 home 🎇 路由文档中的 EventChannel 是什么 如果一个页面由另一个页面通过 wx.navigateTo 打开，这两个页面间将建立一条数据通道 被打开的页面可以通过 this.getOpenerEventChannel() 方法来获得一个 EventChannel 对象； wx.navigateTo 的 success 回调中也包含一个 EventChannel 对象。 有点 Vue 中的父子组件通信 $emit 和 @on ，比如说来进行数据回传： 1.先打开页面A；2.然后选择具体信息（打开页面B）；3.选择完成确定；4.返回页面A（接收页面B回传的数据） 的步骤。 示例代码就不复制过来了，直接看 示例代码 内的 Demo 就好了，也可以查看 📌代码片段 EventChannel | 微信开放文档页面间通信 - Page(Object object) | 微信开放文档 本文所描述小程序最新版本 v2.17.0 (2021-04-28)","categories":[{"name":"踩坑日记","slug":"踩坑日记","permalink":"https://yogwang.site/categories/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://yogwang.site/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"学习","slug":"学习","permalink":"https://yogwang.site/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"微信小程序学习日记 L01 目录结构","slug":"miniprogram-devDiary-01-structure","date":"2021-05-06T14:21:47.000Z","updated":"2021-05-29T03:31:46.866Z","comments":true,"path":"2021/miniprogram-devDiary-01-structure/","link":"","permalink":"https://yogwang.site/2021/miniprogram-devDiary-01-structure/","excerpt":"小程序包含一个描述整体程序的 app 和多个描述各自页面的 page。刚刚接触到小程序，使用 微信开发者工具 新建完项目之后，会有一个这样的初始结构： ├─pages │ ├─index │ │ index.js │ │ index.json │ │ index.wxml │ │ index.wxss │ │ │ └─logs │ logs.js │ logs.json │ logs.wxml │ logs.wxss │ ├─utils │ util.js ├─ app.js ├─ app.json ├─ app.wxss ├─ project.config.json └─ sitemap.json","text":"小程序包含一个描述整体程序的 app 和多个描述各自页面的 page。刚刚接触到小程序，使用 微信开发者工具 新建完项目之后，会有一个这样的初始结构： ├─pages │ ├─index │ │ index.js │ │ index.json │ │ index.wxml │ │ index.wxss │ │ │ └─logs │ logs.js │ logs.json │ logs.wxml │ logs.wxss │ ├─utils │ util.js ├─ app.js ├─ app.json ├─ app.wxss ├─ project.config.json └─ sitemap.json 先看最外层的文件 [ app.js, app.json, app.wxss, project.config.json, sitemap.json ] app.js 小程序实例化，可配置小程序实例 设置生命周期回调和事件监听 配置小程序全局对象 globalData 全局可以通过 getApp() 方法获取小程序实例恶 app.json 小程序全局公共配置、默认配置项 &quot;pages&quot; 页面路由配置 &quot;window&quot; 全局默认页我面样式配置 配置文档 &quot;tabBar&quot; 底部 选项卡 配置就 &quot;usingComponents&quot; 全局自定义组件配置 使用自定义组件 其它他配置项可以查看 👉 全局配置 | 微信开放文档 app.wxss 小程序全局样式 小程序全局的样式配置，会被局部样式覆盖 具有 CSS 大部分特性 当前支持的选择器 👉 选择器 | 微信开放文档 拓展了一个尺寸单位 rpx 尺寸单位 | 微信开放文档 project.config.json 小程序项目配置文件 可以直接配置本地小程序项目属性，工具栏-设置-项目设置 中设置的配置项 每次提交项目时不会提交该文件 sitemap.json 配置小程序及其页面是否允许被微信搜索索引 rules 索引规则，具体可查看 sitemap 配置 | 微信开放文档 如果没有 sitemap.json ，默认所有页面都允许被索引 然后看 pages 目录 小程序的页面目录 pages/index 下是包括了4种文件的 [ js, wxml, json, wxss ], 和根目录一样，只是多了一个 wxml 文件，分别对应的是： js - 注册页面，配置页面的初始数据、生命周期回调、事件处理函数等 配置文档 wxml - 组件的结构，微信自己的一套类似 html 的标签语言，来构建出页面结构 WXML | 微信开放文档 &lt;view&gt; 对应 &lt;div&gt; 标签 &lt;text&gt; 对应 &lt;span&gt; 标签 &lt;template&gt; 对应 Vue 的 &lt;template&gt; 模板标签 &lt;image&gt; 对应 &lt;img&gt; 标签 其它更多标签可以查看 视图容器 | 微信开放文档 json - 当前页面配置，类似 app.json 会覆盖 app.json 的 window 中相同的配置项 具体配置查看 👉 配置文档 非必须项，可以被删除 wxss - 组件的样式 会覆盖 app.wxss 当中相同的选择器样式 非必须项，可以被删除 注意：为了方便开发者减少配置项，描述页面的四个文件必须具有相同的路径与文件名。 微信客户端会先根据 index.json 配置生成一个界面，顶部的颜色和文字都可以在这个 json 文件里边定义好。然后微信就会装载这个页面的 WXML 结构和 WXSS 样式，最后微信会装载 index.js utils 目录一般来说 utils 目录下是一些被抽离出来的公共代码，比如说你封装好的请求函数，和默认给你的时间格式化和数字格式化。通过 export 导出，在需要的文件中通过 import 引入。 但是不支持 绝对路径，需要使用 相对路径 来引入，这个比较麻烦需要自己注意。 最后在正常使用过程中，我们还会遇到 component - 自定义组件，它和 pages 页面组件类似，也是由 [ json, wxml, wxss, js ] 4个文件组成，但是稍有不同。 你可以单独新建一个顶级的 components 目录，例如：/components/userInfo/...，也可以放到不同 page 对应的目录下 /pages/home/components/userInfo/... 不同点：首先，.json 文件中需要声明 component 为 true &#123; &quot;component&quot;: true &#125; 然后是在 .js 文件中注册组件的不同， 需要使用 Component() 来注册组件，多了 properties 属性和 methods 属性。 具体配置就不多说了，直接参看文档 Component 构造器 | 微信开放文档 总结整体和 Vue 的遍写思路很像了， .js 文件对应的是 Vue 文件的 &lt;script&gt; 部分 .wxml 文件对应的是 Vue 文件的 &lt;template&gt; 部分 .wxss 文件时 Vue 文件中的 &lt;style&gt; 部分 .json 文件算是 Vue 实例初始化时的 options 本文所描述小程序最新版本 v2.17.0 (2021-04-28)","categories":[{"name":"踩坑日记","slug":"踩坑日记","permalink":"https://yogwang.site/categories/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://yogwang.site/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"学习","slug":"学习","permalink":"https://yogwang.site/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"微信小程序学习开发日记 L00","slug":"miniprogram-devDiary-00","date":"2021-04-01T03:22:28.000Z","updated":"2021-08-13T08:56:15.687Z","comments":true,"path":"2021/miniprogram-devDiary-00/","link":"","permalink":"https://yogwang.site/2021/miniprogram-devDiary-00/","excerpt":"发现我安装小程序开发者工具是18年的事情了，那个时候还没有开始学 vue，算是开始填早几年立的一个 📌Flag 吧。 当时是想给我们的烘焙工作室的公众号做一个配套的营销工具，所以在18年底有去了解，只不过后来只做了一个展示型网站 岁礼气球派对，后来又改版了好几次现在主营是派对布置，好了有点扯远了。 填坑的动力主要是业务驱动，因为现在正好有这个任务安排，在回顾2020也大概提到了。所以今天先开始概括一下没有开发过小程序的前端，对于小程序的一些疑问。","text":"发现我安装小程序开发者工具是18年的事情了，那个时候还没有开始学 vue，算是开始填早几年立的一个 📌Flag 吧。 当时是想给我们的烘焙工作室的公众号做一个配套的营销工具，所以在18年底有去了解，只不过后来只做了一个展示型网站 岁礼气球派对，后来又改版了好几次现在主营是派对布置，好了有点扯远了。 填坑的动力主要是业务驱动，因为现在正好有这个任务安排，在回顾2020也大概提到了。所以今天先开始概括一下没有开发过小程序的前端，对于小程序的一些疑问。 # Roadmap 学习路径会在学习和开发中不断调整，不同阶段会有不同的理解，以下只是现阶段我对于学习顺序先后的整理。 目录结构 👉 学习日记 L01 目录结构路由跳转 👉 学习日记 L02 路由跳转生命周期 👉 学习日记 L03 生命周期网络请求 👉 学习日记 L04 网络请求拉起授权 👉 学习日记 L05 拉起授权组件分割 # 疑问🎇 小程序开发到底是像 Vue 还是 React？🎇 小程序开发能否使用 npm 进行包管理？可以，npm 支持 | 微信开放文档 tips：在小程序中使用npm包前，需先构建 npm 🎇 尺寸单位 rpx 应该怎么去理解正常来说，在网页端我们基本都是使用 px/em/rem 这类的常规单位，然后按照不同的设备尺寸去适配，但是小程序有一个 rpx 单位，可以根据屏幕宽度进行自适应，怎么去理解呢？其实就是看设计稿，因为 rpx 默认屏幕宽为 750rpx ，所以如果UI给的设计稿为 750px 则 1rpx 趋近于 0.5px 或者 1pt 因为大部分设备 DPR = 2，如果设计稿是 375px 宽度的则 1：1 转换就可。一句话形容就是按照设计稿的宽度除以 750 再乘以 2 来计算。 🎇 小程序是否支持CSS预处理器不支持，但是你可以自己处理成 .wxss，具体可以查看这篇文章： 📍在小程序中使用CSS预处理器 🎇 Component 如何使用 properties 中的 observer🎇 bindtap 绑定的函数怎么传入自定义参数使用 dataset，例如：&lt;view id=&quot;tapTest&quot; data-hi=&quot;Weixin&quot; bindtap=&quot;&#123;&#123;tapName&#125;&#125;&quot;&gt; Click me! &lt;/view&gt;，具体可以看 事件 | 微信开放文档。是不是有点蠢…. 🎇 事件如何绑定在按键上使用 bindtap 等绑定事件 事件的使用方式 🎇 是否有组件 slot有，组件提供一个 &lt;slot&gt; 节点，具体文档 组件模板和样式 | 微信开放文档 🎇 组件间通信方法/事件类似 Vue 中的 $emit 方法， this.triggerEvent(&quot;myEventName&quot;, myEventDetail, myEventOption)，文档 组件间通信与事件 | 微信开放文档 🎇 双向绑定的 properties 属性变更父级没有同步改变绑定 properties 的时候不要使用驼峰写法，请使用短横线命名(-分割) 🎇 双向绑定的变量在键盘唤起时不会更新长度改变在安卓出现这个问题，但是iOS没有复现问题，在视图层直接使用 content.length，在唤起键盘时键入文字，不会实时改变length的数字，只有在收起键盘时才会更新。解决办法: 不使用双向绑定，使用 bindinput 去监听改变手动去 setData 就可以了。 🎇 小程序iOS端不支持 Promise.finally()🎇 小程序开发工具的调试模式能不能热更新/局部刷新，每次重新编译好麻烦不能，(当前版本v2.16.0)，现在每次改动都会重新编译一次，文件越多编译越慢，如果一直改动比较频繁的话的话，可以在开发者工具顶部的编译模式中添加编译模式选择指定页面以及参数信息，期待以后会支持局步热更新吧…. 🎇 小程序 input 组件设置 letter-spacing 无效暂时没办法，想着用间隔来实现验证码方块之类的效果，可是不行，官方虽然说可以，但实现不了，暂时增加了输入框宽度，然后 transform 偏移光标部分到可视区域外，然后使用多 view 标签 + CSS样式模拟激活光标和文字间距 🎇 图片内容自适应容器&lt;image mode=&quot;aspectFit&quot;&gt;&lt;/image&gt;，根据 mode 值来达到目标: scaleToFill 对应 background-size:100% 100% aspectFit 对应 background-size:cotain aspectFill 对应 background-size:cover 更多 image | 微信开放文档 🎇 复制到剪切板wx.setClipboardData(Object object) 具体文档 wx.setClipboardData(Object object) | 微信开放文档，以及接口滥用示例 5.15.4 滥用操作剪切板接口 - 原则及相关说明 | 微信开放文档 🎇 自定义组件无法应用 app.wxss 中的样式 除继承样式外， app.wxss 中的样式、组件所在页面的的样式对自定义组件无效（除非更改组件样式隔离选项）。修改一下组件的 addGlobalClass 选项就可以了。具体文档 Component(&#123; options: &#123; addGlobalClass: true, &#125; &#125;) 附：微信开放文档 · 小程序微信开发者代码管理","categories":[{"name":"学习日记","slug":"学习日记","permalink":"https://yogwang.site/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"未完成","slug":"未完成","permalink":"https://yogwang.site/tags/%E6%9C%AA%E5%AE%8C%E6%88%90/"},{"name":"小程序","slug":"小程序","permalink":"https://yogwang.site/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"学习","slug":"学习","permalink":"https://yogwang.site/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"挖坑","slug":"挖坑","permalink":"https://yogwang.site/tags/%E6%8C%96%E5%9D%91/"}]},{"title":"JavaScript 中的位运算符","slug":"JS-operators","date":"2021-03-23T01:43:40.000Z","updated":"2021-05-29T03:25:26.704Z","comments":true,"path":"2021/JS-operators/","link":"","permalink":"https://yogwang.site/2021/JS-operators/","excerpt":"在思否上遇到一个问位运算符的问题 字符串的位运算，是怎么执行的，我也挺好奇的，就是为啥字符串进行位运算的时候返回的结果是 0，索性在解答这个问题的同时把位运算符都整理一遍。 那么先来整理一下位运算符，最后再说明为什么字符串的处理结果为 0","text":"在思否上遇到一个问位运算符的问题 字符串的位运算，是怎么执行的，我也挺好奇的，就是为啥字符串进行位运算的时候返回的结果是 0，索性在解答这个问题的同时把位运算符都整理一遍。 那么先来整理一下位运算符，最后再说明为什么字符串的处理结果为 0 位运算符按位与 AND &amp; a &amp; b 在 a, b 的位表示中，每一个对应的位都为 1 则返回 1 ， 否则返回 0。 10 &amp; 5 // 1010 &amp; 0101 => 0000 // logs 0 按位或 OR | a | b 在 a, b 的位表示中，每一个对应的位，只要有一个为 1 则返回 1 ， 否则返回 0。 10 | 5 // 1010 | 0101 => 1111 // logs 15 按位异或 XOR ^ a ^ b 在 a, b 的位表示中，每一个对应的位，两个不相同则返回 1，相同则返回 0。 15 ^ 5 // 1111 ^ 0101 => 1010 // logs 10 按位非 NOT ~ ~ a 反转被操作数的位。 这里就不能像上边这样简写了，需要完整书写32位，再反转。 ~ 1 // ~ 00000000000000000000000000000001 => 11111111111111111111111111111110 // logs -2 就是把运算数转换为 32 位的二进制整数，然后逐位进行取反操作，最后返回十进制浮点数 左移 shift &lt;&lt; a &lt;&lt; b 将 a 的二进制串向左移动 b 位,右边移入 0。 5 &lt;&lt; 2 // 0101 &lt;&lt; 2 => 010100 // logs 20 简单来说就是整个二进制串向左移动，如果超出就被丢弃，然后末尾补充 0，举个负数例子可能会清晰很多 -113 &lt;&lt; 4 // 11111111111111111111111110001111 &lt;&lt; 4 => 11111111111111111111100011110000 // logs -1808 算术右移 &gt;&gt; a &gt;&gt; b 把 a 的二进制表示向右移动 b 位，丢弃被移出的所有位。译注:算术右移左边空出的位是根据最高位是 0 和 1 来进行填充的 10 >> 2 // 1010 >> 2 => 10 // logs 2 和左移一样的处理思路，只不过方向反过来，并且按照首位来填充，如果是1则填充1，0则填充0 -2 >> 4 // 11111111111111111111111111111110 >> 4 => 11111111111111111111111111111111 // logs -1 2147483647 >> 4 // 01111111111111111111111111111111 >> 4 => 00000111111111111111111111111111 // logs 134217727 无符号右移 &gt;&gt;&gt; a &gt;&gt;&gt; b 把 a 的二进制表示向右移动 b 位，丢弃被移出的所有位，并把左边空出的位都填充为 0。 这个挺好理解的，比算术右移方便记，只需要填0就好了。 -2 >>> 4 // 11111111111111111111111111111110 >> 4 => 00001111111111111111111111111111 // logs 268435455 100 >>> 4 // 1100100 >> 4 => 0000100 // logs 6 回到最初的问题为什么字符串进行位运算的时候返回的结果是 0位操作符在移位前做了两种转换，第一步，将不是 number 类型的数据转换为 number，第二步，将 number 转换为无符号的 32bit 数据，也就是 Uint32 类型。 字符串转换为 number 会失败，所以返回 0，最终操作的时候其实是在操作 0 附表达式与运算符 - JavaScript | MDNJS中表达式 &gt;&gt;&gt; 0 浅析 - SegmentFaultWhat is the JavaScript &gt;&gt;&gt; operator and how do you use it? - Stack Overflow","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"}]},{"title":"在小程序中使用CSS预处理器","slug":"use-stylus-with-gulp-in-miniprogram","date":"2021-03-18T03:09:04.000Z","updated":"2021-05-29T03:33:31.563Z","comments":true,"path":"2021/use-stylus-with-gulp-in-miniprogram/","link":"","permalink":"https://yogwang.site/2021/use-stylus-with-gulp-in-miniprogram/","excerpt":"该来的一天还是来了，两年前立的Flag还是到了，现在在跟进项目配套的小程序开发，但对于写惯了 Stylus 的我，真的是太煎熬了，每次都忘记写冒号和分号…所以就想着翻翻开发文档看 .wxss 支持不支持CSS预处理器的写法，比如 SCSS。明显这是不可能的，官方也没有计划支持，所以还是得自己动手。 大概看了一下大家的解决方案，和我想的一样，使用 Gulp 来自动化构建成 .wxss 文件。","text":"该来的一天还是来了，两年前立的Flag还是到了，现在在跟进项目配套的小程序开发，但对于写惯了 Stylus 的我，真的是太煎熬了，每次都忘记写冒号和分号…所以就想着翻翻开发文档看 .wxss 支持不支持CSS预处理器的写法，比如 SCSS。明显这是不可能的，官方也没有计划支持，所以还是得自己动手。 大概看了一下大家的解决方案，和我想的一样，使用 Gulp 来自动化构建成 .wxss 文件。 一、抄脚本首先呢，就是安装依赖，这次需要的依赖项有3个：gulp 、 gulp-rename 和 gulp-stylus（也可以是 sass 或 less） npm init -y npm i gulp gulp-rename gulp-stylus -D 然后创建 Gulp 脚本 最初我直接复制的肉大的脚本改了下，但是遇到了报错信息 TypeError: gulp.src(...).pipe(...).pipe is not a function，Google 后是说，Gulp4 更新后，API调整过了，旧的写法不可以用了。 所以我先选择降低了 Gulp 版本到 v3.9.1，降低版本后继续执行，遇到另一个报错信息 ReferenceError: primordials is not defined，好像是 Node 版本太高了，切换到 11.15.0 可以运行了，但是 侦听文件改变 的部分还有问题，运行之后执行了两次，后边再修改就没有编译了，所以还是用 Gulp4 自己重新调整吧。 二、Gulp4 重写const gulp = require('gulp'); const stylus = require('gulp-stylus'); const rename = require('gulp-rename'); // 样式文件地址，我设置了全部，排除了node_modules，你也可以自己选择指定目录 const stylusFiles = [ \"./**/*.styl\", \"!./node_modules/**/*.styl\", ] // 编译stylus并且重命名为.wxss，生成在原目录下 const styl2wxss = () => &#123; return gulp .src(stylusFiles) .pipe(stylus(&#123; prefixer: false&#125;)) .pipe(rename(&#123; extname: '.wxss' &#125;)) .pipe(gulp.dest('./')); &#125;; // 编译任务 gulp.task(styl2wxss); // 监听任务 gulp.task('watch', () => &#123; gulp.watch(stylusFiles, styl2wxss); &#125;); // 如果你有多个任务比如同时使用pug与stylus，可以像这样放入series内，会自动依次执行 gulp.task('dev', gulp.series('styl2wxss', 'watch')); 然后把执行脚本加入到 package.json 中 &quot;scripts&quot;: &#123; &quot;watch&quot;: &quot;gulp watch&quot; &quot;dev&quot;: &quot;gulp dev&quot; &#125; 执行 npm run watch 或者 npm run dev 就可以了。 到这里位置一切都正常，但是我编译完成之后，小程序编译报错了，因为不能加私有兼容前缀，所以还得处理一下，看看 stylus 的配置文档。 2 hours later….翻了好久文档也没找到解决办法，不过 stylus 提供了一个 vendors 属性，具体看 文档链接把 vendors = official 加到文件头部就可以了，但是总觉得怪怪的不舒服，官方好像也没有想处理这个问题的念头？先不管了，之后看有没有遇到其它解决方案吧。 三、使用VSCode扩展VSCode的扩吧展商店里已经有大佬上传了 Stylus/Sass/Less 转换成 wxss 的插件了，有直接安装就可以用的，而且我上边提到的编译后出现兼容前缀的问题插件转换后没有遇到，还不知道他们是如何解决这个问题的，等空了看看他们的源码怎么写的吧。 扩展# 如何让图片 url 在编译时自动补全CDN路径？ 本地资源图片无法通过 WXSS 获取，可以使用网络图片，或者 base64，或者使用&lt;image/&gt;标签 现阶段的小程序是不允许在 wxss 中使用本地资源了，不然会报错。如果用图片CDN，每次都输入全网络地址又太麻烦了，所以就想着有没有什么好一些的解决方式。 解决方案1：使用 stylus 全局变量。例如我的全局变量文件位于 /assets/stylus/variables.styl。那么修改一下脚本文件就可： const styl2wxss = () => &#123; return gulp .src(stylusFiles) .pipe(stylus(&#123; prefixer: false, import: path.join(__dirname,'./assets/stylus/variables.styl'), &#125;)) .pipe(rename(&#123; extname: '.wxss' &#125;)) .pipe(gulp.dest('./')) &#125;; 就这可以这样书写了 &#x2F;&#x2F; 例如变量名为 $httpUrl .className background url($httpUrl&#x2F;img&#x2F;bg_img.png) center&#x2F;contain no-repeat &#x2F;&#x2F; 编译为 &#x2F;&#x2F; background: url(&quot;http:&#x2F;&#x2F;www.domain.com&#x2F;assets&#x2F;img&#x2F;bg_img.png&quot;) center&#x2F;contain no-repeat; 解决方案2：stylus 编译成 css 自动处理补全 CDN 地址虽然使用全局变量可以用，但是也不优雅，想着可以在 stylus 编译成 css 的时候同步处理补全 CDN 路径，在书写的时候只需要键入 url(/img/xxx.jpg) 就会得到对应的 CDN 地址 url(https://www.baidu.com/assets/img/xxx.jpg) 了。但是找了一圈还没找到解决，思路有了得等有时间了尝试一下，先挖个坑。 附使用 Pug 和 Stylus 开发小程序的 watch 脚本gulp.jsExpressive, dynamic, robust CSS — expressive, robust, feature-rich CSS preprocessor node.js - How to fix ReferenceError: primordials is not defined in node - Stack OverflowVendor prefixed properties WITHIN vendor prefixed @keyframes · Issue #882 · stylus/stylusBug in vendored keyframes · Issue #1135 · stylus/stylus","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://yogwang.site/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"挖坑","slug":"挖坑","permalink":"https://yogwang.site/tags/%E6%8C%96%E5%9D%91/"},{"name":"Gulp","slug":"Gulp","permalink":"https://yogwang.site/tags/Gulp/"}]},{"title":"程序员社群 成长&生活分享 2021/03/18","slug":"jirengu-share-my-life-88th","date":"2021-03-17T08:54:37.000Z","updated":"2021-05-29T03:25:56.542Z","comments":true,"path":"2021/jirengu-share-my-life-88th/","link":"","permalink":"https://yogwang.site/2021/jirengu-share-my-life-88th/","excerpt":"各位程序猿(媛)晚上好，今天轮到我来分享，先来自我介绍16年毕业计算机通信，后来专升本（计算机科学），这教育经历算是很差了，从事前端大概有三年(我也不是很确定…)，中间有留校工作了1年多，后来辗转成都和重庆，19年回的浙江。 好自我介绍结束，开始正题： 💻 怎么入的前端坑？之前一直学的计算机通信嘛，大概是13/14年有一届青少年科技创新大赛被老师拉进团队开始接触网站制作，那段时间接触的是PHP和ASP。快实习的时候一起比赛的学长找我去他们公司做，算是正式进入到前端领域（是一个外包公司）。当时也没有认识到 外包 和 自研 的区别，工作也简单就是做一个 页面仔 还原设计稿的，一开始一个月熟悉项目开发流程，后边就开始独立自己切，每天都一直努力还原设计稿，这段时间积累HTML、CSS的知识确实是最快的时候，我到现在都没有怎么回顾过了，基本看到设计稿大概就知道应该是怎么样的一个HTML结构，CSS应该怎么去写，有哪些部分可以复用，到实习结束大概已经切了大概有一百个网站（我们实习期很长有一年）","text":"各位程序猿(媛)晚上好，今天轮到我来分享，先来自我介绍16年毕业计算机通信，后来专升本（计算机科学），这教育经历算是很差了，从事前端大概有三年(我也不是很确定…)，中间有留校工作了1年多，后来辗转成都和重庆，19年回的浙江。 好自我介绍结束，开始正题： 💻 怎么入的前端坑？之前一直学的计算机通信嘛，大概是13/14年有一届青少年科技创新大赛被老师拉进团队开始接触网站制作，那段时间接触的是PHP和ASP。快实习的时候一起比赛的学长找我去他们公司做，算是正式进入到前端领域（是一个外包公司）。当时也没有认识到 外包 和 自研 的区别，工作也简单就是做一个 页面仔 还原设计稿的，一开始一个月熟悉项目开发流程，后边就开始独立自己切，每天都一直努力还原设计稿，这段时间积累HTML、CSS的知识确实是最快的时候，我到现在都没有怎么回顾过了，基本看到设计稿大概就知道应该是怎么样的一个HTML结构，CSS应该怎么去写，有哪些部分可以复用，到实习结束大概已经切了大概有一百个网站（我们实习期很长有一年） 那个时候就喜欢研究CSS，每天到公司之后都会看一会群里别人分享的优质网站，就觉得视觉效果很好，也会看一些特效分享什么的，小城市那个时候也没有那么内卷的氛围，但是到了JS部分是真的弱，只会jQuery，原生JS基本不会，document.getElementsByClassName() 这种的我当时肯定拼不出来，我只会 $(&quot;.xxx&quot;)。现在如果只研究CSS的话，就算你是第二个张鑫旭你也进不了大厂了。 📖 关于学习老生常谈的问题，前端的坑还是很大而且很杂什么都有，如果不是自己喜欢，需要业务推动的话，可能你很快就会落后于时代，就像当初实习的我一样，jQuery + Bootstrap 一把梭用到死。我实习是在15年那个时候 React/Vue 项目已经大规模出现了，当时我一直感叹那些项目怎么那么流畅也没有页面跳转的白屏，只是知道全部通过 Ajax 请求，但是不知道如何去实现，思维模式还是停留在MVC框架上。学校内的专业课知识更不用提了，落后于生产最少一个时代，基本上没有用武之地，只是给了可以读代码的机会，能不能看明白工作的业务代码都是问题。 每天 固定时间逛一逛社区 V2ex，思否，CNode, CSS-Tricks，能力范围内解决一些问题，一下子大脑宕机的时候也可以去逛逛放空一下。 学习新技术，大多数时候都是需要自己来找资料，我觉得比较好用的方式是 记公开的笔记，能让其他人看见，既能帮助自己，也能帮助别人。 你需要重新用文字描述一遍，学习的过程，重新归类整理脑中的记忆； 怕内容写错出糗，你会在记录的时候翻阅大量的相关资料来验证你的想法； 在别人会指出你理解错误的地方，这些部分自己可能不会察觉到； 每一次有人评论了，你就又会回过头来看到当初的笔记，重新回想起来部分内容，加深记忆。 也把参考的链接放在文章底部，以后如果回顾如果发现有问题也可以快速找到。 博客的话，我现在是用的 Hexo，部署在Github Page上边，也做了国内镜像方便同学们访问，有需求的话，可以了解一下阿里云的OSS静态托管，如果流量不大 ￥18 可以用两年，域名也不贵，一百块钱够折腾很久了。 还有就是 多加一些活跃的技术群 ，能听到很多以前没有了解过的东西。 💼 最后聊一聊找工作首先你要有一个目标，确定你想要找什么样子的工作，前端也分很多种，不同类型的岗位可能技术栈你都没听说过。如果之前一直都是日常业务路线的，接触到数据可视化的时候可能会不知道如何下口。 校招的部分 我就不多说了，我毕业的那段时间就有校招，不过都是实业类型的，互联网企业少得可怜，聊不出来什么，具体可以看方方老师讲 进入阿里巴巴需要什么水平 这期视频。 社招部分，首先你要做好简历的内容管理和排版，HR看一份简历不会超过1分钟，简历的作用就是在这一分钟内让HR的眼睛停下来，所以需要针对不同的公司来展示你的技术栈和项目经历。 海投先不说会不会被系统屏蔽，首先你的内容就不可能打到招聘方的痛点上。除非他们不在乎简历内容只看是否对口，具体怎么展示方方老师也在每期的模拟面试里都有说。这里 墙裂推荐 模拟面试实录，面试他们的时候你也要自己回答，如果卡壳了，就记下来卡住的地方，拓展开来写成笔记。 还有一个我之前看 令人心动的Offer 时刷到的一个Up主 超级简历WonderCV，平时也出一些简历评价和面试评价，只需要记住并且避开这些点就可。 再就是你之前加的社群的作用就体现了 找内推！！ 首先你会比别人多出来很多优质岗位的信息，其次你的简历一定会被HR看到，并且你如果你一直活跃再社群中，你的印象分会有一定的加成。 最后我的观点就是 找对重点多准备，不要裸辞，耐心多等等。 以上就是我今天的分享，祝各位 需求永远不变、再无BUG、永不脱发 😉","categories":[{"name":"生活杂谈","slug":"生活杂谈","permalink":"https://yogwang.site/categories/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"社群分享","slug":"社群分享","permalink":"https://yogwang.site/tags/%E7%A4%BE%E7%BE%A4%E5%88%86%E4%BA%AB/"}]},{"title":"回顾史无前例的 2020 年","slug":"summary-at-the-end-of-2020","date":"2021-03-13T12:36:48.000Z","updated":"2021-05-29T03:33:23.542Z","comments":true,"path":"2021/summary-at-the-end-of-2020/","link":"","permalink":"https://yogwang.site/2021/summary-at-the-end-of-2020/","excerpt":"不知不觉庚子年已经过完了，都不知道怎么就过完了看似艰难的一年，甚至觉得中间缺失另一部分的时间，还有很多想做的事情还没来得及做，可能年纪大了吧，真像别人说的，现在的一年只占用了 1/27 份的记忆空间，所以回忆起来觉得时间过得特别快，以后也只会越来越快。说实话去年没有什么好回顾的，所以一直拖到正月都过完了都不想动手写，很多事情都不顺心，也出现了很多计划之外的事情。不管是工作还是生活上，特别是感情上，导致全年大部分的时间情绪都不高涨，先回顾一下去年吧。","text":"不知不觉庚子年已经过完了，都不知道怎么就过完了看似艰难的一年，甚至觉得中间缺失另一部分的时间，还有很多想做的事情还没来得及做，可能年纪大了吧，真像别人说的，现在的一年只占用了 1/27 份的记忆空间，所以回忆起来觉得时间过得特别快，以后也只会越来越快。说实话去年没有什么好回顾的，所以一直拖到正月都过完了都不想动手写，很多事情都不顺心，也出现了很多计划之外的事情。不管是工作还是生活上，特别是感情上，导致全年大部分的时间情绪都不高涨，先回顾一下去年吧。 🎐 去年的小目标 学习 TypeScript 年初实在有点不知道该干嘛，就开坑学了一段时间，感觉现在除了强类型之外，剩余的价值已经没有以前高了，也没有在项目里应用上TS 学习 ReactJS 五月份大概学习了一下，只是算了解了怎么去用，写了个一个Demo就没有再动过了。 学习 VueJS 3.0 看了几次尤大演讲和先行分享会，大概知道怎么一回事情，但是没有展开学习，也没有上手写过Demo 阅读 《Code Complete》 换了一本书《设计模式：可复用面向对象软件的基础》，大概读了 30% 有点读不下去了。 阅读 《Clean Code》 已经买了，还没有开始看 了解并使用单元测试 没有去了解 了解 Svelte 没有去了解 了解 React Native 或 Flutter 没有去了解 算是 🚩 Flag 立了太多了，一个都没有完成，特别是后边补充部分，年初有了想法，但是后续就没有那个劲了，书是下单买回家了，但是只开封了一本，另外一本连塑封都没拆就躺了半年多。可能也因为生活上不顺心的事情比较多，加上敏捷开发基本一两周就是一个小版本迭代，每周都是 30小时 左右的有效 Coding 时间，每天在公司忙完等回到家就只想着瘫着休息。 中间要不是偶尔看一下方方老师的直播，真的可能连笔记都不想写了，每次也都是需要立马拿出电脑开始写，只要过了一两天也就不想再动手写了，我数了下还有10多个草稿等着我完成，都是一些小话题，自己在思考的时候卡住的部分，想加深一下印象。还算好，博客算是没有断更… 关于工作上 💼上边提到了敏捷开发，去年一整年一直在忙公司自研的项目，坑开得很大，而且Web前端部分初期就只有我一个人，所以整个 0.x 版本，一直都是一边设计系统一边实现功能，也不断有老需求被砍，新需求进来。反反复复折腾了挺久，最近应该快要上线了。开发中的踩坑部分我也在 Jeecg-boot 开发挖坑日记 大概提到了，本来还想着可以在项目内加上单元测试什么的，一直没有机会，最近稍微空闲了点但整个人心情都怎么好就一直搁置着。中间穿插了公司产品配套的H5应用开发，这些东西小应用基本没有什么含金量都是重复工作，增加熟练度罢了，可以聊的东西没有什么。 总体来说20年，没有19年对我来说有那么大的提升，业务上技术栈已经开始重复了，WebGL 我算是被劝退了，需要的横向知识面太广了，瞬间感觉到无尽的学习压力，而且当前公司的业务可以说是完全用不到，如果自学的话，真的进行不下去了。 你说关于今年我是怎么打算啊？可能先 调整心态 吧，这段时间三观打击的比较厉害，总是伴随的颓的心态，干什么都很难提起兴趣，等小腿好一点，就可以 恢复夜跑 了，去年一直没有锻炼，确实感觉到身体不如从前了，快跑一公里心率居高不下很久。 不出意外 小程序开发 是在日程上了，然后把近期开的一些坑填一填。 再有的话，能想到的就是刷 LeetCode 吧，去年有过跳槽的念头，如果要落实，应该会刷一下算法题，公司的项目后续就是维护了，找到人手接班就好了。 最后就是把外包项目结束掉，再往后的话，边走边考虑吧，如果年中能恢复过来的话，再展望一下。 末尾总结 整个人潦草的在工作和生活中没有计划的过完了一年，一直处于情绪低谷，舍断离、刷新自己失败。 这次庚子年对于很多人来说都是很差的一年，我甚至都很难提起回顾2020年的念头，毕竟谁都想生活得一帆风顺。 以上，Peace!","categories":[{"name":"生活杂谈","slug":"生活杂谈","permalink":"https://yogwang.site/categories/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"总结","slug":"总结","permalink":"https://yogwang.site/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"关于情感勒索与关系依存自尊者","slug":"about-emotional-blackmail","date":"2021-02-23T09:33:57.000Z","updated":"2021-05-29T03:41:06.241Z","comments":true,"path":"2021/about-emotional-blackmail/","link":"","permalink":"https://yogwang.site/2021/about-emotional-blackmail/","excerpt":"最近和女友闹得很僵，情绪很低落，没有什么动力填坑，更别提开新坑了，光把 设计模式学习 补完就折腾的够呛，而且有一些定义很模糊容易混淆，经常就为了区分两个很类似的模式停滞几个小时。 周二的时候知乎推送了一个问题 在恋爱中，女孩子真的会遇到一个满眼都是自己的男孩子吗?, 第一次接触到一个名词 关系依存自尊，确实一直以来都把感情看得很重要，并且已经深刻影响到自己生活的方方面面。 KnowYourself 的回答真的让我一下子明白过来，原来在不经意中我已经情感勒索了很久并不自知，也理解了她口中的压力并不是我以前所想的那样……","text":"最近和女友闹得很僵，情绪很低落，没有什么动力填坑，更别提开新坑了，光把 设计模式学习 补完就折腾的够呛，而且有一些定义很模糊容易混淆，经常就为了区分两个很类似的模式停滞几个小时。 周二的时候知乎推送了一个问题 在恋爱中，女孩子真的会遇到一个满眼都是自己的男孩子吗?, 第一次接触到一个名词 关系依存自尊，确实一直以来都把感情看得很重要，并且已经深刻影响到自己生活的方方面面。 KnowYourself 的回答真的让我一下子明白过来，原来在不经意中我已经情感勒索了很久并不自知，也理解了她口中的压力并不是我以前所想的那样…… 在了解一下回答中所描述的 关系依存自尊型 和 情绪勒索 之后，下单了两本关于情感勒索的书，准备这几天把它们看完，之后再来把文章写完吧，今天就这样。 未完成… 附在恋爱中，女孩子真的会遇到一个满眼都是自己的男孩子吗？- 知乎情绪勒索 - Wikipedia情感勒索 - Susan Forward讀《情緒勒索》你為什麼拿自己的人生滿足別人？","categories":[{"name":"生活杂谈","slug":"生活杂谈","permalink":"https://yogwang.site/categories/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"未完成","slug":"未完成","permalink":"https://yogwang.site/tags/%E6%9C%AA%E5%AE%8C%E6%88%90/"},{"name":"情感","slug":"情感","permalink":"https://yogwang.site/tags/%E6%83%85%E6%84%9F/"}]},{"title":"「 设计模式学习 」 L00 开坑贴 & 设计模式概览","slug":"design-pattern-learning-L00","date":"2020-11-24T16:10:59.000Z","updated":"2021-05-29T03:30:09.609Z","comments":true,"path":"2020/design-pattern-learning-L00/","link":"","permalink":"https://yogwang.site/2020/design-pattern-learning-L00/","excerpt":"设计模式是我在2018年在成都工作的时候听 肉山老师 的直播JavaScript 设计模式 导言的时候就想学习的一个东西，但是一直拖拖拖，虽然后来买了肉老师的 Chat 从 jQuery 里学习设计模式，但是看了一头雾水，后来同样买了肉老师推荐的书《设计模式：可复用面向对象软件的基础》，也是在家里吃灰了半年多。一直想把整个设计模式都了解一下，不用吃透大概明了就可以，但是每次都提不起开坑的念头，如果再写成学习笔记的话，学习周期会大大拉长。 这次在项目的不断迭代中，我遇到了一个问题，就是 项目中的类型和状态管理，所以就想着是否有一个合适的设计模式来解决问题，所以就被逼迫着捡起来了……","text":"设计模式是我在2018年在成都工作的时候听 肉山老师 的直播JavaScript 设计模式 导言的时候就想学习的一个东西，但是一直拖拖拖，虽然后来买了肉老师的 Chat 从 jQuery 里学习设计模式，但是看了一头雾水，后来同样买了肉老师推荐的书《设计模式：可复用面向对象软件的基础》，也是在家里吃灰了半年多。一直想把整个设计模式都了解一下，不用吃透大概明了就可以，但是每次都提不起开坑的念头，如果再写成学习笔记的话，学习周期会大大拉长。 这次在项目的不断迭代中，我遇到了一个问题，就是 项目中的类型和状态管理，所以就想着是否有一个合适的设计模式来解决问题，所以就被逼迫着捡起来了…… 肉老师谈论如何学习设计模式的方法，和我的学习想法是类似的，不管是学习设计模式还是学习一个框架/库，先了解一个大概心里有一个底，然后在实际遇到问题的时候再去找文档来炒冷饭，我觉得这样会更清晰一些，但是他不推荐了解的那么多设计模式，只需要过一遍，等遇到了差不多的场景再去具体看适合哪一个。 《设计模式：可复用面向对象软件的基础》这本书是 1995 出版的，可能会有一些问题，或者有一些新的设计模式出现，但都不是问题，咱先把这本书内的 23 个设计模式了解，之后再看情况去了解新的内容。 所以这篇文章应该会陆陆续续的更新一些新内容，好了，在这篇标号 00 的笔记中我就以前端开发者的视角按照设计模式名称+概括+简单示例，来大概描述一下每种设计模式，如果有遇到可用场景时再深入的去记录。 这本书内把设计模式分成 三种类型（ 创建型、结构形、行为型） 和 二十三个模式 创建型 1. 工厂方法 Factory Method 定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂模式使一个类的实例化延迟到其子类。 工厂模式在实际应用中有很多，比如前端er最了解的 jQuery 中的 $() 方法查看文档，传入一个类名或者ID或者其它的值，返回回来一个DOM实例。中间的一些过程就不需要关注了，直接使用 $() 方法就会必定返回一个DOM实例。讲人话，就是传入一些值，返回一个符合预期的结果。 2. 抽象工厂 Abstract Factory 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 抽象工厂模式是一个比较复杂的创建型模式，如果用最简单的话来说，可以描述成基于一组工厂方法，传入数据之后返回一个复杂对象，中间的步骤不需要关注。有点类似于Vue中的高阶组件中包含了很多子组件和一些其它元素最后展现出一个渲染结果。用廖雪峰老师的例子来举例就很容易让人明白 我们希望为用户提供一个Markdown文本转换为HTML和Word的服务 - 抽象工厂，虽然示例是Java，但是不影响理解。 3. 生成器 Builder 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 生成器模式，有些地方也叫建造者模式，用简单的话来概括就是传入一个或者一组数据，最后拼接返回一个结果，用Vue来举例的话就有点像 Reander 函数。乍一看可能和抽象工厂很像，对确实很像，他们都是基于工厂模式的扩展，主要的区别就是抽象工厂模式对于中间的数据没有要求，而生成器重点关注如何分步生成复杂对象。 争议 这边的具体区别我还没有彻底弄明白确实需要整理之后来区别一下。具体得等这篇文章最后了。 4. 原型模式 Prototype 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 这个在Javascript中并不需要多理解，因为Js中每个数据类型都是对象，都拥有一个 prototype 属性，当然你也可以自己用代码来实现自己得原型模式其实显得很奇怪。大概可以用构造函数的视角来理解，只不过构造函数生成的实例对象的属性都是独立的，所以引入了 prototype 属性，来做到数据共享(修改其中一个，影响到其它所有)。同样JS有提供一个原生的实现 Object.create() 5. 单例模式 Singleton 保证一个类仅有一个实例，并提供一个访问它的全局访问点 类似于 window 对象，全局确保只有一个我们可以使用的 window 实例。具体业务使用场景中，Vuex 也是单例模式，全局只会有一个Store实例来供用户去读取和修改。 我在查阅资料的时候稍微看到了还有人提到 惰性单例模式，这个之后再去了解 结构形 1. 适配器 Adapter 将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 适配器模式的话，我们可以这样来理解，很多时候我们不确定客户端浏览器是否支持我们所使用的API，这个时候就会写兼容，大概来写一个伪代码段来举例 var getByClass = function (className) &#123; if(document.querySelector) &#123; return document.querySelector(className); &#125; else &#123; return document.getElementsByClassName(className) &#125; &#125;; 就是那么简单，虽然有点强行解释，但这个就是适配器…. 2. 桥接 Bridge 将抽象部分与它的实现部分分离，使它们都可以独立地变化 这个我本来想用 UI 库中的 Notification 组件来举例的，因为只需要调用 notification[type].open(&#123;config&#125;) 函数传入几个参数就可以展现出不同的消息通知栏了， 但是隔了一天之后发现拿这个例子来讲好像不是很的能解释抽象和实现的分离，所以我用系统中的画图附件来举例会好理解很多。 在画版中会有很多不同的 工具，比如说画笔，图形和文字等，同样他们都有颜色、大小这些个 属性，我们在使用的时候只需要选择 工具 ，然后选择 属性 就可以绘制出我们所需要的结果了。 我们可以 单独 的去 变化组合 工具、属性，并不会出现红色画笔和黑色画笔这种 带有属性的工具（没有强耦合），如果后期扩展了新得工具只要单独增加新工具的业务逻辑就行，不需要去关注它的大小和颜色这些属性，同样增加新属性的时候也同理。 3. 组合 Composite 将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。 组合模式简单来说具有统一接口的一组树形结构。父级和子级拥有相同的接口，比如系统的文件管理，每个文件夹都可以包含具体文件和文件夹，并且每个文件/文件夹都有类似的功能，比如说创建/删除/重命名。在执行删除功能的时候开始递归执行子级的删除操作，每个子级都被删除后执行父级的删除操作。 4. 装饰 Decorator 动态地给一个对象添加一些额外的职责。就增加功能来说，相比生成子类更为灵活。 一般来说我们都会直接想到使用类的继承，然后在子类上附加新的功能，但是继承为类引入静态特征，并且随着扩展功能的增多，子类就会爆炸式增长。所以我们不想增加很多子类的情况下扩展类，就会用到装饰器模式。 看到一个很形象的比喻，现在UI库中的表单组件的表单验证，在不同的表单组件上使用不同的校验规则，而且并不影响组件本身，只是在提交之前额外调用了传入的校验函数。 5. 外观 Facade 为子系统中的一组接口提供一个一致的界面。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 简单概括就是，在日常工作中会编辑出来很多子功能，这些子功能只有你清楚，如果你想给同事使用，就可以l考虑外观模式，整合起来并且开放一个相对统一的调用接口。 6. 享元 Flyweight 运用共享技术有效地支持大量细粒度的对象。 享元模式的话，我描述一个场景来帮助理解，比如说现在有一个气球里边装了几千个小球，这些小球材质大小一致，并且有三种颜色，如果我们为每一个气球都船舰一个对象，就会浪费大量的内存，这个时候我们就可以把相同的材质和大小和颜色提取出来，通过外部引用或者继承的方式来共享这些属性。 7. 代理 Proxy 为其他对象提供一种代理以控制对这个对象的访问。 这个的话，学习过Vue的前端就很清晰了，Vue对一些数据的操作进行了代理，去检查是否需要更新视图。ES6中也新增了 Proxy 这个API，并且Vue3中使用 Proxy 代替了 defineProperty。 行为型 1. 职责链 Chain of Responsibility 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。 简短的来说就是分工合作，比如说工厂的流水线，每一个工作站都有自己的工作，完成自己的工作（加工/质检）之后通过传输带到下一个工作站进行处理，最后出厂一个成品的手机。 2. 命令 Command 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。 设计思想是把命令拆分开来，创建和执行分离，使得调用者无需关心具体的执行过程，大概是，每天中午点餐的时候只要和老板娘喊一嗓子炒年糕，一会老板就会端出来一盆炒年糕。 3. 解释器 Interpreter 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。 快速的话可以理解成 正则，把一系列复杂的规则判断用简单的语句实现。 4. 迭代器 Iterator 提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。 这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。可以用对象的 Object.entries() 方法来理解。每一个对象都有它自己的迭代方法，你不需要知道它具体有哪些属性，它可以按照顺序去输出对象的内部元素。 5. 中介者 Mediator 用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 MVC 框架中的 C（控制器），它就是用来控制 M（模型）和 V（视图）的中介者。 6. 备忘录 Memento 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。 一般来描述这个模式都是举例文本编辑器的撤销功能，并且可以一直退回到空白文本的状态，其它的类似还有，浏览器的后退前进，数据库的事务回滚等等。保持对象的状态，并且可以在调用组件生命周期内持久保存这些快照。 7. 观察者 Observer 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。 这个直接用Vue来举例吧，data 内 声明 的变量被修改时，会自动通知UI更新。最直接可以看到的就是每一个在data内声明的变量都会有一个 __ob__ 对象。观察者模式和中介者模式其实非常的相似，只不过这里的 “中介者/订阅者” 就是观察者 8. 状态 State 允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。 可以描述一个应用场景，在一个后台管理系统中，一定会有审核相关的部分，每一条不同状态的记录都会对应不同的操作，这边就会适合状态模式的应用。 9. 策略 Strategy 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。 也描述一个应用场景吧，比如你现在老板给你一个任务，让你做一个根据职位、绩效、考勤和工资自动计算奖金的程序，不同的职务有不同的标准，不同的绩效等级也会影响奖金系数。一开始你可以使用 if...else，去判断不同的场景，随着需求变化，代码不断调整，越来越臃肿。代码几乎不能维护，因为你根本不知道这里的一处改动会对后面造成什么样的影响。这时候可以使用策略模式来更具不同的条件执行不同的业务逻辑。 10. 模板方法 Template Method 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 在面向对象程序设计过程中，程序员常常会遇到这种情况：设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但某些步骤的具体实现还未知，或者说某些步骤的实现与具体的环境相关。 这个很容易解释，我们所熟悉的 Ajax 函数就是，基本流程都确定，只需要接受 URL 地址 和 Settings 对象 就可以，再把需要执行的操作放在回调函数里。它封装了不变部分，扩展可变部分。在父类中提取了公共的部分代码，便于代码复用，而把可变部分算法由子类继承实现，便于子类继续扩展。 11. 访问者 Visitor 表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 核心思想是为了访问比较复杂的数据结构，不去改变数据结构，而是把对数据的操作抽象出来，在“访问”的过程中以回调形式在访问者中处理操作逻辑。 这个还没有想到合适的场景，大概就是说 有一个稳定的数据结构，但是需要实现的功能并不确定，针对不同的访问者有不同的行为职责。感觉有点类似命令模式，命令模式Plus？ 不断了解各种设计模式的的时候，发现其实不同的设计模式之间可能并没有很明确的界限，并且这些传统的设计模式在前端工作中很多都使用不上，应该可以简略成几个模式即可，不需要每一个都了解，反而可能影响自己的认知。 附《设计模式：可复用面向对象软件的基础》《深入设计模式》一本关于设计模式及其背后原则的电子书籍JavaScript设计模式与开发实践 - 曾探设计模式 | 菜鸟教程设计模式 - 廖雪峰从 jQuery 里学习设计模式 - MeathillJavascript继承机制的设计思想 - 阮一峰JavaScript中的设计模式","categories":[{"name":"踩坑日记","slug":"踩坑日记","permalink":"https://yogwang.site/categories/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://yogwang.site/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"挖坑","slug":"挖坑","permalink":"https://yogwang.site/tags/%E6%8C%96%E5%9D%91/"},{"name":"设计模式","slug":"设计模式","permalink":"https://yogwang.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"项目中的类型和状态管理","slug":"JS-type-and-status-management-dictionary","date":"2020-11-24T15:47:32.000Z","updated":"2021-05-29T03:25:17.575Z","comments":true,"path":"2020/JS-type-and-status-management-dictionary/","link":"","permalink":"https://yogwang.site/2020/JS-type-and-status-management-dictionary/","excerpt":"这段时间项目迭代比较快，所以很多时候对于记录的状态和类型判断我都是使用的 魔术字符串 的形式，但是这样就与代码形成了 “强耦合”， 不利于后期的维护。 例如这样的代码结构： &lt;!-- 用vue template来举例 --> &lt;template> &lt;table> &lt;!-- 其它结构 --> &lt;td> &lt;!-- 直接使用状态值判断 --> &lt;a @click='xxx' v-if='record.status === 0'>操作A&lt;/a> &lt;!-- 使用数组下标判断 --> &lt;a @click='xxx' v-eles-if='record.status === status[1].key'>操作B&lt;/a> &lt;a @click='xxx' v-else'>其他操作&lt;/a> &lt;/td> &lt;!-- 其它结构 --> &lt;/table> &lt;/template> 特别是最近一整个分类的类型和状态的都变更了，所以在业务逻辑内的魔术字符串也需要一个一个文件去同步修改，大部分的都被替换了，但还有一些零碎的地方没有被修改到，导致不断有 BUG 被提上来，这就很头疼了。 所以我就想者怎么把业务逻辑内的魔术字符串使用一种方式替换掉，最开始我想法是把状态集中起来进行管理","text":"这段时间项目迭代比较快，所以很多时候对于记录的状态和类型判断我都是使用的 魔术字符串 的形式，但是这样就与代码形成了 “强耦合”， 不利于后期的维护。 例如这样的代码结构： &lt;!-- 用vue template来举例 --> &lt;template> &lt;table> &lt;!-- 其它结构 --> &lt;td> &lt;!-- 直接使用状态值判断 --> &lt;a @click='xxx' v-if='record.status === 0'>操作A&lt;/a> &lt;!-- 使用数组下标判断 --> &lt;a @click='xxx' v-eles-if='record.status === status[1].key'>操作B&lt;/a> &lt;a @click='xxx' v-else'>其他操作&lt;/a> &lt;/td> &lt;!-- 其它结构 --> &lt;/table> &lt;/template> 特别是最近一整个分类的类型和状态的都变更了，所以在业务逻辑内的魔术字符串也需要一个一个文件去同步修改，大部分的都被替换了，但还有一些零碎的地方没有被修改到，导致不断有 BUG 被提上来，这就很头疼了。 所以我就想者怎么把业务逻辑内的魔术字符串使用一种方式替换掉，最开始我想法是把状态集中起来进行管理 阶段一：使用数组来管理 方式 ①在数组中枚举所有状态，然后调用数组下标的方式去使用。例如这个示例： // order.js const statusLabels = ['已创建', '申请中', '通过审核', '....'] 就可以这样使用 statusLabels[index] 来转换 key 值为 label ，但是这样很明显会有一些问题，比如说： 这个 key 值不能是负数，虽然可以通过下面的方式来处理，但是有点蠢….如果最小的 key 值 为 -2 时，把对应的 状态名 放到数组首位，通过这样转换 status[index + 2]； 依旧强耦合，在组件的条件判断中还是会使用 key 值，例如：&lt;a @click=&#39;xxx&#39; v-if=&#39;record.status === 0&#39;&gt;编辑&lt;/a&gt;,如果将来 增加/删除 状态的时候会还是需要一个一个文件修改。 只能处理 key - label 的转换，并不能增加其他属性 当然如果单纯只是转换 key 和 label 可以这样使用，这个是项目一开始所使用的方式，后来陆续修改成了 方式 ② 的形式。 阶段二：数组管理 方式 ②这个阶段因为很多组件复用了订单状态表，并且增加了很多属性，比如说图标等。 // order.js const status = [ &#123; label:'已创建', key:0, icon: 'exclamation-circle', &#125;, &#123; label:'申请中', key:1, icon: 'clock-circle', &#125;, &#123; label:'通过审核', key:2, icon: 'check-circle', &#125;, // ..... ] 转换 key 值为 label 就可以这样使用 status.find(r =&gt; r.key===record.status)，然后通过 .属性名 的方式来使用需要的属性，但是这样也会有一些问题，比如说： 条件判断中语义不明，会出现这样的代码，&lt;a @click=&#39;xxx&#39; v-if=&#39;record.status === status[1].key&#39;&gt;编辑&lt;/a&gt;，除了我之外其他人并不知道 status[1] 是什么意思； 如果将来 增加/删除 状态的时候会还是需要去同步修改使用下标的组件，不然可能下标错位，当然可以直接追加在最后，但是我有代码洁癖的所以就没办法了。 这个阶段就是我写这篇笔记时的管理，因为项目的 v1.2.x 版本 状态码整体调整了一次，后续状态码一直有小范围的改动，所以出现了需要大面积替换魔术字符串的情况。 那么我就在考虑如何在状态管理的文件中 枚举一次 所有状态，来处理转换状态标签和操作的判断条件，如果后续如果状态码有改动也方便维护的处理方式，就有之后两个阶段的处理方式 阶段三：使用对象来管理这个阶段有考虑过使用 Map 数据结构 因为可以遍历，但是在取值的时候会比较麻烦，并不能直接使用 链式（变量属性）来使用。 所以使用对象来管理，并且使用 Object.values 来返回所有状态数组，例如以下示例： // order.js const status = &#123; created:&#123; label:'已创建', key:0 &#125;, pending:&#123; label:'申请中', key:1 &#125;, approved:&#123; label:'通过审核', key:12 &#125;, // ..... &#125; const statusList = Object.values(status) // 转换 const getOrderStatus = function(key)&#123; const f = statusList.find(item => item.key === key) return f || status.created &#125; 这个时候可以通过 getOrderStatus 函数来处理 key-label 的转换，并且可以使用 链式（变量属性）的方式去处理判断条件。 &lt;a @click='xxx' v-if='record.status === status.created.key'>编辑&lt;/a> 那这样就可以很方便的来 转换状态 和 在判断条件中使用，并且不用担心语义化的问题。 但是这边又出现了一个问题，比如说： 在用户下的客户类别中的付费用户，如果单纯使用一个 user.js 来管理，并且使用 user.customer.member.key 去判断是否展示操作内容，但是这样的话，在管理端的用户列表中，去替换用户类型的 key 为 label 就比较麻烦，因为层级会比较深，Object.values 只会返回一层，如果一个一个拿出来手动放到一个数组里边有会显得很呆。 所以！ 阶段四：对集中管理文件中的对象拆分因为如果同一个列别中有多级分类的话，就类似上边的例子，user.customer.member 这种用户类别。所以这个时候就把 user.js 拆分成多个文件，然后再 import 进来，这样既可以在状态判断和label转换的时候引入需要的文件就可以了。 示例： // customer.js const customer = &#123; normal:&#123; /*...*/ &#125;, member:&#123; /*...*/ &#125;, // ... &#125; const customerTypes = Object.values(customer) const getCustomerType = function (key) &#123; const record = customerTypes.find(record => record.key === key) return record || &#123; label: '未指定', key: 0 &#125; &#125; export &#123; customer, customerTypes, getCustomerType &#125; // agent.js const agent = &#123; province:&#123; /*...*/ &#125;, area:&#123; /*...*/ &#125;, // ... &#125; const agentTypes = Object.values(agent) const getAgentType = function (key) &#123; const record = agentTypes.find(record => record.key === key) return record || &#123; label: '未指定', key: 0 &#125; &#125; export &#123; agent, agentTypes, getAgentType &#125; // user.js import &#123; customer, customerTypes &#125; from \"./customer.js\" import &#123; agent, agentTypes &#125; from \"./agent.js\" const user = &#123; customer:customer, agent:agent, // 一些单独的其它类型 xxxx:&#123; /*...*/ &#125;, xxxx:&#123; /*...*/ &#125; // ... &#125; const allUserTypeList = [ ...customerTypes, ...agentTypes, users.xxxx, users.xxxx, ] // 获取账户角色类型 const getAccountType = function (type, key = 'key') &#123; const finder = allUserTypeList.find(item => item[key] === type) return finder || &#123; label: '未指定', key: 0 &#125;, &#125; 确定是用户类型的时候，只需要 import 对应的 角色.js 的就可以，如果不确定类型的时候就可以使用 user.js 来使用 user.xxx.xxx 来使用对应的角色类型数据，或者用 getAccountType 来获取类型。 现在我是用这种方式来管理状态的，但是我觉得还是有一些问题，准备看一下前人是否已经总结出来这种模式，所以准备把之前买来的设计模式大概翻看一下，看看有没有可用的，也算把自己的基础能力完善起来。 尾声我在 Segmentfault 上的问题帖：项目中前端部分关于订单状态管理的一些疑问，如果有更好的想法，可以直接评论，或者 📧 Mail给我","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"挖坑","slug":"挖坑","permalink":"https://yogwang.site/tags/%E6%8C%96%E5%9D%91/"},{"name":"设计模式","slug":"设计模式","permalink":"https://yogwang.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Symbol() 是个什么东西?","slug":"JS-ES6-Symbol","date":"2020-11-21T15:44:47.000Z","updated":"2021-05-29T03:25:44.354Z","comments":true,"path":"2020/JS-ES6-Symbol/","link":"","permalink":"https://yogwang.site/2020/JS-ES6-Symbol/","excerpt":"最近在一些 Demo 中经常会看到 Symbol() 这个东西，例如: var race = &#123; protoss: Symbol(), terran: Symbol(), zerg: Symbol() &#125; 就只能记得大概了，就是赋值一个独特的值，但是这个值具体是什么我想不起来了。所以还是记个笔记加深下印象，省的看了又忘。 ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型","text":"最近在一些 Demo 中经常会看到 Symbol() 这个东西，例如: var race = &#123; protoss: Symbol(), terran: Symbol(), zerg: Symbol() &#125; 就只能记得大概了，就是赋值一个独特的值，但是这个值具体是什么我想不起来了。所以还是记个笔记加深下印象，省的看了又忘。 ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型 如果只看 阮一峰的 ECMAScript 6入门 和 MDN 上的说明，可能会有点迷糊，但是大概知道只要是 Symbol类型 是都是独一无二的，保证不会与其他属性名产生冲突。例如： var s1 = Symbol(1) // Symbol(1) var s2 = Symbol(1) // Symbol(1) s1 === s2 // false s1 == s2 // false 所以，就出现了文章一开始的那个例子，出自方应杭老师的的每日一题（在文章最后有附链接）大概的需求场景，就是需要通过传入不同的 String 来执行不同的操作，接下来我就大概引用该文章内的例子来说明 例如：在玩SC2的时候，我们需要在开始时选择种族，选择完成之后在游戏加载时就会执行对应的创建角色操作。 var race = &#123; protoss: 'protoss', // 神族 terran: 'terran', // 人族 zerg: 'zerg' // 虫族 &#125; function createRole(type)&#123; if(type === race.protoss)&#123; 创建神族角色 &#125; else if(type === race.terran)&#123; 创建人族角色 &#125; else if(type === race.zerg)&#123; 创建虫族角色 &#125; &#125; 用户选择种族后，就需要调用 createRole 来创建角色： // 传入字符串 createRole('zerg') // 或者传入变量 createRole(race.zerg) 但是在传入 type 值的时候，如果直接用字符串，就不是一个好的方式（不利于将来的修改和维护），所以需要传入例如 race.zerg 这样的变量属性。那么如果这样操作的话，其实这些对象属性（race.protoss,race.terran,race.zerg）对应的值并不重要，因为传入的肯定是同一个值。所以以下声明和前一个例子中声明可以完成同一个作用。 var race = &#123; protoss: 'askdjaslkfjas;lfkjas;flkj', // 神族 terran: ';lkfalksjfl;askjfsfal;skfj', // 人族 zerg: 'qwieqwoirqwoiruoiwqoisrqwroiu' // 虫族 &#125; 也就是说， race.zerg 的值是多少并不重要，只要它的值跟 race.protoss 和 race.terran 的值不一样就行，Symbol 的用途就是如此。 凡是数据类型属于 Symbol 类型，就都是独一无二的 所以可以用以下代码来声明，并且保证不会出现冲突的属性值： var race = &#123; protoss: Symbol(), terran: Symbol(), zerg: Symbol() &#125; // 抑或填入描述 var race = &#123; protoss: Symbol('protoss'), terran: Symbol('terran'), zerg: Symbol('zerg') &#125; 至此我觉得 Symbol 数据类型已经解释清楚了，如果还是不明白，请重新回到头部阅读一遍。 Symbol 拥有的一些特性一、Symbol 作为属性名进行遍历时： Symbol 作为属性名，遍历对象的时候，该属性不会出现在 for...in、for...of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 返回。 Symbol 也不是私有属性。 可以通过 Object.getOwnPropertySymbols() 方法来获取指定对象的所有 Symbol 属性名（方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值） const obj = &#123;&#125;; let a = Symbol('a'); let b = Symbol('b'); obj[a] = 'Hello'; obj[b] = 'World'; Object.getOwnPropertySymbols(obj); // [Symbol(a), Symbol(b)] 当然也可以使用 ES6 的新 API Reflect.ownKeys() 来获取所有类型的键名，包括 常规键名 和 Symbol 键名。 二、Symbol.for() 方法 Symbol.for()方法可以接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。 如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。 let s1 = Symbol.for('foo'); let s2 = Symbol.for('foo'); s1 === s2 // true Symbol.for(\"bar\") === Symbol.for(\"bar\") // true Symbol.for() 与 Symbol() 都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。 三、Symbol.keyFor() 方法 Symbol.keyFor() 方法返回一个已登记的 Symbol 类型值的 key。 let s1 = Symbol.for(\"foo\"); Symbol.keyFor(s1) // \"foo\" let s2 = Symbol(\"foo\"); Symbol.keyFor(s2) // undefined 四、内置的 Symbol 属性除了定义自己使用的 Symbol 值以外，ES6 还提供了 11 个内置的 Symbol 值，指向语言内部使用的方法。 Symbol.hasInstance Symbol.isConcatSpreadable Symbol.species Symbol.match Symbol.replace Symbol.search Symbol.split Symbol.iterator Symbol.toPrimitive Symbol.toStringTag Symbol.unscopables 这11个属性具体的说明看阮一峰老师的 ECMAScript 6入门 就可以了，里边有单独的小Demo可以阅读，我就不单独说明了，因为如果全部说明的话，内容就太多了，并且和书的内容高度重复了。 附「每日一题」JS 中的 Symbol 是什么？ | 方应杭Symbol - ECMAScript 6入门 | 阮一峰Symbol - JavaScript | MDNSymbol.prototype.description - JavaScript | MDNReflect - ECMAScript 6入门 | 阮一峰Reflect.ownKeys() - JavaScript | MDN","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"},{"name":"ECMAScript 6","slug":"ECMAScript-6","permalink":"https://yogwang.site/tags/ECMAScript-6/"}]},{"title":"📟 树莓派 4B(2GB RAM) 开箱记录","slug":"raspberrypi-01-setup","date":"2020-11-16T12:56:29.000Z","updated":"2021-08-03T09:50:15.160Z","comments":true,"path":"2020/raspberrypi-01-setup/","link":"","permalink":"https://yogwang.site/2020/raspberrypi-01-setup/","excerpt":"自从我爸妈他们屋子重新装修好了之后，我爸就嚷嚷着要把他的旧电脑搬上楼装起来，但是家里没有多少地方能摆电脑桌了(怕他又和以前一样在书房看着小说抽一整天的烟)。所以趁着双十一，就入手了一个树莓派 4 Model B，准备给他放客厅连到电视上，通过家里人时不时打断他投入看小说的状态。 今天到货了，开始折腾一下….","text":"自从我爸妈他们屋子重新装修好了之后，我爸就嚷嚷着要把他的旧电脑搬上楼装起来，但是家里没有多少地方能摆电脑桌了(怕他又和以前一样在书房看着小说抽一整天的烟)。所以趁着双十一，就入手了一个树莓派 4 Model B，准备给他放客厅连到电视上，通过家里人时不时打断他投入看小说的状态。 今天到货了，开始折腾一下…. 📦 喜闻乐见的开箱环节 我买的是官方的国内代理，其实就是淘宝店，然后买的 【 官方配件基础套餐 】，里边有一个板子然后一些配件(电源，散热贴片，外壳，TF卡(16G)，读卡器) 💾 安装镜像安装镜像没什么好说的，使用官方文档上的软件，格式化SD卡以及写入系统镜像即可。 意外情况：如果一直卡在 Writing..0% 的界面的话，直接到官网手动下载需要的镜像，然后在 CHOOSE OS 中选择 Use custom 选项，然后找到下载的镜像文件再写入就可以了。 安装完成之后在 Boot 分区下创建 ssh 文件(开启SSH)和 wpa_supplicant.conf 文件(自动连接WiFi)，然后把TF卡插回树莓派，接入电源后使用 SSH 链接就可以连接到树莓派了，默认用户名（pi）和密码（raspberry）。 如果要使用桌面的话，如果使用 VNC Viewer 来访问的话，直接查看官方的文档即可。 我的话，直接就通过 Win10 自带的远程连接的话，就不能按照文档照搬了， sudo apt-get install xrdp tightvncserver 安装完成后键入 sudo /etc/init.d/xrdp start 启动 xrdp，这个时候就已经可直接使用远程连接访问树莓派了。但是浏览网页明显感觉到卡顿，不知道是不是远程链接的问题。 2020年11月17日更新，使用 Ubuntu Server 安装 Desktop 之后就没有感觉很卡了。 💥遇问题1、没有外接显示器，直接使用SSH连接的时候遇到 Connection refused因为中午在办公室开箱的，所以在午休的时候捣鼓，写入系统之后发现怎么都连接不上，以为是没有镜像没有写入好，所以又重新格式化又写了一遍，之后发现还是连不上，就Google了一下，发现是SSH没有开启的问题。 As of the November 2016 release, Raspberry Pi OS has the SSH server disabled by default. 但是我手头上没有可以用的显示器，就想着怎么不用显示器来开启SSH，官方提供了几个方案（连接在文档最后）： 连接显示器后进入 Preferences 菜单进行操作。 连接显示器后使用命令行开启。 通过 headless 可以直接在 boot 分区下创建 ssh 文件(小写)，在系统启动时自启动 SSH。 方案1 和 方案2 直接放弃，要有这个条件我还纠结啥….所以只能在 方案3 上尝试一下。 由于后来我又尝试安装了 Ubuntu Desktop 20.10 所以可能有些不一样，各种创建文件的方式我都尝试了，但是都没有成功，好像是说 Ubuntu Desktop 默认没有 SSH 服务，需要手动安装启动。只能尝试通过先安装 Ubuntu Server版，再安装 ubuntu-desktop 的方式看看能不能行得通。 2020年11月17日更新，确实 Ubuntu Server 版本写入TF卡后直接连网线就可以使用SSH连接了。换源什么的应该都不用说了吧？ 2、Ubuntu Desktop 中使用Firefox看B站提示缺少Flash刚刚安装完 Ubuntu Desktop 包，想试试看视频卡不卡，然后进入B站提示我缺少Flash，因为Ubuntu中不包含 Ubuntu Restricted Extras 软件包，使用 sudo apt-get install ubuntu-restricted-extras 安装就可以了。（画外音：同意协议记得用键盘操作，鼠标点击是没有用的） 附SD Memory Card Formatter - SD AssociationOperating system images – Raspberry PiSSH (Secure Shell) - Raspberry Pi Documentation","categories":[{"name":"生活杂谈","slug":"生活杂谈","permalink":"https://yogwang.site/categories/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"RaspberryPi","slug":"RaspberryPi","permalink":"https://yogwang.site/tags/RaspberryPi/"}]},{"title":"聊一下自己 VueJS 项目的编码习惯和风格","slug":"vue-coding-style-and-lint","date":"2020-11-11T04:01:49.000Z","updated":"2021-05-28T02:41:46.952Z","comments":true,"path":"2020/vue-coding-style-and-lint/","link":"","permalink":"https://yogwang.site/2020/vue-coding-style-and-lint/","excerpt":"最近在考虑把遍码习惯整理一下，一个良好的遍码习惯可以有效减少一个项目的维护成本，因为不可能在整个项目的生命周期中，均由最初的开发人员来维护，或者所有的代码都是由你一个人写出来的，改善代码的可读性，可以让开发人员尽快理解历史的业务代码。 之前也有研究过 ESlint的格式化风格 选择一款适合自己的来规范自己，但是了解的越多，越觉得还是需要团队互相讨论来找一个大家能都接受的妥协结果，所以最后还是选择了 Prettier ，因为我觉得其它两种风格相对来说太严苛了，很多项目都是自己开发并没有多人合作开发的情况出现，所以使用 Prettier 相对来说所自由一些…","text":"最近在考虑把遍码习惯整理一下，一个良好的遍码习惯可以有效减少一个项目的维护成本，因为不可能在整个项目的生命周期中，均由最初的开发人员来维护，或者所有的代码都是由你一个人写出来的，改善代码的可读性，可以让开发人员尽快理解历史的业务代码。 之前也有研究过 ESlint的格式化风格 选择一款适合自己的来规范自己，但是了解的越多，越觉得还是需要团队互相讨论来找一个大家能都接受的妥协结果，所以最后还是选择了 Prettier ，因为我觉得其它两种风格相对来说太严苛了，很多项目都是自己开发并没有多人合作开发的情况出现，所以使用 Prettier 相对来说所自由一些… 先来讲代码的格式与注释代码的格式和注释虽起不到逻辑作用，但是可以是团队合作效率更高，代码更易于维护。特别是在其他人接手自己项目的时候，能让他很快了解自己的想法。 我这边一直在使用的类似 AirBnb 的 Lint 风格，但只是其中的一些命名、缩进和换行的风格，我并没有严格按照他们的风格来，例如： 用命名函数表达式而不是函数声明 func-style 函数表达式： const func = function () &#123;&#125; 函数声明： function func() &#123;&#125; 虽然有他们的道理，但是我并不是很喜欢，当然会根据不同团队做出改变。所以保持业务代码的可读性就好，我没有按部就班的使用，项目也只是启用了 Prettier 的默认设置。 概念隔离：不同的的概念/逻辑代码使用空行隔离 代码注释代码注释我这边还没有很明确到很精细的规范，很自由。只是要求了在 文件头、函数声明时 以及 函数内一些关键的部分 进行补充说明，因为有时候只是代码的语义化并不能很好的说明情况。虽然自己也经常会忘记在一些复杂场景下补充注释，但是事后记得补全就好。 哦，对了，记得增加提示信息，防止出现踩坑事件，例如使用 TODO 等标记未来得及完成的部分，并且安装 TODO Tree 插件确保自己不会遗忘填坑。 冗余代码尽量避免重复代码，我对于冗余代码的意见是很大的，需要代码简洁明了清晰易读，特别是明显可以抽离出来复用的业务逻辑。如果重复出现多次的话，我一定会分离出去，特别是一些复杂场景下的大段代码中，尽量 保持一个函数职责单一 对于代码的提炼在考虑到项目的后续发展和可能会出现的扩展之后，在一定版本迭代中不会出现功能拓展的业务代码进行提炼和优化，这就需要你对于项目整体要有一定程度的了解。 对可能在可遇见的时间范围内会出现变动的的业务代码精心适量的优化，并且保持扩展的便利性，确保不会出现死结。 同时保持代码短小精炼并且易维护、易拓展是很困难的，优先保证易维护和易拓展。 效率有时候为了实现尽快实现功能，会出现急功近利的情况，牺牲代码的可读性以及结构。如果很赶时间，尽量在Coding之前，整理好需求，在设计完代码流程和结构之后把注释写在功能头部。方便结束之后整理优化，就算自己忘记整理了，也不至于接手的下一任直接重写，记得代码面向读代码的人来写。 最后是 Vue 官方的风格规范:Vue 有一套官方的风格指南，里边有一些指导和参考，总共分为四类： 优先级 A：必要的 优先级 B：强烈推荐 优先级 C：推荐 优先级 D：谨慎使用 优先级 A 的就不需要说了吧，必要的这块内容，应该在学习 Vue 的时候就已经从官方给出的 Demo 感受到了，比如 组件名为多个单词，以及 组件的 data 必须是一个函数。虽然有一些规范在 Vue3 中已经被修改了，但是在 Vue2 中还是适用的。 优先级 B 这一类的内容是为了增加代码可读性的，所以尽最大可能的保证使用以及一贯性，基本都是一些命名和书写规范，刻意保持一段时间就习惯了。 优先级 C 这块内容是比较自由的，官方也设定为推荐级别，其中提到的 组件/实例的选项的顺序，我觉得重要性还是很高的，在Cooding时保持和官方文档一样的排列顺序。 最近我就出现了同事把 created 代码放到组件最后，我在增加功能的时候在头部也增加了 created ，发现自己的 created 钩子没有执行。当然这个锅其实有一部分是编辑器的，我这边没有对重复声明的对象属性进行错误高亮。 优先级 D 中的内容是警告内容，这块内容在良好的编码习惯下一般是不会出现的。 当然如果你觉得官方的Lint的风格很好，那么你可以使用他们提供的 eslint-plugin-vue 这个依赖项，来规范和格式化代码。 最后的最后我对之前 Vue 官方指导没有提到的一些地方进行补充： 每一个组件都要有 name 属性。 你需要了解 mixins 和 extends。 使用 computed 来计算一些属性，比如路由信息 $route中的一些传递参数，或者在代码中出现频率很高的深层属性。 在生命周期钩子中，保证不出现业务代码，如果一块内容超过6行那就单独拿出来写成函数放到 methods 中，尽量减少生命周期钩子中的代码量。 业务代码都在 methods 中，或者取成 功能名称.js文件。 在路由中使用 params 来传递参数，记得在路由配置中绑定动态路径参数，不然会丢失 保持Lint开启。 使用环境变量。 附风格指南 — Vue.jsvue/order-in-components | eslint-plugin-vue Introduction | eslint-plugin-vue","categories":[],"tags":[{"name":"VueJS","slug":"VueJS","permalink":"https://yogwang.site/tags/VueJS/"},{"name":"Coding","slug":"Coding","permalink":"https://yogwang.site/tags/Coding/"}]},{"title":"ES6 中的 新数据结构 Set & Map","slug":"JS-ES6-MAP","date":"2020-11-07T05:22:28.000Z","updated":"2021-05-29T03:25:45.611Z","comments":true,"path":"2020/JS-ES6-MAP/","link":"","permalink":"https://yogwang.site/2020/JS-ES6-MAP/","excerpt":"今天在一个需求里边遇到一个使用 MAP 数据结构的场景，就去解了一下 ES6 的新数据结构 ECMAScript 6 内提供了 4种 新结构 Set, WeakSet, Map, WeakMap，虽然已经是5年前的知识了，但是对于我来说还是新🤣 本来想先聊 Map 的，但是仔细看了阮一峰老师的文章之后发现，确实是要从 Set 开始讲","text":"今天在一个需求里边遇到一个使用 MAP 数据结构的场景，就去解了一下 ES6 的新数据结构 ECMAScript 6 内提供了 4种 新结构 Set, WeakSet, Map, WeakMap，虽然已经是5年前的知识了，但是对于我来说还是新🤣 本来想先聊 Map 的，但是仔细看了阮一峰老师的文章之后发现，确实是要从 Set 开始讲 1 | Set 数据结构 类似于数组，但是成员的值都是唯一的，没有重复的值。 本身是一个构造函数，用来生成 Set 数据结构。 拥有两个属性： Set.prototype.constructor：构造函数，默认就是 Set 函数。 Set.prototype.size：返回 Set 实例的成员总数。 四个操作方法和四个遍历方法： 操作方法 Set.prototype.add(value)：添加某个值，返回 Set 结构本身。 Set.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 Set.prototype.has(value)：返回一个布尔值，表示该值是否为Set的成员。 Set.prototype.clear()：清除所有成员，没有返回值。 遍历方法 Set.prototype.keys()：返回 键名 的遍历器 Set.prototype.values()：返回 键值 的遍历器 Set.prototype.entries()：返回 键值对 的遍历器 Set.prototype.forEach()：使用回调函数遍历每个成员 先说 Set 数据结构的创建，因为 Set 本身是一个构造函数，所以可以使用 new 命令来创建，然后通过 add() 来添加成员。 当然也可以通过传入一个数组来进行初始化，或者具有 iterable 接口的其他数据结构。 // 直接创建一个Set结构 const s = new Set(); s.add(1); // Set(1) &#123;1&#125; // 传入数组的形式创建Set结构 const s2 = new Set([1, 2, 3, 4]) // Set(4) &#123;1, 2, 3, 4&#125; 既然 Set 函数支持传入数组来进行初始化，并且成员的值都是唯一的，没有重复的值，所以可以使用 Set 来实现一个简短的数组去重方法： // 简单数组去重 const sourceArray = [1, 2, 3, 4, 5, 5, 5, 6, 7, 6, 8] const newArray = Array.from((new Set(sourceArray))) console.log(newArray) // (8) [1, 2, 3, 4, 5, 6, 7, 8] 另外向 Set 添加成员的时候需要注意几个点: 添加成员的时候，不会发生类型转换 两个 对象 总是不相等的，但是两个 NaN 会被认为是相等的 插入顺序就是遍历顺序，所以能保证按照添加顺序调用（不能直接改变结构） 内部使用的算法叫做 “Same-value-zero equality”，类似于精确相等运算符（===） 乍一看可能不明白，我举几个例子🌰 // 插入数字和字符串 let set = new Set() set.add(1) set.add('1') // Set(2) &#123;1, \"1\"&#125; // 插入对象 let set = new Set() let a1 = &#123;&#125; let a2 = &#123;&#125; set.add(a1) set.add(a2) set.size // 2 // Set(2) &#123;&#123;…&#125;, &#123;…&#125;&#125; // 插入 NaN let set = new Set() let a1 = NaN let a2 = NaN set.add(a1) set.add(a2) set.size // 1 // Set(1) &#123;NaN&#125; // 顺序保持 let set = new Set() set.add(1) set.add(2) set.add(6) set.add(4) set.add(5) // Set(5) &#123;1, 2, 6, 4, 5&#125; 接着就是 Set 的遍历方法了， 第一类： keys()，values()，entries() 返回的都是遍历器对象（Iterator 对象 - SetIterator） Set 的遍历顺序就是插入顺序 Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的 values 方法。 由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以 keys 方法和 values 方法的行为完全一致。 第二类： forEach() const set = new Set(['red', 'green', 'blue']); // 返回键名 for (let item of set.keys()) &#123; console.log(item); &#125; // red // green // blue // 返回键值 for (let item of set.values()) &#123; console.log(item); &#125; // red // green // blue // 返回键值对 for (let item of set.entries()) &#123; console.log(item); &#125; // (2)[\"red\", \"red\"] // (2)[\"green\", \"green\"] // (2)[\"blue\", \"blue\"] // 直接遍历 for (let x of set) &#123; console.log(x); &#125; // red // green // blue set.forEach((value, key) => console.log(key + ' : ' + value)) // red : red // green : green // blue : blue 2 | Map 数据结构 JavaScript 的对象（Object），本质上是 键值对 的集合（Hash 结构），但是传统上只能用 字符串 当作键。这给它的使用带来了很大的限制。为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是 键值对 的集合，但是 “键” 的范围 不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了 “字符串 — 值” 的对应，Map 结构提供了 “值 — 值” 的对应，是一种更完善的 Hash 结构实现。如果你需要 “键值对” 的数据结构，Map 比 Object 更合适。 来一段对比的例子： const data = &#123;&#125;; const key = &#123; key: 1 &#125;; data[key] = 'Value'; console.log(data) // &#123; '[object Object]': 'Value' &#125; console.log(data[key]) // Value const key2 = &#123; key: 2 &#125;; data[key2] = 'Key2 Value'; console.log(data[key]) // Key2 Value console.log(data[key2]) // Key2 Value console.log(data) // &#123; '[object Object]': 'Key2 Value' &#125; 上面代码原意是将一个 对象key 作为 对象data 的键，但是由于对象只接受字符串作为键名，所以key被自动转为字符串 [object Object]。虽然也能用 data[key] 来调用，但实质是把 key 自动转换成了字符串 [object Object] 来调用，所以当有设置多个对象作为键的时候就会覆盖原先的属性。 下边的代码使用 Map 结构的set方法，将上面的代码进行复原： const data = new Map(); const key = &#123; key: 1 &#125;; m.set(key, 'Value') console.log(m.get(key)） // \"Value\" const key2 = &#123; key: 2 &#125;; m.set(key2, 'Key2 Value') console.log(m.get(key2)) // \"Key2 Value\" console.log(data) // Map &#123; &#123; key: 1 &#125; => 'Value', &#123; key: 2 &#125; => 'Key2 Value' &#125; 可以看到 Map 数据结构 可以完美实现原意，使用对象作为 键，其它就和对象的结构基本类似。 Map 结构的实例和 Set 结构一样的属性和相似的操作方法 拥有两个属性： Map.prototype.constructor：构造函数，返回一个函数，它创建了实例的原型。默认是 Map 函数。 Map.prototype.size：返回 Map对象的键/值对的数量。 五个操作方法和四个遍历方法： 操作方法 Map.prototype.set(value)：设置 Map 对象中键的值。返回该 Map 对象。 Map.prototype.get(value)：返回键对应的值，如果不存在，则返回 undefined。 Map.prototype.has(value)：返回一个布尔值，表示 Map 实例是否包含键对应的值。 Map.prototype.delete(value)：删除某个元素，返回一个布尔值，表示删除是否成功。 Map.prototype.clear()：移除 Map 对象的所有键/值对，没有返回值。 遍历方法 Map.prototype.keys()：返回 键名 的遍历器 Map.prototype.values()：返回 键值 的遍历器 Map.prototype.entries()：返回 键值对 的遍历器 Map.prototype.forEach()：使用回调函数遍历每个成员 和 Set 一样，Map 也可以接收传入数组来进行初始化，但是数组内需要是键值对的形式，例如： // 数组 转为 Map const data = [ [1, 'one'], [2, 'two'], [3, 'three'], ] const map = new Map(data); console.log(map) // Map(3) &#123;1 => \"one\", 2 => \"two\", 3 => \"three\"&#125; 对象不是一个可迭代的结构，可以通过 Object.entries() 转换成可迭代结构 // 对象转为 Map let obj = &#123;\"a\":1, \"b\":2&#125;; let map = new Map(Object.entries(obj)); console.log(map) // Map(2) &#123;\"a\" => 1, \"b\" => 2&#125; Map 也可以转换回其它数据结构 // Map 转为数组 const myMap = new Map() .set(true, 7) .set(&#123;foo: 3&#125;, ['abc']); [...myMap] // 使用 扩展运算符 最简便 // [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ 'abc' ] ] ] 如果所有 Map 的键都是字符串，它可以无损地转为对象。 如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名（如本节最开始的Demo所示） // Map 转为对象 function strMapToObj(strMap) &#123; let obj = Object.create(null); for (let [k,v] of strMap) &#123; obj[k] = v; &#125; return obj; &#125; const myMap = new Map() .set('yes', true) .set('no', false); strMapToObj(myMap) // &#123; yes: true, no: false &#125; Map 转为 JSONMap 转为 JSON 要区分两种情况。一种情况是，Map 的键名 都是字符串，这时可以选择转为 对象 JSON。 function strMapToJson(strMap) &#123; return JSON.stringify(strMapToObj(strMap)); &#125; let myMap = new Map().set('yes', true).set('no', false); strMapToJson(myMap) // '&#123;\"yes\":true,\"no\":false&#125;' 另一种情况是，Map 的键名 有非字符串，这时可以选择转为 数组 JSON。 function mapToArrayJson(map) &#123; return JSON.stringify([...map]); &#125; let myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, ['abc']); mapToArrayJson(myMap) // '[[true,7],[&#123;\"foo\":3&#125;,[\"abc\"]]]' JSON 转为 Map这段我直接引用阮一峰老师的文字吧 正常情况下，所有键名都是字符串。 function jsonToStrMap(jsonStr) &#123; return objToStrMap(JSON.parse(jsonStr)); &#125; jsonToStrMap('&#123;\"yes\": true, \"no\": false&#125;') // Map &#123;'yes' => true, 'no' => false&#125; 但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。 function jsonToMap(jsonStr) &#123; return new Map(JSON.parse(jsonStr)); &#125; jsonToMap('[[true,7],[&#123;\"foo\":3&#125;,[\"abc\"]]]') // Map &#123;true => 7, Object &#123;foo: 3&#125; => ['abc']&#125; 3 | WeakSet 数据结构 WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。 WeakSet 的成员只能是 对象，而 不能是其他类型的值。 WeakSet 中的对象都是 弱引用（即垃圾回收机制不考虑 WeakSet 对该对象的引用） WeakSet 不能遍历，是因为成员都是弱引用 那直接看说明，很直接明了，第一个区别也很直接，主要就是第二个区别，什么是 垃圾回收机制不考虑 WeakSet 对该对象的引用 垃圾回收机制依赖引用计数，如果一个值的引用次数不为 0，垃圾回收机制就不会释放这块内存。结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。 而 WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。 因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些 对象 在 外部消失，它在 WeakSet 里面的引用就会自动消失。 由于上面这个特点，WeakSet 的成员是不适合引用的，因为它会随时消失。另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 WeakSet 不可遍历。 总而言之，言而总之，就是一个只能存储 Object 和 Array 的集合，而且内存泄漏得问题现在应该已经解决了吧…. WeakSet 结构有以下三个方法： WeakSet.prototype.add(value)：向 WeakSet 实例添加一个新成员。 WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。 WeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员，返回一个布尔值。 我能想到的场景就是判断是否某个对象是否还存在与场景中，🤦‍♂️其它的应用场景我真的想不到了…. 好了，大概看几个演示Demo吧 const ws = new WeakSet(); const obj = &#123;&#125; const arr = [] const arr2 = arr const arr3 = arr ws.add(obj) // WeakSet &#123;&#123;…&#125;&#125; ws.add(arr) // WeakSet &#123;Array(0), &#123;…&#125;&#125; ws.add(1) // Uncaught TypeError: Invalid value used in weak set ws.add(NaN) // Uncaught TypeError: Invalid value used in weak set ws.add(arr2) // WeakSet &#123;Array(0), &#123;…&#125;&#125; ws.has(obj) // true ws.has(arr) // true ws.has(arr2) // true ws.has(arr3) // true ws.has(&#123;&#125;) // false ws.has([]) // false ws.delete(arr) // true ws.has(arr) // false ws.has(arr2) // false 4 | WeakMap 数据结构 WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。 同时也和 WeakSet 一样，只接受 对象 作为键名（ null 除外），不接受其他类型的值作为键名。并且同样是弱引用，WeakMap 的键名所指向的对象，不计入垃圾回收机制。 实例方法 WeakMap 比 WeakSet 多了一个可用 get()： 返回 key 关联对象, 或者 undefined (没有 key 关联对象时)。 结尾再阮一峰老师的文章最后有一段，但是我实际操作的时候触发垃圾回收，所以 Weak* 的弱引用暂时没有 Demo 。 Chrome 浏览器的 Dev Tools 的 Memory 面板，有一个垃圾桶的按钮，可以强制垃圾回收（garbage collect）。这个按钮也能用来观察 WeakMap 里面的引用是否消失。 其它问题1、Vue 的不能监听到 Map 和 Set 的数据改变: Vue 的响应式系统不支持 Map 和 Set，也就是说，当 Map 与 Set 里面的元素变化时Vue追踪不到这些变化，因此无法做出响应。 2、为啥把对象设置为Null了，WeakSet/WeakMap 内的成员不会消失我在写笔记的时候一直想写一个 WeakSet 的弱引用 Demo，但是一直没有成功，就算把变量设置为 null 了，还能可以能从 WeakSet 里边看到，例如以下代码： let a = &#123; name: 'a' &#125; const ws = new WeakSet(); ws.add(a) // WeakSet &#123;&#123;…&#125;&#125; a = null // null console.log(ws) // WeakSet &#123;&#123;…&#125;&#125; // - [[Entries]] // - 0: // - value: &#123;name: \"a\"&#125; // __proto__: WeakSet 一个人坐在沙发上纠结了好久，然后还是去群里问了下，得到了一下回复….我是真的没想到🤣 MeatHill：虽然 weak* 允许被回收，但是大多数情况下，在内存压力不大的时候它不会被回收，所以一般建议默认它不会被回收。尤其不要在 set 之后立刻看，几乎一定不会被回收。GC (垃圾回收机制)的成本不低，不是时时运转的。 Emmmm….. 我裂开🙃 3、WeakMap.prototype.clear() 当前版本或者起草中没有这个方法，这个方法在版本 28（2014 年 10 月 14） 之前是 ECMAScript 6 起草规范的一部分，但是在起草之后的版本中被移除了。它不在是最终标准的一部分了 。 附 Set 和 Map 数据结构 - 阮一峰 迭代器 Symbol.iterator - JavaScript | MDN Iterator 和 for…of 循环 - 阮一峰 Set - JavaScript | MDN Map - JavaScript | MDN WeakSet - JavaScript | MDN WeakMap - JavaScript | MDN 解决内存问题 | Chrome DevTools | Google Developers","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"},{"name":"ECMAScript 6","slug":"ECMAScript-6","permalink":"https://yogwang.site/tags/ECMAScript-6/"}]},{"title":"VueJS中 v-bind 的一些修饰符","slug":"vue-v-bind-props-camel-sync","date":"2020-11-05T13:59:52.000Z","updated":"2021-08-04T01:44:39.845Z","comments":true,"path":"2020/vue-v-bind-props-camel-sync/","link":"","permalink":"https://yogwang.site/2020/vue-v-bind-props-camel-sync/","excerpt":"今天洗澡的时候在听 饥人谷的模拟面试 (五) 的时候，一直觉得这次面试的学生有点差，如果是我来面话可能已经让他回家了，但是 方方老师 很有耐心，在中间问道 .sync 的时候我 ???? 完全没有印象了。 正好已经有2个月没有更新了，所以复习一下 v-bind 的三个修饰符 [ .prop, .camel, .sync ]","text":"今天洗澡的时候在听 饥人谷的模拟面试 (五) 的时候，一直觉得这次面试的学生有点差，如果是我来面话可能已经让他回家了，但是 方方老师 很有耐心，在中间问道 .sync 的时候我 ???? 完全没有印象了。 正好已经有2个月没有更新了，所以复习一下 v-bind 的三个修饰符 [ .prop, .camel, .sync ] 首先就是 .sync .sync (2.3.0+) 语法糖，会扩展成一个更新父组件绑定值的 v-on 侦听器。 直接看文档里边的这段话，可能会有点懵，但是可以大概猜到是更新单向流数据相关的。 然后看文档里边的 Demo 👇 &lt;!-- 向子组件传入 title, 并且接收update事件更新title --> &lt;text-document v-bind:title=\"doc.title\" v-on:update=\"doc.title = $event\" /> 然后通过子组件的 this.$emit(&#39;update:title&#39;, newTitle) 触发 update:title 事件, 不过正常时候的业务代码我不会这样写，会习惯使用以下的代码（不过没差啦，意思都一样） &lt;text-document :title=\"doc.title\" @update=\"title => doc.title = title\" /> 然后通过子组件的 this.$emit(&#39;update&#39;, newTitle) 触发更新 虽然精简了一点，但是还是很冗余，所以轮到 .sync 这个语法糖出场，可以更加精简父组件的代码： &lt;text-document :title.sync=&quot;doc.title&quot; /&gt; 可以看到就是省略了接受子组件的 update 事件，像 v-model 这个语法糖一样双向绑定了数据。 需要注意一点的是，使用 .sync 这个语法糖，需要子组件内的 $emit 触发的事件以 update:myPropName 的形式来命名 所以我自己的遍码习惯就触发不了，需要修改子组件的 $emit 和文档中的一样使用 this.$emit(&#39;update:title&#39;, newTitle) 来触发更新 也可以将这个 .sync 修饰符和 v-bind 配合使用，用于修改传入的同一个对象中的多个属性 &lt;text-document v-bind.sync=\"doc\">&lt;/text-document> 这样会把 doc 对象中的每一个 property (如 title ) 都作为一个独立的 prop 传进去，然后各自添加用于更新的 v-on 监听器。 二： .prop .prop - 作为一个 DOM property 绑定而不是作为 attribute 绑定 (差别在哪里？)。 这个的主要就是你需要先理解 DOM property 和 attribute 的 区别（ DOM属性 和 属性 挖个坑找时间聊聊），然后就很容易知道这个修饰符的作用了。 大概就是 v-bind 默认绑定到 DOM 节点的 attribute 上，使用 .prop 修饰符后，会绑定到 property 上 最后一个 .camel .camel - (2.1.0+) 将 kebab-case attribute 名转换为 camelCase。(从 2.1.0 开始支持) 因为 HTML代码是不区分大小写的，但是有一些标签需要使用驼峰来申明属性，例如文档中的 svg 标签的 viewBox 属性，如果渲染成 viewbox 则会找不到值。 这个真的很少用到，文档还特别说明了 vue-loader 渲染的不会有这个问题： 在使用字符串模板或通过 vue-loader/vueify 编译时，无需使用 .camel。 在Vue 3.0中的 .sync 今天写Vue遍码风格的时候发现了一个3.0的新规范，就是不推荐使用 v-bind-sync 这一个选项，里边提到了在 3.0 中已经解决了在组件上 v-model 只允许使用一个的问题，所以不推荐继续使用 .sync 了，大概看一下就好，链接添加在了附录内，所以这又是一篇迟到的文章，2333333。 附 DOM property 和 attribute 的区别详解 vue 2.x 的 v-bind 指令的 .prop 事件修饰符详解 v-model | Vue.js 迁移指南","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"VueJS","slug":"VueJS","permalink":"https://yogwang.site/tags/VueJS/"},{"name":"挖坑","slug":"挖坑","permalink":"https://yogwang.site/tags/%E6%8C%96%E5%9D%91/"}]},{"title":"Vue 使用 ref 注册组件的特性","slug":"vue-api-ref","date":"2020-11-02T09:14:09.000Z","updated":"2021-05-29T03:33:36.621Z","comments":true,"path":"2020/vue-api-ref/","link":"","permalink":"https://yogwang.site/2020/vue-api-ref/","excerpt":"一直以来，我对于 VueJS 中对于使用 ref 注册的组件，在使用 $refs 调用时，为什么有时候是一个 DOM元素/组件实例，是时候会是一个实例数组。 所以在很长一段时间内我觉得 ref 注册的的组件在使用 $refs 调用时有很大的不确定性，虽然我的弹窗组件一直都是用的 $refs.modal.open() 来打开的。 直到前一段时间，我在一个场景下想在 v-for 循环渲染的组件下 slot 模板中想使用 ref 注册成一个实例集合来调用时，发现怎么样重写返回的都只是一个组件实例，而不是一个组件实例集合。 所以有了这样一篇笔记。","text":"一直以来，我对于 VueJS 中对于使用 ref 注册的组件，在使用 $refs 调用时，为什么有时候是一个 DOM元素/组件实例，是时候会是一个实例数组。 所以在很长一段时间内我觉得 ref 注册的的组件在使用 $refs 调用时有很大的不确定性，虽然我的弹窗组件一直都是用的 $refs.modal.open() 来打开的。 直到前一段时间，我在一个场景下想在 v-for 循环渲染的组件下 slot 模板中想使用 ref 注册成一个实例集合来调用时，发现怎么样重写返回的都只是一个组件实例，而不是一个组件实例集合。 所以有了这样一篇笔记。 注册 | ref 用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。 如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素； 如果用在子组件上，引用就指向组件实例： 关于 ref 注册时间的重要说明：因为 ref 本身是作为 渲染结果 被创建的，在初始渲染的时候你不能访问它们 - 它们还不存在！$refs 也 不是响应式 的，因此你不应该试图用它在模板中做数据绑定。 所以不要在 mounted() 之前的生命周期钩子里边直接使用 $refs 来获取元素，或者在没有渲染组件的情况下调用元素内的属性或方法，如果一定要的话，记得放在 $nextTick() 里。 使用 | $refs 一个对象，持有注册过 ref attribute 的所有 DOM 元素和组件实例。 只读 允许父级组件通过 $refs 来访问子组件实例内部元素的访问，比如来访问子组件实例内的 data 和 methods 当 ref 和 v-for 一起使用的时候，将得到一个 DOM 节点数组 或 包含了对应数据源 的组件实例的。 1、什么时候只返回一个组件/DOM实例一般来说，直接在一个没有使用 v-for 循环的元素上使用 ref 注册的元素，在使用 this.$refs.xxx 获取时，返回的只会是一个组件实例。 2、什么时候返回一个实例集合按照文档上边来看，在使用 v-for 循环的元素上使用 ref 注册的元素，在使用 this.$refs.xxx 获取时，会返回一个实例集合。 有没有其他办法？比如我不是使用 v-for 循环出来的实例，但是我想注册在同一个 ref 下。 暂时没有办法。 附：ref — Vue.jsvm.$refs — Vue.js访问子组件实例或子元素 — Vue.jsDocument.querySelectorAll - MDNquerySelectorAll 方法相比 getElementsBy 系列方法有什么区别？- 知乎 如何评价 Vue 的 ref 语法糖提案？尤雨溪的回答 - 知乎","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"VueJS","slug":"VueJS","permalink":"https://yogwang.site/tags/VueJS/"}]},{"title":"JavaScript 中的 this 指向问题","slug":"JS-about-this","date":"2020-10-26T04:01:21.000Z","updated":"2021-05-29T03:25:53.177Z","comments":true,"path":"2020/JS-about-this/","link":"","permalink":"https://yogwang.site/2020/JS-about-this/","excerpt":"今天在群里看到大家在讨论一个问题，就是 this 的指向，并且牵扯到了 let，const 的变量提升，比如说在全局顶部声明的 let 变量能否挂载到 window 下之类的。还是老流程，先讨论第一个问题，然后再开始牵扯到后续的展开。 this 指向大概分为两种，普通函数内的 this 和 箭头函数内的 this，箭头函数内的 this 其实挺好理解的，主要是因为各种 call()、apply()、bind() 和 new 影响下的 this 指向问题。","text":"今天在群里看到大家在讨论一个问题，就是 this 的指向，并且牵扯到了 let，const 的变量提升，比如说在全局顶部声明的 let 变量能否挂载到 window 下之类的。还是老流程，先讨论第一个问题，然后再开始牵扯到后续的展开。 this 指向大概分为两种，普通函数内的 this 和 箭头函数内的 this，箭头函数内的 this 其实挺好理解的，主要是因为各种 call()、apply()、bind() 和 new 影响下的 this 指向问题。 先来最简单的demo来说明 this 的最终指向的是那个调用它的对象 function t1()&#123; console.log(this); &#125; t1() // logs Window // 其实等同于 window.t1() var t2 = &#123; name:'t2', fn:function()&#123; console.log(this); &#125; &#125; t2.fn(); // logs &#123;name: \"t2\", fn: ƒ&#125; var t3 = &#123; a:1, b:&#123; fn:function()&#123; console.log(this.a) &#125; &#125; &#125; t3.b.fn() // logs undefined // t3.b中并没有属性a 这样就很好理解了，就是从谁的身上点出来的方法，这个 this 就是在指向谁的。如果没有默认就是 window（严格模式下稍有不同是 undefined），例如 t1() # 构造函数中的 this# Call, Apply, Bind 影响下的 this# Class 下的 this 未完成突然发现之前还有一个坑没有填，我先去把旧坑填完。 附函数的扩展 - ECMAScript 6入门彻底理解js中this的指向，不必硬背 - 追梦子那些年我们一起过的JS闭包，作用域，this，让我们一起划上完美的句号 - 追梦子如何理解 Call, Apply, Bind?","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"未完成","slug":"未完成","permalink":"https://yogwang.site/tags/%E6%9C%AA%E5%AE%8C%E6%88%90/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"}]},{"title":"JS 中的各种 for 循环","slug":"JS-for","date":"2020-07-23T16:03:04.000Z","updated":"2021-05-29T03:25:33.619Z","comments":true,"path":"2020/JS-for/","link":"","permalink":"https://yogwang.site/2020/JS-for/","excerpt":"真是一坑未填又开一坑….现在阶段，for循环有4种，我们先把所有的 for 循环列出，一个一个的聊。 从MDN上边，找到了 四种 for 循环，分别是：for、for...in、for...of 和 for await...of","text":"真是一坑未填又开一坑….现在阶段，for循环有4种，我们先把所有的 for 循环列出，一个一个的聊。 从MDN上边，找到了 四种 for 循环，分别是：for、for...in、for...of 和 for await...of 1. for 原始 for 循环语句经典的 for 循环，所有新手一开始都会写的 demo 基本都会用到的 for 循环吧，我就不多讲了，上一个学生时代（伪）的*号金字塔吧。 const max = 5 for (let n = 1; n &lt; max; n++) &#123; let str = '' for (let i = 1; i &lt; max - n; i++) &#123; str += ' ' &#125; for (let j = 1; j &lt; 2 * n; j++) &#123; str += '*' &#125; console.log(str); &#125; // * // *** // ***** // ******* 2. for...in 为遍历对象属性而构建的 for 循环 for...in 语句以任意顺序遍历一个对象的除Symbol以外的可枚举属性。啥？你问我 Symbol 是啥？看这里 上 demo 配合着来看，先是对象 const obj = &#123; a: 1, b: 2, c: 3 &#125;; for (let prop in obj) &#123; console.log(prop); &#125; // a // b // c 再看一下用它来遍历数组 const arr = ['a', 'b', 'c']; for (let prop in arr) &#123; console.log(prop); &#125; // 0 // 1 // 2 可以看到，它遍历对象的属性名，MDN最后有一句： “它最常用的地方应该是用于调试，可以更方便的去检查对象属性（通过输出到控制台或其他方式）” ？？？？？ ，可我实一般调试时都是直接把整个对象都打印出来啊 所以 for...in 是为遍历对象属性而构建的 for 循环，虽然数组可以用，但是并没有Dio用….并且它会枚举所有属性，包含了被迭代的对象的原型，实际工作开发，这些对象很可能是不需要出现的属性，比如VueJS的 __ob_。 虽然可以配合使用 hasOwnProperty() 来处理，但是太蛮烦了，最好用的场景可能就是这个同时输出键名和键值的场景 const triangle = &#123;a: 1, b: 2, c: 3&#125;; function ColoredTriangle() &#123; this.color = 'red'; &#125; ColoredTriangle.prototype = triangle; const obj = new ColoredTriangle(); for (let prop in obj) &#123; if (obj.hasOwnProperty(prop)) &#123; console.log(`obj.$&#123;prop&#125; = $&#123;obj[prop]&#125;`); &#125; &#125; // obj.color = red 3. for...of 遍历可迭代对象的可枚举属性for...of 可迭代的对象就多了（包括 Array，Map，Set，String，TypedArray，arguments 对象，DOM 集合等等，但是 不包括Object 哦），在这些 可迭代 对象上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句，具体可以看MDN的文档。for…of - MDN 它与 for...in 的区别是什么？ 主要区别在于它们的迭代方式： for...in 语句以任意顺序迭代对象的可枚举属性。 for...of 语句遍历可迭代对象定义要迭代的数据。 配合着demo来看吧。 // 为对象和数组原型增加方法 Object.prototype.objCustom = function() &#123;&#125;; Array.prototype.arrCustom = function() &#123;&#125;; // 声明数组并赋值 let iterable = [3, 5, 7]; iterable.foo = 'hello'; // for...in 遍历输出属性名 for (let i in iterable) &#123; console.log(i); // 0, 1, 2, \"foo\", \"arrCustom\", \"objCustom\" &#125; // for...in 判断是否拥有属性并输出属性名 for (let i in iterable) &#123; if (iterable.hasOwnProperty(i)) &#123; console.log(i); // 0, 1, 2, \"foo\" &#125; &#125; // arrCustom和objCustom不会被输出，因为它们是继承的，并非自身的属性 // for..of 输出可迭代数据 for (let i of iterable) &#123; console.log(i); // 3, 5, 7 // 仅仅输出可迭代对象数组定义的元素值 &#125; 每个对象将继承 objCustom 属性，并且作为 Array 的每个对象将继承 arrCustom 属性，因为将这些属性添加到 Object.prototype 和 Array.prototype。由于继承和原型链，对象 iterable 继承属性 objCustom 和 arrCustom。所以 for...in 会遍历出所有属性名，包括数组元素的下标和继承下来的属性，而 for...of 只遍历了可迭代的数组元素值。 4. for await...ofES9的内容？？？我先看看文档： for await...of 语句创建一个循环，该循环遍历异步可迭代对象以及同步可迭代对象，包括: 内置的 String, Array，类似数组对象 (例如 arguments 或 NodeList)，TypedArray, Map, Set 和用户定义的异步/同步迭代器。它使用对象的每个不同属性的值调用要执行的语句来调用自定义迭代钩子。 然后 类似于 await 运算符一样，该语句只能在一个 async function 内部使用。 简单的用 generator 举一个例子： async function* asyncGenerator () &#123; var i = 0; while (i &lt; 3) &#123; yield i++; &#125; &#125; (async function () &#123; for await (num of asyncGenerator()) &#123; console.log(num); &#125; &#125;)() 但是没有想到有食用的业务场景，可能循环的异步调用？类似依次调用函数读取文件列表进行处理？？？等以后遇到了合适场景再展开了解吧。 以上 附 for - MDN for…in - MDN for…of - MDN for await…of - MDN 看，for..in和for..of在那里吵架！","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"},{"name":"挖坑","slug":"挖坑","permalink":"https://yogwang.site/tags/%E6%8C%96%E5%9D%91/"}]},{"title":"Js数组中的 find/findIndex/some 以及 every","slug":"JS-array-find-some-every","date":"2020-07-22T07:37:33.000Z","updated":"2021-05-29T03:25:50.627Z","comments":true,"path":"2020/JS-array-find-some-every/","link":"","permalink":"https://yogwang.site/2020/JS-array-find-some-every/","excerpt":"今天写 Demo 的时候突然在想 find() 与 some() 的区别是什么？ 都是为了找到数组中的内容啊？他们的区别在哪里呢 其实我在打这行字的时候就突然想起来区别是什么了😂，所以我把标题改了 相对于 some() 方法， 我知道 find() 方法会更加早一些，不知道为何，🤔明明 find() 方法才是更加新的特性( 也许因为子龙提到的因为jQuery？) 所以今天我们来聊一聊 find/findIndex/some 以及 every 这4个使用起来感觉差不多的方法。","text":"今天写 Demo 的时候突然在想 find() 与 some() 的区别是什么？ 都是为了找到数组中的内容啊？他们的区别在哪里呢 其实我在打这行字的时候就突然想起来区别是什么了😂，所以我把标题改了 相对于 some() 方法， 我知道 find() 方法会更加早一些，不知道为何，🤔明明 find() 方法才是更加新的特性( 也许因为子龙提到的因为jQuery？) 所以今天我们来聊一聊 find/findIndex/some 以及 every 这4个使用起来感觉差不多的方法。 先来说 find() 方法： find 方法会寻找数组中满足条件的第一个元素的值(返回的是整个元素的内容，并不是元素的引用)，如果没有则返回 undefined。 接着是 some() 方法： some 方法会判断数组中是否存在满足条件的元素，如果有则返回 true, 如果没有则返回 false。 这两个方法都会在遇到第一个满足条件的元素时返回并退出方法。 我个人之前一直使用 find 方法来寻找数组中是否有满足条件的元素，很多时候只是判断是否存在，并没有使用返回的元素值。也许 find 更加语义话点吧，后来知道了 findIndex 之后开始使用 findIndex。直到有天群里在谈论 filter 时，有人提了一嘴 some() 我才知道这个 ECMA 5.1 的方法 匹配全体 every() 方法 every 方法判断一个数组内的所有元素是否都满足指定条件，返回一个布尔值。 这个方法和 some 方法类似，用到的场景并不多，它会匹配全体，全体都通过时才会返回 true，如果过程中遇到一个元素没有通过条件，则将会立即退出并返回 false 最后是 findIndex() 方法 findIndex 方法返回数组中满足条件的第一个元素的下标，如果没有满足条件的元素则返回 -1。 这个简直就是 find 方法的简化版，只是返回值从匹配的元素换成元素下标，我就不说了。。 所以 在用于判断是否存在指定条件的元素时，使用 some(); 如果需要全体元素都需要满足指定条件时使用 every(); 需要寻找满足指定条件并返回元素值时使用 find(); 需要寻找满足指定条件的元素下标的时使用 findIndex(). 当然，如果你的数组子元素不是对象或者数组时可以使用 includes 和 indexOf 来判断是否存在那个元素和查找这个元素的下标，具体可以看下方附录连接。 附： Array.prototype.every() - MDN Array.prototype.find() - MDN Array.prototype.findIndex() - MDN Array.prototype.some() - MDN 数组实例的 find() 和 findIndex() - ECMAScript 6 入门 Array.prototype.indexOf() - MDN Array.prototype.includes() - MDN","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"}]},{"title":"ES6 中 Array 的 fill() 方法","slug":"JS-array-fill","date":"2020-07-20T01:05:15.000Z","updated":"2021-05-29T03:25:51.781Z","comments":true,"path":"2020/JS-array-fill/","link":"","permalink":"https://yogwang.site/2020/JS-array-fill/","excerpt":"fill 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。 最近遇到的一个坑，其实也不算是坑，只是自己没有了解清楚就在用了。 以前在业务中声明数组变量时我都是使用的 var arr = [] 来声明，这次兴起用了一次 var arr = new Array(8).fill([]) 声明并且填充内容时居然翻车了….","text":"fill 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。 最近遇到的一个坑，其实也不算是坑，只是自己没有了解清楚就在用了。 以前在业务中声明数组变量时我都是使用的 var arr = [] 来声明，这次兴起用了一次 var arr = new Array(8).fill([]) 声明并且填充内容时居然翻车了…. 先来看下使用方法 arr.fill(value[, start[, end]]) fill 方法接受三个参数 value, start 以及 end，并且返回一个修改后的数组; valut 用来填充数组元素的值, 如果不写则填充 undefined start 和 end 参数是可选的, 分别是 起始索引 和 终止索引 ，默认值分别为 0 和 this 对象的 length 属性值。 fill 方法是个可变方法, 它会改变调用它的 this 对象本身, 然后返回它, 而并不是返回一个副本 🌰🌰🌰 时间[1, 2, 3].fill(4); // [4, 4, 4] [1, 2, 3].fill(4, 1); // [1, 4, 4] [1, 2, 3].fill(4, 1, 2); // [1, 4, 3] [1, 2, 3].fill(4, 1, 1); // [1, 2, 3] [1, 2, 3].fill(4, 3); // [1, 2, 3] [1, 2, 3].fill(4, NaN, NaN); // [1, 2, 3] [1, 2, 3].fill(4, -1); // [1, 2, 4] [1, 2, 3].fill(4, -2, -1); // [1, 4, 3] [1, 2, 3].fill(4, -1, -2); // [1, 2, 3] Array(3).fill(4); // [4, 4, 4] // 还有一个MDN上的奇怪操作 [].fill.call(&#123; length: 3 &#125;, 4); // &#123;0: 4, 1: 4, 2: 4, length: 3&#125; 接下来就要提到我遇到坑了，当使用fill方法填充一个对象时，比如说: var arr = new Array(8).fill(&#123; a: 1 &#125;) // [&#123;a: 1&#125;, &#123;a: 1&#125;, &#123;a: 1&#125;, &#123;a: 1&#125;, &#123;a: 1&#125;, &#123;a: 1&#125;, &#123;a: 1&#125;, &#123;a: 1&#125;] 然后我们修改其中任意子项的属性 a，然后输出他们 arr[0].a &#x3D; 2 console.log(arr) &#x2F;&#x2F; [&#123;a: 2&#125;, &#123;a: 2&#125;, &#123;a: 2&#125;, &#123;a: 2&#125;, &#123;a: 2&#125;, &#123;a: 2&#125;, &#123;a: 2&#125;, &#123;a: 2&#125;] 可以看到他们全体都被修改了，对的，当一个对象（数组也一样）被传递给 fill 方法的时候, 填充数组的是这个对象的引用。 所以这次我自己 Debug 了3个小时都没发现的 问题 就是因为这！！ 附： Array.prototype.fill() - MDN","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"},{"name":"ECMAScript 6","slug":"ECMAScript-6","permalink":"https://yogwang.site/tags/ECMAScript-6/"}]},{"title":"NVM 的安装和使用","slug":"nvm-install-use","date":"2020-07-15T08:40:22.000Z","updated":"2021-05-29T03:32:16.921Z","comments":true,"path":"2020/nvm-install-use/","link":"","permalink":"https://yogwang.site/2020/nvm-install-use/","excerpt":"今天后端同学那边遇到了一个问题，那边跑一个react项目，npm install 直接报错，但是在我这边并没有报异常，后来发现他的 NPM 版本为 3.10.10， 我猜测是 NPM 版本太低的缘故，就顺便看了下 Node 的版本，版本是 v6.10.0, 所以直接给他更新了 NodeJS，正当我以为问题解决了的时候，后端同学又和我说，现在的项目可以跑起来了，但是之前的项目他跑不起来了。 emmmm…..我又过去看了下报错信息，这会问题是 Node 给我更新掉了，版本太高项目跑不起来了….所以，有了这篇关于 Node Version Manager (NVM) for Windows 的文章","text":"今天后端同学那边遇到了一个问题，那边跑一个react项目，npm install 直接报错，但是在我这边并没有报异常，后来发现他的 NPM 版本为 3.10.10， 我猜测是 NPM 版本太低的缘故，就顺便看了下 Node 的版本，版本是 v6.10.0, 所以直接给他更新了 NodeJS，正当我以为问题解决了的时候，后端同学又和我说，现在的项目可以跑起来了，但是之前的项目他跑不起来了。 emmmm…..我又过去看了下报错信息，这会问题是 Node 给我更新掉了，版本太高项目跑不起来了….所以，有了这篇关于 Node Version Manager (NVM) for Windows 的文章 安装NVM 安装很简单，直接去Github上边找 nvm-windows 的 releases，直接下载最新那版的zip就可以了。有免安装和安装版可以选择(我选择了安装版)。 安装过程中选择一下 NVM 安装目录以及之后 NodeJS 的管理目录。 之前有安装 NodeJS 记得指定到之前安装的目录下，就可以使用 NVM 管理之前安装的Node版本了。如果是NodeJS使用的是绿色版的话，之后可能需要使用NVM 重新下载安装。 然后就等待安装完成就可以了。完成之后在终端输入 nvm 检查版本确认是否安装成功(当前版本1.1.7) 常用命令 查看 NVM 下已经安装的 Node 版本号显示当前已安装 Node 版本列表，缩写为 ls， 当前使用的版本会在前标识 * ，在末尾加上 available 显示可供下载的所有版本列表 PS C:\\Users\\yog\\Desktop&gt; nvm list &#x2F;&#x2F; 简写为 nvm ls 14.5.0 * 12.12.0 (Currently using 64-bit executable) 切换到指定的 Node 版本 nvm use [version] [arch] 一般先使用 nvm ls 输出已经安装的版本，然后再根据可选项切换版本。 PS C:\\Users\\yog\\Desktop&gt; nvm use 12.12.0 &#x2F;&#x2F; 具体版本号 Now using node v12.12.0 (64-bit) 设置 [arch] 可指定 32/64位结构。如果不填版本号只填写 32( nvm use 32 )将继续使用当前Node版本，只切换到32位模式。 安装指定版本的Node nvm install &lt;version&gt; [arch] &lt;version&gt; 可以是 具体版本号 也可以是 latest 来安装最新的 稳定 版本，[arch] 指定安装 32位 还是 64位 版本（默认为系统结构）， 设置为 all 以同时安装32和64位版本。 PS C:\\Users\\yog\\Desktop&gt; nvm install 6.10.0 Downloading node.js version 6.10.0 (64-bit)... Complete Downloading npm version 3.10.10... Complete Installing npm v3.10.10... Installation complete. If you want to use this version, type nvm use 6.10.0 也可以在末尾添加 --insecure 可以绕过远程下载服务器的SSL验证。 卸载指定Node版本 nvm uninstall &lt;version&gt; PS C:\\Users\\yog\\Desktop&gt; nvm uninstall 6.10.0 Uninstalling node v6.10.0... done 查看所有可安装的Node版本PS C:\\Users\\yog\\Desktop&gt; nvm ls available | CURRENT | LTS | OLD STABLE | OLD UNSTABLE | |--------------|--------------|--------------|--------------| | 14.7.0 | 12.18.3 | 0.12.18 | 0.11.16 | | 14.6.0 | 12.18.2 | 0.12.17 | 0.11.15 | | 14.5.0 | 12.18.1 | 0.12.16 | 0.11.14 | | 14.4.0 | 12.18.0 | 0.12.15 | 0.11.13 | | 14.3.0 | 12.17.0 | 0.12.14 | 0.11.12 | | 14.2.0 | 12.16.3 | 0.12.13 | 0.11.11 | | 14.1.0 | 12.16.2 | 0.12.12 | 0.11.10 | | 14.0.0 | 12.16.1 | 0.12.11 | 0.11.9 | | 13.14.0 | 12.16.0 | 0.12.10 | 0.11.8 | | 13.13.0 | 12.15.0 | 0.12.9 | 0.11.7 | | 13.12.0 | 12.14.1 | 0.12.8 | 0.11.6 | | 13.11.0 | 12.14.0 | 0.12.7 | 0.11.5 | | 13.10.1 | 12.13.1 | 0.12.6 | 0.11.4 | | 13.10.0 | 12.13.0 | 0.12.5 | 0.11.3 | | 13.9.0 | 10.22.0 | 0.12.4 | 0.11.2 | | 13.8.0 | 10.21.0 | 0.12.3 | 0.11.1 | | 13.7.0 | 10.20.1 | 0.12.2 | 0.11.0 | | 13.6.0 | 10.20.0 | 0.12.1 | 0.9.12 | | 13.5.0 | 10.19.0 | 0.12.0 | 0.9.11 | | 13.4.0 | 10.18.1 | 0.10.48 | 0.9.10 | This is a partial list. For a complete list, visit https:&#x2F;&#x2F;nodejs.org&#x2F;download&#x2F;release 其它命令 nvm arch 查看 Node 当前运行32位还是64位模式。 nvm on 开启 NVM 版本管理. nvm off 关闭 NVM 版本管理. nvm proxy [url] 设置用于下载的代理。将 [url] 留空查看当前设置的代理，将 [url] 设置为 “none” 来删除代理。 nvm node_mirror [url] 设置节点镜像。默认为 https://nodejs.org/dist/，将 [url] 留空 以使用 默认url nvm npm_mirror [url] 设置 NPM 镜像。默认为 https://github.com/npm/cli/archive/，将 [url] 留空 保留为 默认url。 nvm root [path] 设置 NVM 不同版本的 Node.js 的存储目录，如果 [path] 留空，将显示当前设置的存储目录。 nvm version 显示当前 NVM 运行版本。 缩写 v。 遇到的问题安装完成之后使用 nvm ls 没有看到之前已经安装的NodeJS版本我在使用的过程中没有遇到这个问题，但是同事在安装之后遇到了，这个问题。有可能是因为安装时指定的Node目录错误了，可以卸载之前安装的 NodeJS，然后使用 nvm install &lt;version&gt; 重新安装对应版本的 NodeJS 切换版本之后全局依赖丢失今天小伙伴问题，切换了新版本之后他以前安装的全局依赖都没了，又要重新安装，然后切换到老版本之后和新安装的全局依赖版本还不一样，问我怎么解决的。 这个问题，是因为切换了版本之后其实是切换软链接路径，然后你又重新配置过依赖项安装位置了，比如指向到了NodsJs目录下，所以现在指向到的是新的NodeJs下的目录，肯定目录下就没有老的全局依赖了。所以重新切换到外部就好了，比如说我是在 NVM 目录下新建一个 dependencies 文件夹，然后重新 npm set prefix 到这个目录就好了，和以前切换npm安装路径一样，记得也同时修改一下缓存位置。对了，最后记得修改系统的环境变量，分别在用户变量和系统变量的 path 中，只不过我是单独配置了一个 prefix 项，所以就不展示了。 附 nvm-windows - Github","categories":[{"name":"工作延伸","slug":"工作延伸","permalink":"https://yogwang.site/categories/%E5%B7%A5%E4%BD%9C%E5%BB%B6%E4%BC%B8/"}],"tags":[{"name":"NVM","slug":"NVM","permalink":"https://yogwang.site/tags/NVM/"}]},{"title":"简单实现滑动滑块完成验证","slug":"JS-slider-captcha","date":"2020-07-08T01:40:50.000Z","updated":"2021-05-29T03:25:23.703Z","comments":true,"path":"2020/JS-slider-captcha/","link":"","permalink":"https://yogwang.site/2020/JS-slider-captcha/","excerpt":"偶尔会遇到PM提的需求，要加入滑动验证，但是不想使用付费的第三方验证，想就在前端实现滑块验证即可(zuò zuò yàng zi)，这一段时间遇到两次要求加滑动验证了，就整理一下构思和部分伪代码逻辑。 本例只是一个面子工程，不会牵扯到复杂的人机验证部分，所以如果需要考虑人机校验，还是推荐你选择靠谱的第三方行为验证，不要自己瞎折腾。","text":"偶尔会遇到PM提的需求，要加入滑动验证，但是不想使用付费的第三方验证，想就在前端实现滑块验证即可(zuò zuò yàng zi)，这一段时间遇到两次要求加滑动验证了，就整理一下构思和部分伪代码逻辑。 本例只是一个面子工程，不会牵扯到复杂的人机验证部分，所以如果需要考虑人机校验，还是推荐你选择靠谱的第三方行为验证，不要自己瞎折腾。 主要使用的是 mousedown, mouseup 和 mousemove 这三个事件的事件绑定。如果考虑移动端需要使用 touchstart,touchend 和 touchmove 这三个事件，需要根据设备选择绑定的事件。目前的项目只考虑桌面设备所以直接就省去判断设备这个步骤。 先简单预览一下： 布局及样式好，首先拆分元素，整体可以拆分为两个部分：1. 滑动验证的容器 和 2. 滑块两个部分 容器部分可以继续拆分为 i. 外部容器 和 ii. 内部的文字 两块。 所以布局方面可以这样来写 &lt;div class=\"slider-captcha\"> &lt;div class=\"slider\"> &lt;i class=\"double-right\" /> &lt;/div> &lt;div class=\"msg\">请按住滑块拖动到最右边，获取验证码&lt;/div> &lt;/div> 先简单实现样式 .slider-captcha&#123; width: 400px; height: 50px; border: 1px solid #ECEBED; border-radius: 5px; position: relative; &#125; .slider&#123; width: 60px; height: @height; line-height: @height; text-align: center; font-size: 20px; color: white; background: #55CEA7; border-radius: 5px; position: absolute; left: 0; /* 因为滑块是第一个子元素所以 top 可以省略不写 */ z-index: 2; cursor: pointer; box-sizing: border-box; &#125; .msg&#123; height: @height; line-height: @height; text-align: center; font-size: 13px; color: #A1ACC6; pointer-events: none; user-select: none; box-sizing: border-box; &#125; 完成预览： 接下来我会使用到 VueJS，希望你有使用 Vue。如果你没有使用过 Vue，直接看 methods 里边的函数也可以 先把 HTML 模板改成 Vue 模板 &lt;template> &lt;div class=\"slider-captcha\" ref=\"container\"> &lt;div :class=\"['slider', success&amp;&amp;'success']\" ref=\"slider\" :style=\"&#123;left: `$&#123;vX&#125;px`&#125;\"> &lt;a-icon type=\"double-right\" v-if=\"!success\" /> &lt;/div> &lt;div :class=\"['msg', success&amp;&amp;'success']\"> &#123;&#123; msg &#125;&#125; &lt;/div> &lt;/div> &lt;/template> &lt;script> export default &#123; name: 'slider-captcha', data() &#123; return &#123; vX: 0, maxX: 0, msg:'请按住滑块拖动到最右边，获取验证码', success: false, moveing: false &#125; &#125; &#125; &lt;/script> &lt;style lang=\"stylus\" scoped> $green = #55CEA7 .slider-captcha width 100% height 50px border 1px solid #ECEBED border-radius 5px position relative .msg height 100% color #A1ACC6 display flex justify-content center align-items center transition color 1s ease pointer-events none user-select none box-sizing border-box &amp;.success color white background $green .slider width 60px height 100% font-size 20px color white text-align center background $green border-radius 5px display flex position absolute left 0 z-index 2 cursor pointer transition background 1s ease box-sizing border-box &amp;.success display none &lt;/style> 简单滑动逻辑这个时候就要用到 mousedown 和 mousemove 两个事件的绑定， 最后才用到 mouseup 事件。 有点忙， 看啥时候有空再补完，还需要调整一下排版","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"},{"name":"挖坑","slug":"挖坑","permalink":"https://yogwang.site/tags/%E6%8C%96%E5%9D%91/"}]},{"title":"Caddy单域名部署Vue与Laravel项目","slug":"caddy-single-domain-vue-laravel-deployment","date":"2020-06-23T06:16:12.000Z","updated":"2021-05-29T03:30:41.965Z","comments":true,"path":"2020/caddy-single-domain-vue-laravel-deployment/","link":"","permalink":"https://yogwang.site/2020/caddy-single-domain-vue-laravel-deployment/","excerpt":"之前是想写一篇 Nginx 关于配置前后端项目公用一个域名笔记的，可是后来客户提供的是已经是由其它项目的服务器，他们是使用的 Caddy 作为 web 服务器，所以也就变成了这篇文章。 我对于服务器环境配置可以说是一无所知，勉勉强强完成这次的项目部署，各位将就看看…😖","text":"之前是想写一篇 Nginx 关于配置前后端项目公用一个域名笔记的，可是后来客户提供的是已经是由其它项目的服务器，他们是使用的 Caddy 作为 web 服务器，所以也就变成了这篇文章。 我对于服务器环境配置可以说是一无所知，勉勉强强完成这次的项目部署，各位将就看看…😖 使用两个二级域名一个顶级域名可以创建很多个二级域名，所以使用两个二级域名就很容易配置了，直接创建两个服务就可以，但是会跨域，因为是不同二级域名，后端单独做一下跨域允许就可以了。 # Vue https:&#x2F;&#x2F;www.example.com &#123; root &#x2F;var&#x2F;www&#x2F;vue log &#x2F;var&#x2F;log&#x2F;caddy&#x2F;fe.log errors &#x2F;var&#x2F;log&#x2F;caddy&#x2F;fe.errors.log gzip rewrite &#123; to &#123;path&#125; &#x2F; &#125; &#125; # Laravel https:&#x2F;&#x2F;api.example.com &#123; root &#x2F;var&#x2F;www&#x2F;laravel&#x2F;public log &#x2F;var&#x2F;log&#x2F;caddy&#x2F;bk.log errors &#x2F;var&#x2F;log&#x2F;caddy&#x2F;bk.errors.log gzip # PHP-FPM Configuration for Caddy fastcgi &#x2F; &#x2F;run&#x2F;php&#x2F;php7.2-fpm.sock php &#123; ext .php split .php index index.php &#125; rewrite &#123; to &#123;path&#125; &#123;path&#125;&#x2F; &#x2F;index.php?&#123;query&#125; &#125; &#125; 使用同一个域名方法一：使用同一域名然后不同路径作为站点地址：我使用 https://www.example.com/ 作为 Vue 项目的地址；https://www.example.com/api 作为 laravel 项目的站点地址。配置如下 # Vue https:&#x2F;&#x2F;www.example.com &#123; root &#x2F;var&#x2F;www&#x2F;vue log &#x2F;var&#x2F;log&#x2F;caddy&#x2F;fe.log errors &#x2F;var&#x2F;log&#x2F;caddy&#x2F;fe.errors.log gzip rewrite &#123; to &#123;path&#125; &#x2F; &#125; &#125; # Laravel https:&#x2F;&#x2F;www.example.com&#x2F;v&#x2F; &#123; root &#x2F;var&#x2F;www&#x2F;laravel&#x2F;public log &#x2F;var&#x2F;log&#x2F;caddy&#x2F;bk.log errors &#x2F;var&#x2F;log&#x2F;caddy&#x2F;bk.errors.log gzip # PHP-FPM Configuration for Caddy fastcgi &#x2F; &#x2F;run&#x2F;php&#x2F;php7.2-fpm.sock php &#123; ext .php split .php index index.php &#125; rewrite &#123; to &#123;path&#125; &#123;path&#125;&#x2F; &#x2F;index.php?&#123;query&#125; &#125; &#125; 这个时候访问的地址，后台可以接收到，但是在路由表中找不到对应信息，因为 laravel 部分把 /api 作为路由前缀，修改一下就可以了，例如 https://www.example.com/v ，前端请求的时候使用 /v/api 这个地址 方法二：使用一个域名作为 Vue 项目站点地址，api接口使用重定向这个方法我还没有在Caddy尝试，Nginx倒是知道，等以后尝试看看 遇到问题 配置完之后访问 laravel 提示 [ file not found ]一般来说遇到这个问题的同时，可以在日志文件中查看到 Primary script unknown 的异常，这个问题是由于配置的目录没有写入权限，如果已经配置了写入权限，请确保在 同一用户/组 下运行 Caddy 和php-fpm 如果 Vue 项目需要启用 History 路由模式怎么配置Caddy ?当使用 history 模式时，URL 就像正常的 url，例如 http://yoursite.com/user/id，不过这种模式还需要后台配置支持。因为应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问 http://oursite.com/user/id 就会返回 404，所以需要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面 rewrite &#123; regexp .* to &#123;path&#125; &#x2F; &#125; 附 Caddy_v1 官方文档 Caddy 中文文档 Primary script unknown - Caddy FORUM HTML5 History 模式 - Vue Router","categories":[{"name":"工作延伸","slug":"工作延伸","permalink":"https://yogwang.site/categories/%E5%B7%A5%E4%BD%9C%E5%BB%B6%E4%BC%B8/"}],"tags":[{"name":"挖坑","slug":"挖坑","permalink":"https://yogwang.site/tags/%E6%8C%96%E5%9D%91/"},{"name":"Caddy","slug":"Caddy","permalink":"https://yogwang.site/tags/Caddy/"}]},{"title":"记录单独配置内网路由和外网路由的办法","slug":"intranet-and-extranet-routes","date":"2020-06-22T03:04:47.000Z","updated":"2021-08-05T08:58:39.914Z","comments":true,"path":"2020/intranet-and-extranet-routes/","link":"","permalink":"https://yogwang.site/2020/intranet-and-extranet-routes/","excerpt":"由于公司刚刚搬迁，本地服务器还没有连上网络，所以并不能在外网访问到公司的服务器，只能使用局域网访问到。所以想连接手机热点来连外网，并且通过插网线来访问内网，想实现同时访问外网和内网的效果。 单独连热点或者单独连内网都是可以的，但是同时就不行了，会默认使用本地连接也就是插的网线来访问网络，所以只能从一下选择其中一个： 可以访问外网，但是不能访问内部服务器； 不可以访问内网，但可以使用内网服务器。 然而每次都要切换网络来完成需求，我觉得有点蠢，肯定有更加优雅的方式来实现的需求。 所以就记一下这个办法。","text":"由于公司刚刚搬迁，本地服务器还没有连上网络，所以并不能在外网访问到公司的服务器，只能使用局域网访问到。所以想连接手机热点来连外网，并且通过插网线来访问内网，想实现同时访问外网和内网的效果。 单独连热点或者单独连内网都是可以的，但是同时就不行了，会默认使用本地连接也就是插的网线来访问网络，所以只能从一下选择其中一个： 可以访问外网，但是不能访问内部服务器； 不可以访问内网，但可以使用内网服务器。 然而每次都要切换网络来完成需求，我觉得有点蠢，肯定有更加优雅的方式来实现的需求。 所以就记一下这个办法。 我们 使用管理员权限 打开终端 CMD。在终端中输入 route print 我们获得以下信息： 可以看到路由表中有两个 0.0.0.0 的路由信息 并且跃点数也是一样的都是 35，这样会路由冲突，只能使用其中一个。 我们重新配置一下路由信息就可以了，这个时候我们把两个冲突的路由信息复制出来，如果你不嫌麻烦的话上下翻也可以，重新打开一个新的终端也行。 先把两个 0.0.0.0 路由删掉route delete 0.0.0.0 添加外网路由信息这里就需要用到之前复制出来的路由信息了，不过只要网关信息 route add 0.0.0.0 mask 0.0.0.0 192.168.200.1 添加内网路由信息这里也需要用到之前复制出来的路由信息，网关 以及 网络掩码（网络掩码这部分一般都是 255.255.255.0 如果不确定的话联系一下网管就可以了） route add 192.168.1.0 mask 255.255.255.0 192.168.1.1 重新查看路由信息，看到新的路由配置已经被加上了 不过中间我看到 192.168.1.0 出现了两次，并且配置信息是一样的，是不是我这边本来就有这个路由信息的，所以我又把后来添加的信息去掉了。 各位添加的时候注意检查一下原来的路由表里边是否已经有内网的路由信息了。 因为是临时网络没有通，所以我就不加永久路由，每天手动调整一下路由就行，如果你这边是固定的内网有网络限制的话，可以在 route 之后添加 -p 就可以实现永久路由了。 route -p add 192.168.1.0 mask 255.255.255.0 192.168.1.1 以上","categories":[{"name":"工作延伸","slug":"工作延伸","permalink":"https://yogwang.site/categories/%E5%B7%A5%E4%BD%9C%E5%BB%B6%E4%BC%B8/"}],"tags":[]},{"title":"谈一谈 JavaScript 中的闭包","slug":"JS-closures","date":"2020-06-15T09:56:21.000Z","updated":"2021-05-29T03:25:46.845Z","comments":true,"path":"2020/JS-closures/","link":"","permalink":"https://yogwang.site/2020/JS-closures/","excerpt":"函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起构成闭包（closure）。也就是说，闭包可以让你从内部函数访问外部函数作用域。在 JavaScript 中，每当函数被创建，就会在函数生成时生成闭包。 先拿 MDN 上的一个简单的 🌰 来说： function init() &#123; var name = \"Mozilla\"; // name 是一个被 init 创建的局部变量 function displayName() &#123; // displayName() 是内部函数，一个闭包 alert(name); // 使用了父函数中声明的变量 &#125; displayName(); &#125; init(); init() 创建了一个局部变量 name 和一个名为 displayName() 的函数。displayName() 是定义在 init() 里的内部函数（仅在 init() 函数体内可用），它没有自己的局部变量，然而它可以访问到外部函数的变量，所以 displayName() 可以使用父函数 init() 中声明的变量 name 。","text":"函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起构成闭包（closure）。也就是说，闭包可以让你从内部函数访问外部函数作用域。在 JavaScript 中，每当函数被创建，就会在函数生成时生成闭包。 先拿 MDN 上的一个简单的 🌰 来说： function init() &#123; var name = \"Mozilla\"; // name 是一个被 init 创建的局部变量 function displayName() &#123; // displayName() 是内部函数，一个闭包 alert(name); // 使用了父函数中声明的变量 &#125; displayName(); &#125; init(); init() 创建了一个局部变量 name 和一个名为 displayName() 的函数。displayName() 是定义在 init() 里的内部函数（仅在 init() 函数体内可用），它没有自己的局部变量，然而它可以访问到外部函数的变量，所以 displayName() 可以使用父函数 init() 中声明的变量 name 。 这个就是最简单的一个闭包实现。 不过要了解闭包，就得先了解 JavaScript 变量的作用域，变量的作用域分为 全局变量 和 局部变量例如全局变量 var a='test' function fn()&#123; console.log(a) &#125; fn() // test 全局变量可以在函数内使用，函数内部的变量就不可以在函数外部被调用了 function fn()&#123; var a = 'test' &#125; console.log(a) // Uncaught ReferenceError: a is not defined 在函数内部可以使用在外部函数内声明的变量，例如文章开头提到的例子，并且每次函数被执行是在内存里都会开辟一个新的区块，所以每次一执行的函数并不是指向同一个内存地址。 但是有些时候我们需要在函数外部调用这个函数内的局部变量。 这就是Javascript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。 既然内部函数可以读取 外部函数 中的 局部变量，那么只要 内部函数 作为 返回值，我们不就可以在函数外部读取它的 内部变量 了吗！ 的确，大都数情况我们都是在 函数内部定义一个函数，并且把这个内部函数 return 出来，从而来达到目的。 🌰 例如这个例子 function makeAdder(x) &#123; return function(y) &#123; return x + y; &#125;; &#125; var add5 = makeAdder(5); var add10 = makeAdder(10); console.log(add5(2)); // 7 console.log(add10(2)); // 12 上方的例子就可以看到在把 内部函数 赋值给 外部变量 之后，可以继续在之前的运行结果之上进行加运算。 当然也可以修改被调用的外部函数变量，例如这个累加的例子： function makeAdder(x) &#123; var x = x return function(y) &#123; x += y return x; &#125;; &#125; var add5 = makeAdder(5); var add10 = makeAdder(10); console.log(add5(5)); // 10 console.log(add5(10)); // 20 console.log(add10(5)); // 15 console.log(add10(10)); // 25 一句话形容闭包 由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。 所以，在本质上，闭包就是将 函数内部 和 函数外部 连接起来的一座桥梁。 闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。 ES6 普及之后真的很少有使用到闭包了，const 和 let 的出现方便了太多了。 最后给你们看一个 阮一峰 老师文章里边的例子，乍一看 nAdd() 我懵了半分钟。function f1()&#123; var n=999; nAdd=function()&#123;n+=1&#125; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 nAdd(); result(); // 1000 遇到的疑问 闭包是否一定要被外部变量保存（保持被引用） 并不是只有被外部变量引用的子函数叫做闭包，没有内存地址没有被保持引用的函数也可以是闭包； 因此可以把闭包简单理解成”定义在一个函数内部的函数”。 引发问题：变量提升，到底会被提升到哪里？ 以前一直以为 变量提升 会把使用 var 声明的变量提升到全局环境下。但是这次再写demo的时候发现原来是提升当前函数的顶部，并不是到全局下的。 function a()&#123; function b()&#123; console.log(str) &#125; var str='test text' &#125; 在 变量提升 下可以这样理解 function a()&#123; var str function b()&#123; console.log(str) &#125; str='test text' &#125; 附 闭包 - MDN 学习闭包 - 阮一峰 关于let声明的变量在window里无法获取到的问题","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"}]},{"title":"DigitalOcean向已经创建的Droplets实例添加SSH_key","slug":"digitalocean-created-droplets-add-ssh-key","date":"2020-06-13T17:23:22.000Z","updated":"2021-08-04T01:42:03.794Z","comments":true,"path":"2020/digitalocean-created-droplets-add-ssh-key/","link":"","permalink":"https://yogwang.site/2020/digitalocean-created-droplets-add-ssh-key/","excerpt":"几近一周没有好好写过代码了，就准备远程配置一下客户服务器的环境。 这次客户邀请我加入了他们 DigitalOcean 的 Team 中，但是他们不想提供 Droplet 实例 Root 密码， 看了一下控制台大概找到了一个添加 SSH_Key 登陆的地方，所以使用了 PuTTYGen 创建了一对 Key，但是添加之后使用 SSH 连接时提示我: 远程服务器拒绝此密钥，让我重新输入Root账户的密码。 大概找了一下国内的相关问题并没有找到解决的方法，Google 出来也差不多，基本都是添加 Key 之后，需要创建新的实例才可以使用新添加的 Key。那我需要对 已经创建了的 Droplet 实例 添加 Key 怎么办呢？ 相信大家在搜索该问题时已经添加好了自己的 SSH Key，具体添加创建 key 的过程我就不详述了，大家在官方 文档 中查找即可。","text":"几近一周没有好好写过代码了，就准备远程配置一下客户服务器的环境。 这次客户邀请我加入了他们 DigitalOcean 的 Team 中，但是他们不想提供 Droplet 实例 Root 密码， 看了一下控制台大概找到了一个添加 SSH_Key 登陆的地方，所以使用了 PuTTYGen 创建了一对 Key，但是添加之后使用 SSH 连接时提示我: 远程服务器拒绝此密钥，让我重新输入Root账户的密码。 大概找了一下国内的相关问题并没有找到解决的方法，Google 出来也差不多，基本都是添加 Key 之后，需要创建新的实例才可以使用新添加的 Key。那我需要对 已经创建了的 Droplet 实例 添加 Key 怎么办呢？ 相信大家在搜索该问题时已经添加好了自己的 SSH Key，具体添加创建 key 的过程我就不详述了，大家在官方 文档 中查找即可。 也可以在文末 附 中直接点击链接查看详细文档。 那么我就直接开始描述我是如何对已经创建的实例使用新增加的 Key。方法应该并不只有这一种，如果有其它更好的方式可以留言给我。 1.打开网页终端这步应该不用说了吧，打开终端之后切换到 ~/.ssh 目录下，查看一下目录下文件 root@test:&#x2F;# cd ~&#x2F;.ssh root@test:~&#x2F;.ssh# ls authorized_keys id_rsa id_rsa.pub know_hosts 可以看到有一个名为 authorized_keys 的文件，这个我不知道是不是本来就有，我这边因为客户已经关联过一个 key 了所以是有这个文件。然后你使用 vi 或者 nano 打开这个 authorized_keys 文件。 2. 添加你的公钥到文件中我希望你没有把之前创建Key的公钥给丢了，不过找不到了也没有关系，回到 DigitalOcean 的控制台在 Account -&gt; Settings -&gt; Security -&gt; SSH keys 中找到你添加的 Key 然后点击编辑就可以看到你添加的公钥了。 把公钥复制一下，粘贴进去保存就可以了。 在粘贴的过程中遇到了粘贴进来的公钥出现转码的情况:这是因为复制的密钥太长了，控制的一下每次粘贴内容长度，分段粘贴过来就好了。 然后就可以使用 SSH 远程连接到服务器上了（具体连接步骤查看下方 附 中查看详细文档）。 以上。 附参考资源链接 使用PuTTY创建Key - Create Keys with PuTTY 使用OpenSSH创建Key - Create Keys with OpenSSH 添加Key到DO账户 - Add Keys to a DO Account 使用SSH连接到服务器 - Connect with SSH 相关类似问题 How do I add a second SSH key to droplet? Additional SSH Key not working","categories":[{"name":"工作延伸","slug":"工作延伸","permalink":"https://yogwang.site/categories/%E5%B7%A5%E4%BD%9C%E5%BB%B6%E4%BC%B8/"}],"tags":[{"name":"Server","slug":"Server","permalink":"https://yogwang.site/tags/Server/"},{"name":"DigitalOcean","slug":"DigitalOcean","permalink":"https://yogwang.site/tags/DigitalOcean/"}]},{"title":"Jeecg-boot 开发挖坑日记11 查询过滤器整理","slug":"jeecg-boot-devDiary11","date":"2020-06-02T06:31:26.000Z","updated":"2021-05-29T03:26:00.795Z","comments":true,"path":"2020/jeecg-boot-devDiary11/","link":"","permalink":"https://yogwang.site/2020/jeecg-boot-devDiary11/","excerpt":"如果不配置默认查询条件是全匹配，想实现模糊查询需求在查询值的前后加: * Jeecg-boot支持不编码通过配置实现 模糊查询、 匹配查询、 范围查询、 不匹配查询 等规则，但是页面查询字段，需跟后台 Controller 中 Page 的字段对应一致，就可以不需写后台代码自动生成查询条件SQL。 例如：想实现模糊查询需求在查询值的前后加: *","text":"如果不配置默认查询条件是全匹配，想实现模糊查询需求在查询值的前后加: * Jeecg-boot支持不编码通过配置实现 模糊查询、 匹配查询、 范围查询、 不匹配查询 等规则，但是页面查询字段，需跟后台 Controller 中 Page 的字段对应一致，就可以不需写后台代码自动生成查询条件SQL。 例如：想实现模糊查询需求在查询值的前后加: * 查询规则1、全匹配查询：查询数据没有特殊格式，默认为全匹配查询 2、模糊查询：查询数据格式需加星号：{ * } 后模糊匹配： 张* 前模糊匹配： *张 全模糊匹配： *张* 更高级匹配： *张*三* 3、包含查询：查询数据格式采用逗号分隔：{ , } 例如：张三,李四 (含义：In(&#39;张三&#39;,&#39;李四&#39;)) 4、不匹配查询：查询数据格式需要加叹号前缀：{ ! }例如：!张三 （含义：不等于’张三’） 特殊说明： 查询不为Null的语法：!null （大小写没关系）; 查询不为空字符串的方法：! （只有一个叹号）; 5、范围查询支持数字，时间的范围查询，针对范围查询页面会生成两个查询控件 如果是单一匹配方式，则页面查询控件的 name， 跟实体字段命名一样 如果是范围匹配方式，则页面查询控件需要变成两个分别名 &#123;*&#125;_begin，&#123;*&#125;_end &#123;*&#125;_begin 表示查询范围开始值 &#123;*&#125;_end 表示查询范围结束值 举例： 字段名称 orderDate 查询开始时间 : orderDate_begin 查询结束时间 : orderDate_end 注意部分 数值类型不支持此种 取非查询 ,可以将数值字段定义为字符串类型的在查询； 数字类型字段多值查询，需要将字段加上后缀 _MultiString，其他规则同理； 因为后端的实体字段也需要增加后缀，例如：实体类中为： tableType，页面接受参数字段就是 tableType_MultiString 高级值规则 小于查询：查询内容值规则：”lt+ 空格 + 内容”;🌰：输入值：lt 100 小于等于查询： 查询内容值规则：”le+ 空格+ 内容”;🌰：输入值：le 100 大于查询：查询内容值规则：”gt+ 空格+ 内容”;🌰：输入值：gt 100 大于等于查询： 查询内容值规则：”ge+ 空格+ 内容”;🌰：输入值：ge 100 高级规则暂时发现不能在 integer 类型中使用，加上 _MultiString 虽然不会报错了，但是返回的数据错误。 后端小哥和我说虽然你这边不报错并且又返回值，但是他那边报错了。 自定义排序额外传入两个字段即可： column: 排序依据字段 order: 排序方式 [asc|desc] (默认asc) 文章所使用后端框架版本 v2.2.0 (发布日期：2020-05-06）不知道后续开发团队会不会更新说明文档。 附 查询过滤器用法 · Jeecg-boot 开发文档 Online报表排序 · Jeecg-boot 开发文档 因为查询过滤器已经重构多次，版本最好 2.2.0 以上，2.1.x 的版本只有 范围查询, 1.x 版本只有全匹配/模糊查询/包含查询/不匹配查询","categories":[{"name":"踩坑日记","slug":"踩坑日记","permalink":"https://yogwang.site/categories/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"挖坑","slug":"挖坑","permalink":"https://yogwang.site/tags/%E6%8C%96%E5%9D%91/"},{"name":"Jeecg-boot","slug":"Jeecg-boot","permalink":"https://yogwang.site/tags/Jeecg-boot/"}]},{"title":"关于 ES6 Class 继承中 Constructor 的整理","slug":"JS-class-constructor","date":"2020-05-26T03:14:27.000Z","updated":"2021-05-29T03:25:48.111Z","comments":true,"path":"2020/JS-class-constructor/","link":"","permalink":"https://yogwang.site/2020/JS-class-constructor/","excerpt":"今天在和小伙伴聊天时, 发现对于 ES6 中的 Class 继承的理解我其实还是只是一个模棱两可的状态, 其实也不只是 constructor 有问题其它的部分其实也有问题, 这次先写类的继承之后再看有没有其它没理解的地方 整篇文章搭配食用 阮一峰老师的 ECMAScript 6 入门 - Class的继承 更佳 Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。","text":"今天在和小伙伴聊天时, 发现对于 ES6 中的 Class 继承的理解我其实还是只是一个模棱两可的状态, 其实也不只是 constructor 有问题其它的部分其实也有问题, 这次先写类的继承之后再看有没有其它没理解的地方 整篇文章搭配食用 阮一峰老师的 ECMAScript 6 入门 - Class的继承 更佳 Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。 Constructor 方法首先, 在继承的类中 constructor 可以省略不写(会被默认添加) class A &#123; echo () &#123; console.log('Hi!') &#125; &#125; class B extends A &#123; &#125; let b = new B b.echo() // Hi! 但是如果写了 constructor 就必须要在内部调用 super() , 否则在创建实例的过程中会报错 class A &#123; echo () &#123; console.log('Hi!') &#125; &#125; class B extends A &#123; constructor() &#123; &#125; &#125; let b = new B b.echo() // ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor 从提示中就能看到, 必须调用 super() 才能完成塑造 阮一峰: 这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。 从阮一峰老师的解释中也可以得出, 如果要在继承类中使用 this 就必须要先使用 super(), 那么对应的属性声明也需要放到 super() 之后才行: class A &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; &#125; class B extends A &#123; constructor(x, y, z) &#123; this.z = z; // ReferenceError super(x, y); this.z = z; // Success &#125; &#125; let b = new B 注意，super() 虽然代表了父类A的构造函数，但是返回的是子类B的实例，即 super() 内部的 this 指的是B的实例，因此 super() 在这里相当于 A.prototype.constructor.call(this)。 super 关键字除了在 constructor 中被当作父类的构造函数使用( super() ),也可以当成对象( super )使用, 指向父类的原型对象, 相当于 A.prototype, 但是在静态方法中 super 之中指向于父类 class A &#123;&#125; A.prototype.x = 2; class B extends A &#123; constructor() &#123; super(); console.log(super.x) // 2 &#125; &#125; let b = new B(); 这里需要注意，由于 super 指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过 super 调用的。class A &#123; constructor() &#123; this.x = 1; &#125; &#125; class B extends A &#123; constructor() &#123; super(); this.x = 2; super.x = 3; console.log(super.x); // undefined console.log(this.x); // 3 &#125; &#125; let b = new B(); 另外 ES6 规定，在子类普通方法中通过 super 调用父类的方法时，方法内部的 this 指向当前的子类实例。 所以通过 super 修改的是当前子类实例的属性,父类的属性并不会被修改 class A &#123; &#125; A.prototype.x = 2; class B extends A &#123; constructor() &#123; super(); super.x = 3; console.log(super.x); // 2 console.log(this.x); // 3 &#125; &#125; let b = new B(); console.log(A.prototype.x) // 2 静态方法中的 super虽然静态方法中的 super 就是按照字面的理解就行, 但是可能对于不是特别熟悉 Class 的朋友来说, 还是会有一点迷糊.那么就还是用阮一峰老师的例子来说 如果对于静态方法还不是特别清楚的, 请先阅读阮一峰老师的 ES6 入门 - Class 章节 class Parent &#123; static myMethod(msg) &#123; console.log('static', msg); &#125; myMethod(msg) &#123; console.log('instance', msg); &#125; &#125; class Child extends Parent &#123; static myMethod(msg) &#123; super.myMethod(msg); &#125; myMethod(msg) &#123; super.myMethod(msg); &#125; &#125; Child.myMethod(1); // static 1 let child = new Child(); child.myMethod(2); // instance 2 以上这个例子中, Child.myMethod(1) 是调用的调用的是 Child 类的静态方法 static, 在静态方法中 super 指向于父类 Parent 并不是父类原型, 故输出的是 static 1 另外，在子类的静态方法中通过 super 调用父类的方法时，方法内部的this指向当前的子类，而不是子类的实例。 class A &#123; constructor() &#123; this.x = 1; &#125; static print() &#123; console.log(this.x); &#125; &#125; class B extends A &#123; constructor() &#123; super(); this.x = 2; &#125; static m() &#123; super.print(); &#125; &#125; B.x = 3; B.m() // 3 个人觉得这个例子还是好的, 如果不这样写, 可能就会有朋友会误以为会输出 2, 其实并不是, 这里的 this 指向的是 子类, 并不是 子类实例 🌰 举个对于初学者容易摸不着头脑的例子 我先把已知定义列出来: 在 constructor 函数中, 可以当作父类的构造函数使用 可以把 super 当成对象使用 普通方法 中 super 指向 父类的原型对象 静态方法 中 super 指向 父类 静态方法 的 this 指向 当前子类 Example #1为什么可以赋值,但是读取的时候是 undefined class A &#123; constructor() &#123; this.x = 1; &#125; &#125; class B extends A &#123; constructor() &#123; super(); this.x = 2; super.x = 3; console.log(super.x); // undefined console.log(this.x); // 3 &#125; &#125; let b = new B(); super 作为对象使用时提到过, 普通方法中 super 指向父类的原型对象,那么可以知道: 在输出 super.x 时, 读取到的其实是 A.rototype.x, 但是在父类原型链上并没有 x 这个属性, 所以输出 undefined ; 那为什么可以赋值呢? 我们先来看一下之前我故意跳过然后在这里讲的例子 👇 Example #2class A &#123; constructor() &#123; this.x = 1; &#125; print() &#123; console.log(this.x); &#125; &#125; class B extends A &#123; constructor() &#123; super(); this.x = 2; &#125; m_print() &#123; super.print(); &#125; &#125; let b = new B(); b.m() // 2 super.print() 虽然调用的是 A.prototype.print(), 但是 A.prototype.print() 内部的 this 指向 子类B 的实例，导致输出的是 2 , 而不是 1 . 也就是说, 实际上执行的是 super.print.call(this) 所以在 Example #2 中, 由于 this 指向子类实例，赋值操作的时候属性会变成子类实例的属性, 所以修改的其实是 this.x. 番外在讨论的过程中我与小伙伴都有几个问题 constructor 中传递的参数是怎么决定的; 可以把 constructor 理解为调用父类构造函数, 这里传入的就是父类所需要的参数 如果只需要使用父类的几个方法呢; 继承的原意就是从父类的所有属性和方法, 如果不需要使用, 直接忽视就行了","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"}]},{"title":"「 ReactJS 笔记 」 L01 井字棋","slug":"react-learning-01","date":"2020-05-25T00:48:12.000Z","updated":"2021-05-29T03:33:03.230Z","comments":true,"path":"2020/react-learning-01/","link":"","permalink":"https://yogwang.site/2020/react-learning-01/","excerpt":"学习新东西的时候只看肯定是不够的, 所以既然 ReactJS 官方提供了一个学习的案例, 那么就一边写Demo, 一边读文档. Tips: 我是直接看案例然后按照自己的理解去写的, 并没有按照官方案例亦步亦趋, 所以可能流程会不一样. 井字棋这个 demo 主要分为两部分: 棋盘 点击棋盘空白格子可以落子, 落子之后交换棋手. 棋格已经落子 / 有棋手获胜时不可落子","text":"学习新东西的时候只看肯定是不够的, 所以既然 ReactJS 官方提供了一个学习的案例, 那么就一边写Demo, 一边读文档. Tips: 我是直接看案例然后按照自己的理解去写的, 并没有按照官方案例亦步亦趋, 所以可能流程会不一样. 井字棋这个 demo 主要分为两部分: 棋盘 点击棋盘空白格子可以落子, 落子之后交换棋手. 棋格已经落子 / 有棋手获胜时不可落子 游戏信息 棋手信息 提示当前落子的棋手信息 棋手获得胜利后, 显示胜利方 对局历史记录 展示对局历史信息 点击历史信息进行操作回溯 先从棋盘开始, 一共有9个格子, 每个格子有 3 个状态 (空, X, O)我想到的就直接用 flex 布局了, 不需要考虑 row 和 col, 这样也可以直接用循环直接输出 9 个棋格, 同时也可以从循环里边取出棋格的状态 所以首先是造棋盘: // App.js import React, &#123; Component &#125; from 'react'; // 引入 React 以及React下的 Component 类 import './App.styl'; // 引入样式文件 class App extends Component &#123; // 声明棋盘状态 state = &#123; squares: [0, 1, 2, 3, 4, 5, 6, 7, 8] // 这里是棋盘9个格子的状态 &#125; // /* * 当然你也可以使用 constructor, * 如果不理解 ES6 类的继承可以阅读 https://yogwang.github.io/2020/JS-class-constructor/ constructor()&#123; super() this.state=&#123; squares: [0, 1, 2, 3, 4, 5, 6, 7, 8] &#125; &#125; */ render () &#123; const &#123; squares &#125; = this.state return ( &lt;div id='app'> &lt;div className='game-bar'> // 棋盘 &lt;div className='board'> // 循环遍历棋格状态 并且返回单元格, 记得添加key, 这点于Vue一样 &#123;squares.map((info, index) => ( &lt;div className='square' key=&#123;index&#125;>&#123;info&#125;&lt;/div> ))&#125; &lt;/div> &lt;/div> &lt;/div> ) &#125; &#125; export default App; 样式这边我用的预编译是 Stylus, 省略了括号, 冒号以及分号, 其它和 SCSS 基本一样.如果不了解大概看一下就行 &#x2F;&#x2F; App.styl $square &#x3D; 60px &#x2F;* 定义一个格子的宽度 *&#x2F; &#x2F;&#x2F; 棋盘样式 .board width $square * 3 &#x2F;* 一行3个格子的宽度 *&#x2F; border 1px solid black display flex &#x2F;* flex 布局 *&#x2F; flex-wrap wrap &#x2F;* 超出宽度可换行 *&#x2F; &#x2F;&#x2F; 棋格样式 .square width $square height @width &#x2F;* 高度同宽度 *&#x2F; line-height @height &#x2F;* 文字行高同容器高度 这里应该要减去 border 的高度, 但是不碍事 *&#x2F; font-size 25px text-align center border 1px solid black box-sizing border-box &#x2F;* 修改盒模型 *&#x2F; cursor pointer 完成之后大概是这样的一个样子 然后是游戏信息的展示, 因为是交替落子, 所以单数步数是 棋手X 落子的话, 双数步数就一定是 棋手O 落子.顺便给棋格绑定上点击事件, 棋盘的组件大概可以这样初步完成 // App.js import React, &#123; Component &#125; from 'react'; import './App.styl'; class App extends Component &#123; state = &#123; squares: [0, 1, 2, 3, 4, 5, 6, 7, 8], step:0, // 增加计步器 &#125; // 获取当前Player getCurPlayer () &#123; const &#123; step &#125; = this.state // 获取当前步数 return step % 2 ? \"O\" : \"X\" // 按照步数奇偶返回棋手 &#125; // 方块被点击 handleSquareClick (position, player) &#123; const &#123; squares, step &#125; = this.state // 获取当前棋盘信息以及步数 // 既然获取到了棋格信息那么就顺便输出一下当前信息 console.log(`当前步数: $&#123;step&#125;, 棋手: $&#123;player&#125;, 点击位置: $&#123;position&#125;`) const newStep = step + 1 // 步数 +1 const newSquares = squares newSquares[position] = player // 修改对应棋格信息 // 修改State, 并且触发渲染 this.setState(&#123; squares: newSquares, step: newStep &#125;) &#125; render () &#123; const &#123; squares &#125; = this.state const player = this.getCurPlayer() return ( &lt;div id='app'> &lt;div className='game-bar'> &lt;div className='board'> &#123;squares.map((info, index) => ( /* * 增加onClick事件, 这里和Vue不一样, 需要使用箭头函数, 或者使用 .bind(this) 绑定this * 具体原因请看上一篇 [React L00 起步] */ &lt;div className='square' key=&#123;index&#125; onClick=&#123;() => this.handleSquareClick(index,player)&#125;>&#123;info&#125;&lt;/div> ))&#125; &lt;/div> &lt;/div> &lt;div className='game-info'> // 棋手信息 &lt;div className='player-info'>Current player: &#123;player&#125;&lt;/div> &lt;/div> &lt;/div> ) &#125; &#125; export default App; &#x2F;&#x2F; App.styl &#x2F;&#x2F; ...接上一部分样式 .game-info width 400px height 600px max-height 100vh margin-left 60px .player-info font-size 22px 现在棋盘可以被修改了, 棋手信息也有了, 同样也可以获取到每次操作的落子信息. 那么就可以先把历史记录加上, 并且展示 // App.js import React, &#123; Component &#125; from 'react'; import './App.styl'; class App extends Component &#123; state = &#123; squares: [0, 1, 2, 3, 4, 5, 6, 7, 8], step:0, history:[], // 增加历史记录 &#125; // 获取当前Player getCurPlayer () &#123; const &#123; step &#125; = this.state return step % 2 ? \"O\" : \"X\" &#125; // 方块被点击 handleSquareClick (position, player) &#123; const &#123; squares, step, history &#125; = this.state const newStep = step + 1 const newSquares = squares newSquares[position] = player const newHistory = history.concat([&#123; step:step, player:player, position:position &#125;]) this.setState(&#123; squares: newSquares, step: newStep, history: newHistory &#125;) &#125; render () &#123; const &#123; squares,history &#125; = this.state const player = this.getCurPlayer() return ( &lt;div id='app'> &lt;div className='game-bar'> &lt;div className='board'> &#123;squares.map((info, index) => ( &lt;div className='square' key=&#123;index&#125; onClick=&#123;() => this.handleSquareClick(index,player)&#125;>&#123;info&#125;&lt;/div> ))&#125; &lt;/div> &lt;/div> &lt;div className='game-info'> &lt;div className='player-info'>Current player: &#123;player&#125;&lt;/div> // 历史信息 &lt;ol className='history'> // 遍历循环历史信息记录 &#123;history.map((record, index) => ( &lt;li key=&#123;index&#125;>Player_&#123;record.player&#125; to &#123;record.position&#125;&lt;/li> ))&#125; &lt;/ol> &lt;/div> &lt;/div> ) &#125; &#125; export default App; 现在的游戏界面应该如下 这个时候呢, 就会有几个问题: 棋格可以重复落子 没有获胜判断 棋盘默认显示数字, 很不美观 其实还有一个问题, 在历史回溯的时候会很麻烦, 这个我实在游戏基本都完成了之后才发现的. 这个之后再说 所以在落子的时候增加当前棋格不为空 的判断, 并且以 null 填充数组; 代码修改如下 // App.js import React, &#123; Component &#125; from 'react'; import './App.styl'; class App extends Component &#123; state = &#123; squares: new Array(9).fill(null), // 创建一个长度为 9 的数组,并且填充 null step:0, history:[], &#125; // 获取当前Player getCurPlayer () &#123; const &#123; step &#125; = this.state return step % 2 ? \"O\" : \"X\" &#125; // 方块被点击 handleSquareClick (position, player) &#123; const &#123; squares, step, history &#125; = this.state if (squares[position]) return // 增加棋格不会空的判断 const newStep = step + 1 const newSquares = squares newSquares[position] = player const newHistory = history.concat([&#123; step:step, player:player, position:position &#125;]) this.setState(&#123; squares: newSquares, step: newStep, history: newHistory &#125;) &#125; render () &#123; const &#123; squares, history &#125; = this.state const player = this.getCurPlayer() return ( &lt;div id='app'> &lt;div className='game-bar'> &lt;div className='board'> &#123;squares.map((info, index) => ( &lt;div className='square' key=&#123;index&#125; onClick=&#123;() => this.handleSquareClick(index,player)&#125;>&#123;info&#125;&lt;/div> ))&#125; &lt;/div> &lt;/div> &lt;div className='game-info'> &lt;div className='player-info'>Current player: &#123;player&#125;&lt;/div> // 历史信息 &lt;ol className='history'> // 遍历循环历史信息记录 &#123;history.map((record, index) => ( &lt;li key=&#123;index&#125;>Player_&#123;record.player&#125; to &#123;record.position&#125;&lt;/li> ))&#125; &lt;/ol> &lt;/div> &lt;/div> ) &#125; &#125; export default App; 好了, 棋盘的大致都完成了, 现在来写获胜判断.因为我想者是每次循环一次所有棋格, 然后找出获胜的玩家, 但是这里循环有点傻,所以我是看了一下官方的demo, 是这样的一个思路, 把所有的胜利条件都所列了出来, 然后去循环胜利条件, 如果所有胜利条件都循环结束, 没有出现胜利的玩家则继续游戏. // 计算赢家 calculateWinner () &#123; // 获胜条件 const lines = [ [0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6], ]; const &#123; squares &#125; = this.state // 取得所有棋盘数据 // 循环判断胜利条件 for (let i = 0; i &lt; lines.length; i++) &#123; const [a, b, c] = lines[i]; // 取出获胜坐标 // 判断对应坐标是否有值 并且 三个坐标内的值是否相等 if (squares[a] &amp;&amp; squares[a] === squares[b] &amp;&amp; squares[a] === squares[c]) &#123; return squares[a]; // 返回胜利者 &#125; &#125; return null; &#125; 然后补完一下棋盘, 胜利时在当前玩家信息提示获胜玩家. // App.js import React, &#123; Component &#125; from 'react'; import './App.styl'; // 获胜条件 const lines = [ [0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6], ]; class App extends Component &#123; state = &#123; squares: new Array(9).fill(null), step:0, history:[], &#125; // 获取当前Player getCurPlayer () &#123; const &#123; step &#125; = this.state return step % 2 ? \"O\" : \"X\" &#125; // 方块被点击 handleSquareClick (position, player) &#123; const &#123; squares, step, history &#125; = this.state if (this.calculateWinner() || squares[position]) return // 增加是否有赢家的判断 const newStep = step + 1 const newSquares = squares newSquares[position] = player const newHistory = history.concat([&#123; step:step, player:player, position:position &#125;]) this.setState(&#123; squares: newSquares, step: newStep, history: newHistory &#125;) &#125; // 计算赢家 calculateWinner () &#123; const &#123; squares &#125; = this.state for (let i = 0; i &lt; lines.length; i++) &#123; const [a, b, c] = lines[i]; if (squares[a] &amp;&amp; squares[a] === squares[b] &amp;&amp; squares[a] === squares[c]) &#123; return squares[a]; &#125; &#125; return null; &#125; render () &#123; const &#123; squares,history &#125; = this.state const player = this.getCurPlayer() const winner = this.calculateWinner() // 获取赢家 return ( &lt;div id='app'> &lt;div className='game-bar'> &lt;div className='board'> &#123;squares.map((info, index) => ( &lt;div className='square' key=&#123;index&#125; onClick=&#123;() => this.handleSquareClick(index,player)&#125;>&#123;info&#125;&lt;/div> ))&#125; &lt;/div> &lt;/div> &lt;div className='game-info'> &lt;div className='player-info'> &#123;winner ? `Player_$&#123;winner&#125; is Winner!!!` : `Current player: $&#123;player&#125;`&#125; // 判断是否有玩家获胜, 如果有则输出获胜信息, 没有则输出当前玩家信息 &lt;/div> &lt;ol className='history'> &#123;history.map((record, index) => ( &lt;li key=&#123;index&#125;>Player_&#123;record.player&#125; to &#123;record.position&#125;&lt;/li> ))&#125; &lt;/ol> &lt;/div> &lt;/div> ) &#125; &#125; export default App; 整个游戏流程到现在基本就完成了, 但是点击历史记录回溯操作的功能还没有加上来.这个时候我就有点卡壳了, 不知道在当前逻辑下怎么回退操作. 就去看了官方的案例,它是每一步在历史记录内插入当前棋盘数据, 然后回退的时候直接读取历史棋盘数据, 并且没有在历史记录中展示每一步的具体操作内容. 所以想了想还是继续原先的历史记录, 并且按照历史记录来生成棋盘数据(这边参考了山地人老师的思路),那这样的话, 就不需要手动去修改棋盘数据了, 只要调用一下生成棋盘的函数就可以了. 具体代码修改如下 // App.js import React, &#123; Component &#125; from 'react'; import './App.styl'; const lines = [ [0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6], ]; class App extends Component &#123; state = &#123; squares: new Array(9).fill(null), step: 0, history: [], &#125; // 获取当前Player getCurPlayer () &#123; const &#123; step &#125; = this.state return step % 2 ? \"O\" : \"X\" &#125; // 方块被点击 handleSquareClick (position, player) &#123; const &#123; squares, step, history &#125; = this.state if (this.calculateWinner() || squares[position]) return const newStep = step + 1 // 移除了棋盘数据操作, const newHistory = [ ...history.slice(0, step), &#123; step: step, player: player, position: position &#125; ] this.setState(&#123; step: newStep, history: newHistory, squares: this.calculateSquares(newHistory, newStep), // 调用 calculateSquares 产生数据 &#125;) &#125; // 计算赢家 calculateWinner () &#123; const &#123; squares &#125; = this.state for (let i = 0; i &lt; lines.length; i++) &#123; const [a, b, c] = lines[i]; if (squares[a] &amp;&amp; squares[a] === squares[b] &amp;&amp; squares[a] === squares[c]) &#123; return squares[a]; &#125; &#125; return null; &#125; // 生成棋盘数据 calculateSquares (history, step) &#123; const newSquares = new Array(9).fill(null) // 创建空棋盘数组 // 循环插入历史数据 for (let i = 0; i &lt; step; i += 1) &#123; const tempHistory = history[i] newSquares[tempHistory.position] = tempHistory.player &#125; return newSquares // 返回棋盘数据 &#125; // 回退历史步骤 handleGoBack (step) &#123; const &#123; history &#125; = this.state const tempHistory = history.slice(0, step) // 根据传入步数截取历史记录 this.setState(&#123; step: step, // 重设步数 squares: this.calculateSquares(tempHistory, step), // 生成棋盘数据 &#125;) &#125; render () &#123; const &#123; squares, history &#125; = this.state const player = this.getCurPlayer() const winner = this.calculateWinner() return ( &lt;div id='app'> &lt;div className='game-bar'> &lt;div className='board'> &#123;squares.map((info, index) => ( &lt;div className='square' key=&#123;index&#125; onClick=&#123;() => this.handleSquareClick(index, player)&#125;>&#123;info&#125;&lt;/div> ))&#125; &lt;/div> &lt;/div> &lt;div className='game-info'> &lt;div className='player-info'> &#123;winner ? `Player_$&#123;winner&#125; is Winner!!!` : `Current player: $&#123;player&#125;`&#125; &lt;/div> &lt;ol className='history'> &#123;history.map((record, index) => ( &lt;li key=&#123;index&#125; onClick=&#123;() => this.handleGoBack(record.step + 1)&#125;>Player_&#123;record.player&#125; to &#123;record.position&#125;&lt;/li> ))&#125; &lt;/ol> &lt;/div> &lt;/div> ) &#125; &#125; export default App; 至此为止, 基本的游戏功能都完成了, 只不过整个项目都是写在一个文件中的, 并没有进行组件化操作.你们可以自行决定怎么拆分, 也可以继续阅读下去. 组件化我认为可以把棋盘和游戏信息展示进行拆分; 棋盘这部分我觉得单独一个组件就可以了, 不用继续分解了, 因为单个棋格就一个 div 元素 加上 onClick 事件, 组件化的结果并没有简化代码, 反而增加代码量和不方便阅读. 游戏信息可以继续拆分成玩家信息和历史记录, 然后再对应组件内进行状态维护和样式的编辑. 拆分后的 App.js 文件如下 // App.js import React, &#123; Component &#125; from 'react'; import Board from './components/Board' import GameInfo from './components/GameInfo' import './App.styl'; // 获胜条件 const lines = [ [0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6], ]; class App extends Component &#123; // 定义属性 state = &#123; squares: new Array(9).fill(null), player: \"\", history: [], step: 0, &#125; // 计算当前Player getCurPlayer () &#123; const &#123; step &#125; = this.state return step % 2 ? \"O\" : \"X\" // 能否被2整除 &#125; // 生成棋盘数据 calculateSquares (history, step) &#123; // 创建新数组 const newSquares = new Array(9).fill(null) // 循环插入历史数据 for (let i = 0; i &lt; step; i += 1) &#123; const tempHistory = history[i] newSquares[tempHistory.position] = tempHistory.player &#125; return newSquares &#125; // 计算赢家 calculateWinner () &#123; const &#123; squares &#125; = this.state // 循环判断胜利条件 for (let i = 0; i &lt; lines.length; i++) &#123; const [a, b, c] = lines[i]; if (squares[a] &amp;&amp; squares[a] === squares[b] &amp;&amp; squares[a] === squares[c]) &#123; return squares[a]; &#125; &#125; return null; &#125; // 方块被点击 handleSquareClick (position, player) &#123; const &#123; squares, step, history &#125; = this.state // 如果已经获胜或棋格不为空则跳出 if (this.calculateWinner() || squares[position]) return const newStep = step + 1 // 新步数 // 插入新历史记录 const newHistory = [ ...history.slice(0, step), &#123; step: step, player: player, position: position &#125; ] this.setState(&#123; step: newStep, history: newHistory, squares: this.calculateSquares(newHistory, newStep), // 生成棋盘数据 &#125;) &#125; // 回退历史步骤 handleGoBack (step = 0) &#123; const &#123; history &#125; = this.state const tempHistory = history.slice(0, step) this.setState(&#123; step: step, squares: this.calculateSquares(tempHistory, step), // 生成棋盘数据 &#125;) &#125; // 重新开始 handleRestart () &#123; this.setState(&#123; history: [] &#125;) this.handleGoBack() &#125; render () &#123; const &#123; squares, history &#125; = this.state const player = this.getCurPlayer() const winner = this.calculateWinner() return ( &lt;div id='app'> &lt;div className='game-bar'> &lt;Board squares=&#123;squares&#125; onClick=&#123;i => this.handleSquareClick(i, player)&#125; /> &lt;/div> &lt;GameInfo player=&#123;player&#125; winner=&#123;winner&#125; history=&#123;history&#125; goBack=&#123;step => this.handleGoBack(step)&#125; /> &lt;/div> ) &#125; &#125; export default App; 棋盘组件// Board.js import React, &#123; Component &#125; from 'react'; import './Board.styl'; class Board extends Component &#123; // 生成棋格 renderSquare (status, index) &#123; return (&lt;div className='square' onClick=&#123;() => this.props.onClick(index)&#125; key=&#123;index&#125;>&#123;status&#125;&lt;/div>) &#125; render () &#123; const &#123; squares &#125; = this.props // 获取棋盘数据 return ( &lt;div className='board'> // 循环棋盘数据生成棋格 &#123;squares.map((status, index) => this.renderSquare(status, index))&#125; &lt;/div> ) &#125; &#125; export default Board 游戏信息组件// GameInfo.js import React, &#123; Component &#125; from 'react' import History from './History' class GameInfo extends Component &#123; render () &#123; const &#123; player, winner, history &#125; = this.props // 从父组件获取棋手, 胜利方, 历史记录数据 // 当前棋手信息, 如果已经有棋手胜利 返回胜利信息 const playerInfo = winner ? `Player_$&#123;winner&#125; is Winner!!!` : `Current player: $&#123;player&#125;` return ( &lt;div className='game-info'> &lt;div className='player-info'>&#123;playerInfo&#125;&lt;/div> &lt;History history=&#123;history&#125; onClick=&#123;step => this.props.goBack(step)&#125;>&lt;/History> &lt;/div> ) &#125; &#125; export default GameInfo 操作历史组件// History.js import React, &#123; Component &#125; from 'react'; import Record from './Record' import './History.styl'; class History extends Component &#123; render () &#123; const &#123; history &#125; = this.props return ( &lt;ol className='history'> &lt;li onClick=&#123;() => this.props.onClick(0)&#125;>Go to game start&lt;/li> // 回到游戏开始 &#123; history.map((record, index) => ( &lt;Record info=&#123;record&#125; key=&#123;index&#125; onClick=&#123;() => this.props.onClick(record.step + 1)&#125;>&lt;/Record> )) &#125; &lt;/ol> ) &#125; &#125; export default History 单条历史记录import React, &#123; Component &#125; from 'react' class Record extends Component &#123; // 计算坐标 返回二维坐标 [0,0] calculatePosition (position) &#123; const posY = (position / 3 >> 0) + 1 // 取行号 const posX = position % 3 + 1 // 取列号 return `[$&#123;posY&#125;,$&#123;posX&#125;]` &#125; render () &#123; const &#123; info &#125; = this.props // 继承历史记录 return ( &lt;li onClick=&#123;() => this.props.onClick()&#125;> Player_&#123;info.player&#125; to &#123;this.calculatePosition(info.position)&#125; &lt;/li> ) &#125; &#125; export default Record 样式文件如下: &#x2F;&#x2F; App.styl body font-family consolas margin 0 #app width 100vw height 100vh display flex justify-content center align-items center .game-bar height 600px max-height 100vh .game-info width 400px height 600px max-height 100vh .player-info font-size 22px &#x2F;&#x2F; Board.styl $square &#x3D; 60px .board width $square * 3 border 1px solid black margin-right 50px display flex flex-wrap wrap .square width $square height $square line-height @height font-size 25px text-align center border 1px solid black box-sizing border-box cursor pointer &amp;:hover background #ddd &#x2F;&#x2F; History.styl .history padding 0 counter-reset number -1 li margin 5px 0 counter-increment number list-style-type none cursor pointer &amp;:before content counter(number) &#39;.&#39; margin-right 10px display inline-bloack &amp;:hover color red text-decoration underline 以上 附录一些卡壳的地方 如何创建 State 状态 Constructor 是怎么一回事 组件化后子组件如何触发父组件事件 为何 onClick 中的事件会自动执行 React中怎么使用 Stylus 组件多层嵌套的情况下怎么获取其它的属性状态，类似 Vuex 的Store","categories":[{"name":"踩坑日记","slug":"踩坑日记","permalink":"https://yogwang.site/categories/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://yogwang.site/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"ReactJS","slug":"ReactJS","permalink":"https://yogwang.site/tags/ReactJS/"}]},{"title":"「 ReactJS 笔记 」 L00 起步","slug":"react-learning-00","date":"2020-05-22T03:47:43.000Z","updated":"2021-05-29T03:33:00.112Z","comments":true,"path":"2020/react-learning-00/","link":"","permalink":"https://yogwang.site/2020/react-learning-00/","excerpt":"Vue 3.0 Beta版本已经更新很久了,不出意外正式的 Release 应该如约在第三季度发布,然而我还没有开始学习 TypeScript 以及 Composition API,趁着这几天项目还没开始,就抓紧了解了一下 React","text":"Vue 3.0 Beta版本已经更新很久了,不出意外正式的 Release 应该如约在第三季度发布,然而我还没有开始学习 TypeScript 以及 Composition API,趁着这几天项目还没开始,就抓紧了解了一下 React ReactJS现存的一些疑问 ReactJS 与 VueJS 的区别 ReactJS 有什么好的? 为什么 ReactJS 是单向数据流 create-react-app 创建的项目依赖为什么都在dependencies 绑定函数时为什么要使用箭头函数或者.bind() onClick会渲染成功会自动执行 怎么不使用constructor的情况下定义state react是否有生命周期 如果有生命周期钩子是否和vue差不多? 加上Typescript之后的问题 Props怎么定义interface 如果需要手动定义接口岂不是太傻?","categories":[{"name":"踩坑日记","slug":"踩坑日记","permalink":"https://yogwang.site/categories/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"未完成","slug":"未完成","permalink":"https://yogwang.site/tags/%E6%9C%AA%E5%AE%8C%E6%88%90/"},{"name":"学习","slug":"学习","permalink":"https://yogwang.site/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"ReactJS","slug":"ReactJS","permalink":"https://yogwang.site/tags/ReactJS/"}]},{"title":"Jeecg-boot 开发挖坑日记10 升级AntD依赖后按钮组件配色出现异常","slug":"jeecg-boot-devDiary10","date":"2020-04-24T06:02:57.000Z","updated":"2021-05-29T03:26:09.841Z","comments":true,"path":"2020/jeecg-boot-devDiary10/","link":"","permalink":"https://yogwang.site/2020/jeecg-boot-devDiary10/","excerpt":"昨天项目有新需求用到了，Ant Design Vue 1.5.0+ 的新组件 Descriptions，所以就单独升级了一下UI库依赖，从 v1.3.9 升到了 v1.5.3，然后新组件是可以用了，但是按钮组件出现问题了；当type 为 danger 时，背景会变成白色，同时文字也是白色的，就会如下图一样的情况。","text":"昨天项目有新需求用到了，Ant Design Vue 1.5.0+ 的新组件 Descriptions，所以就单独升级了一下UI库依赖，从 v1.3.9 升到了 v1.5.3，然后新组件是可以用了，但是按钮组件出现问题了；当type 为 danger 时，背景会变成白色，同时文字也是白色的，就会如下图一样的情况。 然后审查模式下边看到是有一个样式覆盖了组件库的样式 然后我自己就没有定义过组件库的全局样式，正常我自己覆盖组件库内样式的时候都是私有样式，就郁闷了一个早上，在视图层到处找哪个组件里没有加样式私有化，结果一个上午都没有找到。然后午休完了之后就突然想起来是不是 Jeecg-boot 自己定义了一个全局样式，在入口文件中引入了，所以导致样式被覆盖了。结果就真的是这个问题。 第22行引入的 OnlineForm.css中就重定义了 .ant-btn-danger 的背景色为白色，把 AntD 的样式文件在这个之后引入就不会被覆盖了，我大概看了一下，这个样式表中重写了 AntD 的 169 个样式 这个意思就是说，不只是按钮的样式会出现问题，如果其它的样式没有做好覆盖，也会导致显示异常… 有一些还是加了私有作用域，不知道是怎么一个情况…反正我不用在线报表就先注释了，之后看开发团队会不会修复这个问题吧。 附 本文所使用的 Jeecg-boot 版本为 v2.1.0 v2.2.0 版本也有这个问题，已经提交了 issue 等开发团队回复吧。","categories":[{"name":"踩坑日记","slug":"踩坑日记","permalink":"https://yogwang.site/categories/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"Jeecg-boot","slug":"Jeecg-boot","permalink":"https://yogwang.site/tags/Jeecg-boot/"},{"name":"Ant-Design-Vue","slug":"Ant-Design-Vue","permalink":"https://yogwang.site/tags/Ant-Design-Vue/"}]},{"title":"export { x as x } 中的 as 是什么？","slug":"what-the-export-x-as-x","date":"2020-04-13T06:38:59.000Z","updated":"2021-05-29T03:33:52.832Z","comments":true,"path":"2020/what-the-export-x-as-x/","link":"","permalink":"https://yogwang.site/2020/what-the-export-x-as-x/","excerpt":"今天在读一个开源框架的时候看到了一行 export &#123; installer as VueAxios, service as axios &#125;; 然后我就 ? ? ?，以前一直都不知道这个 as，然后就赶紧百度，结果没有一个匹配的结果。 然后就只能从阮一峰老师的ES6入门里边找…","text":"今天在读一个开源框架的时候看到了一行 export &#123; installer as VueAxios, service as axios &#125;; 然后我就 ? ? ?，以前一直都不知道这个 as，然后就赶紧百度，结果没有一个匹配的结果。 然后就只能从阮一峰老师的ES6入门里边找… 通常情况下，export 输出的变量就是本来的名字，但是可以使用 as 关键字重命名。 示例代码：function v1() &#123; ... &#125; function v2() &#123; ... &#125; export &#123; v1 as streamV1, v2 as streamV2, v2 as streamLatestVersion &#125;; 上面代码使用 as 关键字，重命名了函数 v1 和 v2 的对外接口。重命名后，v2 可以用不同的名字输出两次。 所以其实 as 关键词的作用就是重命名导出的关键词，来起一个更加语义化的名称，或者隐藏模块里边的变量名称。然后再重新查阅其它博客的文章的时候发现，有一部分的博客把重命名写在了 as 关键词前边，我就又奇怪了，难不成两边都可以嘛？我就自己写了个demo，然而只能写在后边…. 好了，Demo 也写了，也闹明白了，其实就是一个关键字重命名，所以用到的太少了，看到就蒙了，以后记着就好。","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"}]},{"title":"使用 Webpack 的 Proxy 解决跨域问题","slug":"webpack-dev-server-proxy-note","date":"2020-03-27T07:20:58.000Z","updated":"2021-05-29T03:33:48.002Z","comments":true,"path":"2020/webpack-dev-server-proxy-note/","link":"","permalink":"https://yogwang.site/2020/webpack-dev-server-proxy-note/","excerpt":"在这次的项目中，遇到了后端配置了允许跨域，但是我这边请求的时候还是提示跨域，后端折腾了会，我说算了，我这边本地做一下代里还快一点，你继续整接口吧。 所以就用到了 webpack-dev-server 的 proxy，但是有一些部分我并没有整明白，所以写一篇文章梳理一下。 最简单的就是直接在 webpack 的配置文件中启用 proxy 就可以了，","text":"在这次的项目中，遇到了后端配置了允许跨域，但是我这边请求的时候还是提示跨域，后端折腾了会，我说算了，我这边本地做一下代里还快一点，你继续整接口吧。 所以就用到了 webpack-dev-server 的 proxy，但是有一些部分我并没有整明白，所以写一篇文章梳理一下。 最简单的就是直接在 webpack 的配置文件中启用 proxy 就可以了， module.exports = &#123; publicPath: \"./\", outputDir: \"./dist\", lintOnSave: true, css: &#123; loaderOptions: &#123; .... &#125;, &#125;, devServer: &#123; proxy: &#123; \"/api\": &#123; // 这里的api可以是 / 也可以是具体的path也可以配置多个 target: \"http://www.domain.com/\", //对应自己的api接口 changeOrigin: true, // 如果接口跨域，需要配置这个参数 secure: false, // 如果是https接口，需要配置这个参数 &#125;, &#125;, &#125;, &#125;; 然后再请求的配置文件中修改地址为启动的服务地址就可以初步实现了。改编成生产环境的时候就需要去修改配置文件，我就觉得很麻烦，一点也不优雅，所以就需要用到环境变量来配置代里。 VueCLI 4x中通过为 .env 文件增加后缀来设置某个模式下特有的环境变量，例如在项目根目录创建一个名为 .env.development 的文件，那么在这个文件里声明过的变量就只会在 development 模式下被载入。 development 模式用于 vue-cli-service serveproduction 模式用于 vue-cli-service build 和 vue-cli-service test:e2etest 模式用于 vue-cli-service test:unit 所以默认你不需要配就可以在 run serve 时读取 .env.development 的配置，同理 build 时会读取 .env.production 的配置。 附只有以 VUE_APP_ 开头的变量会被 webpack.DefinePlugin 静态嵌入到客户端侧的包中。你可以在应用的代码中这样访问它们： console.log(process.env.VUE_APP_SECRET) 在构建过程中，process.env.VUE_APP_SECRET 将会被相应的值所取代。在 VUE_APP_SECRET=secret 的情况下，它会被替换为 “secret”。 除了 VUE_APP_* 变量之外，在你的应用代码中始终可用的还有两个特殊的变量： NODE_ENV - 会是 &quot;development&quot;、&quot;production&quot; 或 &quot;test&quot; 中的一个。具体的值取决于应用运行的模式。BASE_URL - 会和 vue.config.js 中的 publicPath 选项相符，即你的应用会部署到的基础路径。 环境变量和模式 | Vue CLI","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"https://yogwang.site/tags/Webpack/"}]},{"title":"使用VueJS的计算属性监听DOM元素属性的问题","slug":"vue-computed-DOM-element-attributes","date":"2020-03-16T06:18:59.000Z","updated":"2021-05-29T03:33:39.086Z","comments":true,"path":"2020/vue-computed-DOM-element-attributes/","link":"","permalink":"https://yogwang.site/2020/vue-computed-DOM-element-attributes/","excerpt":"今天在写一个模拟微信的聊天组件的时候，需要获取消息列表的滚动条高度，来实现每次发送接受消息数据时，自动滚动到列表末尾。当然就想到了用 Computed 属性来计算容器的 scrollHeight。然后就发现一开始滚动条会定位到列表最后，但是测着测着就发现怎么超出了一定高度范围之后就不会滚动到列表末尾了，而是固定在了一个值。","text":"今天在写一个模拟微信的聊天组件的时候，需要获取消息列表的滚动条高度，来实现每次发送接受消息数据时，自动滚动到列表末尾。当然就想到了用 Computed 属性来计算容器的 scrollHeight。然后就发现一开始滚动条会定位到列表最后，但是测着测着就发现怎么超出了一定高度范围之后就不会滚动到列表末尾了，而是固定在了一个值。 所以在我在控制台输出了一下获取到的值:就觉得是不是因为这里拿到的是容器可视部分的值 offsetHeight，检查后发现我并没有取错属性。 接着我就把之前填充默认填充的假数据给去掉了，再一次获取了计算出来的属性：嗯？为啥都是一个值，这个值不应该是会随内容的增加变化的吗？为什么就一直是初始的值呢。 想了想会不会是计算属性缓存了 scrollHeight，然后就在滚动方法里同样输出了容器的scrollHeight，确实是被缓存了。 然后就去查阅了一下资料，也询问了群内的大佬回答是： 计算属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。注意，如果某个依赖 (比如非响应式属性) 在该实例范畴之外，则计算属性是不会被更新的。 然后翻了翻Vue的文档关于 Computed 部分的介绍： 计算属性的结果会被缓存，除非依赖的响应式 property 变化才会重新计算。注意，如果某个依赖 (比如非响应式 property) 在该实例范畴之外，则计算属性是不会被更新的。 确实 DOM 元素相关的属性不能被 Computed 计算，DOM 元素不具有响应式依赖，所以会被计算属性缓存。","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"VueJS","slug":"VueJS","permalink":"https://yogwang.site/tags/VueJS/"}]},{"title":"什么是 [Arguments] 隐式参数？","slug":"JS-whats-arguments","date":"2020-03-14T01:01:27.000Z","updated":"2021-05-29T03:25:13.487Z","comments":true,"path":"2020/JS-whats-arguments/","link":"","permalink":"https://yogwang.site/2020/JS-whats-arguments/","excerpt":"这段时间总是看到有人提到 arguments 隐式参数, 并且在 方方老师 的面试经中也提到了这个词，但是好像很多人不知道怎么一回事。确实在 ES6 普及之后，有了 ... 展开运算符之后就很少有用到 arguments 了，并且我在写这篇文章之前还总是拼错单词，因为我喜欢自己定义 parameter 形参…","text":"这段时间总是看到有人提到 arguments 隐式参数, 并且在 方方老师 的面试经中也提到了这个词，但是好像很多人不知道怎么一回事。确实在 ES6 普及之后，有了 ... 展开运算符之后就很少有用到 arguments 了，并且我在写这篇文章之前还总是拼错单词，因为我喜欢自己定义 parameter 形参… arguments 是一个对应于传递给函数的参数的类数组对象（并不是 Array，除了 length 属性和索引元素之外没有任何 Array 属性） arguments 对象是所有（非箭头）函数中都可用的局部变量。你可以使用 arguments 对象在函数中引用函数的参数。此对象包含传递给函数的每个参数，第一个参数在索引 0 处。 使用方式例如，如果一个函数传递了三个参数，你可以以如下方式引用他们： function test() &#123; console.log(arguments[0]); console.log(arguments[1]); console.log(arguments[2]); &#125; test(1, 2, 3); // => 1 // => 2 // => 3 同样也可以进行赋值操作 arguments[1] = \"new value\"; console.log(arguments[1]); // => new value 再重复一遍，arguments 不是数组它只能在函数内使用，类似于 Array，但除了 length 属性和索引元素之外没有任何 Array 属性。但是它可以被转换为一个真正的 Array：上一组 demo console.log(typeof arguments); // arguments 对象只能在函数内使用 function test() &#123; console.log(typeof arguments); console.log(arguments[0]); &#125; test(1); // => undefined // => object // => 1 拓展 1当然也可以通过以下方法转变成 Js 数组： var args = Array.prototype.slice.call(arguments); var args = [].slice.call(arguments); // ES6 const args = Array.from(arguments); const args = [...arguments]; 拓展 2在严格模式与非严格模式下进行赋值操作会出现不一样的结果 // 严格模式 function test(a) &#123; \"use strict\"; console.log(a, arguments[0]); a = 50; console.log(a, arguments[0]); arguments[0] = 100; console.log(a, arguments[0]); &#125; test(10); // => 10 10 // => 50 10 // => 50 100 // 非严格模式 function test(a) &#123; console.log(a, arguments[0]); a = 50; console.log(a, arguments[0]); arguments[0] = 100; console.log(a, arguments[0]); &#125; test(10); // => 10 10 // => 50 50 // => 100 100 当然这些看看就好 拓展 3一些专业名词： Parameters 函数显式参数 function test(parameter1, parameter2, parameter3) Arguments 隐式参数 ( 我就不写伪代码了… ) 参考资料 Arguments 对象 - MDN","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"}]},{"title":"map() 和 forEach() 的区别","slug":"JS-map-and-forEach","date":"2020-03-12T03:27:13.000Z","updated":"2021-05-29T03:25:31.888Z","comments":true,"path":"2020/JS-map-and-forEach/","link":"","permalink":"https://yogwang.site/2020/JS-map-and-forEach/","excerpt":"一直以来没有整理查阅过数组的原生方法，所以对什么时候用 map, 什么时候用 forEach 并不是很明确，完全看心情。只是知道 map有返回值而 forEach 没有需要自己操作，所以今天准备好好梳理一下记录下来。","text":"一直以来没有整理查阅过数组的原生方法，所以对什么时候用 map, 什么时候用 forEach 并不是很明确，完全看心情。只是知道 map有返回值而 forEach 没有需要自己操作，所以今天准备好好梳理一下记录下来。 两个操作都有相同的部分 都只能遍历数组 都可以循环遍历数组中的每一项 第一个参数都是 callback 函数，且该函数接收三个参数（ item, index, array ） 都有可选的第二个参数 thisArg 可改变 callback 中 this 的值（这个可以忽略基本用不到） 不同的是： map 有返回值，而 forEach 没有 map 的运行速度更快 map 可以被链式调用（ forEach 因为没有返回值不能被链式调用） 所以哪个更好？如果你想改变数组并且返回一个新数组时候推荐使用 .map()，不光是因为它会返回一个新数组和速度快，而且可以被链式调用继续操作返回的数组。 如果只是单纯想操作数据但是不想返回一个数组时，使用 .forEach() 就可以省略多余的步骤。 拓展 如果已访问的元素在迭代时被删除了（ 例如使用 .shift() 操作了原数组 ），之后的元素将被跳过 var words = [\"one\", \"two\", \"three\", \"four\"]; words.forEach(function(word) &#123; console.log(word); if (word === \"two\") &#123; words.shift(); &#125; &#125;); // => one // => two // => four // 这里的 three 被跳过了 为什么都说 map 和 forEach 不会改变原数组？因为不管是 map 还是 forEach，当中的 item 都是拷贝的对象，你去直接修改他不会影响原数组，但是你去修改其内部的属性，就会影响。类似于深浅拷贝的问题，所以说不能修改原数组也不是绝对的，看你怎么修改操作数据的。 最近真的时间很紧张，都没有空闲的时间好好的去整理，等有时间了准备梳理一下被 VueJS 改写的 7 个数组原生方法：push, pop, shift, unshift, splice, sort, reverse 参考 Array.prototype.forEach() Array.prototype.map() JS 中 map 和 forEach 的区别","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"},{"name":"挖坑","slug":"挖坑","permalink":"https://yogwang.site/tags/%E6%8C%96%E5%9D%91/"}]},{"title":"「 TypeScript 笔记 」 楔子","slug":"TypeScript-learning-00","date":"2020-02-27T02:03:51.000Z","updated":"2021-05-29T03:34:00.454Z","comments":true,"path":"2020/TypeScript-learning-00/","link":"","permalink":"https://yogwang.site/2020/TypeScript-learning-00/","excerpt":"这两天同时写 3 个项目，脑子有点乱，每天白天写一个晚上另外写一个，第二天可能就是第三个项目，所以每天上午到公司之后有大概 1 个多小时就处于梦游的状态，就等着群里有谁提问题，然后我解决的时候可以把脑回路给转换过来，但是这段时间可能因为疫情的原因吧，活跃的人越来越少了，还是自己写写 demo 把今年要学的 TS 给学起来吧。 本来是想等到 Vue 更新 3.0 的时候再学的，但是感觉可能等到 3.0 出来了应该要是下半年了，如果上半年就只学习 React，不配合 TS 的就有点太浪费了，好多小伙伴就是用 TS 在开发 React 项目。","text":"这两天同时写 3 个项目，脑子有点乱，每天白天写一个晚上另外写一个，第二天可能就是第三个项目，所以每天上午到公司之后有大概 1 个多小时就处于梦游的状态，就等着群里有谁提问题，然后我解决的时候可以把脑回路给转换过来，但是这段时间可能因为疫情的原因吧，活跃的人越来越少了，还是自己写写 demo 把今年要学的 TS 给学起来吧。 本来是想等到 Vue 更新 3.0 的时候再学的，但是感觉可能等到 3.0 出来了应该要是下半年了，如果上半年就只学习 React，不配合 TS 的就有点太浪费了，好多小伙伴就是用 TS 在开发 React 项目。 此文是一篇引子，大概讲述一下为什么要学习 TypeScript、TypeScript 的优点等，可能要等到我全部学习完成之后才能把整篇文章整理写完，可能进度会很慢，因为要同时学习 ReactJS。现在我的对 TS 的了解知之甚少，只知道 TS 是一种强类型的脚本语言， 可以让编写的代码避免一些基础的 Bug，来提高自己的开发效率，并且可以增强项目的可维护性。 现存的一些疑问 为什么要学 TS TS 有什么好的，为什么 React,Vue,Ng 都是开始使用 TS 为什么能避免低级 BUG 三大框架哪一个更适合 TS TS 除了类型约束还和 JS 有什么区别 其它的一些杂物 TS -&gt; JS 的超集 一门静态语言 现阶段可能搭配 React 学习更好，搭配 Vue 2.x 可能有点尴尬 参考 typescript - 一种思维方式 现在还是一篇草稿要整理过，暂时先把一些想法写下来，等学习全部完成了再重新编辑发布，期间应该会有很多版的调整，最终版应该会面目全非","categories":[{"name":"踩坑日记","slug":"踩坑日记","permalink":"https://yogwang.site/categories/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"未完成","slug":"未完成","permalink":"https://yogwang.site/tags/%E6%9C%AA%E5%AE%8C%E6%88%90/"},{"name":"学习","slug":"学习","permalink":"https://yogwang.site/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://yogwang.site/tags/TypeScript/"}]},{"title":"ESlint的格式化风格有很多种，选择哪一种作为自己的代码格式化风格呢？","slug":"choose-the-ESLint-formatting-rule-that-suits-you","date":"2020-02-20T06:04:37.000Z","updated":"2021-05-29T03:30:35.397Z","comments":true,"path":"2020/choose-the-ESLint-formatting-rule-that-suits-you/","link":"","permalink":"https://yogwang.site/2020/choose-the-ESLint-formatting-rule-that-suits-you/","excerpt":"这段时间刚刚复工，年前的我负责的一个年会大屏系统公司准备重新整理制作成为商城可售卖版本，然后又来了一个公司服务器租赁的 WebAPP 的项目，我春节期间的外包项目也没有做完。那么给我自身 CodeReview 的时间就不够了，所以需要一个 ESLint 的通配规则来减少我编写的时候小失误，虽然有自己的代码书写习惯，但是并没有强制要求自己，一直以来自己的 ESLint 配置仅具有错误预防功能，并没有使用一个通用的格式化风格，一直考虑的是使用 Airbnb config。 趁着 CLI 在创建项目下载依赖的时间，我想选择一个规则作为我自己的以后的编码风格，根据 CLI 给出的提示，默认可以配置的有三种： ESLint + Airbnb configdetail ESLint + Standard config detail ESLint + Prettier detail","text":"这段时间刚刚复工，年前的我负责的一个年会大屏系统公司准备重新整理制作成为商城可售卖版本，然后又来了一个公司服务器租赁的 WebAPP 的项目，我春节期间的外包项目也没有做完。那么给我自身 CodeReview 的时间就不够了，所以需要一个 ESLint 的通配规则来减少我编写的时候小失误，虽然有自己的代码书写习惯，但是并没有强制要求自己，一直以来自己的 ESLint 配置仅具有错误预防功能，并没有使用一个通用的格式化风格，一直考虑的是使用 Airbnb config。 趁着 CLI 在创建项目下载依赖的时间，我想选择一个规则作为我自己的以后的编码风格，根据 CLI 给出的提示，默认可以配置的有三种： ESLint + Airbnb configdetail ESLint + Standard config detail ESLint + Prettier detail 第一个 Airbnb 我是知道的，后边两个我并不了解，所以去搜索了一下，但是并没有找到一篇详细说明每个规则各自的风格特点，我就只能一个一个的去找，然后整理选择一个自己更喜欢的风格,并且保持下去。 但是我并没有找到一个简短代码片段可以展示它们各自的风格特点，所以就只能大概说一下： 如果使用 Airbnb 和 Standard 的风格那么就是以他人的书写风格来限制自己的书写习惯，并不自由但是强制代码风格统一，多人开发的时候让所有人代码风格感觉像是一个人写出来的，我觉得挺好的而且不需要考虑规则编辑，开箱即用慢慢适应就可以了。 如果使用 prettier 虽然会默认一种风格，但是是可以修改配置文件来达到最偏好的 lint 规则，但是多人开发时要不就选择默认要不就要大家一起讨论制定出一个规则来。如果每个人都配置了文件但是没有上传，或者上传了其他人修改了就会出现意外的警告。 所以我觉得个人开发会适合 prettier 一些，当然多人开发选择也不是不行，只是需要提前规范好，选择 Airbnb 和 Standard 的话就不需要考虑配置，安装了之后直接使用就可以了，适合多人开发以及喜欢开箱即用的人。 附eslint 在线规则配置","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"},{"name":"挖坑","slug":"挖坑","permalink":"https://yogwang.site/tags/%E6%8C%96%E5%9D%91/"},{"name":"ESlint","slug":"ESlint","permalink":"https://yogwang.site/tags/ESlint/"},{"name":"Coding","slug":"Coding","permalink":"https://yogwang.site/tags/Coding/"}]},{"title":"使用 npm-check-updates 更新全局依赖提示 No dependencies","slug":"update-global-dependencies-with-npm-check-updates","date":"2020-02-14T09:20:40.000Z","updated":"2021-05-29T03:33:28.281Z","comments":true,"path":"2020/update-global-dependencies-with-npm-check-updates/","link":"","permalink":"https://yogwang.site/2020/update-global-dependencies-with-npm-check-updates/","excerpt":"今天想起自己一直依赖没有更新全局依赖，就直接在 bash 里边输入 ncu -g 居然提示 No dependencies.我就纳闷了，打错命令了吗，为啥提示没有依赖？项目内依赖检查更新是没问题的，但是检测全局依赖就显示没有依赖，换了几个终端还是这个问题。我怀疑是我全局以来的路径设置错了(我是使用 npm 来安装全局依赖，yarn 安装项目依赖)查看了 npm 的全局依赖路径发现没错啊。","text":"今天想起自己一直依赖没有更新全局依赖，就直接在 bash 里边输入 ncu -g 居然提示 No dependencies.我就纳闷了，打错命令了吗，为啥提示没有依赖？项目内依赖检查更新是没问题的，但是检测全局依赖就显示没有依赖，换了几个终端还是这个问题。我怀疑是我全局以来的路径设置错了(我是使用 npm 来安装全局依赖，yarn 安装项目依赖)查看了 npm 的全局依赖路径发现没错啊。 然后去到了 npm-check-updates 的 Github 上找 Issues 看，是不是有解决办法了，但是相关的问题都被关闭了，然后提到的 Issue 里边答的也不一样， 最后在 Issue#146 上边看到了一个回答的思路，所以我就自己去查看源码了。 然后找到了一个问题所在 libs/package-managers/npm.js 中，有一个 defaultPrefix 函数，其中返回了全局依赖的路径，最后返回的数据是错误的。 function defaultPrefix(options) &#123; if (options.prefix) &#123; return Promise.resolve(options.prefix); &#125; const cmd &#x3D; process.platform &#x3D;&#x3D;&#x3D; &quot;win32&quot; ? &quot;npm.cmd&quot; : &quot;npm&quot;; return spawn(cmd, [&quot;config&quot;, &quot;get&quot;, &quot;prefix&quot;]).then(prefix &#x3D;&gt; &#123; &#x2F;&#x2F; FIX: for ncu -g doesn&#39;t work on homebrew or windows #146 &#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;tjunnone&#x2F;npm-check-updates&#x2F;issues&#x2F;146 return options.global &amp;&amp; prefix.match(&quot;Cellar&quot;) ? &quot;&#x2F;usr&#x2F;local&quot; : &#x2F;&#x2F; Workaround: get prefix on windows for global packages &#x2F;&#x2F; Only needed when using npm api directly process.platform &#x3D;&#x3D;&#x3D; &quot;win32&quot; &amp;&amp; options.global &amp;&amp; !process.env.prefix ? &#96;$&#123;process.env.AppData&#125;\\\\npm&#96; : null; &#125;); &#125; 这个函数查询了一个 prefix 的环境变量，但是在项目的 README 中并没有提到，可能是因为我修改全局依赖的安装目录的时候没有正确的在环境变量中添加新的全局依赖路径，所以他直接获取了默认的 AppData 地址。 解决方法 1.在系统的环境变量中添加名为 prefix 值为你的自定义全局路径即可。(PS.记得重启电脑) 2.修改 npm.js 的 169 行，把 process.env 替换为 npmConfig 也可以，就不需要重启电脑了… 以上","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"},{"name":"Node.js","slug":"Node-js","permalink":"https://yogwang.site/tags/Node-js/"}]},{"title":"一年结束，回顾2019","slug":"summary-at-the-end-of-2019","date":"2020-01-25T12:59:58.000Z","updated":"2021-05-29T03:33:19.444Z","comments":true,"path":"2020/summary-at-the-end-of-2019/","link":"","permalink":"https://yogwang.site/2020/summary-at-the-end-of-2019/","excerpt":"前言很快啊，2019 结束了，本来是不想写总结的，因为也没有啥可以总结的，毕竟中间离开了前端圈子一段时间，再回来基本都是接触的新东西。 按照我今年的认知来说，其实我从 16 年实习开始，一直在原地踏步，并没有成长多少，而且学的东西乱七八糟，基本都是业务用到了什么就学什么。 从 接触客户了解需求 到 前端 再到 后端 最后 运维，基本上都沾了点，然后除了 CSS 部分玩出了花，其他都是半瓶子水到处乱晃。 从学校离职之后去到成都就还是找的外包公司去作企业网站模板（当时自己也就这个拿手了，投的也大多都是这个类型的公司），所以技术栈就是 16 年学的那些东西。","text":"前言很快啊，2019 结束了，本来是不想写总结的，因为也没有啥可以总结的，毕竟中间离开了前端圈子一段时间，再回来基本都是接触的新东西。 按照我今年的认知来说，其实我从 16 年实习开始，一直在原地踏步，并没有成长多少，而且学的东西乱七八糟，基本都是业务用到了什么就学什么。 从 接触客户了解需求 到 前端 再到 后端 最后 运维，基本上都沾了点，然后除了 CSS 部分玩出了花，其他都是半瓶子水到处乱晃。 从学校离职之后去到成都就还是找的外包公司去作企业网站模板（当时自己也就这个拿手了，投的也大多都是这个类型的公司），所以技术栈就是 16 年学的那些东西。 然后离开成都到重庆帮女朋友做蛋糕，其实说是帮不如说是打下手，并没有帮到什么忙，多半顶个小工的作用。中间也去面试了一些公司，但是因为自己并没有实际的 Vue/React 项目所以并不如意，结果就是有大概将近 4 个月没有收入，欠下的信用卡也基本在这个时间段刷出来的。 好了废话就那么多，以下是 19 年的回顾。 📃 回顾 20194 月末离开重庆回到嘉兴面试，倒是挺顺利劳动节过了就入职（4 月 30 日拿到 Offer），然后开始学习 VueJS 这大半年下来，全家桶也学的七七八八， 从一开始的这是啥？为啥要这样写？不是绕圈子嘛。到后来 “哎嘛，真香。“ 当初给自己定的目标还算达标了，当初定的也算简单。 学习 Vue 全家桶 Vue.js Vue CLI（还只是处于会用阶段没有仔细看过文档） Vue Router Axios Vuex 使用全家桶做一个项目 拓展学习的部分 项目的包管理技术（npm、yarn 和 npx） 项目打包及编译（webpack 与 babel） WebSocket 长连接的使用（仿微信的客服聊天系统、后端远程控制） ElectronJS 打包成桌面应用 Git 和 SVN 的使用（自己使用 Git,公司项目使用 SVN） Jeecg-boot（VueJs 与 Ant Design of Vue） ThreeJS（年会活动的 WebGL 部分） 前端社区的活跃以及 Github 的使用 从学习到的东西来看，2019 年基本是我从初级前端向中级前端转变的一年。 5 月 正如开头写的一样，从最开始的只会使用 html + css 配合一些 js 或者 jQuery 来写一些企业站模板，到一个组件化的 SPA 项目。 其实回过头来看可能变化的并不多，只是了解一些以前并不清楚的概念，就比如 17 年我看 MeatHill 老师的 尬聊会，视频中提到的一些名词当初听的时候并不知道在说什么，可能一个小时下来听过也就听过了，直到今年再回过头来看才顺利整场听下来。 然后今年最感谢的一位就是 山地人 老师，通俗易懂的讲解了 Vue 全家桶，我最开始学习 VueJS 的思维屏障就是因为 【跟山地人学 Vue.js 系列教程】 打破的，到后边的 webpack 以及 babel 的学习都是一边看文档一边听老师的视频学习的。 当然光看教程不自己动手写 Demo 是不行的，一定要自己动手写 Demo 然后进行调试才能掌握。 6 月 接着就是自己入职之后的第一个项目，用 Vue 去写一个仿微信的客服聊天系统的前端部分，并使用 Electron 打包成桌面应用。那个时候刚刚里明白怎么用 Vue 去写一个单页面应用，怎么安装依赖都没有搞清楚，然后就直接上，还有自己看都没看的 WebSocket 和 瞄了一眼的 Electron。一开始进度很慢，还没有自己的一个书写习惯，然后想自己实例化 axios 也苦难重重，基本都是一边看别人的代码一边自己写。而且第三天，后端就在问 “你写的怎么样了，我这边都好了就等你接对口了”，然后和我说你是用 http 还是 TCP，我有点懵只能硬着头皮说随你，心想说啥我就百度啥呗。大概用了一周的时间出了测试版，然后开始调试，第二周打包上线。（开始整理 Electron 笔记的时间点） 后边就开始写公司的一个模块化商城，应该算是重构之前的一个项目，然后模块化出售。说是要 1 个月左右的时间开始内部测试，但是实际写了超过 2 个月，还没有写完，现在也没有后文了，（中间插进来了一个其它项目要做）现在回过头来看感觉想可能是自己之前动作太慢了，然后正好那个时候公司的安卓端开始测试 Flutter 的可行性，就当成了一个练手项目。Vue 全家桶就是在这个时期学习并运用起来的。 7 月 再就是不断的 3 天左右的小项目进来，一些小的系统查询单页面应用，基本第一天了解完需求之后，第二、第三天就要出结果。（这些项目反复强化自己的掌握程度） 接着就是这个 Blog 的开始，从今年 7 月开始，我把之前整理的笔记用写博客的方式重新整理了一遍，起初是想发布在 segmentfault 上的，但是总会觉得有点麻烦，而且没有文章分类的功能，不知道现在有没有这个功能了。 强迫自己复习学到的知识，查阅大量文档来巩固，确保自己的想法没有摸棱两可或者有错误的理解，也方便之后自己能够回过头来查阅。 然后也可以学习新的东西，比如现在 blog 所使用的 Hexo，就需要搭配 Github Pages ，因为我不想再去买 VPS 来放而且没有在 Github 托管来的方便。也可以顺带的使用 Git 的命令，不至于太久不用而忘记了。然后就遇到了百度不收录的问题，然后去做镜像来解决。 🚩 关于 2020 的小目标 学习 ReactJS 了解并开始使用单元测试 学习 VueJS 3.0 （如果更新 3.0 的话） 学习 TypeScript 了解 Svelte 阅读 《Code Complete》 阅读 《Clean Code》 学习了解 React Native 或 Flutter（如果有时间） 😝 2020 一起加油！ 王阳阳 庚子年 正月初一江南梅里","categories":[{"name":"生活杂谈","slug":"生活杂谈","permalink":"https://yogwang.site/categories/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"总结","slug":"总结","permalink":"https://yogwang.site/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"被忽略的两个 Background 新属性(CSS3)","slug":"CSS-neglected-background-attributes","date":"2020-01-18T07:04:16.000Z","updated":"2021-05-29T03:30:25.952Z","comments":true,"path":"2020/CSS-neglected-background-attributes/","link":"","permalink":"https://yogwang.site/2020/CSS-neglected-background-attributes/","excerpt":"之前在看一个文章的时候有提到过，background 的这两个属性，确实不常用到，以至于没有几个人知道这两个新属性。和他们同时期出的 background-size 因为经常用到所以被大众所熟知。 对的，这次我要说的是background-origin 和 background-clip 两兄弟","text":"之前在看一个文章的时候有提到过，background 的这两个属性，确实不常用到，以至于没有几个人知道这两个新属性。和他们同时期出的 background-size 因为经常用到所以被大众所熟知。 对的，这次我要说的是background-origin 和 background-clip 两兄弟 background-origin 规定背景的绘制区域。 background-clip 规定背景图片的定位区域。 可选值都是一样的三种： padding-box （相对于内边距框来定位/裁剪,background-origin 默认值） border-box （相对于边框盒来定位/裁剪，background-clip 默认值） content-box （相对于内容框来定位/裁剪） 哥俩好的 DEMObackground-origin background-clip 乍一看两兄弟的作用还是挺像的，可选值也是一样 啥？你问 background-clip 不是多了一个 text？还是草案没确定呢，经常会有草案被废弃的事发生，所以等什么时候通过了再说吧（ 虽然兼容性还行主流浏览器都兼容 查看兼容性 ） background-origin 是把背景图定位的起点修改成为设置的值得盒模型右上角，而 background-clip 则直接粗暴的把背景图按照盒模型进行了裁剪。 所以这俩可以做到什么？暂时还没有想好到底有啥应用场景，看以后会不会用到吧，怪不得会被人遗忘… 怪不得会有 text 这个属性的出现啊","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://yogwang.site/tags/CSS/"}]},{"title":"鼠标移出时颠倒元素过度效果","slug":"CSS-reverse-hover-transition","date":"2020-01-14T03:35:05.000Z","updated":"2021-05-29T03:30:19.335Z","comments":true,"path":"2020/CSS-reverse-hover-transition/","link":"","permalink":"https://yogwang.site/2020/CSS-reverse-hover-transition/","excerpt":"今天有一个小伙伴在群里问，怎么让鼠标经过的移出效果和移入效果相反。 比如说移入的时候先让元素增加宽度，接着增加高度，最后显示内部元素，鼠标移出的时候，先收缩高度隐藏元素，最后还原宽度。 看了一些回复有些答非所问，或者推荐用 Js 的。最开始想的是，animation 是不是有一个 direction 属性可以设置反向么，就想看 transition 是不是也有，但是并没有。CSS transition - MDN所以就想着用 :hover 来覆盖原先的 transition","text":"今天有一个小伙伴在群里问，怎么让鼠标经过的移出效果和移入效果相反。 比如说移入的时候先让元素增加宽度，接着增加高度，最后显示内部元素，鼠标移出的时候，先收缩高度隐藏元素，最后还原宽度。 看了一些回复有些答非所问，或者推荐用 Js 的。最开始想的是，animation 是不是有一个 direction 属性可以设置反向么，就想看 transition 是不是也有，但是并没有。CSS transition - MDN所以就想着用 :hover 来覆盖原先的 transition 精简后的 CSS 片段/* 导航元素 */ .nav-item &#123; width: 125px; height: 45px; /* 默认鼠标移出的补间 width 延迟.5s height 延时.3s */ transition: width 0.4s 0.5s, height 0.4s 0.3s; &#125; .nav-item:hover &#123; width: 200px; height: 83px; /* 鼠标移入的补间 width 无延迟 height 延时.3s*/ transition: width 0.4s, height 0.4s 0.3s; &#125; /* 子元素 */ .nav-item a &#123; opacity: 0; /* 默认的补间 opacity 无延迟 */ transition: opacity 0.4s; &#125; .nav-item:hover a &#123; opacity: 1; /* 鼠标移入的补间 opacity 延迟.5s */ transition: opacity 0.4s 0.5s; &#125; :hover 内的是鼠标移入补间，默认的是鼠标移出的补间，并且配合 transition-delay 来达成补间动画执行的顺序。 当鼠标移入 nav-item 时 :hover 内的 transition 会覆盖原先的补间，所以先是 无延时 的宽度改变，然后是 .3s 延时的高度改变，最后是 .5s 延时的子元素透明度补间。 等鼠标离开 nav-item 时 transition 就恢复成默认的，先改变 无延时 的子元素透明度，然后是 .3s 的高度改变，最后是 .5s 延时的宽度改变。 当然可以随意修改 transition-delay 来达到不同的补间动画执行顺序。 来看一下完成之后的 DEMO 吧！ 附transition CSS 属性是 transition-property，transition-duration，transition-timing-function 和 transition-delay 的一个简写属性。 所以使用时尽量按照此顺序书写 .tween &#123; transition: margin-right 2s ease-in-out 0.5s; /* 依次为:需要过渡的属性,持续时间,变化曲线,开始之前的等待时间 */ &#125; /* 等同于 */ .tween &#123; transition-property: margin-right; /* 需要过渡的属性 */ transition-duration: 2s; /* 持续时间 */ transition-timing-function: ease-in-out; /* 变化曲线 可以忽略不写 默认为 ease */ transition-delay: 0.5s; /* 开始之前的等待时间 可以忽略不写 默认为 0 */ &#125; 如果需要用到多个过度属性可以使用 all 来设置 transition-property，但是如果过度效果是不同的需要单独设置并且使用 , 来分割。 /* 设置多个不同过度属性 */ .tween &#123; transition: width 0.4s, height 1s 0.3s; &#125;","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://yogwang.site/tags/CSS/"}]},{"title":"使用 webpack 打包时去除注释和控制台日志","slug":"webpack-ignore-comments-logs","date":"2020-01-13T03:14:17.000Z","updated":"2021-05-29T03:33:50.081Z","comments":true,"path":"2020/webpack-ignore-comments-logs/","link":"","permalink":"https://yogwang.site/2020/webpack-ignore-comments-logs/","excerpt":"","text":"开一个坑，今天怎么尝试也都只能在打包的时候去除 console 但是注释还是不会被去除掉。","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"未完成","slug":"未完成","permalink":"https://yogwang.site/tags/%E6%9C%AA%E5%AE%8C%E6%88%90/"},{"name":"Webpack","slug":"Webpack","permalink":"https://yogwang.site/tags/Webpack/"}]},{"title":"Jeecg-boot 开发挖坑日记09 AntD 表单校验","slug":"jeecg-boot-devDiary09","date":"2020-01-09T03:20:11.000Z","updated":"2021-05-29T03:26:10.938Z","comments":true,"path":"2020/jeecg-boot-devDiary09/","link":"","permalink":"https://yogwang.site/2020/jeecg-boot-devDiary09/","excerpt":"之前开发的时间比较赶，所以在某些还没弄明白的地方我直接使用了 v-model 来绑定数据，没并没有使用 v-decorator，所以表单验证需要自己手动去写，异常提示也是需要单独的去做， 现在空下来了，重新整理了一下业务代码，总的来说大部分的表单元素都有demo可以对照着看，复杂的部分也只是上传组件或者一些联动的部分。","text":"之前开发的时间比较赶，所以在某些还没弄明白的地方我直接使用了 v-model 来绑定数据，没并没有使用 v-decorator，所以表单验证需要自己手动去写，异常提示也是需要单独的去做， 现在空下来了，重新整理了一下业务代码，总的来说大部分的表单元素都有demo可以对照着看，复杂的部分也只是上传组件或者一些联动的部分。 表单验证使用 this.$form.createForm() 创建的收集器，可以通过 validateFields 和 validateFieldsAndScroll 这两个api对收集器进行数据校验，当然需要提前在 form-item 中配置校验规则。 配置校验规则&lt;a-form-item> &lt;a-input v-decorator=\"['email',&#123; rules: [ &#123; required: true, message: '请输入您的电子邮箱!' &#125;, &#123; type: 'email', message: '请输入正确的电子邮箱号!' &#125;, ], &#125;]\" placeholder=\"您的电子邮箱 > &lt;a-icon slot=\"prefix\" type=\"mail\" /> &lt;/a-input> &lt;/a-form-item> 表单校验methods:&#123; // 保存 handleSubmit() &#123; // 触发表单验证 this.form.validateFields(['email', 'password'],(err, values) => &#123; // ['email', 'password'] 是需要校验的字段名 ... &#125;) &#125;, // 保存 handleSubmit() &#123; // 触发表单验证 this.form.validateFields(,(err, values) => &#123; // 也可以直接省略 [fieldNames] 校验全部数据 ... &#125;) &#125;, &#125; 这样每次在提交表单时就会触发数据校验，并且在 err 中会返回错误信息，values中返回校验过的数据，搭配 if(!err) 就可以完成业务操作了。 头像上传组件使用 Upload 组件的 picture-card 模式来作为头像上传组件，在@change事件中对 form 进行 setFieldsValue 来赋值给 a-input:hidden 这样就可以进行校验和返回值了。 &lt;template> &lt;a-form :form=\"form\" @submit.prevent=\"handleSubmit\"> &lt;a-form-item> &lt;a-upload listType=\"picture-card\" class=\"avatar-uploader\" :headers=\"headers\" :showUploadList=\"false\" :action=\"uploadURL\" :beforeUpload=\"beforeUpload\" @change=\"handleChange\" > &lt;img v-if=\"avatar\" :src=\"avatar\" alt=\"avatar\" style=\"width:100%;\" /> &lt;div v-else> &lt;a-icon :type=\"loading ? 'loading' : 'plus'\" /> &lt;div class=\"ant-upload-text\">Upload&lt;/div> &lt;/div> &lt;/a-upload> &lt;a-input type=\"hidden\" v-decorator=\"['avatar', validatorRules.avatar]\" /> &lt;/a-form-item> &lt;a-form-item> &lt;a-button type=\"primary\" html-type=\"submit\" block>保存&lt;/a-button> &lt;/a-form-item> &lt;/a-form> &lt;/template> &lt;script> export default &#123; name: 'UserInfoEdit', data() &#123; return &#123; avatar: '', loading: false, validatorRules: &#123; avatar: &#123; rules: [&#123; required: true, message: '请上传头像!' &#125;] &#125;, &#125;, form: this.$form.createForm(this), &#125; &#125;, methods:&#123; // 头像上传前检查 beforeUpload(file) &#123; const isLt2M = file.size / 1024 / 1024 &lt; 2 if (!isLt2M) &#123; this.$message.error('图片最大限制为2MB！') &#125; return isLt2M &#125;, // 头像修改 handleChange(info) &#123; if (info.file.status === 'uploading') &#123; this.loading = true return &#125; if (info.file.status === 'done') &#123; this.form.setFieldsValue(&#123; avatar: info.file.response.url &#125;) // 短链接提交给后端的数据 this.avatar = info.file.response.thumbUrl // 赋值给展示链接展示链接 this.loading = false &#125; &#125;, // 保存 handleSubmit() &#123; // 触发表单验证 this.form.validateFields((err, values) => &#123; if (!err) &#123; // 具体业务代码 &#125; &#125;) &#125;, &#125; &#125; &lt;/script> 当然也可以直接绑定在 Upload 组件上，我只是偷个懒不想再在验证之后去修改数据了。 动态校验规则比如说，可以修改上传数量限制。这个时候直接修改规则并不会直接重新验证，需要重新修改数据之后才会再次校验。 如果动态校验，需要校验的时候在 option 中加上 &#123; force: true &#125; // 伪代码片段 methods:&#123; // 保存 handleSubmit() &#123; // 触发表单验证 this.form.validateFields(&#123; force: true &#125;,(err, values) => &#123; ... &#125;) &#125;, &#125; 一个FormItem中多个被装饰过的表单元素有时候会遇到这样的的情况，在一个FormItem中有多个Input或者Select联动。 如果只是使用 v-decorator 来装饰会有警告提示： Warning: [antdv: Form.Item] Cannot generate &#96;validateStatus&#96; and &#96;help&#96; automatically, while there are more than one &#96;getFieldDecorator&#96; in it.&#96; 反正就是 一个 Form.Item 建议只放一个被 getFieldDecorator 或 v-decorator 装饰过的 child如果存在多个就需要自己配置 help, required, validateStatus，这点可以在 API文档 中看到。 如何配置呢？附一个伪代码例子 &lt;template> &lt;a-form :form=\"form\"> &lt;a-form-item :labelCol=\"labelCol\" :wrapperCol=\"wrapperCol\" label=\"地址\" :help=\"help\" :validateStatus=\"validateStatus\" > &lt;a-input-group compact> &lt;a-select style=\"width:33%\" placeholder=\" - \" v-decorator=\"['provinceId', validatorRules.provinceId]\" @change=\"handleCityChange\" > &lt;a-spin v-if=\"regionList.province.fetch\" slot=\"notFoundContent\" size=\"small\" /> &lt;a-select-option v-for=\"i in regionList.province.list\" :key=\"i.id\" :title=\"i.regionName\" >&#123;&#123; i.regionName &#125;&#125;&lt;/a-select-option> &lt;/a-select> &lt;a-select style=\"width:33%\" placeholder=\" - \" v-decorator=\"['cityId',validatorRules.cityId]\" @change=\"handleCityChange\" > &lt;a-spin v-if=\"regionList.city.fetch\" slot=\"notFoundContent\" size=\"small\" /> &lt;a-select-option v-for=\"i in regionList.city.list\" :key=\"i.id\" :title=\"i.regionName\" >&#123;&#123; i.regionName &#125;&#125;&lt;/a-select-option> &lt;/a-select> &lt;a-select style=\"width:33%\" placeholder=\" - \" v-decorator=\"['areaId', validatorRules.areaId]\" > &lt;a-spin v-if=\"regionList.area.fetch\" slot=\"notFoundContent\" size=\"small\" /> &lt;a-select-option v-for=\"i in regionList.area.list\" :key=\"i.id\" :title=\"i.regionName\" >&#123;&#123; i.regionName &#125;&#125;&lt;/a-select-option> &lt;/a-select> &lt;/a-input-group> &lt;/a-form-item> &lt;a-form-item :wrapperCol=\"offsetWrapperCol\"> &lt;a-button type='primary' @click=\"handleSubmit\">提交&lt;/a-button> &lt;/a-form-item> &lt;/a-form> &lt;/template> &lt;script> export default &#123; name: 'address-modal', data() &#123; return &#123; // 自定义校验信息 validateStatus: '', help: '', form: this.$form.createForm(this), confirmLoading:false, // 校验规则 validatorRules: &#123; provinceId: &#123; rules: [&#123; required: true, message: '请选择省份' &#125;] &#125;, cityId: &#123; rules: [&#123; required: true, message: '请选择城市' &#125;] &#125;, areaId: &#123; rules: [&#123; required: true, message: '请选择地区' &#125;] &#125;, &#125;, // 城市列表数据 regionList: &#123; province: &#123; list: [], fetch: false &#125;, city: &#123; list: [], fetch: false &#125;, area: &#123; list: [], fetch: false &#125; &#125;, // 表单栅格 labelCol: &#123; xs: &#123; span: 24 &#125;, sm: &#123; span: 5 &#125; &#125;, wrapperCol: &#123; xs: &#123; span: 24 &#125;, sm: &#123; span: 16 &#125; &#125;, offsetWrapperCol: &#123; xs: &#123; span: 24 &#125;, sm: &#123; span: 16, offset: 5 &#125; &#125;, &#125; &#125;, methods: &#123; handleSubmit() &#123; // 监听表单提交事件，触发表单验证 this.form.validateFields((err, values) => &#123; if (!err) &#123; // 这里是验证通过之后的操作 &#125; else &#123; // 校验失败，自定义校验信息 // 这边三个值依次取值，返回第一个有错误信息的属性 const onErr = err.provinceId || err.cityId || err.areaId if (onErr &amp;&amp; onErr.errors) &#123; // 如果有错误信息，设置错误状态 this.validateStatus = 'error' // 一个错误信息内部是校验内容是以数组的形式返回的，可以在data.validatorRules中的rules中看到顺序 this.help = onErr.errors[0].message &#125; else &#123; // 如果没有报错的情况 this.validateStatus = 'success' this.help = '' &#125; &#125; &#125;) &#125;, handleCityChange(value, option) &#123; // 这里是监听改变的业务逻辑，比如获取下级地址列表 &#125;, &#125; &#125; &lt;/script> 两种提交方式（存为草稿和保存发布）保存数据分委两种，一种是存为草稿，另一种是保存并发布； 存为草稿则只需要验证一部分必填字段，其它字段如果填写就校验，并且收集所有已经填写的字段。 保存校验所有字段，并且需要匹配所有规则。 暂时还没有想好，现阶段分开两个函数，存为草稿是在 validateFields 中的规则内填写需要校验的字段，并且在if(!err) 中，使用 getFieldsValue 获取整个表单数据 附： AntD Vue 1.5.0+ 增加了新组件FormModel 表单 可以通过 v-model 绑定收集数据，并且校验数据了","categories":[{"name":"踩坑日记","slug":"踩坑日记","permalink":"https://yogwang.site/categories/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"挖坑","slug":"挖坑","permalink":"https://yogwang.site/tags/%E6%8C%96%E5%9D%91/"},{"name":"Jeecg-boot","slug":"Jeecg-boot","permalink":"https://yogwang.site/tags/Jeecg-boot/"},{"name":"Ant-Design-Vue","slug":"Ant-Design-Vue","permalink":"https://yogwang.site/tags/Ant-Design-Vue/"}]},{"title":"如何让百度收录自己的Github Pages","slug":"How-to-make-GithubPage-included-by-Baidu","date":"2020-01-03T05:59:53.000Z","updated":"2021-08-03T09:49:19.006Z","comments":true,"path":"2020/How-to-make-GithubPage-included-by-Baidu/","link":"","permalink":"https://yogwang.site/2020/How-to-make-GithubPage-included-by-Baidu/","excerpt":"为何百度不收录 Github Pages ???起初还以为是应为自己写的文章很少关键词检索量不够所以没有被百度收录。等了有几个月，Google 和 Bing 都收录了，百度还是没有动静，就查了下为啥不会被收录… 结果最后发现因为早些年百度统计被劫持然后 DDos 攻击了 Github…对 Github 用户造成了可用性的问题，然后被 Github Ban 掉了，对百度 UA 直接 403。 所以只能靠自己来做一些工作让百度蜘蛛可以收录自己的 Github Pages 具体方式有几种，我选择在国内搭建一个镜像（成本最低，Hexo 支持多个 Git 地址）针对百度蜘蛛，解析到镜像服务器上以此来达到收录 Github Pages 的效果","text":"为何百度不收录 Github Pages ???起初还以为是应为自己写的文章很少关键词检索量不够所以没有被百度收录。等了有几个月，Google 和 Bing 都收录了，百度还是没有动静，就查了下为啥不会被收录… 结果最后发现因为早些年百度统计被劫持然后 DDos 攻击了 Github…对 Github 用户造成了可用性的问题，然后被 Github Ban 掉了，对百度 UA 直接 403。 所以只能靠自己来做一些工作让百度蜘蛛可以收录自己的 Github Pages 具体方式有几种，我选择在国内搭建一个镜像（成本最低，Hexo 支持多个 Git 地址）针对百度蜘蛛，解析到镜像服务器上以此来达到收录 Github Pages 的效果 国内代码托管平台有很多，这次尝试了两个，一个是 码云，一个是 Coding.net别问我为什么不用 vps，没钱！！！ 码云操作一同之后发现自定义域名需要会员，Coding 不需要。 就选择了 Coding，但是需要实名认证 1、注册 这个都不需要多说了吧….直接上链接吧。Coding.net SignUp 2、创建代码托管仓库 注册好了之后和使用 Github 一样，创建一个项目，选择 代码托管项目 。 项目名称随便填写，我直接填写的用户名因为 Github Pages 是这样要求的，但是 Coding 并没有这个要求；项目标识是你的 Git 仓库标识，起一个自己好记得就行。我输入的 blog，其实填写了项目名称会自动填写进去的。（这个是可以修改的，相应的也要修改本地 Git 的 Origin Url） 然后选择 Git仓库项目描述就随便填咯，反正也就自己用，后边不满意了也可以在项目设置里边修改。 3、绑定 SSH 公钥 创建完成之后在个人设置里边添加自己的 SSH 公钥，如果已经配置 Github Pages 的话这个也不用多说了吧 Coding.net 官方的 配置文档 我之前写的 Git 关联到 GigHub 配置完成之后在本地的 Git Bash 内执行 ssh -T git@e.coding.net，加入信任主机 途中遇到了 Permission denied (publickey). 这个问题 😂原因是自己本地 Git 配置的默认 Keygen 是另外一个，然后忘记自己用的是哪个 Keygen 了，尴尬一直在反复添加我觉得对的那个到 Coding 上，我说怎么一直被拒绝… 4、在 Hexo 内添加 Coding.net 上的仓库 打开自己本地的 Hexo 项目目录，找到根目录下的 _config.yml 文件，在最底部找到 deploy 项，修改 repo deploy: type: git repo: github: https:&#x2F;&#x2F;github.com&#x2F;&#123;username&#125;&#x2F;&#123;repositoryname&#125;.github.io coding: https:&#x2F;&#x2F;e.coding.net&#x2F;&#x2F;&#123;repositoryname&#125;&#x2F;&#123;gitname&#125;.git Hexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。 然后直接使用 hexo deploy/hexo d 就可以自动部署到两个远程仓库中了。 5、部署 Coding Pages 回到 Coding.net 项目中 找到项目左侧菜单中的 构建与部署 下的 静态网站项 点击立即发布静态网站 网站名称不重要，随便填自己能看明白就好；部署来源选择 本项目仓库；触发机制 自动部署；勾选 代码更新时自动部署，选择默认的 推送到 Master 时触发构建 这个是看你需要部署的是主线还是分支了，选择自己用的就好。 点击保存，完成创建。 这时候在页面中会显示你的 Coding Pages 访问地址，点击立即部署，这时候正常的话就会部署成功了。 然后点击在右上角的设置，进入 Coding Pages 设置后滑动到底部，将自己的域名添加到自定义域名列表中。 6、解析域名到 Coding Pages 在自己域名服务商的控制台添加解析记录，类型为 CNAME 这些应该都不用多说了吧。对应之前的解析记录增加不同的解析路线。 要注意的是如果只是想让百度蜘蛛爬取 Coding Pages，正常访问还是走的 Github Pages 的话，解析线路要设置成 百度。（如果想要国内访问 Coding Pages，海外 Github Pages 的话，Coding 的解析路径设置成默认，Github 设置成海外） 等待解析生效就可以在百度的 站长平台 提交 sitemap 让百度收录了 完成 问题申请 SSL/TLS 证书失败 Coding Pages 是免费提供 ssl/tls 证书的，这样以来部署的博客就支持 https 访问，证书到期前一周，系统自动续签。 但是按照我的这个流程下来申请证书会失败，原因是域名解析的问题，我的默认解析是到 Coding Pages 的，但是海外线路是解析到 Github Pages 上，先停用 Github Pages 的解析再申请，等证书申请成功后再恢复解析即可。 部署失败 EvilType: 21000：综合在最初的 Coding Pages 部署成功之后我在百度站长平台提交了 sitemap.xml， 但是我重新提交了新的文章之后，部署就出现了问题，原因是 Coding Pages 部署接入了腾讯云的 TMS 文本内容安全系统，TMS 识别到我的文章内有违规内容，从而部署失败，导致百度蜘蛛爬取 404（站点都没起来怎么爬取…） 但是我检查了好几遍并没有发现违规的内容,所以邮件联系了 Coding.net，官方回复是： 您好，由于相关政策因素，目前 Pages 的部署接入了系统级的自动审核，系统对于 Pages 的内容进行非常严格的排查，若是部署网站中出现涉政，涉黄，广告，链接 等内容，系统会自动判别为违规，无法部署成功，具体的违规内容涉及方向您可以参考 T-Sec 天御文本内容安全判别标准进行修正：https://cloud.tencent.com/product/tms ，给您造成的不便非常抱歉。 我加粗了问题出现的部分，不知道这个 TMS 管控是怎么识别链接的，现阶段的日志文件看只要我的文章内出现了一些引用链接，就会提示 EvilType: 21000：综合 ，Coding Pages 的自动部署就会失败： 2020&#x2F;01&#x2F;16 15:44:21 Fetching depot archive: Ref: refs&#x2F;heads&#x2F;master CommitSHA: 974e01660df7063b4d703d7286ae1e8f7dbd9538 2020&#x2F;01&#x2F;16 15:44:23 Extracting depot archive. 2020&#x2F;01&#x2F;16 15:44:24 The following file contains offending content: 2020&#x2F;01&#x2F;16 15:44:24 - Path: 2019&#x2F;CSS-text_truncation&#x2F;index.html 2020&#x2F;01&#x2F;16 15:44:24 - EvilType: 21000：综合 再次询问客服，回复： 目前是第三方做的检测，我们也在和第三方沟通，还请你耐心等待。 头疼，等一段时间再看吧。如果可以我应该会在之后更新文章，实在不行的话，在看看其它的代码托管平台。 2020.01.16 15:52 尊敬的 CODING 用户：关于 pages 部署时提示文件内容违规问题，我们这边已经联系开发进行定位，目前为了不影响用户使用，我们暂时下线该审查功能，您只需要重新部署一下 pages 即可。 23333，刚刚把文章编辑完，就收到 Coding.net 的通知，现在可以正常部署了，百度收录完成。但是不知道等审查重新上线还会不会被提示违规。 2020.01.16 16:47 2020 年 2 月 18 日更新尝试了几种方法，一直都是链接提交成功了，但是百度抓取网页，查看抓取频率一直都是 0，但是抓取诊断一直都是成功的。不知道什么原因，后边在尝试一下。 添加 robots.txt 无效 修改 DNS 解析 无效 2020 年 6 月 15 日更新突然被百度收录了，也不知道是为啥….因为 CodingNet 的自动部署服务关闭了，所以我国内镜像被我取消了，但是这次突然被收录了。 附 为什么 Github Pages 禁用了百度爬虫？ Github Pages 不被百度蜘蛛抓取的问题 T-Sec 天御 文本内容安全","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://yogwang.site/tags/Hexo/"},{"name":"Github","slug":"Github","permalink":"https://yogwang.site/tags/Github/"}]},{"title":"Js对象 调整属性排序是否有意义","slug":"JS-Object-attribute-sort","date":"2020-01-03T04:36:41.000Z","updated":"2021-05-29T03:25:28.152Z","comments":true,"path":"2020/JS-Object-attribute-sort/","link":"","permalink":"https://yogwang.site/2020/JS-Object-attribute-sort/","excerpt":"年会终于结束了，忙了一个月，终于可以开始填坑了。 昨天把之前写了一半的 滚动侦测导航 给写完了。 写的途中就有在思考 对象属性的排序问题， 最开始我是直接用数组的下标作为年份，输出的时候会出现一堆空白 item， 然后改成赋值给一个 timeline 对象，以年为属性名，月份为内部数组元素 但是循环输出内容的时候就发现会按照正序的方式去输出属性。比如我整理好的数据为","text":"年会终于结束了，忙了一个月，终于可以开始填坑了。 昨天把之前写了一半的 滚动侦测导航 给写完了。 写的途中就有在思考 对象属性的排序问题， 最开始我是直接用数组的下标作为年份，输出的时候会出现一堆空白 item， 然后改成赋值给一个 timeline 对象，以年为属性名，月份为内部数组元素 但是循环输出内容的时候就发现会按照正序的方式去输出属性。比如我整理好的数据为 const timeline = &#123; \"2020\": [\"01\"], \"2019\": [\"12\", \"11\", \"10\", \"09\", \"08\", \"07\", \"06\", \"05\", \"04\", \"03\", \"02\", \"01\"], \"2018\": [\"12\", \"11\", \"10\", \"09\"] &#125;; 那么我使用 Vue 的 v-for 循环输出的时候，其实是从 2018 开始的，配合 flex 布局是达到了效果，但是使用 Js 去滚动的时候出现了问题。自己也思考了很久，最后还是用数组的方式去实现了。 const timeline = [ &#123; year: \"2020\", months: [\"01\"] &#125;, &#123; year: \"2019\", months: [\"12\", \"11\", \"10\", \"09\", \"08\", \"07\", \"06\", \"05\", \"04\", \"03\", \"02\", \"01\"]&#125;, &#123; year: \"2020\", months: [\"12\", \"11\", \"10\", \"09\"] &#125; ]; 方式二 const timeline = [ [\"2020\", [\"01\"]], [\"2019\", [\"12\", \"11\", \"10\", \"09\", \"08\", \"07\", \"06\", \"05\", \"04\", \"03\", \"02\", \"01\"]], [\"2020\", [\"12\", \"11\", \"10\", \"09\"]] ]; 这种方式也行，而且代码更简洁，判断是否是新的一年时也方便很多。但是我觉得写 demo 这样可能不够明了还是用了数组包对象的方式来做。 然后昨天夜里刚填完坑，今天上午就有人在群里问对象的属性排序的问题。 正巧别人也有这个疑问，我就接着琢磨了。 然后在 segmentfault 上找到了一样的问题 Js 中如何调换对象属性的位置。 里边直接就有人提到了 意义何在 详细的回答 dablwow80：object 是无序的，看起来像添加顺序也不是稳定的，所以你改变 key 的“顺序”，以及利用这个“顺序”执行一些逻辑，都是不稳定的 具体原因我在大佬群里问了一下。 object 作为 javascript 的一种数据存储格式，采用哈希表的存取方式，而 hashmap 是不保证属性顺序的 基本可以理解为 object 数据存储是没有顺序的 所以，在对有数据顺序有要求的场景下，应该避免使用 object 来存取数据，尽量用 array 来替代。如果可以运用 Map 结构 来存储就可以自定义的顺序来使用。","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"}]},{"title":"CSS 实现条纹背景","slug":"CSS-striped-background","date":"2019-12-20T20:23:40.000Z","updated":"2021-05-29T03:30:15.970Z","comments":true,"path":"2019/CSS-striped-background/","link":"","permalink":"https://yogwang.site/2019/CSS-striped-background/","excerpt":"刚刚写年会红包雨的时候用到了 linear-gradient 来实现条纹背景，但是突然卡壳想不起来怎么写了。就去百度一下，所以现在把它记下来，方便以后查阅。","text":"刚刚写年会红包雨的时候用到了 linear-gradient 来实现条纹背景，但是突然卡壳想不起来怎么写了。就去百度一下，所以现在把它记下来，方便以后查阅。 基础部分使用 linear-gradient 实现没有渐变的色块 .color-block &#123; background: linear-gradient(#c498bc 50%, #81a2cf 0); &#125; 横向条纹再上一个基础之上增加 background-size 属性进行 repeat .stripe &#123; background: linear-gradient(#c498bc 50%, #81a2cf 0); background-size: 100% 30px; // 宽度100%, 高度30px 如果没有no-repeat的话他会一直铺满整个div &#125; 竖直条纹再在上一个的基础之上增加 linear-gradient 的朝向，然后交换 background-size 的宽高 .stripe &#123; // 向右填色 如果是 'to left' 就是向左填色 background: linear-gradient(to right, #c498bc 50%, #81a2cf 0); background-size: 30px 100%; // 宽度30px, 高度100% &#125; 倾斜条纹倾斜条纹的话就相对麻烦一点了，如果只修改 linear-gradient 的朝向为角度那么就会出现下边这个情况： .stripe1 &#123; background: linear-gradient(45deg, #c498bc 50%, #81a2cf 0); background-size 30px 100%; &#125; 所以要修改 background-size ,但是只是这样也会有问题： .stripe2 &#123; background: linear-gradient(45deg, #c498bc 50%, #81a2cf 0); background-size 30px 30px &#125; 结果是会形成一小块一小块的斜线色块，而不是整个倾斜条纹 所以按照现象修改 linear-gradient 之后为： .stripe3 &#123; background: linear-gradient(45deg, #c498bc 25%, #81a2cf 0, #81a2cf 50%, #c498bc 0, #c498bc 75%, #81a2cf 0 ); background-size 30px 30px &#125; 简单的实现时没问题了，但是感觉太长了。如果要简化的话，需要使用的是 repeating-linear-gradient .stripe4 &#123; background: repeating-linear-gradient( 45deg, #81a2cf, #81a2cf 15px, #c498bc 0, #c498bc 30px ); &#125; 这样的话只需要一行就可以实现 .stripe3 的效果了。 以上2019/12/21 05：00","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://yogwang.site/tags/CSS/"}]},{"title":"年会开发日记03 - WebSocket长连接获取微信签到用户信息","slug":"AnnualParty-devDiay03","date":"2019-12-20T11:35:24.000Z","updated":"2021-05-29T03:30:48.784Z","comments":true,"path":"2019/AnnualParty-devDiay03/","link":"","permalink":"https://yogwang.site/2019/AnnualParty-devDiay03/","excerpt":"接着 年会开发日记 01 的签到墙，里边用到了 WebSocket 来实现用户微信扫码签到，然后后端推送签到用户信息到前端，前端收到数据之后创建元素添加到 3D 墙中。 本来是想直接自己写的，但是有后来又加入了礼品活跃气氛，就要用到用户列表的展示和抽取过程中的随机效果，虽然哪些人获奖是后台返回给我的。所以这些用户信息需要在多组件内共用，那我就懒得自己写了，就去找了 Vue 的组件库了。","text":"接着 年会开发日记 01 的签到墙，里边用到了 WebSocket 来实现用户微信扫码签到，然后后端推送签到用户信息到前端，前端收到数据之后创建元素添加到 3D 墙中。 本来是想直接自己写的，但是有后来又加入了礼品活跃气氛，就要用到用户列表的展示和抽取过程中的随机效果，虽然哪些人获奖是后台返回给我的。所以这些用户信息需要在多组件内共用，那我就懒得自己写了，就去找了 Vue 的组件库了。 参与用户 抽奖效果 所以在 Awesome Vue 中了找了一些关于 Websocket 的插件 vue-socket.io vue-websocket vue-native-websocket 其中 vue-socket.io 和 vue-websocket 是基于 socket.io 的所以需要后端也是 Socket.io 遂放弃，不然会连接上之后会请求服务端的 login 方法，如果服务端不是的话，会不断轮询。 vue-native-websocket顾名思义，就是原生的 WebSocket，并且可以使用 Vuex native websocket implementation for Vuejs 2 and Vuex 安装依赖以后，简单配置一下就可以使用了。 import VueNativeSock from \"vue-native-websocket\"; Vue.use(VueNativeSock, \"ws://localhost:9090\"); 也可以启动 Vuex import VueNativeSock from \"vue-native-websocket\"; import store from \"./store\"; Vue.use(VueNativeSock, \"ws://localhost:9090\", &#123; store: store &#125;); 具体可以看作者写的说明文档，怎么在 Vue 实例中使用和怎么配合 Vuex 和一些基础事件函数","categories":[{"name":"踩坑日记","slug":"踩坑日记","permalink":"https://yogwang.site/categories/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"},{"name":"年会开发日记","slug":"年会开发日记","permalink":"https://yogwang.site/tags/%E5%B9%B4%E4%BC%9A%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0/"},{"name":"WebSocket","slug":"WebSocket","permalink":"https://yogwang.site/tags/WebSocket/"}]},{"title":"年会开发日记02 - 红包雨","slug":"AnnualParty-devDiay02","date":"2019-12-17T13:12:50.000Z","updated":"2021-05-29T03:30:50.452Z","comments":true,"path":"2019/AnnualParty-devDiay02/","link":"","permalink":"https://yogwang.site/2019/AnnualParty-devDiay02/","excerpt":"鸽了6个月了，终于想起来这篇还没有写完… 年会预备了一个红包雨的活动，虽然到最后也没有用上，但是笔记还是要写的。整个流程是关注公众号，然后回复 抢红包 返回一个授权地址获取用户授权信息，然后跳转到活动h5页面，抢红包的同时会在大荧幕上实时展示排名数据。","text":"鸽了6个月了，终于想起来这篇还没有写完… 年会预备了一个红包雨的活动，虽然到最后也没有用上，但是笔记还是要写的。整个流程是关注公众号，然后回复 抢红包 返回一个授权地址获取用户授权信息，然后跳转到活动h5页面，抢红包的同时会在大荧幕上实时展示排名数据。 📱 先说说手机端部分 手机端的部分其实很简单，从url上边获取用户的 openID,然后请求接口返回用户信息，这个时候也会返回活动是否开始的状态 活动并没有开始，那么就进入手动进入的页面，用户手动点击按钮进入 活动入口页； 活动已经开始则直接进入 预开始页； 缺失openID，提示授权失败返回授权页面重新获取授权。 参与用等待大荧幕指令，在大银幕倒数时就可以点击开始按钮进入同步的倒计时页面，同时会请求后端数据，这个时候后端会返回给我该用户被分配到的金额（哈，你没看错，后台已经按照设置的总金额给每个用户分配好了红包金额），然后按照分配到的金额数来判断是否会刷出 188、88 等大红包，怕用户错过这个大红包还做了特殊的样式（金色红包），剩下的金额则按照设置的持续时间数来生成具体的红包雨，一般来说会在收到数据的同时生成完红包雨数据，倒计时结束之后就开始下落。 生成红包金额代码片段// 红包金额分配 rainBuild() &#123; let total = this.info.amount; // 总金额 let lucky = []; // 红包雨数组 // 分配188红包 if (total > 18800) &#123; total -= 18800; lucky.push(&#123; amount: 18800 &#125;); &#125; // 分配88红包 if (total > 8800) &#123; total -= 8800; lucky.push(&#123; amount: 8800 &#125;); &#125; const timer = 10; // 拆分成10组 let data = []; // 临时红包数据 // 红包雨数量限制 const length = Math.max( Math.ceil(((this.info.duration / 1000) * 4) / timer), 1 ); // 平均每组金额 const amount = total / timer; // 循环生成每组红包数据 for (let i = 0; i &lt; timer; i++) &#123; let temp = this.randomAlloc(amount, length, 0, amount); // 传入数据为 金额，数量，最小金额，最大金额 data.push(...temp); &#125; // 打乱红包数据 if (lucky.length) &#123; lucky.forEach(item => &#123; let random = Math.floor(Math.random() * (data.length - 10)); data.splice(random, 0, item); &#125;); &#125; this.data = data; &#125; // 金额生成 randomAlloc(total, length, min, max) &#123; // 首先要判断是否符合 min 和 max 条件 if (min * length > total || max * length &lt; total) &#123; throw Error(`没法满足最最少 $&#123;min&#125; 最大 $&#123;max&#125; 的条件`); &#125; const result = []; let restValue = total; let restLength = length; for (let i = 1; i &lt; length; i++) &#123; restLength--; // 这一次要发的数量必须保证剩下的要足最小量 // 同进要保证剩下的不能大于需要的最大量 const restMin = restLength * min; const restMax = restLength * max; // 可发的量 const usable = restValue - restMin; // 最少要发的量 const minValue = Math.max(min, restValue - restMax); // 以 minValue 为最左，max 为中线来进行随机，即随机范围是 (max - minValue) * 2 // 如果这个范围大于 usable - minValue，取 usable - minValue const limit = Math.min(usable - minValue, (max - minValue) * 2); // 随机部分加上最少要发的部分就是应该发的，但是如果大于 max，最大取到 max const amount = Math.min( max, minValue + Math.floor(limit * Math.random()) ); result.push(&#123; amount: amount &#125;); restValue -= amount; &#125; result[length - 1] = &#123; amount: Math.floor(restValue) &#125;; return result; &#125;, 下落的具体代码我从Github上找了一个开源的红包下落的构造函数，然后按照公司的需求改写了一下，直接贴上来吧： function luckyMoney(options) &#123; this.el = options.el; // 容器对象 this.rain = []; // 红包雨数组 this.speed = options.speed; // 红包落下的速度 this.density = options.density; // 红包下落的密度 this.callback = options.callback; // 回调 &#125; // 创建红包 luckyMoney.prototype.create = function(id, amount) &#123; const el = this.el, // 容器 lucky = document.createElement(\"span\"); // 创建一个span元素 let flag = true; // 标志为true lucky.setAttribute(\"amount\", amount); // 设置红包金额 lucky.setAttribute(\"title\", (amount / 100).toFixed(2)); // 设置红包金额 lucky.className = \"luckyMoney\"; // 设置类名 luckyMoney if (amount > 1000) lucky.setAttribute(\"lucky\", \"lucky\"); lucky.style.left = Math.random() * (el.clientWidth * 0.5) + el.clientWidth * 0.2 + \"px\"; // 设置 left 初始位置 lucky.style.top = -el.clientHeight / 10 + \"px\"; // 设置 top 初始位置 el.appendChild(lucky); // 把虚拟节点添加到容器内 this.rain.push(lucky); // 把红包元素添加到红包雨数组内 this.move(lucky); // 开始移动红包元素 // 打开红包 var handler = e => &#123; // 如果flag为真 -> 红包未点开过 if (flag === true) &#123; e.target.className = \"luckyMoney opened\"; // 添加已打开类名 opened this.callback(e); // 回调 flag = false; // 标志改为false &#125; else &#123; return; // 跳出 &#125; &#125;; // 添加触摸事件 document.addEventListener(\"touchstart\", function(e) &#123; // 如果被点击的元素类名为 luckyMoney if (e.target.className === \"luckyMoney\") &#123; handler(e); // 触发红包打开事件 &#125; else if (e.target.getAttribute(\"amount\") === \"0\") &#123; e.target.className = \"luckyMoney luckyMoneyNone\"; // 如果红包金额为 0修改类名为 luckyMoneyNone &#125; else &#123; return false; // 其它直接返回 &#125; &#125;); &#125;; // 红包开始下落 luckyMoney.prototype.start = function(data) &#123; let i = 0; // 计数器 // 按照红包密度时间创建红包 this.timer = setInterval(() => &#123; // 如果没有超过红包总数 if (i &lt; data.length) &#123; const id = data[i].id, // 红包ID amount = data[i].amount; // 包红金额 this.create(id, amount); // 创建红包对象 i++; // 计数器+1 &#125; &#125;, this.density); &#125;; // 红包下落停止 luckyMoney.prototype.stop = function() &#123; clearInterval(this.timer); // 清除计时器 // 清除所有红包的移动计时器 this.rain.forEach(rain => &#123; clearInterval(rain.timer); &#125;); &#125;; // 红包移动 luckyMoney.prototype.move = function(rain) &#123; const el = this.el; // 容器 let diffY = Math.random() / 2 + 0.4, // 垂直上的轻微偏移 diffX = Math.random() / 2; // 水平上的轻微偏移 const amount = rain.getAttribute(\"amount\"); // 特殊红包大于10元重置为缓落 if (amount > 1000) &#123; diffY = 0.4; diffX = Math.random() / 10; &#125; // 红包移动按照设置的速率 rain.timer = setInterval(() => &#123; // 如果y轴偏移吵过1.5 if (diffY > 1.5) &#123; // 设置红包雨的 left 值 rain.style.left = parseInt(rain.style.left) + parseInt((diffX * rain.clientHeight) / 30) + \"px\"; &#125; else &#123; // 设置红包雨的 left 值 rain.style.left = parseInt(rain.style.left) - parseInt((diffX * rain.clientHeight) / 30) + \"px\"; &#125; // 设置红包雨的 top 值 rain.style.top = parseInt(rain.style.top) + parseInt((diffY * rain.clientHeight) / 20) + \"px\"; const position = &#123; top: parseInt(rain.style.top), left: parseInt(rain.style.left) &#125;; if ( position.top > el.clientHeight || position.left > el.clientWidth || position.left &lt; -100 ) &#123; // 超出屏幕过后，清除定时器，删除红包 clearInterval(rain.timer); el.removeChild(rain); &#125; &#125;, this.speed); &#125;; // 时间停止时清除剩余红包 luckyMoney.prototype.clear = function() &#123; const el = this.el, // 容器 redItem = el.childNodes; for (let i = redItem.length - 1; i > -1; i--) &#123; el.removeChild(redItem[i]); &#125; &#125;; export default luckyMoney; 每次点开红包之后会收集金额到 tempMoney 和 totalMoney中，并且提交到后台然后清空 tempMoney（这边做了1秒的节流操作），这样大银幕就能展示当前轮次的 Top5 用户。 手机端的大部分内容就是这样了，主要是下落这块比较麻烦，其它的都是一些样式的问题，稍微调试一下就行了。 🏮大荧幕部分 大银幕这块的话就容易很多了，本来是考虑用 WebSocket 来实时传输红包排名的，但是发现还不如轮询简单，所以还是我这边做了1秒间隔的轮询。获取到数据之后跟新排名数据，界面就会实时刷新了，这边在展示用户排名时做了动画，每次用户新进和排名更替都会进行左右移动，并不只是简单的修改了展示的数据。 用到了transform的偏移量来修改展示的位置，这样就可以通过修改元素次序来打到用户排名更替补间动画了 Stylus片段.rank-box width 90% height 300px max-width 1600px display flex justify-content space-around position absolute left 50% bottom 5vh z-index 5 transform translateX(-50%) .lucky-box width 180px height 260px line-height 25px font-size 18px background url(&#39;~assets&#x2F;img&#x2F;luckyBox.png&#39;) center no-repeat background-size 100% 100% padding 20px border-radius 15px border #d5b06e 3px solid box-shadow 10px 10px 32px rgba(black, 0.45) display flex justify-content center align-items center flex-direction column position absolute left 50% bottom 0 transform translateX(800px) opacity 1 transition all 0.5s box-sizing border-box &amp;:nth-child(1) transform translateX(-350%) z-index 10 &amp;:nth-child(2) transform translateX(-200%) z-index 9 &amp;:nth-child(3) transform translateX(-50%) z-index 8 &amp;:nth-child(4) transform translateX(100%) z-index 7 &amp;:nth-child(5) transform translateX(250%) z-index 6 &amp;:nth-child(5)~.lucky-box transform translateX(800px) z-index 5 opacity 0 .avatar width (@width &#x2F; 2) height @width border #d5b06e 4px solid border-radius 50% margin 0 auto 10px display block","categories":[{"name":"踩坑日记","slug":"踩坑日记","permalink":"https://yogwang.site/categories/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"},{"name":"年会开发日记","slug":"年会开发日记","permalink":"https://yogwang.site/tags/%E5%B9%B4%E4%BC%9A%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0/"}]},{"title":"Javascript 滚动侦测导航","slug":"JS-navigation-detection","date":"2019-12-09T15:40:07.000Z","updated":"2021-05-29T03:25:30.347Z","comments":true,"path":"2019/JS-navigation-detection/","link":"","permalink":"https://yogwang.site/2019/JS-navigation-detection/","excerpt":"一个以前的小项目要改，新增一个根据时间线显示不同月份绩效的需求。没有设计稿，想了下怎么做出来好看。就有了以下这个想法 左侧显示时间线，滑动会显示不同的年份和月份，右侧显示不同月份的统计数据。","text":"一个以前的小项目要改，新增一个根据时间线显示不同月份绩效的需求。没有设计稿，想了下怎么做出来好看。就有了以下这个想法 左侧显示时间线，滑动会显示不同的年份和月份，右侧显示不同月份的统计数据。 为了显示这个想法不是很蠢，所以需要做的很 酷炫 ，其实就是交互友好些，左右块都有相应的交互动作。 预想的效果设想的是，点击左侧月份之后右侧会快速滚动到相应的月份，方便用户操作。当然右侧下滑操作的时候左侧的时间线也会对应的滚动。 那么就要用到滚动侦测了，以前都是用的 UI 框架里边的，所以这次也是直接去翻阅了这个项目所用到的 UI，MuseUI 的文档，当然里边没有这个组件，不然也不会有这篇笔记了 去翻阅了一下 BootStrap 的 Scrollspy 源码，其实就是用到了内容元素的 offsetTop 和滚动条的监听 后端给的数据格式是类似这样的 &#123; date:&#39;2020-01&#39;, detail:&#123; a:100, b:78, total:178, machines:967 &#125;, note:&#39;some text of 2020-01&#39; &#125;, 所以可以直接使用 computed 返回所有的月份，对，我使用的 Vue 作为框架。 computed: &#123; timeline() &#123; let list = []; const data = this.sourceData; if (!data) return list; data.forEach(item => &#123; const date = item.date.split(\"-\"); const year = list.find(item => item.year === date[0]); if (year) &#123; year.months.push(date[1]); &#125; else &#123; list.push(&#123; year: date[0], months: [date[1]] &#125;); &#125; &#125;); return list; &#125;, &#125;, 尝试过直接使用对象，用年份作为字段名，但是使用 v-for 循环的时候会按照升序打印出来，折腾了有一会放弃了，还是使用数组，记不得前段时间自己是怎么直接用对象实现的时间分组的了 😂 -&gt; Js 对象 调整属性排序是否有意义其实差不多只是匹配的时候稍微麻烦点需要用到 find() 方法。 然后也根据后台返回的数据来计算右侧内容部分每一个月份的 offsetTop computed:&#123; offsetList() &#123; const list = this.$refs[\"month-detail\"]; let data = list.map(el => &#123; return &#123; date: el.getAttribute(\"date\"), offset: el.offsetTop - 100 &#125;; &#125;); return data; &#125; &#125; 这块其实很简单，直接在循环输出的时候注册 ref 即可，然后直接遍历 DOM 元素数组保存 offsetTop 。（但是如果是动态改变的DOM就不能使用 computed 来计算了，具体查看 使用VueJS的计算属性监听DOM元素属性的问题） 然后是点击左侧时间轴右侧内容部分滚动到对应的月份， methods:&#123; // 跳转到对应月份 toMonth(year, month) &#123; this.currTime = `$&#123;year&#125;-$&#123;month&#125;`; const detailItem = this.offsetList.find( item => item.date === this.currTime ); this.$refs[\"wrap\"].scrollTo(&#123; top: detailItem.offset, behavior: \"smooth\" &#125;); &#125;, &#125; 这里有一个 Js 的新东西 behavior: &quot;smooth&quot; 是原生滚动的一个新 API，应该是新 API 哈，以前都没有见到过，这次才发现有这个 Option，也可以考虑使用 CSS 来实现，但是听说兼容性堪忧。最后加上右侧内容的滚动事件绑定 &lt;div class=&quot;wrap&quot; ref=&quot;wrap&quot; @scroll=&quot;scrollSpyNav&quot;&gt; watch: &#123; currTime() &#123; this.scrollTimeline(); &#125; &#125;, methods:&#123; // 滚动侦测导航 scrollSpyNav(e) &#123; clearTimeout(this.timer); const offsetTop = e.target.scrollTop; const curr = this.offsetList.find(item => item.offset >= offsetTop); this.timer = window.setTimeout(() => &#123; this.currTime = curr.date; &#125;, 300); &#125;, // 滚动左侧时间线 scrollTimeline() &#123; const el = this.$refs[\"month-block\"].find( item => item.getAttribute(\"date\") === this.currTime ); this.$refs[\"timeline\"].scrollTo(&#123; top: el.offsetTop - 50, behavior: \"smooth\" &#125;); &#125;, &#125; 直接使用了 watch 来侦听的了日期的改变，来触发左侧时间线的滚动，也实现了点击时间轴自动置顶当前月份的效果。顺带写了个计时器，防止抖动…. 🌰 DEMO 兼容 JavaScript - scrollTo [MDN] CSS - scroll-behavior:smooth [Can I use]","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"}]},{"title":"PHPOK 不能创建项目和修改项目信息","slug":"phpok-create-project-failed","date":"2019-12-04T16:10:29.000Z","updated":"2021-05-29T03:32:47.832Z","comments":true,"path":"2019/phpok-create-project-failed/","link":"","permalink":"https://yogwang.site/2019/phpok-create-project-failed/","excerpt":"今天写网站的时候直接用了以前的 CMS 框架，并没有在官网下载最新版的。 安装完成之后发现项目不能创建和修改，想起之前做的时候也遇到过这个问题，但是之前的网站，整体的项目总数比初始填充数据少，直接在数据库里边修改了，并且在讨论群和开发团队提了一下。 这次又遇到了在这个问题，就想着开发团队应该解决了这个问题吧，就把程序更新到了最新的 version 5.4，结果还是不行。 去看了下更新日志，就没有提这茬，估计忙忘记了。 好吧，自己动手丰衣足食，自己改吧。","text":"今天写网站的时候直接用了以前的 CMS 框架，并没有在官网下载最新版的。 安装完成之后发现项目不能创建和修改，想起之前做的时候也遇到过这个问题，但是之前的网站，整体的项目总数比初始填充数据少，直接在数据库里边修改了，并且在讨论群和开发团队提了一下。 这次又遇到了在这个问题，就想着开发团队应该解决了这个问题吧，就把程序更新到了最新的 version 5.4，结果还是不行。 去看了下更新日志，就没有提这茬，估计忙忘记了。 好吧，自己动手丰衣足食，自己改吧。 打开控制台查看 Network 请求，发现 Response 里边直接提示了 SQL 执行失败，请检查。 打开 SQL 的调试模式后，详细的报错信息是： 随即找到 control 文件， framework\\admin\\project_control.php 并且在第 326 行找到了 is_api 的赋值语句，把它注释掉。 返回项目管理界面，提交保存 完事，顺便在群里又提了一下，也在论坛发了帖子，这次应该会解决这个问题了吧…","categories":[{"name":"工作延伸","slug":"工作延伸","permalink":"https://yogwang.site/categories/%E5%B7%A5%E4%BD%9C%E5%BB%B6%E4%BC%B8/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://yogwang.site/tags/PHP/"},{"name":"PHPOK","slug":"PHPOK","permalink":"https://yogwang.site/tags/PHPOK/"}]},{"title":"年会开发日记01 - 3D签到墙","slug":"AnnualParty-devDiay01","date":"2019-12-03T02:01:35.000Z","updated":"2021-05-29T03:30:51.941Z","comments":true,"path":"2019/AnnualParty-devDiay01/","link":"","permalink":"https://yogwang.site/2019/AnnualParty-devDiay01/","excerpt":"年会签到做到最后特效实现的部分，使用 Js 来不断绘制 Canvas 会出现擦除背景图的情况，而且并不流畅，所以又考虑了下 CSS3 的动画属性，可是 Javascript 并不能控制 CSS3 动画。 昨天折腾到晚上 10 点还没怎么好的思路，今天看到一个开源 WebGL Js 库 👉 ThreeJs.org","text":"年会签到做到最后特效实现的部分，使用 Js 来不断绘制 Canvas 会出现擦除背景图的情况，而且并不流畅，所以又考虑了下 CSS3 的动画属性，可是 Javascript 并不能控制 CSS3 动画。 昨天折腾到晚上 10 点还没怎么好的思路，今天看到一个开源 WebGL Js 库 👉 ThreeJs.org 前置文章 Canvas 识别图片内容并使用用户头像拼接 中间不断重写和踩坑的过程就省略了，主要自己也记不得了…. ThreeJS 的 examples 中有一个 Demo 和需求简直一摸一样 👉 CSS3D - Periodic Table 读了一下源码并且添加了释。 import * as THREE from '../build/three.module.js'; import &#123; TWEEN &#125; from './jsm/libs/tween.module.min.js'; import &#123; TrackballControls &#125; from './jsm/controls/TrackballControls.js'; import &#123; CSS3DRenderer, CSS3DObject &#125; from './jsm/renderers/CSS3DRenderer.js'; var table = [...]; var camera, scene, renderer; var controls; var objects = []; var targets = &#123; table: [], sphere: [], helix: [], grid: [] &#125;; init(); animate(); function init() &#123; // 创建一个透视相机 视角40，宽高比窗口内宽度/高度，近场1，远场1000 camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 10000 ); camera.position.z = 3000; // 相机置于 z - 3000 scene = new THREE.Scene(); // 创建场景对象 // table 元素周期表 // 循环创建所有数据 for ( var i = 0; i &lt; table.length; i += 5 ) &#123; // 创建一个新的div元素 var element = document.createElement( 'div' ); element.className = 'element'; // 设置类名为 element element.style.backgroundColor = 'rgba(0,127,127,' + ( Math.random() * 0.5 + 0.25 ) + ')'; // div.element 设置背景色 rgba // 创建一个新的div元素 var number = document.createElement( 'div' ); number.className = 'number'; // 设置类名为 number number.textContent = ( i / 5 ) + 1; // div.number 设置文本内容为 i/5 +1 element.appendChild( number ); // 把 div.number 添加到 div.element 内 // 创建一个新的div元素 var symbol = document.createElement( 'div' ); symbol.className = 'symbol'; // div.symbol 设置类名为symbol symbol.textContent = table[ i ]; // div.symbol 的文本内容为 table[i]的内容 element.appendChild( symbol ); // 把 div.symbol 添加到 div.element 内 // 创建一个新的div元素 var details = document.createElement( 'div' ); details.className = 'details'; // 设置类名为 details // div.details 的 html 赋值为 table[ i + 1 ] + '&lt;br>' + table[ i + 2 ] details.innerHTML = table[ i + 1 ] + '&lt;br>' + table[ i + 2 ]; element.appendChild( details ); // 把 div.details 添加到 div.element 内 // 创建一个新的 CSS3D 对象 var object = new CSS3DObject( element ); object.position.x = Math.random() * 4000 - 2000; // 设置 3D对象的 x轴 位置 区间 -2000 ~ 2000 object.position.y = Math.random() * 4000 - 2000; // 设置 3D对象的 y轴 位置 object.position.z = Math.random() * 4000 - 2000; // 设置 3D对象的 z轴 位置 scene.add( object ); // CSS3D 添加对象到场景中 objects.push( object ); // 把 CSS3D 填加到 objects 中 // Object3D // New一个新的三维对象 var object = new THREE.Object3D(); object.position.x = ( table[ i + 3 ] * 140 ) - 1330; // 设置物体的 x轴 位置 object.position.y = - ( table[ i + 4 ] * 180 ) + 990; // 设置物体的 y轴 位置 targets.table.push( object ); // 把object添加到 targets.table 中 &#125; // sphere 球形数据 var vector = new THREE.Vector3(); // 创建一个新的三维向量 // 循环创建所有数据 for ( var i = 0, l = objects.length; i &lt; l; i ++ ) &#123; var phi = Math.acos( - 1 + ( 2 * i ) / l ); // 设置 分割比/phi var theta = Math.sqrt( l * Math.PI ) * phi; // 设置 半径/l 角度/theta // 创建一个新的三维对象 var object = new THREE.Object3D(); object.position.setFromSphericalCoords( 800, phi, theta ); // 设置向量 在球体坐标中 vector.copy( object.position ).multiplyScalar( 2 ); // 复制向量给 object，将该向量与 2 相乘。 object.lookAt( vector ); // 将 object 朝向三维向量的方向 targets.sphere.push( object ); // 把 object 添加到 targets.sphere 中 &#125; // helix 螺旋圆柱的数据 var vector = new THREE.Vector3(); // 创建一个新的三维向量 // 循环创建所有数据 for ( var i = 0, l = objects.length; i &lt; l; i ++ ) &#123; var theta = i * 0.175 + Math.PI; // 设置 角度 theta var y = - ( i * 8 ) + 450; // 设置 y 这边我修改成了 y = i * 1 - (l * 1) / 2 按对象数量去修改y值 // 创建一个新的三维对象 var object = new THREE.Object3D(); object.position.setFromCylindricalCoords( 900, theta, y ); // 设置向量 在圆柱体中 900为半径 y为x-z平面以上的高度 vector.x = object.position.x * 2; // 设置 x轴 位置 vector.y = object.position.y; // 设置 y轴 位置 vector.z = object.position.z * 2; // 设置 z轴 位置 object.lookAt( vector ); // 将object朝向三维向量的方向 targets.helix.push( object ); // 把object添加到 targets.helix 中 &#125; // grid 栅格的数据 // 循环创建所有数据 for ( var i = 0; i &lt; objects.length; i ++ ) &#123; // 创建一个新的三维对象 var object = new THREE.Object3D(); object.position.x = ( ( i % 5 ) * 400 ) - 800; // 设置 x轴 位置 %5为行数 400为间隔 object.position.y = ( - ( Math.floor( i / 5 ) % 5 ) * 400 ) + 800; // 设置 y轴 位置 %5为列数 400为间隔 object.position.z = ( Math.floor( i / 25 ) ) * 1000 - 2000; // 设置 z轴 位置 25为一个平面的元素数量 /* * @description 如果要自己修改行列数，可以修改成 * @param &#123;Integer&#125; row - 行数. * @param &#123;Integer&#125; col - 列数. * @param &#123;Integer&#125; interval - 间隔. * const row = 4 * const col = 8 * const interval = 40 * object.position.x = (i % row) * interval - (row * interval) / 2 + interval / 2; * object.position.y = (Math.floor(i / row) % col) * interval - (col * interval) / 2 + interval / 2; * object.position.z = -Math.floor(i / row / col) * interval; * */ targets.grid.push( object ); // 把object添加到 targets.grid 中 &#125; // renderer renderer = new CSS3DRenderer(); // 创建一个新的CSS 3D渲染器 renderer.setSize( window.innerWidth, window.innerHeight ); // 将渲染器尺寸重新调整为 innerWidth innerHeight document.getElementById( 'container' ).appendChild( renderer.domElement ); // 将渲染器添加到容器.container 中 // controls controls = new TrackballControls( camera, renderer.domElement ); // 创建一个新的轨迹球控件 controls.minDistance = 500; // 设置最小缩放数 controls.maxDistance = 6000; // 设置最大缩放数 controls.addEventListener( 'change', render ); // 添加 change 事件监听，触发render事件 var button = document.getElementById( 'table' ); // 把 #table 赋值给 button 变量 button.addEventListener( 'click', function () &#123; // 给 button 添加点击事件监听，点击后 触发 transform 事件 transform( targets.table, 2000 ); &#125;, false ); var button = document.getElementById( 'sphere' ); // 把 #sphere 赋值给 button 变量 button.addEventListener( 'click', function () &#123; // 给 button 添加点击事件监听，点击后 触发 transform 事件 transform( targets.sphere, 2000 ); &#125;, false ); var button = document.getElementById( 'helix' ); // 把 #sphere 赋值给 button 变量 button.addEventListener( 'click', function () &#123; // 给 button 添加点击事件监听，点击后 触发 transform 事件 transform( targets.helix, 2000 ); &#125;, false ); var button = document.getElementById( 'grid' ); // 把 #grid 赋值给 button 变量 button.addEventListener( 'click', function () &#123; // 给 button 添加点击事件监听，点击后 触发 transform 事件 transform( targets.grid, 2000 ); &#125;, false ); transform( targets.table, 2000 ); // 切换到 table 效果，动作时间为 2000 ms // window.addEventListener( 'resize', onWindowResize, false ); // 监听视窗的 resize 事件，每次改变窗口大小是触发 onWindowResize 事件 &#125; // transform function transform( targets, duration ) &#123; TWEEN.removeAll(); // 移除所有补间数据 // 循环所有数据 for ( var i = 0; i &lt; objects.length; i ++ ) &#123; var object = objects[ i ]; // 获取当前对象 var target = targets[ i ]; // 获取当前对象对应形状的数据 // 创建坐标轴移动补间动画，to(目标坐标，动画持续时间) easing(弹性值) start()开始 new TWEEN.Tween( object.position ) .to( &#123; x: target.position.x, y: target.position.y, z: target.position.z &#125;, Math.random() * duration + duration ) .easing( TWEEN.Easing.Exponential.InOut ) .start(); // 创建旋转角度补间动画，to(目标坐标，动画持续时间) easing(弹性值) start()开始 new TWEEN.Tween( object.rotation ) .to( &#123; x: target.rotation.x, y: target.rotation.y, z: target.rotation.z &#125;, Math.random() * duration + duration ) .easing( TWEEN.Easing.Exponential.InOut ) .start(); &#125; // 设置数据更新时render事件，优化render 这里其实我没有怎么明白。 new TWEEN.Tween( this ) .to( &#123;&#125;, duration * 2 ) .onUpdate( render ) .start(); &#125; // 窗口大小改变时 function onWindowResize() &#123; camera.aspect = window.innerWidth / window.innerHeight; // 重新设置相机宽高比 camera.updateProjectionMatrix(); // 更新投影矩阵 renderer.setSize( window.innerWidth, window.innerHeight ); // 重新设置场景渲染器大小 render(); // 触发渲染更新 &#125; // 动画事件触发渲染更新 function animate() &#123; // 每次帧动画更新是触发本身 requestAnimationFrame( animate ); // 补间动画刷新 TWEEN.update(); // 控制器刷新 controls.update(); &#125; // 渲染函数 function render() &#123; // 渲染当前场景 renderer.render( scene, camera ); &#125; 感觉都不用怎么说了。稍微修改一下 element 元素内的内容就可以了。 但是元素不宜多，不然元素移动的时候严重掉帧。 尽量使用元素的组合去作整体的运动 -&gt; Group, 组合之后也可以单独移动内部的元素。 移动镜头来进行元素移动也可以节省一部分的性能消耗 -&gt; Camera 移动 Demo 隔了太久了，先写这么多，等想起来什么了在补全 2020 年 1 月 6 日 17 点 03 分","categories":[{"name":"踩坑日记","slug":"踩坑日记","permalink":"https://yogwang.site/categories/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"Canvas","slug":"Canvas","permalink":"https://yogwang.site/tags/Canvas/"},{"name":"Three.js","slug":"Three-js","permalink":"https://yogwang.site/tags/Three-js/"},{"name":"年会开发日记","slug":"年会开发日记","permalink":"https://yogwang.site/tags/%E5%B9%B4%E4%BC%9A%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0/"}]},{"title":"Canvas识别图片内容并使用用户头像拼接","slug":"html5-canvas-identify-content","date":"2019-12-01T08:27:10.000Z","updated":"2021-09-27T07:01:52.827Z","comments":true,"path":"2019/html5-canvas-identify-content/","link":"","permalink":"https://yogwang.site/2019/html5-canvas-identify-content/","excerpt":"今天 12 月了，本来应该开始做外包的项目，但是好歹不好的长智齿了,下午去拔了牙之后看着电脑发呆了一个下午，看来真的麻药影响 🧠 脑子。所以，先写篇文章醒醒脑…. 前天初步实现了下使用 canvas 来识别图片内容，今天就把它记录下来。毕竟 canvas 这部分的内容是真的不懂，现学现卖，欢迎吐槽。📧 MailTo","text":"今天 12 月了，本来应该开始做外包的项目，但是好歹不好的长智齿了,下午去拔了牙之后看着电脑发呆了一个下午，看来真的麻药影响 🧠 脑子。所以，先写篇文章醒醒脑…. 前天初步实现了下使用 canvas 来识别图片内容，今天就把它记录下来。毕竟 canvas 这部分的内容是真的不懂，现学现卖，欢迎吐槽。📧 MailTo 前几天，领导和我说要制作一个年会的活动页面，需要有用户签到展示、企业形象展示、抽奖小游戏。 其中一个需求如下： Logo 签到墙年会的签到墙，使用微信扫码签到，然后后台拿到微信授权之后传给我用户的头像昵称，然后我就在前台展示并且完成一些特效。 需要用头像图片拼接组成图形以及文字内容。这个图形和文字是用户上传的一个纯色内容+透明/白色底的图片。👇 我就直接想到用 canvas 来识别图片内容， 前天晚上初步实现了需求，直接暴力的按照设置的 size 大小从左上角不断循环识别到右下角，然后保存有内容的坐标点，再按照坐标来绘制矩形和图片填充。 这边是我实现的效果 👇 识别成栅格用户头像填充 识别内容:const maxWidth = document.body.clientWidth; // 获取视窗宽度 const maxHeight = document.body.clientHeight; // 获取视窗高度 const size = 10; // 设置栅格大小 const points = []; // 坐标数组 const canvas = document.querySelector(\"canvas\"); // 拿到canvas实例 canvas.width = maxWidth; // 设置canvas宽度 不能使用canvas.style.width来设置，会造成内容拉伸 canvas.height = maxHeight; // 设置canvas高度 const ctx = canvas.getContext(\"2d\"); // 获取canvas上下文，这边获取的是二维绘图，还有一个3D内容 \"webgl\" let img = new Image(); // 创建图片实例 img.src = require(\"assets/img/text.jpg\"); // 获取设置图片url let w = maxWidth; // 设置临时宽度，后边给绘制图片的时候会用到 let h = 0; // 设置临时高度 img.onload = () => &#123; // img 设置 url 后会立即加载，加载完成后触发 onload 事件 // 图片加载完成 h = (w / img.width) * img.height; // 计算图片高度 ctx.drawImage(img, 0, 0, w, h); // 绘制图片从(0,0)坐标，w为绘制的图片高度，h为绘制的图片高度 // 开始识别 for (let x = 0; x &lt;= w - 10; x += size + 1) &#123; // x轴开始循环 因为我需要有1像素的间隙所以是 size+1 ，如果不需要间隙则 +=size 即可 for (let y = 0; y &lt;= h - 10; y += size + 1) &#123; // y轴开始循环 let color = ctx.getImageData(x, y, size, size).data; // 识别区块内容会 一个像素内返回RGBA四个参数 let count = 0; // 设置计数器 // 以4个一组开始循环 for (let i = 0; i &lt; color.length; i += 4) &#123; // 如果区块中有颜色内容则 count++，我这边识别的是黑色内容 if (color[i] &lt;= 100 || color[i + 1] &lt;= 100 || color[i + 2] &lt;= 100) &#123; count++; &#125; &#125; // 颜色比例超过10%则记录，其实50%也可以，但是会出现 特殊情况1 的问题，下边会提到，但是内容会相对粗一些 if (count >= size * size * 0.1) &#123; points.push(&#123; x: x, y: y &#125;); // 添加到坐标数组 &#125; &#125; &#125; ctx.clearRect(0, 0, maxWidth, maxHeight); // 清除绘制的图片 &#125;; 绘制栅格图ctx.fillStyle = \"rgba(255,0,0,.55)\"; // 设置填充色 // 遍历坐标数组内的所有数据 points.forEach(piont => &#123; ctx.fillRect(piont.x, piont.y, size, size); // 绘制矩形 &#125;); 填充图片填充图片和绘制矩形的原理相似所以就不举例了。 考虑到签到的人数有可能达不到坐标的数量，所以在最后可以重新循环用户头像列表来填充满整个栅格区 以上是简单的使用 canvas 试别图片内容，并且栅格化且使用图片填充。 🎈 尾声可能遇到的一些问题 打印points一直是空数组 因为时机不正确，图片加载是异步的，你写的同步代码会先执行，需要把绘制栅格的部分代码放到图片 onload 之后。 栅格没有绘制 #1 因为异步加载的问题，points 数组为空，没有没办法绘制。#2 因为 canvas 容器的高度不够，识别之后绘制的内容不够显示。#3 我用的 Vue.js 写的 Demo，写笔记的时候忘记去掉 this 了，所以 this.size 会有问题，已经修改了。 加载微信头像或者其他来源的头像出现跨域/403的情况 尝试在绘制图片的时候为 new Image() 出来的图片实例 增加 img.crossOrigin = &quot;Anonymous&quot;; 属性 识别之后底部、右侧出现一整排/列的栅格 尝试调整栅格大小，一般这种情况是因为，识别的栅格太大，最后一排、一列超出的绘制范围拾取不到颜色，各项颜色值都会是0，会被认为是黑色 考虑把笔记重新整理 感觉上每年的年底都会收到邮件来询问这篇笔记的，可能真的要抽时间来完整梳理成文章，而不只是笔记记录一下思路，并且提供一些可预览的DEMO，便于各位学习。P.S. 去年就这样和小伙伴说过了，但是还是一拖再拖，真的自己是拖延症晚期没救了 😂 📌 附 特殊情况 1：如果识别超过 50% 时，笔画交汇时折角会超过 50%，但是没有处在交汇处的内容可能并没有超过 50%调小栅格尺寸会避免大多数的这类情况","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://yogwang.site/tags/HTML/"},{"name":"Canvas","slug":"Canvas","permalink":"https://yogwang.site/tags/Canvas/"},{"name":"年会开发日记","slug":"年会开发日记","permalink":"https://yogwang.site/tags/%E5%B9%B4%E4%BC%9A%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0/"}]},{"title":"记Web端唤起QQ聊天的两种方法","slug":"web-arouse-qq","date":"2019-11-28T01:26:56.000Z","updated":"2021-05-29T03:33:45.587Z","comments":true,"path":"2019/web-arouse-qq/","link":"","permalink":"https://yogwang.site/2019/web-arouse-qq/","excerpt":"以前一直使用的 tencent://message/?Menu=yes&amp;uin=&#123;YourQQCode&#125;&amp;Site=&#123;SiteDomain&#125; 来做的 web 端唤起 QQ 在线聊天。这次接了一个外包是自适应的 Web 页面，在手机端点击会提示 Safari 浏览器打不开该网页，应为网址无效。 👇","text":"以前一直使用的 tencent://message/?Menu=yes&amp;uin=&#123;YourQQCode&#125;&amp;Site=&#123;SiteDomain&#125; 来做的 web 端唤起 QQ 在线聊天。这次接了一个外包是自适应的 Web 页面，在手机端点击会提示 Safari 浏览器打不开该网页，应为网址无效。 👇 搜了搜。腾讯的 Tencent://Message 协议，借助的是注册表 （ Windows 操作系统允许我们为自己的应用程序注册为一个协议处理者 详情 ），所以在手机端并不能使用。 手机端唤起 QQ在手机端唤起 QQ，腾讯给了另外一种链接：mqqwpa://im/chat?chat_type=wpa&amp;uin=&#123;YourQQCode&#125;&amp;version=1&amp;src_type=web&amp;web_src=&#123;SiteDomain&#125; 使用的 URL Scheme 的方式来在不同 App 之间传递消息。 然后搭配 Js 来控制不同的设备之间输出不同的链接，就可以。电脑端使用Tencent://Message，手机端使用 mqqwpa://","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"web","slug":"web","permalink":"https://yogwang.site/tags/web/"}]},{"title":"一直以来记错的CSS属性：Position 元素定位","slug":"CSS-position","date":"2019-11-20T03:40:09.000Z","updated":"2021-07-31T07:35:03.224Z","comments":true,"path":"2019/CSS-position/","link":"","permalink":"https://yogwang.site/2019/CSS-position/","excerpt":"我一直记忆的是 position:relative 是相对于父级元素定位的，今天才发现原来自己记错了。也想明白了绝对定位的元素使用 margin:auto 为什么可以实现垂直居中 今天早上心有点静不下来，就去 SegmentFault 上看了看文章，有一篇文章 【“寒冬”三年经验前端面试总结之 CSS 篇】，里边的 垂直居中的方法四 我觉得挺奇怪的。","text":"我一直记忆的是 position:relative 是相对于父级元素定位的，今天才发现原来自己记错了。也想明白了绝对定位的元素使用 margin:auto 为什么可以实现垂直居中 今天早上心有点静不下来，就去 SegmentFault 上看了看文章，有一篇文章 【“寒冬”三年经验前端面试总结之 CSS 篇】，里边的 垂直居中的方法四 我觉得挺奇怪的。 .outer &#123; position: relative; &#125; .inner &#123; width: 100px; height: 100px; position: absolute; top: 0; right: 0; bottom: 0; left: 0; margin: auto; &#125; 为什么在 position:absolute 时，top,right,bottom,left 都为 0 时，使用 margin:auto 可以实现垂直居中。 是因为脱离文档流了还是因为别的？然后在群里讨论了下。 有些人说，absolute 之后变成行内块元素了，有些人说因为 margin。 然后我又试了下 relative 、 fixed 和 sticky。 只有 absolute 和 fixed 这种脱离文档流的可以使用 margin:auto来居中。 设置了 left，right为 0 所以可以水平居中，top，bottom为 0 可以使其垂直居中 归根结底是因为 margin:auto 填充了外部空间，然后定位是按照合模型最边界开始定位，即从 margin 开始。 另外还把自己一直以来记错的给掰了回来： position:relative 是相对未定位前的元素自身来定位的。 我一直记忆的是相对于父级做定位。 以上 2019 年 11 月 20 日 2021年7月31日更新：今天在写 数据大屏 “炫酷” 容器边框实现 的时候，突然发现 position:absolute 的定位起始点其实不是从定位祖先的左上角开始的，而是去除 border-width 的，小伙伴们请留意哦。 演示例子 🌰 CodePen link 顺便在补充一下，如果定位的值是百分比，那么这个百分比值是通过其 定位祖先 的 content + padding 值来计算得出的，比如说： .father&#123; width: 1000px; height: 1000px; padding: 50px; border: 50px solid red; position: relative; box-sizing: content-box; /* 默认盒模型 */ &#125; .sub&#123; width: 100px; height: 100px; position: absolute; left: 10%; /* 等同于 left:110px */ &#125; 为什么等于 left:20px？因为父级容器的 width 被 border-area 和 padding-area 撑开了，但是不计算 border-area，所以 left = (contentWidth + paddingWidth*2) * 10% = (1000px + 50px*2) * 10% = 110px 如果把上边的例子的 .father 的盒模型改成 border-box 那么：left: 10% 就等于 left: 90px 了。 为何？ 因为把和模型修改成 border-box 之后，CSS中设置的 width 就等于 border-area + padding-area + content-area 的总和，而因为 width、border-width 和 padding-width 是固定值，所以 content-area 就会被压缩。所以在计算 left 百分比值时需要减去边框所占用的宽度，既是 left = (width - borderWidth*2) * 10% = (1000px - 50px*2) * 10% = 90px 参考position - CSS（层叠样式表） | MDNCSS 基础框盒模型介绍 - CSS（层叠样式表） | MDN","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://yogwang.site/tags/CSS/"}]},{"title":"Jeecg-boot 开发挖坑日记08 Vue 中使用百度地图获取坐标点","slug":"jeecg-boot-devDiary08","date":"2019-11-07T08:22:53.000Z","updated":"2021-05-29T03:26:12.116Z","comments":true,"path":"2019/jeecg-boot-devDiary08/","link":"","permalink":"https://yogwang.site/2019/jeecg-boot-devDiary08/","excerpt":"突然想起来项目里边的一个需求，在用户申请称为公司账户的时候需要附加公司地址的百度地图坐标点，以便在 APP 中显示。所以需要用到百度地图的坐标拾取，反正总不可能让用户自己去拾取然后输入到 &lt;input&gt; 中去。 这篇文章就是简单说一下如何在 Vue 项目中使用百度地图。 使用到的组件: Vue-baidu-map 👉 开发手册","text":"突然想起来项目里边的一个需求，在用户申请称为公司账户的时候需要附加公司地址的百度地图坐标点，以便在 APP 中显示。所以需要用到百度地图的坐标拾取，反正总不可能让用户自己去拾取然后输入到 &lt;input&gt; 中去。 这篇文章就是简单说一下如何在 Vue 项目中使用百度地图。 使用到的组件: Vue-baidu-map 👉 开发手册 安装安装依赖总不用说了把，不管你用那种，反正包名没错就对了。 NPM$ npm install vue-baidu-map --save CDN&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;vue-baidu-map&quot;&gt;&lt;&#x2F;script&gt; 快速使用全局注册import Vue from \"vue\"; import BaiduMap from \"vue-baidu-map\"; Vue.use(BaiduMap, &#123; ak: \"YOUR_APP_KEY\" // ak 是在百度地图开发者平台申请的密钥 &#125;); &lt;template> &lt;baidu-map class=\"bm-view\"> &lt;/baidu-map> &lt;/template> &lt;style> .bm-view &#123; width: 100%; height: 300px; &#125; &lt;/style> 局部调用 如果有按需引入组件的需要，可以选择局部注册百度地图组件，这将减少工程打包后的容量尺寸。局部注册的 BaiduMap 组件必须声明 ak 属性。所有的独立组件均存放在 vue-baidu-map/components 文件夹下，按需引用即可。 由于未编译的 ES 模块不能在大多数浏览器中直接运行，如果引入组件时发生运行时错误，请检查 webpack 的 loader 配置，确认 include 和 exclude 选项命中了组件库。 &lt;template> &lt;baidu-map class=\"bm-view\" ak=\"YOUR_APP_KEY\"> &lt;/baidu-map> &lt;/template> &lt;script> import BaiduMap from \"vue-baidu-map/components/map/Map.vue\"; export default &#123; components: &#123; BaiduMap &#125; &#125;; &lt;/script> &lt;style> .bm-view &#123; width: 100%; height: 300px; &#125; &lt;/style> 好，安装完成，让我们 Run 起来。卧槽，怎么是白的？地图呢？ 👇 好，继续查看文档…. 没有设置 center 和 zoom 属性的地图组件是不进行地图渲染的。当 center 属性为合法地名字符串时例外，因为百度地图会根据地名自动调整 zoom 的值。 所以按照例子，在 &lt;baidu-map&gt; 加上 center=&quot;北京&quot; ： ok，跑起来了， 让我们试试另外一种方法，单独设置 center 和 zoom ： 好，快速启动已经没有问题了。 扩展应用时间有限，先把链接放上来，不能同步测试写文档的了。项目完成之后开始写 自动定位https://dafrok.github.io/vue-baidu-map/#/zh/control/geolocation 地区检索https://dafrok.github.io/vue-baidu-map/#/zh/search/local-search 跟随中心点自动赋值https://dafrok.github.io/vue-baidu-map/#/zh/map/baidu-map 自动填充https://dafrok.github.io/vue-baidu-map/#/zh/other/auto-complete 需要配合 &lt;bm-local-search&gt; ,如果需要点选自动切换到对应地区 :auto-viewport=&quot;true&quot; 遇到的问题1. 组件化的时候会造成死循环 组件化的时候 name 和 Vue-baidu-map 的组件重了，换一个就是了。","categories":[{"name":"踩坑日记","slug":"踩坑日记","permalink":"https://yogwang.site/categories/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"VueJS","slug":"VueJS","permalink":"https://yogwang.site/tags/VueJS/"},{"name":"Jeecg-boot","slug":"Jeecg-boot","permalink":"https://yogwang.site/tags/Jeecg-boot/"}]},{"title":"Jeecg-boot 开发挖坑日记07 多登陆入口","slug":"jeecg-boot-devDiary07","date":"2019-11-07T05:57:06.000Z","updated":"2021-05-29T03:26:13.250Z","comments":true,"path":"2019/jeecg-boot-devDiary07/","link":"","permalink":"https://yogwang.site/2019/jeecg-boot-devDiary07/","excerpt":"项目结尾了，但是需要根据用户和管理员设置不同的登陆入口界面， 所以就想着直接在 @/config/router.config.js 中修改基础路由，但是因为不知名原因，路由并没有生效。 感觉像是有设置路由守卫全部都跳转回了 #/user/login","text":"项目结尾了，但是需要根据用户和管理员设置不同的登陆入口界面， 所以就想着直接在 @/config/router.config.js 中修改基础路由，但是因为不知名原因，路由并没有生效。 感觉像是有设置路由守卫全部都跳转回了 #/user/login 在交流群里询问了很久，终于有人回答了，让我去看一下 @/permission.js import ... from 'xxx' // 一些引入 NProgress.configure(&#123; showSpinner: false &#125;) // NProgress Configuration const whiteList = ['/user/login', '/user/register', '/user/register-result','/user/alteration'] // no redirect whitelist router.beforeEach((to, from, next) => &#123; NProgress.start() // start progress bar if (Vue.ls.get(ACCESS_TOKEN)) &#123; /* has token */ if (to.path === '/user/login') &#123; next(&#123; path: '/dashboard/workplace' &#125;) NProgress.done() &#125; else &#123; if (store.getters.permissionList.length === 0) &#123; store.dispatch('GetPermissionList').then(res => &#123; const menuData = res.result.menu; console.log(res.message) if (menuData === null || menuData === \"\" || menuData === undefined) &#123; return; &#125; let constRoutes = []; constRoutes = generateIndexRouter(menuData); // 添加主界面路由 store.dispatch('UpdateAppRouter', &#123; constRoutes &#125;).then(() => &#123; // 根据roles权限生成可访问的路由表 // 动态添加可访问路由表 router.addRoutes(store.getters.addRouters) const redirect = decodeURIComponent(from.query.redirect || to.path) if (to.path === redirect) &#123; // hack方法 确保addRoutes已完成 ,set the replace: true so the navigation will not leave a history record next(&#123; ...to, replace: true &#125;) &#125; else &#123; // 跳转到目的路由 next(&#123; path: redirect &#125;) &#125; &#125;) &#125;) .catch(() => &#123; /* notification.error(&#123; message: '系统提示', description: '请求用户信息失败，请重试！' &#125;)*/ store.dispatch('Logout').then(() => &#123; next(&#123; path: '/user/login', query: &#123; redirect: to.fullPath &#125; &#125;) &#125;) &#125;) &#125; else &#123; next() &#125; &#125; &#125; else &#123; if (whiteList.indexOf(to.path) !== -1) &#123; // 在免登录白名单，直接进入 next() &#125; else &#123; next(&#123; path: '/user/login', query: &#123; redirect: to.fullPath &#125; &#125;) NProgress.done() // if current page is login will not trigger afterEach hook, so manually handle it &#125; &#125; &#125;) router.afterEach(() => &#123; NProgress.done() // finish progress bar &#125;) 一打开我就看到了硕大的几个字 whiteList …. 好吧，原来有设置了白名单，如果不在白名单之内，如果没有权限会直接跳转到 /user/login 然后跳转之前的路径会保存在 query 内的 redirect 中，就出现了路由没有效果的情况 把我们自定义的登陆页 path 放进白名单就好了…..","categories":[{"name":"踩坑日记","slug":"踩坑日记","permalink":"https://yogwang.site/categories/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"VueJS","slug":"VueJS","permalink":"https://yogwang.site/tags/VueJS/"},{"name":"Jeecg-boot","slug":"Jeecg-boot","permalink":"https://yogwang.site/tags/Jeecg-boot/"},{"name":"Vue-Router","slug":"Vue-Router","permalink":"https://yogwang.site/tags/Vue-Router/"}]},{"title":"Jeecg-boot 开发挖坑日记06 富文本编辑器tinyMCE 图片附件上传","slug":"jeecg-boot-devDiary06","date":"2019-10-31T05:40:20.000Z","updated":"2021-05-29T03:26:14.491Z","comments":true,"path":"2019/jeecg-boot-devDiary06/","link":"","permalink":"https://yogwang.site/2019/jeecg-boot-devDiary06/","excerpt":"这个富文本组件本质是 TinyMCE github.com/tinymce/tinymce，在 Vue 项目中使用的封装库 github.com/tinymce/tinymce-vue Github 上有一个人回复了，框架是使用的 TinyMCE 这个富文本编辑器的 封装库，所以在其手册里找到了，修改 上传方式的部分","text":"这个富文本组件本质是 TinyMCE github.com/tinymce/tinymce，在 Vue 项目中使用的封装库 github.com/tinymce/tinymce-vue Github 上有一个人回复了，框架是使用的 TinyMCE 这个富文本编辑器的 封装库，所以在其手册里找到了，修改 上传方式的部分 内置方法自动上传可以使用内置的 automatic_uploads 方法来上传图片文件，并且使用 images_upload_url 指定上传的 URL 地址，但是对后端返回的数据有要求 #automatic_uploadsEnable or disable automatic upload of images represented by data URLs or blob URIs. Such images get generated, for example, as a result of image manipulation through Image Tools plugin, or after image is drag-n-dropped onto the editor from the desktop.Warning: Note that, this option will do nothing if images_upload_url is not specified. 启用或禁用自动上传由 URL 或 Blob URI 表示的图像。例如，通过 Image Tools 插件的 result，或从本地上传的图片附件。警告：请注意，如果 images_upload_url 未指定，此项将不执行任何操作。 #images_upload_urlThis option lets you specify a URL for the server-side upload handler. Upload will get triggered whenever you call editor.uploadImages() or - automatically, if automatic_uploads option is enabled. Upload handler should return a new location for the uploaded file in the following format: &#123; &quot;location&quot;: &quot;folder/sub-folder/new-location.png&quot; &#125; 此项使您可以指定上传处理的 URL 地址。 每当调用 editor.uploadImages() 或启用了 automatic_uploads 功能，则会自动触发上传。 上传处理程序应以以下格式返回上传文件的新位置： &#123; &quot;location&quot;: &quot;folder/sub-folder/new-location.png&quot; &#125; 例子：tinymce.init(&#123; selector: \"textarea\", // change this value according to your HTML automatic_uploads: true, images_upload_url: \"postAcceptor.php\" &#125;); 自动拼接 base_url 在上传成功返回的图片地址之前 #images_upload_base_pathThis option lets you specify a basepath to prepend to URLs returned from the configured images_upload_url page. 通过此项，可以指定 base_path，并拼接在 images_upload_url 返回的 URL 之前。 例子：tinymce.init(&#123; selector: \"textarea\", // change this value according to your HTML automatic_uploads: true, images_upload_url: \"postAcceptor.php\", images_upload_base_path: \"/some/basepath\" &#125;); 自定义上传方法 #images_upload_handlerThe images_upload_handler option allows you to specify a function that is used to replace TinyMCE’s default JavaScript upload handler function with custom logic.The upload handler function takes three arguments: blobInfo, a success callback, and a failure callback. When this option is not set, TinyMCE utilizes an XMLHttpRequest to upload images one at a time to the server and calls the success callback with the location of the remote image. images_upload_handler 可让指定一个函数，该函数用于用自定义逻辑替换 TinyMCE 默认的 JavaScript 上传函数。上传函数采用三个参数：blobInfo, success 回调和 failure 回调，如果此项未设置，则 TinyMCE 会利用 XMLHttpRequest 一次一个将图像上传到服务器，并调用 success 回调 返回的 URL 地址。 Note: Please note that when using this option, no other image uploader options are necessary. Additionally, if you would like TinyMCE to replace the tag’s src attribute with the remote location, please use the success callback defined in the images_upload_handler function with the returned JSON object’s location property. 提示：请注意，使用此项时，不要使用其他图像上传器选项。 此外，如果您希望 TinyMCE 将 &lt;image&gt; 标签的 src 属性替换为远程位置，请使用 images_upload_handler 函数中定义的成功回调 和 返回的 JSON 对象的 location 属性。 例子：tinymce.init(&#123; selector: \"textarea\", // change this value according to your HTML images_upload_handler: function(blobInfo, success, failure) &#123; var xhr, formData; xhr = new XMLHttpRequest(); xhr.withCredentials = false; xhr.open(\"POST\", \"postAcceptor.php\"); xhr.onload = function() &#123; var json; if (xhr.status != 200) &#123; failure(\"HTTP Error: \" + xhr.status); return; &#125; json = JSON.parse(xhr.responseText); if (!json || typeof json.location != \"string\") &#123; failure(\"Invalid JSON: \" + xhr.responseText); return; &#125; success(json.location); &#125;; formData = new FormData(); formData.append(\"file\", blobInfo.blob(), blobInfo.filename()); xhr.send(formData); &#125; &#125;); 疑问？1.使用编辑器内置的图片上传方法，为何拼接的是当前的 domain URL,而不是 base_url 使用完整的 URL 地址即可 images_upload_url:&#39;http://www.domain.com/project/Controller/fanction&#39; 2.如按照文档上所说的，使用 images_upload_base_path，是否会自动拼接 URL? 只有在 automatic_uploads: true 时使用的自动上传功能才会拼接 3.如何关闭多媒体附件功能 如在 Jeecg-boot 框架下，注释掉 @/components/jeecg/JEditor.vue 的第 13 行 import &#39;tinymce/plugins/media&#39; MediaPlugin 的引入 去除 tinymce.init() 初始化函数内 plugins 和 toolbar 属性内的 media 即可。 4.为什么会自动替换图片URL为相对路径默认情况下URL会被编辑器自动转化，如果图片URL和当前域名相同的话，如果不希望被自动转换，可以是修改 convert_urls 为 flase。更多内容可以查看官方文档URL handling options | Docs | TinyMCE 附 ISSUES_富文本组件使用方法 #685 TinyMCE github.com/tinymce/tinymce-vue TinyMCE 使用绝对路径","categories":[{"name":"踩坑日记","slug":"踩坑日记","permalink":"https://yogwang.site/categories/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"Jeecg-boot","slug":"Jeecg-boot","permalink":"https://yogwang.site/tags/Jeecg-boot/"},{"name":"tinyMCE","slug":"tinyMCE","permalink":"https://yogwang.site/tags/tinyMCE/"}]},{"title":"Jeecg-boot 开发挖坑日记05 Axios 异步请求","slug":"jeecg-boot-devDiary05","date":"2019-10-29T07:48:01.000Z","updated":"2021-05-29T03:26:15.930Z","comments":true,"path":"2019/jeecg-boot-devDiary05/","link":"","permalink":"https://yogwang.site/2019/jeecg-boot-devDiary05/","excerpt":"一开始以为这里坑很大，结果坑其实并不大，而且内置了很多常用函数，可能是我带有偏见了，所以这篇文章就简短的介绍了一下。 在 @/utils/request.js 中创建了 Axios 实例，并且在 @/api/manage.js 中封装了常用函数只需要在组件内按需导入即可。","text":"一开始以为这里坑很大，结果坑其实并不大，而且内置了很多常用函数，可能是我带有偏见了，所以这篇文章就简短的介绍了一下。 在 @/utils/request.js 中创建了 Axios 实例，并且在 @/api/manage.js 中封装了常用函数只需要在组件内按需导入即可。 Jeecg-boot 封装好了 Axios 的实例，并且导出了可能会用到的一些常用函数： httpAction() putAction() getAction(), 而且内置了一些简单的内置函数： deleteAction() getUserList() getRoleList() getServiceList() getPermissions() saveService() downFile() 只需要在需要使用的组件内 import 即可， 但是封装好了的 Axios 实例默认是 JSON 传输的，所以需要使用 form-data 传输时，需要用 new FormData() 然后 .append() 来传递数据","categories":[{"name":"踩坑日记","slug":"踩坑日记","permalink":"https://yogwang.site/categories/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"Jeecg-boot","slug":"Jeecg-boot","permalink":"https://yogwang.site/tags/Jeecg-boot/"},{"name":"Axios","slug":"Axios","permalink":"https://yogwang.site/tags/Axios/"}]},{"title":"Jeecg-boot 开发挖坑日记04 全局 Vue-AntD 标签页的控制","slug":"jeecg-boot-devDiary04","date":"2019-10-28T05:49:01.000Z","updated":"2021-05-29T03:26:17.020Z","comments":true,"path":"2019/jeecg-boot-devDiary04/","link":"","permalink":"https://yogwang.site/2019/jeecg-boot-devDiary04/","excerpt":"开坑 2019 年 10 月 28 日 暂时没有找到好的方法，在不修改原来 layout 框架的情况下。","text":"开坑 2019 年 10 月 28 日 暂时没有找到好的方法，在不修改原来 layout 框架的情况下。 Vue-AntD Tabs 事件名称 说明 回调参数 edit 新增和删除页签的回调，在 type=”editable-card” 时有效 (targetKey, action): void 移除 Tab 方法在: @/components/layouts/TabLayout.vue =&gt; remove:117 editPage(key, action) &#123; this[action](key) &#125;, remove(key) &#123; if (key == indexKey) &#123; this.$message.warning('首页不能关闭!') return &#125; if (this.pageList.length === 1) &#123; this.$message.warning('这是最后一页，不能再关闭了啦') return &#125; this.pageList = this.pageList.filter(item => item.fullPath !== key) let index = this.linkList.indexOf(key) this.linkList = this.linkList.filter(item => item !== key) index = index >= this.linkList.length ? this.linkList.length - 1 : index this.activePage = this.linkList[index] &#125;, 没找到好的解决办法，在考虑直接用 vuex 重写了…","categories":[{"name":"踩坑日记","slug":"踩坑日记","permalink":"https://yogwang.site/categories/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"未完成","slug":"未完成","permalink":"https://yogwang.site/tags/%E6%9C%AA%E5%AE%8C%E6%88%90/"},{"name":"VueJS","slug":"VueJS","permalink":"https://yogwang.site/tags/VueJS/"},{"name":"Jeecg-boot","slug":"Jeecg-boot","permalink":"https://yogwang.site/tags/Jeecg-boot/"},{"name":"Ant-Design-Vue","slug":"Ant-Design-Vue","permalink":"https://yogwang.site/tags/Ant-Design-Vue/"}]},{"title":"记一个 CSS 伪类的 content 用法","slug":"CSS-pseudo-elements-content","date":"2019-10-28T05:24:26.000Z","updated":"2021-05-29T03:30:20.518Z","comments":true,"path":"2019/CSS-pseudo-elements-content/","link":"","permalink":"https://yogwang.site/2019/CSS-pseudo-elements-content/","excerpt":"content: url(&#39;...&#39;); 最近在群里看到一种写伪类 content 的用法，觉得很新奇， 群友一开始使用伪类来显示一个小图标，但是这个小图标比较大，所以他就像设置宽高来显示这个伪类，但是他怎么都设置不了这个伪类的宽高， 我就和他说你设置伪类的宽高不就好了嘛？（我一直以来都是用伪类设置背景图片的形式来做 icon）他说不行，我就看到了这个独特的写法… 他是直接在 content 里边写了图片的 url，然后神奇的是居然可以显示 content 里填写的图片！！！","text":"content: url(&#39;...&#39;); 最近在群里看到一种写伪类 content 的用法，觉得很新奇， 群友一开始使用伪类来显示一个小图标，但是这个小图标比较大，所以他就像设置宽高来显示这个伪类，但是他怎么都设置不了这个伪类的宽高， 我就和他说你设置伪类的宽高不就好了嘛？（我一直以来都是用伪类设置背景图片的形式来做 icon）他说不行，我就看到了这个独特的写法… 他是直接在 content 里边写了图片的 url，然后神奇的是居然可以显示 content 里填写的图片！！！ 我都没有用过,就查阅了一下 MDN 👉 [ content - CSS ] URI 值会指定一个外部资源（比如图片）。如果该资源或图片不能显示，它就会被忽略或显示一些占位（比如无图片标志）。 先来看一下 DEMO 虽然这个方式存在很多问题，但是可以方便很多时候处理图片小图标。 就不需要先设置 content:&#39;&#39; 然后 display:inline-block 再设置宽高在设置背景图片，直接把图片地址放在 content 里边就可以解决问题。很方便，但是这个方式显示的小图标并不能控制它的宽高。不过把图片裁剪成合适大小就可以解决这个问题，而且兼容性还不错。 👉 Can I use 你敢信 IE8 都兼容！","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://yogwang.site/tags/CSS/"}]},{"title":"Jeecg-boot 开发挖坑日记03 动态路由传参","slug":"jeecg-boot-devDiary03","date":"2019-10-24T05:39:50.000Z","updated":"2021-08-03T09:49:37.040Z","comments":true,"path":"2019/jeecg-boot-devDiary03/","link":"","permalink":"https://yogwang.site/2019/jeecg-boot-devDiary03/","excerpt":"坑！ @YogWang #2019/10/24 jeecgboot 针对路由组件的名字做了规则处理，所以默认不是 UserInfo 如果自定义了路由组件名，则采用自定义名； 未定义路由 name (通过 URL 生成路由 name,路由 name 供前端开发，页面跳转使用) @zhangdaiscott #2019/10/27 Reply 今天写一个带参数页面的时候，怎么样都是 404 然后跳转到 localhost:8080/#/; 显示空白; 看了 Jeecg-Boot 的技术手册完全按照上边来的写也是不行，还是跳转到 /，在 Vue DevTools 中检查又没有问题。就又折腾了好久，又是查文档又是看官方的教学视频。最后真的是烦了，就偷懒了一把，结果成了….原因是啥呢???","text":"坑！ @YogWang #2019/10/24 jeecgboot 针对路由组件的名字做了规则处理，所以默认不是 UserInfo 如果自定义了路由组件名，则采用自定义名； 未定义路由 name (通过 URL 生成路由 name,路由 name 供前端开发，页面跳转使用) @zhangdaiscott #2019/10/27 Reply 今天写一个带参数页面的时候，怎么样都是 404 然后跳转到 localhost:8080/#/; 显示空白; 看了 Jeecg-Boot 的技术手册完全按照上边来的写也是不行，还是跳转到 /，在 Vue DevTools 中检查又没有问题。就又折腾了好久，又是查文档又是看官方的教学视频。最后真的是烦了，就偷懒了一把，结果成了….原因是啥呢??? WHY?先来看官方文档： 在菜单管理中如技术文档里边所说，填写 /UserInfo/:id ，并在页面中使用 &lt;router-link :to=&quot;&#123;name:&#39;UserInfo&#39;, params: &#123;id:id&#125;&#125;&quot;&gt;查看&lt;/router-link&gt; 点击按钮跳转会到 / ，不会跳转到 /UserInfo/123456 ，并提示 [vue-router] Route with name &#39;UserInfo&#39; does not exist 。 使用 &lt;router-link :to=&quot;&#39;UserInfo/&#39;+id&quot; /&gt;查看&lt;/router-link&gt; 就可以。在 Vue DevTools 中检查发现，UserInfo 对应的是 Name 是 UserInfo-@id 今天提交了一个 Issues 👉 动态路由的带参 #669，看官方怎么说吧。 先使用偷懒的方法吧 ↓ 2019 年 10 月 25 日已更新↓ 2019 年 10 月 27 日已更新 附&#x4a;&#x65;&#101;&#x63;&#x67;&#45;&#x62;&#111;&#x6f;&#116;&#64;&#x32;&#46;&#x31;&#46;&#x30;（发布日期：20190826）vue@^2.6.10@vue/cli@^3.8.0vue-router@^3.0.1 2019 年 10 月 25 日更新使用 :to=&quot;&#39;UserInfo/&#39;+id&quot; 点击多个查看用户后，会创建多个用户资料标签，并且没有激活的方法，来重新获取用户 ID。 👉 修改 : 菜单管理中，最后不添加 /:id ,使用 :to=&quot;&#123;name:&#39;UserInfo&#39;, params: &#123;id:id&#125;&#125;&quot; 直接传参，打开的新标签页可以获得 userID，之后再点击其他用户信息也不会再创建一个新标签，而是直接使用已创建的标签页。 最后 Issues 还没被回复。 2019 年 10 月 27 日更新 zhangdaiscott：jeecgboot 针对路由组件的名字做了规则处理，所以默认不是 UserInfo 如果自定义了路由组件名，则采用自定义名； 未定义路由 name (通过 URL 生成路由 name,路由 name 供前端开发，页面跳转使用)","categories":[{"name":"踩坑日记","slug":"踩坑日记","permalink":"https://yogwang.site/categories/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"VueJS","slug":"VueJS","permalink":"https://yogwang.site/tags/VueJS/"},{"name":"Jeecg-boot","slug":"Jeecg-boot","permalink":"https://yogwang.site/tags/Jeecg-boot/"},{"name":"Ant-Design-Vue","slug":"Ant-Design-Vue","permalink":"https://yogwang.site/tags/Ant-Design-Vue/"}]},{"title":"Hexo 主题开发 -- 代码块颜色高亮","slug":"hexo-theme-development-codeblock","date":"2019-10-19T05:37:18.000Z","updated":"2021-05-29T03:27:00.486Z","comments":true,"path":"2019/hexo-theme-development-codeblock/","link":"","permalink":"https://yogwang.site/2019/hexo-theme-development-codeblock/","excerpt":"使用 Hexo 框架，在发布之后会自动给你的代码块进行区分，并没有安装其他依赖。然后根据生成的 html 基础上进行代码高亮。只需要匹配对应类名加上 CSS 样式就可以完成基础的代码高亮。 代码块: HTML Javascript css 代码行 先开坑，慢慢填坑。可能要等到 Jeecg-boot 之后陆陆续续完成，也有可能提前，随缘。","text":"使用 Hexo 框架，在发布之后会自动给你的代码块进行区分，并没有安装其他依赖。然后根据生成的 html 基础上进行代码高亮。只需要匹配对应类名加上 CSS 样式就可以完成基础的代码高亮。 代码块: HTML Javascript css 代码行 先开坑，慢慢填坑。可能要等到 Jeecg-boot 之后陆陆续续完成，也有可能提前，随缘。 HTML 部分&lt;figure class=&#39;.html&#39;&gt; -&gt; html 代码块 .meta -&gt; 源 .line -&gt; 行 .tag -&gt; 标签 .name -&gt; 标签名 .attr -&gt; 属性名 .string -&gt; 字符串 .comment -&gt; 注释 .javascript -&gt; 脚本代码 .function -&gt; 函数 .keyword -&gt; 关键字 .title -&gt; 标题 .params -&gt; 参数 .comment -&gt; 注释 .literal -&gt; 文字 .number -&gt; 数字 .built_in -&gt; 内置方法/对象 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\" /> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /> &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" /> &lt;title>Document&lt;/title> &lt;link rel=\"stylesheet\" href=\"style.css\" /> &lt;script src=\"http://www.baidu.com/a.js\">&lt;/script> &lt;style type=\"text/css\"> /* 注释 */ #a &#123; width: 100%; height: auto; border: 1px solid #000; display: block; background: rgb(0, 0, 0); &#125; .b &#123; font-size: 15px; &#125; table input &#123; font-size: 15px; &#125; input[type='number'] &#123; font-size: 15px; &#125; &lt;/style> &lt;/head> &lt;body> &lt;div id=\"a\">&lt;/div> &lt;div class=\"b\">&lt;/div> &lt;form action=\"#\" method=\"post\"> &lt;input type=\"button\" value=\"1\" /> &lt;input type=\"checkbox\" name=\"abc\" /> &lt;/form> &lt;table border=\"1\"> &lt;thead> &lt;tr> &lt;td colspan=\"2\">&lt;/td> &lt;/tr> &lt;/thead> &lt;tbody> &lt;tr> &lt;td colspan=\"2\">&lt;/td> &lt;/tr> &lt;tr> &lt;td>文字&lt;/td> &lt;td>文字&lt;/td> &lt;/tr> &lt;/tbody> &lt;/table> &lt;div style=\"border-width:5px;border-style:solid;border-color:red\">&lt;/div> &lt;!-- HTML注释 --> &lt;/body> &lt;script type=\"text/javascript\"> function abc() &#123; var num = 120 let abc = 'string' const setTrue = true for (let i = 0; i &lt;= 10; i++) &#123; console.log(i) &#125; &#125; document.write('Hello World!') // 单行注释 /* * 多行注释 * */ &lt;/script> &lt;/html> JavaScript 部分import &#123; ERR_OK &#125; from 'base.config.js' import goodsList from 'components/index/goods/goods_list' export default &#123; name: 'goods-list', data() &#123; return &#123; goods: [], page: 1, size: 10, sort: null, viewMode: 'img', allLoaded: false &#125; &#125;, components: &#123; goodsList &#125;, mounted() &#123; this.getGoodsList() Indicator.open() &#125;, methods: &#123; ifelse() &#123; if (type === 'aaa') &#123; type = 'bbb' &#125; else &#123; type = 'aaa' &#125; &#125;, getGoodsList() &#123; let data = &#123; categoryId: this.categoryId, pageNum: this.page, pageSize: this.size &#125; this.api .getGoodsList(data) .then(res => &#123; Indicator.close() res = res.data console.log(res) &#125;) .catch(err => &#123; console.log(err) &#125;) &#125; &#125; &#125; CSS 部分/* 注释 */ #a &#123; width: 100%; height: auto; border: 1px solid #000; display: block; background: rgb(0, 0, 0); &#125; .b &#123; font-size: 15px; &#125; table input &#123; font-size: 15px; &#125; input[type='number'] &#123; font-size: 15px; &#125; @keyframes mymove &#123; from &#123; top: 0px; &#125; to &#123; top: 200px; &#125; &#125; @media (max-width: 650px) &#123; #a &#123; font-size: 12px; &#125; &#125;","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"未完成","slug":"未完成","permalink":"https://yogwang.site/tags/%E6%9C%AA%E5%AE%8C%E6%88%90/"},{"name":"Hexo","slug":"Hexo","permalink":"https://yogwang.site/tags/Hexo/"}]},{"title":"Jeecg-boot 开发挖坑日记02 用户头像上传 / Vue-AntD上传组件","slug":"jeecg-boot-devDiary02","date":"2019-10-17T09:07:24.000Z","updated":"2021-05-29T03:26:19.432Z","comments":true,"path":"2019/jeecg-boot-devDiary02/","link":"","permalink":"https://yogwang.site/2019/jeecg-boot-devDiary02/","excerpt":"项目正式开始，第一个功能模块的用户信息编辑就开始卡壳，特别是头像上传组件。 弹出框 a-mdal 的表单值怎么获取到的 ant-design-vue 上传组件的头像上传 使用 ant-design-vue 上传组件的头像上传。在 Jeecg-boot 中头像上传是 antD 的上传组件 listType=&quot;picture-card&quot;，在教程里是直接使用 upload 组件的 defaultFileList API，但他们 DEMO 是 listType=&quot;text&quot;，或 listType=&quot;picture-card&quot; 但绑定的是 fileList，并不是 defaultFileList，就和 ant-design-vue 的文档是一摸一样的照着读了一遍， 然后我直接复制的官方用户头像 DEMO,就出现了问题。","text":"项目正式开始，第一个功能模块的用户信息编辑就开始卡壳，特别是头像上传组件。 弹出框 a-mdal 的表单值怎么获取到的 ant-design-vue 上传组件的头像上传 使用 ant-design-vue 上传组件的头像上传。在 Jeecg-boot 中头像上传是 antD 的上传组件 listType=&quot;picture-card&quot;，在教程里是直接使用 upload 组件的 defaultFileList API，但他们 DEMO 是 listType=&quot;text&quot;，或 listType=&quot;picture-card&quot; 但绑定的是 fileList，并不是 defaultFileList，就和 ant-design-vue 的文档是一摸一样的照着读了一遍， 然后我直接复制的官方用户头像 DEMO,就出现了问题。 AntD 官方 DEMO 点击上传用户头像，并使用 beforeUpload 限制用户上传的图片格式和大小。beforeUpload 的返回值可以是一个 Promise 以支持异步处理，如服务端校验等 &lt;template> &lt;a-upload name=\"avatar\" listType=\"picture-card\" class=\"avatar-uploader\" :showUploadList=\"false\" action=\"https://www.mocky.io/v2/5cc8019d300000980a055e76\" :beforeUpload=\"beforeUpload\" @change=\"handleChange\" > &lt;img v-if=\"imageUrl\" :src=\"imageUrl\" alt=\"avatar\" /> &lt;div v-else> &lt;a-icon :type=\"loading ? 'loading' : 'plus'\" /> &lt;div class=\"ant-upload-text\">Upload&lt;/div> &lt;/div> &lt;/a-upload> &lt;/template> &lt;script> function getBase64(img, callback) &#123; const reader = new FileReader(); reader.addEventListener(\"load\", () => callback(reader.result)); reader.readAsDataURL(img); &#125; export default &#123; data() &#123; return &#123; loading: false, imageUrl: \"\" &#125;; &#125;, methods: &#123; handleChange(info) &#123; if (info.file.status === \"uploading\") &#123; this.loading = true; return; &#125; if (info.file.status === \"done\") &#123; // Get this url from response in real world. getBase64(info.file.originFileObj, imageUrl => &#123; this.imageUrl = imageUrl; this.loading = false; &#125;); &#125; &#125;, beforeUpload(file) &#123; const isJPG = file.type === \"image/jpeg\"; if (!isJPG) &#123; this.$message.error(\"You can only upload JPG file!\"); &#125; const isLt2M = file.size / 1024 / 1024 &lt; 2; if (!isLt2M) &#123; this.$message.error(\"Image must smaller than 2MB!\"); &#125; return isJPG &amp;&amp; isLt2M; &#125; &#125; &#125;; &lt;/script> &lt;style> // css style... &lt;/style> 第一天的时候，我直接复制的 用户头像 DEMO，然后直接使用了 defaultFileList 设置默认头像但是没效果，依然是空白。 找啊找啊找，发现 DEMO 上设置了 :showUploadList=&quot;false&quot;，删之…🙄 还是不行，继续查问题。 发现 defaultFileList 是不能异步设置的，要在组件初始化完成之前就设置好，或者使用 fileList 来设置默认头像 🙃， emmm….怎么还有一个空白头像，原来还有一个 img 标签，删之。 现在的 upload 组件是这样的： &lt;a-upload action=\"https://www.mocky.io/v2/5cc8019d300000980a055e76\" listType=\"picture-card\" :defaultFileList=\"fileList\" @change=\"handleChange\" > &lt;div v-if=\"fileList.length &lt; 1\"> &lt;a-icon :type=\"loading ? 'loading' : 'plus'\" /> &lt;div class=\"ant-upload-text\">Upload&lt;/div> &lt;/div> &lt;/a-upload> 好，现在基本显示没问题了，但是先要删除原先的头像再上传 等等..删除了头像怎么没出现上传头像按钮？handleChange 事件要修改成： handleChange(&#123; fileList &#125;) &#123; this.fileList = fileList; &#125;, 完事，基本完成。但是… 需求：点击头像就能修改，而不是先要删除原先的头像再上传 所以结合两个官方 DEMO，最后修改如下： &lt;template> // 上下文... &lt;a-upload listType=\"picture-card\" class=\"avatar-uploader\" :showUploadList=\"false\" :action=\"uploadURL\" :beforeUpload=\"beforeUpload\" @change=\"handleChange\" > &lt;img v-if=\"imageUrl\" :src=\"imageUrl\" alt=\"avatar\" style=\"width:100%;\" /> &lt;div v-else> &lt;a-icon :type=\"loading ? 'loading' : 'plus'\" /> &lt;div class=\"ant-upload-text\">Upload&lt;/div> &lt;/div> &lt;/a-upload> // 上下文... &lt;/template> &lt;script> export default &#123; data() &#123; return()&#123; url:&#123; upload: '/project/upload' &#125;, imageUrl: '', loading: false &#125; &#125;, computed: &#123; uploadURL() &#123; return `$&#123;window._CONFIG['domianURL']&#125;$&#123;this.url.upload&#125;` &#125; &#125;, methods:&#123; handleChange(info) &#123; if (info.file.status === 'uploading') &#123; this.loading = true return &#125; if (info.file.status === 'done') &#123; getBase64(info.file.originFileObj, imageUrl => &#123; this.imageUrl = imageUrl this.loading = false &#125;) // 这里可以放上传成功后台返回的图片url的表单赋值，使用 form.setFieldsValue 给表单赋值 &#125; &#125;, beforeUpload(file) &#123; const isJPG = file.type === 'image/jpeg' if (!isJPG) &#123; this.$message.error('You can only upload JPG file!') &#125; const isLt2M = file.size / 1024 / 1024 &lt; 2 if (!isLt2M) &#123; this.$message.error('Image must smaller than 2MB!') &#125; return isJPG &amp;&amp; isLt2M &#125; // 初始图片赋值等方法 ... &#125; &lt;/script> &lt;style> // css style... &lt;/style> 弹出框的表单值是怎么设置的？在 edit() 方法中传入了当前对象 record。 AntD 封装了表单域 &lt;Form.Item /&gt; ，需要使用 Form.create 来创建表单实例，而且设置表单的值要用 form.setFieldsValue （有些时候需要确保子组件完成渲染 $nextTick() 后才执行赋值操作） 且使用 pick()[1] 函数从指定的对象中挑选出需要的任意 key 属性。 特殊控件(select,radio,checkbox)需要使用 v-decorator 来绑定数据 [2] 尾声 1,官方 DEMO 的代码差异比较大，特别是 handleChange 部分，需要细看。 2,对后台返回的数据有要求。 3,表单修改需要使用 setFieldsValue 来动态设置其他控件的值。 [ 注 1 ]: pick() 的坑待填，用的 lodash.pick 函数 [ 注 2 ]: 这里的 v-decorator 挖坑，看后边什么时候填上","categories":[{"name":"踩坑日记","slug":"踩坑日记","permalink":"https://yogwang.site/categories/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"VueJS","slug":"VueJS","permalink":"https://yogwang.site/tags/VueJS/"},{"name":"挖坑","slug":"挖坑","permalink":"https://yogwang.site/tags/%E6%8C%96%E5%9D%91/"},{"name":"Jeecg-boot","slug":"Jeecg-boot","permalink":"https://yogwang.site/tags/Jeecg-boot/"},{"name":"Ant-Design-Vue","slug":"Ant-Design-Vue","permalink":"https://yogwang.site/tags/Ant-Design-Vue/"}]},{"title":"文本开头空格不显示问题","slug":"html-space-display","date":"2019-10-15T03:27:28.000Z","updated":"2021-05-29T03:26:41.868Z","comments":true,"path":"2019/html-space-display/","link":"","permalink":"https://yogwang.site/2019/html-space-display/","excerpt":"在 html 中手动输入多个空格，在页面解析的时候都会变成一个空格，如果在开头甚至一个空格都不会显示 但就是一定要求在开头/中间显示多个空格，这个问题怎么解决呢？","text":"在 html 中手动输入多个空格，在页面解析的时候都会变成一个空格，如果在开头甚至一个空格都不会显示 但就是一定要求在开头/中间显示多个空格，这个问题怎么解决呢？ 1.使用字符实体实体名称 &amp;nbsp; 或者实体编号 &amp;#160; 2.使用全角文字3.使用 CSS 样式控制在容器上添加 white-space:pre CSS 属性 4.使用 &lt;pre&gt; 标签","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://yogwang.site/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"https://yogwang.site/tags/HTML/"}]},{"title":"Jeecg-boot 开发挖坑日记01 Jeecg-Boot是个什么鬼?","slug":"jeecg-boot-devDiary01","date":"2019-10-10T06:37:44.000Z","updated":"2021-05-29T03:26:20.581Z","comments":true,"path":"2019/jeecg-boot-devDiary01/","link":"","permalink":"https://yogwang.site/2019/jeecg-boot-devDiary01/","excerpt":"这段时间公司有一个项目是用 Jeecg-Boot 开发的，管理平台部分就分配到我这边了。这段时间看了下他们官方的文档，感觉文档有点少，感觉之后大部分时间都要和这个东西杠上了。 _yogwang 2019.10.10 15:28 what is the fuxk jeecg-boot? Java RAD framework for enterprise web applications 基于代码生成器的 JAVA 快速开发平台,采用前后端分离架构：","text":"这段时间公司有一个项目是用 Jeecg-Boot 开发的，管理平台部分就分配到我这边了。这段时间看了下他们官方的文档，感觉文档有点少，感觉之后大部分时间都要和这个东西杠上了。 _yogwang 2019.10.10 15:28 what is the fuxk jeecg-boot? Java RAD framework for enterprise web applications 基于代码生成器的 JAVA 快速开发平台,采用前后端分离架构： SpringBoot 2.x Ant Design&amp;Vue Mybatis Shiro JWT 代码生成器让前后端代码一键生成，无需写任何代码，绝对是全栈开发福音！！ （现在看来前端开发者的大坑 - yogwang/2019.10.17） JeecgBoot 的宗旨是提高 UI 能力的同时,降低前后分离的开发成本，（后端确实是很喜欢） 获取项目git clone https:&#x2F;&#x2F;github.com&#x2F;zhangdaiscott&#x2F;jeecg-boot.git cd jeecg-boot&#x2F;ant-design-jeecg-vue 前端部分基于 Ant Design of Vue 实现的 Ant Design Pro Vue 版 开发环境和依赖 node Ant-Design-Vue 1.x Vue Cli 3.x Vue 2.x Vue router Vuex 3.x Axios Vue-cropper @antv/g2 Viser-vue vue-print-nb less eslint webpack 简而言之就是 Java 端生成前台 vue 页面（默认增删改查功能，以及弹出框和抽屉页形式的编辑页）。然后自己把生成的页面移动到 Views 目录下，并在 UI 界面添加路由（vue-router）。 组件库使用的是 Ant-Design-Vue，我觉得最坑的部分就是这里。 Day1：卧槽这是啥？点点看。卧槽..真特么删掉了啊！！老子的测试数据…. 然后 JeecgBoot 自己混入的方式抽取了共通 JS，比如生成 Vue 页面时候的增删改查，在 @/mxins 下的 JeecgListMixin.js 后边会陆陆续续更新一些开发过程中卡壳的问题，有些会很沙雕，有些可能是真的挖坑。… 备注 我现在使用的 Jeecg-bot 在项目 README 文档最后，有这么一段。 @vue/cli 升级后，eslint 规则更新了。由于影响到全部 .vue 文件，需要逐个验证。既暂时关闭部分原本不验证的规则，后期维护时，在逐步修正这些 rules 也不知道什么时候会有修复，不过我应该是看不到了。 技术文档 Jeecg-boot 在线演示 开发文档 Jeecg-boot/Github Jeecg 社区论坛 附 Ant Design Vue 报表 viser-vue Vue 路由/菜单说明 ANTD 默认配置项 待补充…","categories":[{"name":"踩坑日记","slug":"踩坑日记","permalink":"https://yogwang.site/categories/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"VueJS","slug":"VueJS","permalink":"https://yogwang.site/tags/VueJS/"},{"name":"Jeecg-boot","slug":"Jeecg-boot","permalink":"https://yogwang.site/tags/Jeecg-boot/"},{"name":"Ant-Design-Vue","slug":"Ant-Design-Vue","permalink":"https://yogwang.site/tags/Ant-Design-Vue/"}]},{"title":"怎么知道依赖包需要安装到生产还是开发环境或者是安装到全局","slug":"nodejs-npm-save-dev-global","date":"2019-09-22T05:48:39.000Z","updated":"2021-05-29T03:32:03.080Z","comments":true,"path":"2019/nodejs-npm-save-dev-global/","link":"","permalink":"https://yogwang.site/2019/nodejs-npm-save-dev-global/","excerpt":"刚开始接触 Node.js (包管理项目) 的时候很多人都会疑惑哪些依赖是可以装在全局的，哪些依赖是安装在项目里的，安装在项目里的依赖又是怎么分辨是否是要安装在开发环境中还是生产环境中？ 小白的时候还不知道怎么搜索关键词，然后就只能看着文档，他们怎么说自己就怎么敲， 上边写的是 npm install vue 就 npm install,如果写的是 npm install -g @vue/cli 那么就 npm install -g,如果是 npm install --save-dev @babel/core 那么就 npm install --save-dev 比如 4 个月前的我就是这样，最近有一些人在群里问，那我就整理了下（原来这不是我笨理解不了，别人也是这样觉得的！）","text":"刚开始接触 Node.js (包管理项目) 的时候很多人都会疑惑哪些依赖是可以装在全局的，哪些依赖是安装在项目里的，安装在项目里的依赖又是怎么分辨是否是要安装在开发环境中还是生产环境中？ 小白的时候还不知道怎么搜索关键词，然后就只能看着文档，他们怎么说自己就怎么敲， 上边写的是 npm install vue 就 npm install,如果写的是 npm install -g @vue/cli 那么就 npm install -g,如果是 npm install --save-dev @babel/core 那么就 npm install --save-dev 比如 4 个月前的我就是这样，最近有一些人在群里问，那我就整理了下（原来这不是我笨理解不了，别人也是这样觉得的！） 其实很简单 先了解下什么是 开发环境 和 生产环境: 开发环境：项目尚且在编码阶段，为了开发调试方便，配置可以比较随意，一般打开全部错误报告。 生产环境: 是指正式提供对外服务了，一般会关掉错误报告，打开错误日志。比如开发企业网站，开发完成之后放在阿里云的服务器上了交付给客户了的时候。 PS: 其实还有一个测试环境，但是现在用不着，就不说了。 怎么分辨依赖安装在开发环境中还是生产环境中？ 如果是你编辑代码的时候用到的辅助工具依赖就安装到 devDependencies 下，也就是 npm install 包名 --save-dev(注意 –save-dev 中间没有空格哦) 例如一些 CSS 预处理器：Less,Sass,Stylus，他们会在你打包项目的时候编译成为正常的 CSS 文件。 ESlint 这样的语法规则检查工具，帮助你检查你语法是否规范，代码风格是否良好，然后提示你需要修改或者直接把代码格式化成未预设的规范格式。 Webpack 这样的打包工具等等 这些帮助你快速开发的工具类依赖包，它们在开发完成之后是不需要存在你项目里边的，所以是安装在开发环境中，在项目打包时就可以忽略这些依赖来达到压缩项目大小的目的。 如果是你项目运行需要的依赖，就安装到 dependencies 下 就是npm install 包名 --save 例如 React、Angular、Vue.js 这样的前端框架 axios 这样的 http 请求库 或者 BootStrap,ElemntUI 这样的 UI 组件库 多了去了不写了 这些必须一直存在在项目里边的依赖包，你的项目运行就依靠这些依赖运行，如果缺少项目就会功能缺失|报错或者直接运行不起来。 比如你的项目是基于 Vue.js 的，那么你的项目运行时 Vue.js 就是必须的，如果缺少了 Vue 项目就运行不起来展示成空白页，所以时安装在生产环境中。 那哪些依赖可以安装在全局呢？像一些快速开发完整系统的项目脚手架。例如: Vue.js 的 Vue CLI,Hexo 的 hexo-cli；对标 npm 的包管理工具 yarn 和一些服务型工具依赖，比如 http-server，npm-check-updates 之类。 不需要在项目里就可能会使用的工具依赖，或者你想写静态 html 文件的时也可以使用 CSS 预处理器那么也可以把它安装在全局（但是如果是基于包管理的项目还是安装在开发环境） 什么？你问 npm 和 yarn 的区别用哪个好？？等下次我什么时候想起来吧，挖个坑先， 简单说下现在 npm 和 yarn 已经没有什么区别了只是命令行的差异 yarn 的某些命令行会精简一些，和安装依赖的时候是不是并行下载的区别了，另外 npm 有一个叫做 npx 的臭弟弟可是很厉害的。","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"},{"name":"挖坑","slug":"挖坑","permalink":"https://yogwang.site/tags/%E6%8C%96%E5%9D%91/"},{"name":"Node.js","slug":"Node-js","permalink":"https://yogwang.site/tags/Node-js/"}]},{"title":"CSS border-radius 制作特殊圆","slug":"CSS-border_radius-semicircle","date":"2019-08-23T02:24:35.000Z","updated":"2021-05-29T03:30:29.582Z","comments":true,"path":"2019/CSS-border_radius-semicircle/","link":"","permalink":"https://yogwang.site/2019/CSS-border_radius-semicircle/","excerpt":"以前只知道 border-radius 有一个圆角半径，今天在做一个半圆的时候突然发现，它还有 x 轴和 y 轴属性。 先来看一下 MDN 中 border-radius 说明： CSS 属性 border-radius 允许你设置元素的外边框圆角。当使用一个半径时确定一个圆形，当使用两个半径时确定一个椭圆。这个(椭)圆与边框的交集形成圆角效果。 该属性是一个 简写属性，是为了将这四个属性 border-top-left-radius、border-top-right-radius、border-bottom-right-radius，和 border-bottom-left-radius 简写为一个属性。 也就是说，每个圆角都有 圆角半径、 水平半长轴 和 垂直半长轴 属性值:","text":"以前只知道 border-radius 有一个圆角半径，今天在做一个半圆的时候突然发现，它还有 x 轴和 y 轴属性。 先来看一下 MDN 中 border-radius 说明： CSS 属性 border-radius 允许你设置元素的外边框圆角。当使用一个半径时确定一个圆形，当使用两个半径时确定一个椭圆。这个(椭)圆与边框的交集形成圆角效果。 该属性是一个 简写属性，是为了将这四个属性 border-top-left-radius、border-top-right-radius、border-bottom-right-radius，和 border-bottom-left-radius 简写为一个属性。 也就是说，每个圆角都有 圆角半径、 水平半长轴 和 垂直半长轴 属性值: border-radius: 1em; /* 等价于： */ border-top-left-radius: 1em; border-top-right-radius: 1em; border-bottom-right-radius: 1em; border-bottom-left-radius: 1em; border-radius: 1em/5em; /* 等价于： */ border-top-left-radius: 1em 5em; border-top-right-radius: 1em 5em; border-bottom-right-radius: 1em 5em; border-bottom-left-radius: 1em 5em; 还有一个复杂一些的 demo border-radius: 4px 3px 6px / 2px 4px; /* 等价于： */ border-top-left-radius: 4px 2px; border-top-right-radius: 3px 4px; border-bottom-right-radius: 6px 2px; border-bottom-left-radius: 3px 4px; 按照 MDN 上示例的拓展半圆.semicircle &#123; width: 100px; height: 50px; background: red; border-radius: 50% 50% 0 0 / 100% 100% 0 0; &#125; 气泡.bubble &#123; width: 120px; height: 120px; background: red; border-radius: 60px 60px 0 60px; &#125; 鸡蛋.egg &#123; width: 120px; height: 160px; background: red; border-radius: 60px 60px 60px 60px/100px 100px 60px 60px; &#125; DEMO 在 CodePen.io 参考：MDN : https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-radius","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://yogwang.site/tags/CSS/"}]},{"title":"CSS 中的文字截断","slug":"CSS-text_truncation","date":"2019-08-13T01:54:39.000Z","updated":"2021-05-29T03:30:14.341Z","comments":true,"path":"2019/CSS-text_truncation/","link":"","permalink":"https://yogwang.site/2019/CSS-text_truncation/","excerpt":"单行文字的截断非常简单，但多行文字的截断就很麻烦了，经常要配合 JavaScript 或者 其他语言进行字符串截断，然后拼接上 “…” 突然发现 line-clamp 它可以完成以纯 CSS 的多行文本截断，并且配合 text-overflow: ellipsis 就可以在尾部加上省略号，当然 overflow: hidden 并不可缺少","text":"单行文字的截断非常简单，但多行文字的截断就很麻烦了，经常要配合 JavaScript 或者 其他语言进行字符串截断，然后拼接上 “…” 突然发现 line-clamp 它可以完成以纯 CSS 的多行文本截断，并且配合 text-overflow: ellipsis 就可以在尾部加上省略号，当然 overflow: hidden 并不可缺少 单行文字的截断text-truncate &#123; word-wrap: normal; text-overflow: ellipsis; white-space: nowrap; overflow: hidden; &#125; 多行文字的截断text-truncate &#123; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; overflow: hidden; &#125; 在 CodePen 中查看 DEMO Can I use 中查看 兼容性 在本地测试中，Chrome, Firefox 和 Edge 都是没问题的，就是不知道国产的那些奇葩有没有问题。 补充:不同行数，修改 -webkit-line-clamp 即可它仅与 display 设置为 -webkit-box 或 -webkit-inline-box 的容器，并且 -webkit-box-orient 属性为 vertical。 Specifications:CSS Overflow Module Level 3 ( Working Draft ) 以上2019-08-13","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://yogwang.site/tags/CSS/"}]},{"title":"CSS 判断 input 是否为空","slug":"CSS-placeholder-shown","date":"2019-08-09T02:44:11.000Z","updated":"2021-05-29T03:30:22.696Z","comments":true,"path":"2019/CSS-placeholder-shown/","link":"","permalink":"https://yogwang.site/2019/CSS-placeholder-shown/","excerpt":"前景：很多情况下，都需要做到这样的一个输入框效果： 很久以前都是使用 :valid 来实现效果 DEMO 01 -&gt; CodePen","text":"前景：很多情况下，都需要做到这样的一个输入框效果： 很久以前都是使用 :valid 来实现效果 DEMO 01 -&gt; CodePen 但是要有 required 属性的必填项才可以使用这个伪类，来实现效果。 :placeholder-shown CSS pseudo-class今天发现了 :placeholder-shown 一个占位符是否显示的伪类，那么就可以配合 :not() 来实现一些效果（不是必须，反过来也可以） DEMO 02 -&gt; CodePen 兼容Chrome,FireFox,Safari 这些主流浏览器都支持, Edge,IE 阵亡… 👉 Can I use… Support","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://yogwang.site/tags/CSS/"}]},{"title":"如何理解 Call, Apply, Bind?","slug":"JS-call-apply-bind","date":"2019-08-06T01:37:07.000Z","updated":"2021-05-29T03:25:49.369Z","comments":true,"path":"2019/JS-call-apply-bind/","link":"","permalink":"https://yogwang.site/2019/JS-call-apply-bind/","excerpt":"今天，介绍这两个方法的区别以及一些妙用，还有用法相似的 bind 的方法。 它们最主要的作用，是改变 this 的指向。在平时的工作中，除了在写一些基础类，或者公用库方法的时候会用到它们，其他时候应用场景并不多（ React 我习惯用箭头函数）。","text":"今天，介绍这两个方法的区别以及一些妙用，还有用法相似的 bind 的方法。 它们最主要的作用，是改变 this 的指向。在平时的工作中，除了在写一些基础类，或者公用库方法的时候会用到它们，其他时候应用场景并不多（ React 我习惯用箭头函数）。 基本介绍func.call(thisArg, arg1, arg2, ...) func.apply(thisArg, [argsArray]) func.bind(thisArg[, arg1[, arg2[, ...]]]) 简单来说，他们都是改变函数执行时的上下文，参数形式都是差不多的。 先来看 call() 和 apply()两个方法，乍一看没啥区别，除了参数部分，也都是于JavaScript 1.3 中实现。 var test = &#123; color: '红色', say: function()&#123; console.log(\"颜色是\"+this.color) &#125; &#125; test.say() // 颜色是红色 var test2 = &#123; color:\"黄色\" &#125; test.say.call(test2) // 颜色是黄色 test.say.apply(test2) // 颜色是黄色 这样看来确实很容易搞混，具体的区别看以下例子🌰 var test = &#123; color:'红色', say:function(n,graph)&#123; console.log(`$&#123;n&#125;个$&#123;this.color&#125;的$&#123;graph&#125;`) &#125; &#125; test.say.call(&#123;color:'绿色'&#125;, 10, '矩形') // 10个绿色的矩形 test.say.apply(&#123;color:'蓝色'&#125;, 2, '三角形') // Uncaught TypeError: CreateListFromArrayLike called on non-object test.say.apply(&#123;color:'蓝色'&#125;, [2, '三角形']) // 2个蓝色的三角形 昂，差别就是这个了，传入的参数形式不一样，因为现在有了展开符 来 传入/接受 参数，所以差异已经不大了，但是在早期的环境中，如果不确定参数的话，一般都会选择用 apply 来一次性传入，并且使用 arguments 来处理。 说完了 apply 和 call ，再来说说 bindbind 方法与 apply 和 call 很相似，也是可以改变函数体内 this 的指向。 bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。 还是举个例子来说吧： var test = &#123; color: '红色', say: function()&#123; console.log(\"颜色是\"+this.color) &#125; &#125; test.say() // 颜色是红色 var test2 = &#123; color:\"黄色\" &#125; test.say.call(test2) // 颜色是黄色 test.say.apply(test2) // 颜色是黄色 test.say.bind(test2) // f() &#123;..&#125; // 可以看到bind()并没有输出，需要自执行或者赋值给一个变量然后调用 test.say.bind(test2)() // 颜色是黄色 var bindTest2 = test.say.bind(test2) bindTest2() // 颜色是黄色 简单总结来说 call()/apply()/bind() 都可以改变函数内的 this 指向； call()/apply()会立即执行函数，而bind() 不会立即执行； bind() 会返回一个新得函数，并不会马上执行； apply()，传入的参数需要数组格式； fun.apply(thisArg, [arg1, arg2, ...]) ↔ fun.call(thisArg, arg1, arg2, ...) bind() 传入的参数的方式和 call() 一样。 fun.call(thisArg, arg1, arg2, ...)，fun.bind(thisArg, arg1, arg2, ...) 疑惑部分1.bind() 传入的参数部分是否可以在 bind 的时候不传入，后续使用的时候在传入？可以 function add(a, b) &#123; return a + b; &#125; var add1 = add.bind(null); console.log(add1(1,3)); // 4 var add2 = add.bind(null,10) console.log(add2(5)); // 15 参考Function.prototype.call() - MDNFunction.prototype.apply() - MDNFunction.prototype.bind() - MDN OBKoro1 - js 面试官想了解你有多理解 call,apply,bind?Micherwa - 「干货」细说 call、apply 以及 bind 的区别和用法公子 - 如何理解，javascript bindSchaos - 一次搞懂前端面試最愛問的 apply、bind、call","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"}]},{"title":"PHPOK 5.x 多站点共享留言板","slug":"phpok-Guestbook","date":"2019-08-03T03:06:49.000Z","updated":"2021-05-29T03:32:45.684Z","comments":true,"path":"2019/phpok-Guestbook/","link":"","permalink":"https://yogwang.site/2019/phpok-Guestbook/","excerpt":"前景： 要求 中文站 和 英文站 提交的留言内容都收集在中文站的留言板中，方便查看。 之前 3.x 版本直接使用 CateID 就可以了，但是在 5.x 版本中不行。 文档里也没有，所以在尝试多次之后，憋不住就在群里问了作者团队， 答： 在 Ajax 请求地址上加上 SiteID 就可以了。","text":"前景： 要求 中文站 和 英文站 提交的留言内容都收集在中文站的留言板中，方便查看。 之前 3.x 版本直接使用 CateID 就可以了，但是在 5.x 版本中不行。 文档里也没有，所以在尝试多次之后，憋不住就在群里问了作者团队， 答： 在 Ajax 请求地址上加上 SiteID 就可以了。 So: ... $(this).ajaxSubmit(&#123; &#39;url&#39;:api_url(&#39;post&#39;,&#39;save&#39;,&#39;id&#x3D;book&#39;)+&#39;&amp;siteId&#x3D;1&#39;, &#39;type&#39;:&#39;post&#39;, &#39;data&#39;: &#123; &#39;title&#39;: name, &#39;fullname&#39;: name, &#39;tel&#39;: tel &#125;, &#39;dataType&#39;:&#39;json&#39;, &#39;success&#39;:function(res)&#123; &#x2F;&#x2F; Do sth... &#125; &#125;); api_url 为框架内置方法，所以只能拼接字符串了。 后台查看：","categories":[{"name":"工作延伸","slug":"工作延伸","permalink":"https://yogwang.site/categories/%E5%B7%A5%E4%BD%9C%E5%BB%B6%E4%BC%B8/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://yogwang.site/tags/PHP/"},{"name":"PHPOK","slug":"PHPOK","permalink":"https://yogwang.site/tags/PHPOK/"}]},{"title":"Apache 配置虚拟域名","slug":"php-VirtualHost","date":"2019-07-30T07:13:41.000Z","updated":"2021-05-29T03:32:15.037Z","comments":true,"path":"2019/php-VirtualHost/","link":"","permalink":"https://yogwang.site/2019/php-VirtualHost/","excerpt":"在本地调试后端项目时候经常会用到虚拟域名的功能； 毕竟项目都放在 WWW 目录下，如果不使用虚拟域名，URL 实在太长，实在不方便调试。 例如：http://localhost/project/public/index.php/sample/test/hello 如果使用虚拟域名就可以简化为 http://p.loc/sample/test/hello 着实方便很多。 但我总是记不住怎么去添加虚拟域名，总不可能一直百度吧,所以就记下笔记了。","text":"在本地调试后端项目时候经常会用到虚拟域名的功能； 毕竟项目都放在 WWW 目录下，如果不使用虚拟域名，URL 实在太长，实在不方便调试。 例如：http://localhost/project/public/index.php/sample/test/hello 如果使用虚拟域名就可以简化为 http://p.loc/sample/test/hello 着实方便很多。 但我总是记不住怎么去添加虚拟域名，总不可能一直百度吧,所以就记下笔记了。 本地使用的 phpStudy 集成环境，所以步骤都是按照 phpStudy 的来，实际也相差不大。 方法 1：针对项目添加虚拟域名Step1： 打开 vhosts-ini 配置文件 或者使用路径打开 ..\\phpStudy\\PHPTutorial\\Apache\\conf\\vhosts.conf Step2： 添加新 VirtualHost&lt;VirtualHost _default_:80&gt; ServerName &quot;p.loc&quot; DocumentRoot &quot;E:&#x2F;WWW&#x2F;project&#x2F;public&quot; &lt;&#x2F;VirtualHost&gt; Step3： 修改 hosts 文件 或者使用路径打开 C:\\Windows\\System32\\drivers\\etc Step3： 重启 ALache 服务 不用修改其他，因为 phpStudy 启用了 conf/vhosts.conf 在 httpd.conf:486 更加偷懒的方式？想到了一种泛域名解析的方式去配置虚拟域名，然后根据二级域名来指向不同目录。但是在只修改 vhosts-ini 情况还不能办到。可能需要启动 htttpd.conf 里的扩展功能，暂时不研究了，记一下先。 Internal Server Error遇到 Internal Server Error ，在 apache 配置文件 httpd.conf 中开启重写 #LoadModule rewrite_module modules&#x2F;mod_rewrite.so &#x2F;&#x2F; 去掉#","categories":[{"name":"工作延伸","slug":"工作延伸","permalink":"https://yogwang.site/categories/%E5%B7%A5%E4%BD%9C%E5%BB%B6%E4%BC%B8/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://yogwang.site/tags/PHP/"},{"name":"挖坑","slug":"挖坑","permalink":"https://yogwang.site/tags/%E6%8C%96%E5%9D%91/"},{"name":"Apache","slug":"Apache","permalink":"https://yogwang.site/tags/Apache/"}]},{"title":"简单设置Video标签的播放倍速","slug":"html5-set_videoSpeed","date":"2019-07-21T08:21:58.000Z","updated":"2021-05-29T03:26:34.099Z","comments":true,"path":"2019/html5-set_videoSpeed/","link":"","permalink":"https://yogwang.site/2019/html5-set_videoSpeed/","excerpt":"在 B 站 看视频教学的时候，发现最快只有 2 倍速, 我觉得太慢了，在百度之后发现有 video 标签有 playbackRate 属性可以设置倍速。","text":"在 B 站 看视频教学的时候，发现最快只有 2 倍速, 我觉得太慢了，在百度之后发现有 video 标签有 playbackRate 属性可以设置倍速。 应该适用使用 HTML5 的 video 标签来为播放器的在线视频站。 记一下省的以后再百度 在控制台输入即可： // 获取视频元素 var video = document.querySelector(\"video\"); // 设置播放倍率 video.playbackRate = 10; // 设置为10倍速 07/30/2019 补：只有 Google Chrome 和 Safari 支持 playbackRate 属性。[ w3school ]","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://yogwang.site/tags/HTML/"}]},{"title":"Electron:Electron-builder+Electron-updater 完成Electron应用的自升级","slug":"Electron04-ElectronBuilder-ElectronUpdater","date":"2019-07-19T06:25:13.000Z","updated":"2021-05-29T03:29:52.941Z","comments":true,"path":"2019/Electron04-ElectronBuilder-ElectronUpdater/","link":"","permalink":"https://yogwang.site/2019/Electron04-ElectronBuilder-ElectronUpdater/","excerpt":"","text":"2019/07/19 开坑。","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"未完成","slug":"未完成","permalink":"https://yogwang.site/tags/%E6%9C%AA%E5%AE%8C%E6%88%90/"},{"name":"Electron","slug":"Electron","permalink":"https://yogwang.site/tags/Electron/"}]},{"title":"万能的 :checked + label","slug":"CSS-checked&label","date":"2019-07-18T06:06:44.000Z","updated":"2021-05-29T03:30:28.402Z","comments":true,"path":"2019/CSS-checked&label/","link":"","permalink":"https://yogwang.site/2019/CSS-checked&label/","excerpt":"Meathill：纯 CSS 组件顾名思义，只改变外观，不改变行为。所以它的功能不会因为浏览器变化而变化，即使浏览器支持不完善，即使因为加载速度或者网络关系，导致 CSS、JS 加载失败，它最多样式回归到原始样式，功能是完全一致的。在非标准浏览器环境下，如读屏器，也是如此 前年看肉大直播的时候听到：万能的 :checked + label 当时没有体会到有啥万能，不就是自定义 input 样式吗，直到前段时间看到一个 Demo 虽然不是使用的这种方法，但是我突然就明白了，这个就可以用 :checked + label 来实现。 … 原来很多需要 Js 配合的一些效果点击效果只需要 :checked + label 就可以完成。","text":"Meathill：纯 CSS 组件顾名思义，只改变外观，不改变行为。所以它的功能不会因为浏览器变化而变化，即使浏览器支持不完善，即使因为加载速度或者网络关系，导致 CSS、JS 加载失败，它最多样式回归到原始样式，功能是完全一致的。在非标准浏览器环境下，如读屏器，也是如此 前年看肉大直播的时候听到：万能的 :checked + label 当时没有体会到有啥万能，不就是自定义 input 样式吗，直到前段时间看到一个 Demo 虽然不是使用的这种方法，但是我突然就明白了，这个就可以用 :checked + label 来实现。 … 原来很多需要 Js 配合的一些效果点击效果只需要 :checked + label 就可以完成。 1. 按钮交互 2. 下拉菜单 3. 折叠面板 4. 选项卡 5. 模拟弹出窗口 应该还有其他我没有想到的，以后想到了，再慢慢补全起来。","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://yogwang.site/tags/CSS/"}]},{"title":"BetterScrol 2.x Mouse-whell 没效果","slug":"BetterScrol-mouse-wheel","date":"2019-07-15T03:13:04.000Z","updated":"2021-05-29T03:30:45.348Z","comments":true,"path":"2019/BetterScrol-mouse-wheel/","link":"","permalink":"https://yogwang.site/2019/BetterScrol-mouse-wheel/","excerpt":"","text":"安装yarn add @better-scroll/mouse-wheel@next 使用import BScroll from &#39;@better-scroll&#x2F;core&#39; import MouseWheel from &#39;@better-scroll&#x2F;mouse-wheel&#39; BScroll.use(MouseWheel) new BScroll(&#39;.bs-wrap&#39;, &#123; &#x2F;&#x2F;... mouseWheel: &#123; speed: 20, invert: false, easeTime: 300 &#125; &#125;) 但是为什么在原有的基础上这样写没有用呢。官方 Demo查看 Demo 源码在 scroll-wrapper 外多了一层 core-mouse-wheel 加上就可以了。 😂 没仔细看 Demo 源码","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"BetterScrol.js","slug":"BetterScrol-js","permalink":"https://yogwang.site/tags/BetterScrol-js/"},{"name":"问题","slug":"问题","permalink":"https://yogwang.site/tags/%E9%97%AE%E9%A2%98/"}]},{"title":"Hexo 主题开发制作","slug":"hexo_theme","date":"2019-07-11T07:34:10.000Z","updated":"2021-06-03T07:40:54.515Z","comments":true,"path":"2019/hexo_theme/","link":"","permalink":"https://yogwang.site/2019/hexo_theme/","excerpt":"前置 Hexo 的安装就不讲了，直接开始我在制作 Hexo 主题遇到的一些问题。 首先在使用 Hexo cli 脚手架创建完 Hexo 项目后会有一个默认官方主题 landscape 在 themes 目录中复制一份出来重命名成自己的名称，例如我的就是改成了 yogwang，并且在根目录中的 _config.yml 中修改主题为自己的主题","text":"前置 Hexo 的安装就不讲了，直接开始我在制作 Hexo 主题遇到的一些问题。 首先在使用 Hexo cli 脚手架创建完 Hexo 项目后会有一个默认官方主题 landscape 在 themes 目录中复制一份出来重命名成自己的名称，例如我的就是改成了 yogwang，并且在根目录中的 _config.yml 中修改主题为自己的主题 # Extensions ## Plugins: https:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F; ## Themes: https:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F; theme: yogwang &#x2F;&#x2F;这里修改成自己的主题 目录完全展开主题目录：─yogwang ├─languages &#x2F;&#x2F; 国际化(i18n)让网站以不同语言呈现 │ └─... ├─layout &#x2F;&#x2F; 布局文件 │ ├─_partial &#x2F;&#x2F; 局部组件 │ │ ├─post &#x2F;&#x2F; 文章组件 │ │ └─... │ ├─_widget &#x2F;&#x2F; 侧边栏部件 │ └─... ├─scripts &#x2F;&#x2F; 启动时自动载入的Js脚本 ├─source &#x2F;&#x2F; 资源文件夹 │ ├─css &#x2F;&#x2F; CSS样式 │ │ ├─fonts &#x2F;&#x2F; 字体 │ │ ├─images &#x2F;&#x2F; 图片 │ │ ├─_partial &#x2F;&#x2F; 局部组件CSS │ │ ├─_util &#x2F;&#x2F; 分栏&amp;Mixin │ │ └─... │ ├─fancybox &#x2F;&#x2F; fancybox插件 │ └─js &#x2F;&#x2F; JS脚本 ├─_config.yml &#x2F;&#x2F; 主题配置文件 ├─.gitignore &#x2F;&#x2F; Git忽略配置 ├─Gruntfile.js &#x2F;&#x2F; Grunt项目文件 ├─LICENSE &#x2F;&#x2F; 授权条款 ├─package.json &#x2F;&#x2F; 包管理配置文件 └─README.md &#x2F;&#x2F; 项目手册 因为我是完全重新创作一个主题，所以需要保留下来的目录如下 保留下来的目录─yogwang ├─layout │ ├─_partial │ │ └─post │ │ └─... │ ├─_widget │ └─... ├─scripts ├─source │ ├─css │ └─js ├─_config.yml ├─.gitignore ├─package.json └─README.md 因为仅自己使用所以 languages、Gruntfile.js 和 LICENSE 没有保留， 保留下了 layout 布局文件夹的全部文件， 清空了 scripts 和 source 目录下文件仅保留目录; README.md 作为备忘录。 制作因为保留下了官方主题的布局文件，所以只需要在原有基础上调整就可以制作一个主题雏形。 调整后的目录：Layout │ archive.ejs &#x2F;&#x2F; 所有归档文章列表 │ category.ejs &#x2F;&#x2F; 归档时间来分类的列表 │ index.ejs &#x2F;&#x2F; 主页 │ layout.ejs &#x2F;&#x2F; 通用布局模板 │ page.ejs &#x2F;&#x2F; 单页模板 │ post.ejs &#x2F;&#x2F; 文章模板 │ tag.ejs &#x2F;&#x2F; 标签归档列表页 ├─_partial &#x2F;&#x2F; 私有组件 │ │ archive-post.ejs &#x2F;&#x2F; 列表页文章预览 │ │ archive.ejs &#x2F;&#x2F; 文章列表 │ │ article.ejs &#x2F;&#x2F; 文章详情 │ │ footer.ejs &#x2F;&#x2F; 尾部模板 │ │ meta.ejs &#x2F;&#x2F; 页面META部分 │ │ header.ejs &#x2F;&#x2F; 头部模板 │ │ sidebar.ejs &#x2F;&#x2F; 侧边栏 │ └─posts &#x2F;&#x2F; 文章组件 │ category.ejs &#x2F;&#x2F; 文章分类归档 │ date.ejs &#x2F;&#x2F; 文章创建时间 │ nav.ejs &#x2F;&#x2F; 文章分页 │ tag.ejs &#x2F;&#x2F; 文章Tag │ title.ejs &#x2F;&#x2F; 文章标题 └─_widget &#x2F;&#x2F; 侧边栏部件 archive.ejs &#x2F;&#x2F; 分类列表部件 category.ejs &#x2F;&#x2F; 时间归档部件 recent_posts.ejs &#x2F;&#x2F; 最后发布部件 tag.ejs &#x2F;&#x2F; 标签分类部件 书写样式直接跳过,以下是一些制作完成之后遇到的问题 问题在主题配置文件中添加个人信息并输出到页面打开 thems 目录下对应主题的 _config.yml 文件，参考官方模板中的 Menu 属性同样创建 userinfo # userinfo user: nickname: 王阳阳 bio: &#39;久之须自见得&#39; commpany: ODIN.INC address: Jiaxing,China follow: github: https:&#x2F;&#x2F;github.com&#x2F;yogwang weibo: http:&#x2F;&#x2F;weibo.com&#x2F;yooooooge 如何在页面中输出？？在页面对应位置 &lt;%= theme.user.nickname %&gt; 即可，也可以循环输出 &lt;% for (var i in theme.follow)&#123; %&gt; &lt;a href&#x3D;&quot;&lt;%&#x3D; theme.follow[i] %&gt;&quot; target&#x3D;&quot;_blank&quot;&gt;&lt;&#x2F;a&gt; &lt;% &#125; %&gt; 其实也可以在 Hexo 根目录下的 _config.yml 文件配置 输出标签如 &lt;%= config.LABEL %&gt; 不知道怎么生成 ‘关于我’ 单页面在 Layout 中编写完 about.ejs 模板之后,我想使用这个布局来创建关于我的单页面 在 Hexo.io 官方文档中是这样写的 hexo new [layout] &lt;title&gt; 新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。 使用 hexo new 命令，创建关于我单页面 PS E:\\yogwang.github.io&gt; hexo new about aboutme INFO Created: E:\\yogwang.github.io\\source\\_posts\\aboutme.md 这样就会生成一篇使用 about.ejs 来布局的 文章 并生成在_posts 文件夹下。注意哦，生成的是文章会在文章列表中显示。 那么问题来了，我怎么创建一个使用 about.ejs 布局，且不在文章列表中显示的单页面呢 Hexo 有 三种默认布局 ：post、page 和 draft，它们分别对应不同的路径，自定义的其他布局和 post 相同，草稿文件都将储存到 source/_posts 文件夹。 所以在 hexo new 页面的时候先使用 hexo new page about PS E:\\yogwang.github.io&gt; hexo new page about INFO Created: E:\\yogwang.github.io\\source\\about\\index.md 这样会在 source 目录下创建 about 目录，并生成 index.md 文件，打开它在 Front-matter 中添加 layout: about --- title: 我 date: 2019-07-11 15:10:39 layout: about ---","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://yogwang.site/tags/Hexo/"}]},{"title":"纯CSS实现瀑布流布局","slug":"CSS-WaterFull","date":"2019-07-10T09:35:57.000Z","updated":"2021-05-29T03:30:13.016Z","comments":true,"path":"2019/CSS-WaterFull/","link":"","permalink":"https://yogwang.site/2019/CSS-WaterFull/","excerpt":"原理： column-count: n 将元素中的文本分为 n 列 break-inside: avoid 避免元素内部断行并产生新列 可以不加，但可能会影响布局效果 Demo:👉 在 CodePen 中打开","text":"原理： column-count: n 将元素中的文本分为 n 列 break-inside: avoid 避免元素内部断行并产生新列 可以不加，但可能会影响布局效果 Demo:👉 在 CodePen 中打开 HTML html5 div#container &#x2F;&#x2F; 外部容器 ul#waterfall &#x2F;&#x2F; 瀑布流容器 - for(let i&#x3D;0;i&lt;12;i++ ) li.item &#x2F;&#x2F; 内部项目 &#x2F;&#x2F; 生成随机高度 - let height &#x3D; Math.ceil(Math.random() *(150+1-500)+500) &#x2F;&#x2F; 模拟不同高度图片 div(class&#x3D;&#39;img&#39;,style&#x3D;&#39;height:&#39;+height+&#39;px&#39;) &#x2F;&#x2F; 模拟介绍文本 p Lorem ipsum dolor sit amet consectetur adipisicing elit. Necessitatibus culpa cupiditate a aperiam libero aspernatur unde CSS &#x2F;&#x2F;reset * padding 0 margin 0 &#x2F;&#x2F; 外部容器 #container width 1200px margin 30px auto &#x2F;&#x2F; 瀑布流容器 #waterfall column-count 3 list-style-type none &#x2F;&#x2F; 内部项目 .item padding 10px margin 0 10px 20px break-inside avoid border: 2px solid #000 div.img background red","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://yogwang.site/tags/CSS/"}]},{"title":"Hello Hexo","slug":"hello you","date":"2019-07-09T03:59:16.000Z","updated":"2021-05-29T03:27:03.083Z","comments":true,"path":"2019/hello you/","link":"","permalink":"https://yogwang.site/2019/hello%20you/","excerpt":"","text":"Hello Hexo,Hello Github Pages2019.7.9 11:59:16","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://yogwang.site/tags/Hexo/"}]},{"title":"Git 撤销上一次提交 并将暂存区文件重新提交","slug":"git_commit--amend","date":"2019-07-03T09:29:11.000Z","updated":"2021-05-29T03:29:48.525Z","comments":true,"path":"2019/git_commit--amend/","link":"","permalink":"https://yogwang.site/2019/git_commit--amend/","excerpt":"把刚刚提交到的版本库的操作撤销掉,并将正确的版本提交 这时我们就需要用到 git commit –-amend 命令 我们把文件修改为正确的，然后 git add 到暂存区 再使用 git commit -–amend 命令这时 Bash 会提示 $ git commit --amend hint: Waiting for your editor to close the file...","text":"把刚刚提交到的版本库的操作撤销掉,并将正确的版本提交 这时我们就需要用到 git commit –-amend 命令 我们把文件修改为正确的，然后 git add 到暂存区 再使用 git commit -–amend 命令这时 Bash 会提示 $ git commit --amend hint: Waiting for your editor to close the file... 并在编辑器弹出 COMMIT_EDITMSG version 0.1.6 # Please enter the commit message for your changes. Lines starting # with &#39;#&#39; will be ignored, and an empty message aborts the commit. # # Date: Wed Jul 3 11:00:38 2019 +0800 # # On branch master # Your branch and &#39;origin&#x2F;master&#39; have diverged, # and have 1 and 1 different commits each, respectively. # (use &quot;git pull&quot; to merge the remote branch into yours) # # Changes to be committed: # modified: readme.md # 最上面的 version 0.1.6 是我们上次提交是的备注下面的 modified: readme.md 则表明我们这次重修提交修改了 readme.md 文件如果需要修改备注则修改最上边的备注并保存，不需要直接退出关闭即可提交成功： [master 5df6a16] version 0.1.6 Date: Wed Jul 3 11:00:38 2019 +0800 1 files changed, 1 insertions(+), 1 deletions(-) 再次查看日志 git log --oneline $ git log --oneline 7475748 (HEAD -&gt; master) version 0.1.6 9750475 version 0.1.5 c1dd820 version 0.1.4 b3d104c version 0.1.3 ... 发现只有 1 次 version 0.1.6 提交说明我们刚刚是在修改而不是再次提交 如果需要再 push 到远程库需要加上 --force/-f 参数$ git push --force","categories":[{"name":"工作延伸","slug":"工作延伸","permalink":"https://yogwang.site/categories/%E5%B7%A5%E4%BD%9C%E5%BB%B6%E4%BC%B8/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://yogwang.site/tags/Git/"}]},{"title":"Git 编辑历史提交的 Commit","slug":"git_rebase","date":"2019-07-03T08:28:25.000Z","updated":"2021-05-29T03:28:32.941Z","comments":true,"path":"2019/git_rebase/","link":"","permalink":"https://yogwang.site/2019/git_rebase/","excerpt":"做一个功能，可能提交了 10 多次，会不会有一些崩溃？单纯这么多次的 commit 就可能出现有无用，或者可以合并的 commit，就很让人不舒服。 基于上面所说问题，不难想到：每一次功能开发， 对多个 commit 进行合并或者删除处理，这时候就需要用到 git rebase 修改提交的历史 Commit Eg:修改最近的 4 次提交纪录 git rebase -i HEAD~4 -i 是 --interactive 的缩写 - 交互的意思； HEAD~4 修改最近的 4 次提交记录；","text":"做一个功能，可能提交了 10 多次，会不会有一些崩溃？单纯这么多次的 commit 就可能出现有无用，或者可以合并的 commit，就很让人不舒服。 基于上面所说问题，不难想到：每一次功能开发， 对多个 commit 进行合并或者删除处理，这时候就需要用到 git rebase 修改提交的历史 Commit Eg:修改最近的 4 次提交纪录 git rebase -i HEAD~4 -i 是 --interactive 的缩写 - 交互的意思； HEAD~4 修改最近的 4 次提交记录； 然后在弹出的编辑器中显示 git-rebase-todo 文件，在 rebase-todo 中修改列表中的 pick 命令。 pick f77a6e7 version 0.1.3 pick 434a2f2 version 0.1.4 pick 094263b version 0.1.5 pick 9135476 version 0.1.5 change XXXX # Rebase 50adf2a..9135476 onto 50adf2a (4 commands) # # Commands: # p, pick &lt;commit&gt; &#x3D; use commit &#x2F;&#x2F; 保留该commit # r, reword &lt;commit&gt; &#x3D; use commit, but edit the commit message &#x2F;&#x2F; 保留该commit，但修改该commit的注释 # e, edit &lt;commit&gt; &#x3D; use commit, but stop for amending &#x2F;&#x2F; 保留该commit, 但我要停下来修改该commit # s, squash &lt;commit&gt; &#x3D; use commit, but meld into previous commit &#x2F;&#x2F; 将该commit合并到前一个commit # f, fixup &lt;commit&gt; &#x3D; like &quot;squash&quot;, but discard this commit&#39;s log message &#x2F;&#x2F; 将该commit合并到前一个commit，并不要保留该提交的注释信息 # x, exec &lt;command&gt; &#x3D; run command (the rest of the line) using shell &#x2F;&#x2F; 执行后边的shell命令 # b, break &#x3D; stop here (continue rebase later with &#39;git rebase --continue&#39;) &#x2F;&#x2F;在这里停止，稍后使用 --continue 继续 # d, drop &lt;commit&gt; &#x3D; remove commit &#x2F;&#x2F; 清除该commit # l, label &lt;label&gt; &#x3D; label current HEAD with a name &#x2F;&#x2F; 使用label标记当前HEAD # t, reset &lt;label&gt; &#x3D; reset HEAD to a label &#x2F;&#x2F; 设置HEAD到标记的label # m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;] &#x2F;&#x2F; 合并分支 # . create a merge commit using the original merge commit&#39;s # . message (or the oneline, if no original merge commit was # . specified). Use -c &lt;commit&gt; to reword the commit message. # # These lines can be re-ordered; they are executed from top to bottom. # # If you remove a line here THAT COMMIT WILL BE LOST. # # However, if you remove everything, the rebase will be aborted. # # Note that empty commits are commented out Eg:我需要修改第二行和第三行的 Commit，那我将第二行和第三行的 pick 改成 edit 或 e，保存并退出。 git 会依次执行上面的操作，当操作为 pick 时，直接 commit。当操作为 edit 时，会中断，并提示 You can amend the commit now, with &#x2F;&#x2F; 你可以使用 git commit --amend 来修改此次提交 git commit --amend Once you are satisfied with your changes, run &#x2F;&#x2F; 修改以后满意了，执行 git rebase --continue 继续剩下的流程 git rebase --continue 全部修改完成以后提示如下： $ git rebase --continue Successfully rebased and updated refs&#x2F;heads&#x2F;master. 如果需要把修改的历史 commit push 到远程库中使用 git push -f 命令即可 如果意外关闭了弹出的编辑窗口如果 git 没有执行完操作，git rebase --edit-todo 命令可以返回编辑","categories":[{"name":"工作延伸","slug":"工作延伸","permalink":"https://yogwang.site/categories/%E5%B7%A5%E4%BD%9C%E5%BB%B6%E4%BC%B8/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://yogwang.site/tags/Git/"}]},{"title":"Chrome下垂直居中容器内区块改变高度使外层容器被移动","slug":"Chrome-VerticalCentering","date":"2019-07-03T07:37:00.000Z","updated":"2021-06-03T07:38:06.962Z","comments":true,"path":"2019/Chrome-VerticalCentering/","link":"","permalink":"https://yogwang.site/2019/Chrome-VerticalCentering/","excerpt":"问题在 Chrome 中，使用 transform 或者 flex 垂直居中内容块，当视窗滚动到容器一半时再经过第一个内容块（之后的都正常），整个容器块都会被移动 内容块高度已经大于文本块高度 内容块垂直居中 视窗滚动到容器一半时 改变文本块高度 Firefox 同样遇到该问题 Edge 正常 IE11 正常","text":"问题在 Chrome 中，使用 transform 或者 flex 垂直居中内容块，当视窗滚动到容器一半时再经过第一个内容块（之后的都正常），整个容器块都会被移动 内容块高度已经大于文本块高度 内容块垂直居中 视窗滚动到容器一半时 改变文本块高度 Firefox 同样遇到该问题 Edge 正常 IE11 正常 前景 要求一般情况下只显示文本前两行，当鼠标悬停时显示全部文本内容 复现👉 CodePen 解决在第一个 li 前创建一个与之等高的伪类就可以解决 ul:before&#123; content : \"\"; width : 1px; height : 520px display : blcok; position : absolute; &#125; 附： CodePen - https://codepen.io/yooooge/pen/MPNGpY Chrome 版本 Firefox 版本 Edge 版本 IE 版本 yogWang 2019/07/03","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://yogwang.site/tags/CSS/"},{"name":"问题","slug":"问题","permalink":"https://yogwang.site/tags/%E9%97%AE%E9%A2%98/"},{"name":"Chrome","slug":"Chrome","permalink":"https://yogwang.site/tags/Chrome/"}]},{"title":"Git 遇到的一些问题","slug":"git_question","date":"2019-07-03T06:27:56.000Z","updated":"2021-05-29T03:29:08.043Z","comments":true,"path":"2019/git_question/","link":"","permalink":"https://yogwang.site/2019/git_question/","excerpt":"这里是我在日常中遇到的一些 Git 方面的问题。 Error: GH007 不能退出、终止当前命令？ 想要删除提交的历史 Commit? 合并与删除历史提交的 Commit ? 操作失误，退回操作之前的版本库","text":"这里是我在日常中遇到的一些 Git 方面的问题。 Error: GH007 不能退出、终止当前命令？ 想要删除提交的历史 Commit? 合并与删除历史提交的 Commit ? 操作失误，退回操作之前的版本库 Error: GH007推送本地库的内容到远程库上报 error: GH007 时，在 Setting 里把 Email 的 Keep my email address private 勾选去掉即可 不能退出、终止当前命令？尝试按下 Q 键 想要删除提交的历史 Commit?1. 上一次提交的 Commit 有错误需要修改？ 详细git commit --amend &#x2F;&#x2F; 撤销上一次提交 并将暂存区文件重新提交 2. 合并与删除历史提交的 Commit ? 详细git rebase -i HEAD~n 常用指令： p,pick - 保留 r,reword - 修改注释 e,edit - 停下来修改注释 s,squash - 合并到上一个 commit 并且合并注释 f,fixup - 丢掉备注并且合并到上一个 commit d,drop - 删除 commit 操作失误，退回操作之前的版本库使用 git reflog 查看操作日志，找到误操之前的版本号 再使用 git reset --hard &lt;commit_id&gt; 退回版本","categories":[{"name":"工作延伸","slug":"工作延伸","permalink":"https://yogwang.site/categories/%E5%B7%A5%E4%BD%9C%E5%BB%B6%E4%BC%B8/"}],"tags":[{"name":"问题","slug":"问题","permalink":"https://yogwang.site/tags/%E9%97%AE%E9%A2%98/"},{"name":"Git","slug":"Git","permalink":"https://yogwang.site/tags/Git/"}]},{"title":"Electron_03 - Electron-builder","slug":"Electron03-Electron-builder","date":"2019-06-21T08:41:29.000Z","updated":"2021-06-03T07:39:57.993Z","comments":true,"path":"2019/Electron03-Electron-builder/","link":"","permalink":"https://yogwang.site/2019/Electron03-Electron-builder/","excerpt":"安装 Electron-builder$ git clone https:&#x2F;&#x2F;github.com&#x2F;electron&#x2F;electron-quick-start $ cd electron-quick-start $ yarn add electron-builder --dev &#x2F;&#x2F; 官方推荐 or $ npm install elctron-builder --save-dev","text":"安装 Electron-builder$ git clone https:&#x2F;&#x2F;github.com&#x2F;electron&#x2F;electron-quick-start $ cd electron-quick-start $ yarn add electron-builder --dev &#x2F;&#x2F; 官方推荐 or $ npm install elctron-builder --save-dev 配置 Electron-builder在 config.json 配置 build &quot;build&quot;: &#123; &quot;productName&quot;:&quot;xxxx&quot;, &#x2F;&#x2F; 项目名 这也是生成的exe文件的前缀名 &quot;appId&quot;: &quot;com.xxx.xxxxx&quot;, &#x2F;&#x2F; 包名 &quot;copyright&quot;:&quot;xxxx&quot;, &#x2F;&#x2F; 版权信息 &quot;directories&quot;: &#123; &#x2F;&#x2F; 输出文件夹 &quot;output&quot;: &quot;build&quot; &#125;, &#x2F;&#x2F; windows相关的配置 &quot;win&quot;: &#123; &quot;icon&quot;: &quot;xxx&#x2F;icon.ico&quot; &#x2F;&#x2F; 图标路径 &#125;, &quot;nsis&quot;: &#123; &#x2F;&#x2F;nsis安装脚本 &quot;oneClick&quot;: false, &#x2F;&#x2F; 是否一键安装 &quot;allowElevation&quot;: true, &#x2F;&#x2F; 允许请求提升。 如果为false，则用户必须使用提升的权限重新启动安装程序。 &quot;allowToChangeInstallationDirectory&quot;: true, &#x2F;&#x2F; 允许修改安装目录 &quot;installerIcon&quot;: &quot;.&#x2F;build&#x2F;icons&#x2F;aaa.ico&quot;,&#x2F;&#x2F; 安装图标 &quot;uninstallerIcon&quot;: &quot;.&#x2F;build&#x2F;icons&#x2F;bbb.ico&quot;,&#x2F;&#x2F;卸载图标 &quot;installerHeaderIcon&quot;: &quot;.&#x2F;build&#x2F;icons&#x2F;aaa.ico&quot;, &#x2F;&#x2F; 安装时头部图标 &quot;createDesktopShortcut&quot;: true, &#x2F;&#x2F; 创建桌面图标 &quot;createStartMenuShortcut&quot;: true,&#x2F;&#x2F; 创建开始菜单图标 &quot;shortcutName&quot;: &quot;xxxx&quot;, &#x2F;&#x2F; 图标名称 &#125;, &#125; 增加 scripts 脚本到 config.json &quot;scripts&quot;: &#123; &quot;pack&quot;: &quot;electron-builder --dir&quot;, &quot;dist&quot;: &quot;electron-builder&quot; &#125; 其他平台 &#x2F;&#x2F; mac &quot;mac&quot;: &#123; &quot;category&quot;: &quot;your.app.category.type&quot; &#125; &#x2F;&#x2F; linux &quot;linux&quot;: &#123; &quot;category&quot;: &quot;your.app.category.type&quot; &#125; …..待完成 与 Electron-parkager 的差异…..待完成2019/6/20","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Electron","slug":"Electron","permalink":"https://yogwang.site/tags/Electron/"}]},{"title":"Electron_02 - Electron-packager","slug":"Electron02-Electron-parkager","date":"2019-06-18T02:58:51.000Z","updated":"2021-06-03T07:39:57.317Z","comments":true,"path":"2019/Electron02-Electron-parkager/","link":"","permalink":"https://yogwang.site/2019/Electron02-Electron-parkager/","excerpt":"安装 Electron-packager 需要 Node.js 6.0 或更高版本 npm install electron-packager --save-dev electron-packager API 使用命令行打包electron-packager &lt;sourcedir&gt; &lt;appname&gt; --platform&#x3D;&lt;platform&gt; --arch&#x3D;&lt;arch&gt; [optional flags...] 必需参数 sourcedir - 应用程序源","text":"安装 Electron-packager 需要 Node.js 6.0 或更高版本 npm install electron-packager --save-dev electron-packager API 使用命令行打包electron-packager &lt;sourcedir&gt; &lt;appname&gt; --platform&#x3D;&lt;platform&gt; --arch&#x3D;&lt;arch&gt; [optional flags...] 必需参数 sourcedir - 应用程序源 选项 appname - 应用名称 electron-version - Electron 版本号 (electron –version) platform - 要构建的平台 all,或者 darwin, linux, mas, win32 arch - 要使用的架构 all,或者 ia32, x64, armv7l, arm64, mips64el out - 输出目录 icon - 自定义图标路径 app-copyright 应用版权 app-version 应用版本 更多选项 添加 packager 脚本方便项目打包 &quot;scripts&quot;: &#123; &quot;packager&quot;: &quot;electron-packager .&#x2F; --platform&#x3D;win32 --electron-version 5.0.3 --out .&#x2F;dist&quot; &#125;, 极简打包 创建目标平台/体系结构的所有有效组合的捆绑包 electron-packager .&#x2F; --all","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Electron","slug":"Electron","permalink":"https://yogwang.site/tags/Electron/"}]},{"title":"Git 关联到GigHub","slug":"git_connectToGitHub","date":"2019-06-17T07:36:06.000Z","updated":"2021-05-29T03:29:45.807Z","comments":true,"path":"2019/git_connectToGitHub/","link":"","permalink":"https://yogwang.site/2019/git_connectToGitHub/","excerpt":"创建 SSH Keygen使用ssh-keygen生成私钥和公钥 $ ssh-keygen -t rsa Generating public&#x2F;private rsa key pair. Enter file in which to save the key (&#x2F;c&#x2F;Users&#x2F;yog&#x2F;.ssh&#x2F;id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in &#x2F;c&#x2F;Users&#x2F;yog&#x2F;.ssh&#x2F;id_rsa. Your public key has been saved in &#x2F;c&#x2F;Users&#x2F;yog&#x2F;.ssh&#x2F;id_rsa.pub. The key fingerprint is: SHA256:0ZYdnPILyMbV9xpgRE&#x2F;hWf1MayqhoEYquZTuOMr8EcE yog@YOG-DESKTOP The key&#39;s randomart image is: +---[RSA 3072]----+ | &#x3D;+.o.o| | . .oo*&#x3D;.oo| | E o.o++.o++o| | .. .&#x3D;o... .o+| | o.o ..S ....oo | | &#x3D; ..o . .... | |o o.. . | |&#x3D;o . | |&#x3D;&#x3D;.. | +----[SHA256]-----+","text":"创建 SSH Keygen使用ssh-keygen生成私钥和公钥 $ ssh-keygen -t rsa Generating public&#x2F;private rsa key pair. Enter file in which to save the key (&#x2F;c&#x2F;Users&#x2F;yog&#x2F;.ssh&#x2F;id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in &#x2F;c&#x2F;Users&#x2F;yog&#x2F;.ssh&#x2F;id_rsa. Your public key has been saved in &#x2F;c&#x2F;Users&#x2F;yog&#x2F;.ssh&#x2F;id_rsa.pub. The key fingerprint is: SHA256:0ZYdnPILyMbV9xpgRE&#x2F;hWf1MayqhoEYquZTuOMr8EcE yog@YOG-DESKTOP The key&#39;s randomart image is: +---[RSA 3072]----+ | &#x3D;+.o.o| | . .oo*&#x3D;.oo| | E o.o++.o++o| | .. .&#x3D;o... .o+| | o.o ..S ....oo | | &#x3D; ..o . .... | |o o.. . | |&#x3D;o . | |&#x3D;&#x3D;.. | +----[SHA256]-----+ 找到 SSH 公钥输出内容，也可以用资源管理器打开复制 $ cd ~&#x2F;.ssh $ pwd &#x2F;c&#x2F;Users&#x2F;yog&#x2F;.ssh $ cat id_rsa.pub ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDb9FSAEzrtUG9bJFt5oaDieFo6FeqBWB9ppX4VCqBnNxKvpnAZbJMjUjxHAIQEFSK2sD9NUXgyuKguilX6kRVGoTq15Lcf12nfqfjoGMUm3qAgNdZlkHPFk7WxBFquaalWV8OOOZNe45W2YcbzPucQMt54iiGSYzuAQLbMW&#x2F;5rn2uF4HPrQNeMmduIvNZ8BxK4gS60IyjnEPTZbyG3RfJ0K5FQBN6wudoSWZZCU4UTcOjFhLRQ3I&#x2F;p5OQTSKXnbBhpoX7nD42Xohijt2xB5GhdLrh42E28AEORchaMJ7OxqenT4U+BDdhQPk87ZBpB254Cv5RCvj60dJv5VjE&#x2F;kTx4bCKslv9kgtV4INyUNPWlDAPhe6dmW1L+9Cl5QUYPvhjlXLLpcXoqne3OlPcS33UwJE0H&#x2F;6++TusANaMTAXxPofD9XCgK&#x2F;ipCNtT+YPxiyWIVJKgVUJ7NKAoieNOqXVN5d09ts&#x2F;hSM5CtBXFbKnFGrPEr9zGiUhfe7HM0gRpWMV0&#x3D; yog@YOG-DESKTOP 复制输出的全部公钥内容 开坑多个 SSH_Key 多个 GitHub 账户ssh-keygen -t rsa -C &quot;Exam@email.com&quot; -f ~&#x2F;.ssh&#x2F;id_rsa_for_Exam 在 GitHub 上添加 SSH key登陆 GitHub ,点击右上角头像，在弹出的菜单中选择 Settings 进入设置页 在右侧 Personal settings 中选择 SSH and GPG keys 点击 New SSH key，在 Key 中粘贴复制的公钥内容,然后 Add SSH key 完成 SSH key 添加 创建 GitHub 仓库同样点击右上角头像，在弹出的菜单中选择 Your repositories 进入资源库页 在页面中间靠右点击 New 按钮 输入 Repository name 然后点击 Create repository 按钮 Description:可选输入一段描述，仓库选择 Public 和 Private 都可以。 资源库创建完成后，复制页面中的 git remote add 命令，回到 Git Bash 回创建的本地 Git 库中，运行复制的 git remote add 命令，关联本地库到 GitHub 远程库上 $ cd E:&#x2F;GitLibrary&#x2F;git_demo $ git remote add origin git@github.com:yogwang&#x2F;demo_repositories.git 使用 git push 命令把本地库的所有内容推送到远程库上 git push -u origin master 然后刷新 GitHub 库页面就可以看到上传的本地库文件了","categories":[{"name":"工作延伸","slug":"工作延伸","permalink":"https://yogwang.site/categories/%E5%B7%A5%E4%BD%9C%E5%BB%B6%E4%BC%B8/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://yogwang.site/tags/Git/"}]},{"title":"Git 查看提交日志","slug":"git_log","date":"2019-06-17T07:33:26.000Z","updated":"2021-05-29T03:29:09.336Z","comments":true,"path":"2019/git_log/","link":"","permalink":"https://yogwang.site/2019/git_log/","excerpt":"git log基础查看提交日志 $ git log commit 2c8fcc81f23aa96073250e1d052473337c968d88 (HEAD -&gt; master, origin&#x2F;master) Author: yogwang &lt;yogwang@yog.red&gt; Date: Mon Jun 17 12:10:01 2019 +0800 wrote a readme file commit 87c9d12bdd979859811fc224c7f9ade7b97b0d13 Author: yogwang &lt;yogwang@yog.red&gt; Date: Mon Jun 17 09:52:50 2019 +0800 add distributed commit 77ac9552a7fb2e8d1f57d324d991de11efa897f2 Author: yogwang &lt;yogwang@yog.red&gt; Date: Mon Jun 17 09:50:33 2019 +0800 wrote a readme file","text":"git log基础查看提交日志 $ git log commit 2c8fcc81f23aa96073250e1d052473337c968d88 (HEAD -&gt; master, origin&#x2F;master) Author: yogwang &lt;yogwang@yog.red&gt; Date: Mon Jun 17 12:10:01 2019 +0800 wrote a readme file commit 87c9d12bdd979859811fc224c7f9ade7b97b0d13 Author: yogwang &lt;yogwang@yog.red&gt; Date: Mon Jun 17 09:52:50 2019 +0800 add distributed commit 77ac9552a7fb2e8d1f57d324d991de11efa897f2 Author: yogwang &lt;yogwang@yog.red&gt; Date: Mon Jun 17 09:50:33 2019 +0800 wrote a readme file git log --oneline精简模式显示 $ git log --oneline 2c8fcc8 (HEAD -&gt; master, origin&#x2F;master) wrote a readme file 87c9d12 add distributed 77ac955 wrote a readme file git log --pretty=oneline精简模式并显示完整版本号 $ git log --pretty&#x3D;oneline 2c8fcc81f23aa96073250e1d052473337c968d88 (HEAD -&gt; master, origin&#x2F;master) wrote a readme file 87c9d12bdd979859811fc224c7f9ade7b97b0d13 add distributed 77ac9552a7fb2e8d1f57d324d991de11efa897f2 wrote a readme file git log --graph图形模式显示 $ git log --graph * commit 2c8fcc81f23aa96073250e1d052473337c968d88 (HEAD -&gt; master, origin&#x2F;master) | Author: yogwang &lt;yogwang@yog.red&gt; | Date: Mon Jun 17 12:10:01 2019 +0800 | | wrote a readme file | * commit 87c9d12bdd979859811fc224c7f9ade7b97b0d13 | Author: yogwang &lt;yogwang@yog.red&gt; | Date: Mon Jun 17 09:52:50 2019 +0800 | | add distributed | * commit 77ac9552a7fb2e8d1f57d324d991de11efa897f2 Author: yogwang &lt;yogwang@yog.red&gt; Date: Mon Jun 17 09:50:33 2019 +0800 wrote a readme file git log --stat显示文件更改列表 $ git log --stat commit 2c8fcc81f23aa96073250e1d052473337c968d88 (HEAD -&gt; master, origin&#x2F;master) Author: yogwang &lt;yogwang@yog.red&gt; Date: Mon Jun 17 12:10:01 2019 +0800 wrote a readme file demo&#x2F;reademe.txt | 2 ++ 1 file changed, 2 insertions(+) commit 87c9d12bdd979859811fc224c7f9ade7b97b0d13 Author: yogwang &lt;yogwang@yog.red&gt; Date: Mon Jun 17 09:52:50 2019 +0800 add distributed readme.txt | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) commit 77ac9552a7fb2e8d1f57d324d991de11efa897f2 Author: yogwang &lt;yogwang@yog.red&gt; Date: Mon Jun 17 09:50:33 2019 +0800 wrote a readme file readme.txt | 2 ++ 1 file changed, 2 insertions(+) git log --author=_name根据作者筛选 _name：作者名 $ git log --author&#x3D;yogwang commit 2c8fcc81f23aa96073250e1d052473337c968d88 (HEAD -&gt; master, origin&#x2F;master) Author: yogwang &lt;yogwang@yog.red&gt; Date: Mon Jun 17 12:10:01 2019 +0800 wrote a readme file commit 87c9d12bdd979859811fc224c7f9ade7b97b0d13 Author: yogwang &lt;yogwang@yog.red&gt; Date: Mon Jun 17 09:52:50 2019 +0800 add distributed commit 77ac9552a7fb2e8d1f57d324d991de11efa897f2 Author: yogwang &lt;yogwang@yog.red&gt; Date: Mon Jun 17 09:50:33 2019 +0800 wrote a readme file git log -p file_name查看某个文件的详细修改 有详细内容 file_name：文件名 $ git log -p readme.txt commit 87c9d12bdd979859811fc224c7f9ade7b97b0d13 Author: yogwang &lt;yogwang@yog.red&gt; Date: Mon Jun 17 09:52:50 2019 +0800 add distributed diff --git a&#x2F;readme.txt b&#x2F;readme.txt index d8036c1..013b5bc 100644 --- a&#x2F;readme.txt +++ b&#x2F;readme.txt @@ -1,2 +1,2 @@ -Git is a version control system. +Git is a distributed version control system. Git is free software. \\ No newline at end of file commit 77ac9552a7fb2e8d1f57d324d991de11efa897f2 Author: yogwang &lt;yogwang@yog.red&gt; Date: Mon Jun 17 09:50:33 2019 +0800 wrote a readme file diff --git a&#x2F;readme.txt b&#x2F;readme.txt new file mode 100644 index 0000000..d8036c1 --- &#x2F;dev&#x2F;null +++ b&#x2F;readme.txt @@ -0,0 +1,2 @@ +Git is a version control system. +Git is free software. \\ No newline at end of file git log -L start,end:file_name查看某个文件某几行范围内的修改记录 start:开始行号 end:结束行号 file_name:文件名 $ git log -L 1,2:readme.txt commit 87c9d12bdd979859811fc224c7f9ade7b97b0d13 Author: yogwang &lt;yogwang@yog.red&gt; Date: Mon Jun 17 09:52:50 2019 +0800 add distributed diff --git a&#x2F;readme.txt b&#x2F;readme.txt --- a&#x2F;readme.txt +++ b&#x2F;readme.txt @@ -1,2 +1,2 @@ -Git is a version control system. +Git is a distributed version control system. Git is free software. \\ No newline at end of file commit 77ac9552a7fb2e8d1f57d324d991de11efa897f2 Author: yogwang &lt;yogwang@yog.red&gt; Date: Mon Jun 17 09:50:33 2019 +0800 wrote a readme file diff --git a&#x2F;readme.txt b&#x2F;readme.txt --- &#x2F;dev&#x2F;null +++ b&#x2F;readme.txt @@ -0,0 +1,2 @@ +Git is a version control system. +Git is free software. \\ No newline at end of file git log --stat commit_id根本版本号查看提交修改列表 commit_id：提交版本号 $ git log --stat 77ac commit 77ac9552a7fb2e8d1f57d324d991de11efa897f2 Author: yogwang &lt;yogwang@yog.red&gt; Date: Mon Jun 17 09:50:33 2019 +0800 wrote a readme file readme.txt | 2 ++ 1 file changed, 2 insertions(+)","categories":[{"name":"工作延伸","slug":"工作延伸","permalink":"https://yogwang.site/categories/%E5%B7%A5%E4%BD%9C%E5%BB%B6%E4%BC%B8/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://yogwang.site/tags/Git/"}]},{"title":"Git 操作命令","slug":"git_common","date":"2019-06-17T07:16:51.000Z","updated":"2021-05-29T03:29:47.162Z","comments":true,"path":"2019/git_common/","link":"","permalink":"https://yogwang.site/2019/git_common/","excerpt":"添加文件到仓库 git add$ git add * 提交文件到仓库 git commit$ git commit -m &quot;Here is the message&quot; commit 命令可以提交多个之前 add 的文件 $ git add file1.txt $ git add file2.txt file3.txt $ git commit -m &quot;add 3 files.&quot;","text":"添加文件到仓库 git add$ git add * 提交文件到仓库 git commit$ git commit -m &quot;Here is the message&quot; commit 命令可以提交多个之前 add 的文件 $ git add file1.txt $ git add file2.txt file3.txt $ git commit -m &quot;add 3 files.&quot; 查看当前仓库状态 git status没有需要提交的修改 $ git status On branch master nothing to commit, working tree clean 文件有修改 $ git status On branch master Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.txt no changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;) 查看差异 git diff$ git diff readme.txt diff --git a&#x2F;readme.txt b&#x2F;readme.txt index 46d49bf..9247db6 100644 --- a&#x2F;readme.txt +++ b&#x2F;readme.txt @@ -1,2 +1,2 @@ -Git is a version control system. +Git is a distributed version control system. Git is free software. 查看日志 git log 详细 git log 查看提交日志 git log --oneline 精简模式显示 git log --pretty=oneline 精简模式并显示完整版本号 git log --graph 图形模式显示 git log --stat 显示文件更改列表 git log --author=_name 根据作者筛选 git log -p file_name 查看某个文件的详细修改 git log -L start,end:file_name 查看文件某行范围内的修改记录 git log --stat commit_id 根本版本号查看提交修改列表 版本退回 git reset 详细在 Git 中，用 HEAD 表示当前版本，也就是最新的提交版本 上一个版本就是 HEAD^ 上上一个版本就是 HEAD^^ 当然往上 n 个版本写 n 个^比较容易数不过来，所以写成 HEAD~n ~n 相当于连续的 n 个”^” git reset --hard HEAD^$ git reset --hard HEAD^ HEAD is now at e475afc add distributed git reset --hard commit_id也可以直接切换到某个版本，版本号可以不写全，前 4 位就可以了，Git 会自动去找，也可以 Tab 补全 查看操作日志 git reflog$ git reflog 77ac955 (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to HEAD~2 2c8fcc8 (origin&#x2F;master) HEAD@&#123;1&#125;: commit: wrote a readme file 87c9d12 HEAD@&#123;2&#125;: commit: add distributed 77ac955 (HEAD -&gt; master) HEAD@&#123;3&#125;: commit (initial): wrote a readme file","categories":[{"name":"工作延伸","slug":"工作延伸","permalink":"https://yogwang.site/categories/%E5%B7%A5%E4%BD%9C%E5%BB%B6%E4%BC%B8/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://yogwang.site/tags/Git/"}]},{"title":"Git 创建版本库","slug":"git_create","date":"2019-06-17T03:22:11.000Z","updated":"2021-05-29T03:29:12.789Z","comments":true,"path":"2019/git_create/","link":"","permalink":"https://yogwang.site/2019/git_create/","excerpt":"创建一个空目录$ mkdir git_demo $ cd git_demo 创建 Git 仓库进入目录后通过git init命令创建 Git 仓库 $ git init Initialized empty Git repository in E:&#x2F;GitLibrary&#x2F;git_demo&#x2F;.git&#x2F;","text":"创建一个空目录$ mkdir git_demo $ cd git_demo 创建 Git 仓库进入目录后通过git init命令创建 Git 仓库 $ git init Initialized empty Git repository in E:&#x2F;GitLibrary&#x2F;git_demo&#x2F;.git&#x2F;","categories":[{"name":"工作延伸","slug":"工作延伸","permalink":"https://yogwang.site/categories/%E5%B7%A5%E4%BD%9C%E5%BB%B6%E4%BC%B8/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://yogwang.site/tags/Git/"}]},{"title":"安装 Git in windows","slug":"git_install","date":"2019-06-17T03:03:48.000Z","updated":"2021-05-29T03:29:10.412Z","comments":true,"path":"2019/git_install/","link":"","permalink":"https://yogwang.site/2019/git_install/","excerpt":"","text":"Git 官网：https://git-scm.com/ 设置提交时的 NAME 和 EMAIL：$ git config --global user.name &quot;nikename&quot; $ git config --global user.email &quot;example@example.com&quot; 查看设置的 NAME 和 EMAIL：$ git config user.name $ git config user.email","categories":[{"name":"工作延伸","slug":"工作延伸","permalink":"https://yogwang.site/categories/%E5%B7%A5%E4%BD%9C%E5%BB%B6%E4%BC%B8/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://yogwang.site/tags/Git/"}]},{"title":"Electron_01 - 快速启动","slug":"Electron01-Electron-quick-start","date":"2019-06-14T09:33:33.000Z","updated":"2021-06-03T07:39:56.846Z","comments":true,"path":"2019/Electron01-Electron-quick-start/","link":"","permalink":"https://yogwang.site/2019/Electron01-Electron-quick-start/","excerpt":"自己创建 Electron 应用1. 使用 npm 初始化一个项目$ mkdir my-app $ cd my-app $ npm init --y Wrote to E:\\my-app\\package.json: &#123; &quot;name&quot;: &quot;my-app&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot; &#125; 修改入口文件为 main.js 并且添加 start 脚本引导 Node 来执行 Electron","text":"自己创建 Electron 应用1. 使用 npm 初始化一个项目$ mkdir my-app $ cd my-app $ npm init --y Wrote to E:\\my-app\\package.json: &#123; &quot;name&quot;: &quot;my-app&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot; &#125; 修改入口文件为 main.js 并且添加 start 脚本引导 Node 来执行 Electron 2. 安装 Electron 官方推荐的安装方法是把它作为应用中的开发依赖项，以在不同的应用中使用不同的 Electron 版本。 npm install electron --save-dev 3. 简易的 Electron 主进程1.在 min.js 中引入 Electron 使用所有 API 和功能 const electron = require('electron') 按需引入 const &#123; app, BrowserWindow &#125; = require('electron') Electron 模块所提供的功能都是通过命名空间暴露出来的 在应用程序准备就绪后打开一个窗口 function createWindow () &#123; // 创建浏览器窗口 let win = new BrowserWindow(&#123; width: 800, height: 600, webPreferences: &#123; nodeIntegration: true &#125; &#125;) // 加载index.html文件 win.loadFile('index.html') &#125; app.on('ready', createWindow) 完善上述例子，完善应用可能遇到的所有系统事件，那么一个简单的 main.js 就像下面这样： const &#123; app, BrowserWindow &#125; = require('electron') // 保持对window对象的全局引用，如果不这么做的话，当JavaScript对象被 // 垃圾回收的时候，window对象将会自动的关闭 let win function createWindow () &#123; // 创建浏览器窗口。 win = new BrowserWindow(&#123; width: 800, height: 600, webPreferences: &#123; nodeIntegration: true &#125; &#125;) // 加载index.html文件 win.loadFile('index.html') // 打开开发者工具 win.webContents.openDevTools() // 当 window 被关闭，这个事件会被触发。 win.on('closed', () => &#123; // 取消引用 window 对象，如果你的应用支持多窗口的话， // 通常会把多个 window 对象存放在一个数组里面， // 与此同时，你应该删除相应的元素。 win = null &#125;) &#125; // Electron 会在初始化后并准备 // 创建浏览器窗口时，调用这个函数。 // 部分 API 在 ready 事件触发后才能使用。 app.on('ready', createWindow) // 当全部窗口关闭时退出。 app.on('window-all-closed', () => &#123; // 在 macOS 上，除非用户用 Cmd + Q 确定地退出， // 否则绝大部分应用及其菜单栏会保持激活。 if (process.platform !== 'darwin') &#123; app.quit() &#125; &#125;) app.on('activate', () => &#123; // 在macOS上，当单击dock图标并且没有其他窗口打开时， // 通常在应用程序中重新创建一个窗口。 if (win === null) &#123; createWindow() &#125; &#125;) // 在这个文件中，你可以续写应用剩下主进程代码。 // 也可以拆分成几个文件，然后用 require 导入。 4. 创建想展示的 index.html&lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Hello World!&lt;/title> &lt;/head> &lt;body> &lt;h1>Hello World!&lt;/h1> We are using node &lt;script>document.write(process.versions.node)&lt;/script>, Chrome &lt;script>document.write(process.versions.chrome)&lt;/script>, and Electron &lt;script>document.write(process.versions.electron)&lt;/script>. &lt;/body> &lt;/html> 5. 启动应用创建并初始化完成 main.js 、 index.html 和 package.json 之后，就可以在当前工程的根目录执行 npm start 命令来启动刚刚编写好的 Electron 应用了。 $ npm start &gt; my-app@1.0.0 start E:\\my-app &gt; electron . 基础结构所以一个最基础的 Electron 应用 应有以下目录结构： my-app&#x2F; ├── package.json ├── main.js └── index.html 快速启动官方 DEMO Electron-quick-start# 克隆示例项目的仓库 $ git clone https:&#x2F;&#x2F;github.com&#x2F;electron&#x2F;electron-quick-start # 进入这个仓库 $ cd electron-quick-start # 安装依赖并运行 $ npm install &amp;&amp; npm start 使用 Electron-forge 创建项目$ npm i -g @electron-forge&#x2F;cli $ electron-forge init my-app $ cd my-app $ npm start","categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Electron","slug":"Electron","permalink":"https://yogwang.site/tags/Electron/"}]}],"categories":[{"name":"前端分享","slug":"前端分享","permalink":"https://yogwang.site/categories/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/"},{"name":"踩坑日记","slug":"踩坑日记","permalink":"https://yogwang.site/categories/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/"},{"name":"学习日记","slug":"学习日记","permalink":"https://yogwang.site/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/"},{"name":"生活杂谈","slug":"生活杂谈","permalink":"https://yogwang.site/categories/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"},{"name":"工作延伸","slug":"工作延伸","permalink":"https://yogwang.site/categories/%E5%B7%A5%E4%BD%9C%E5%BB%B6%E4%BC%B8/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://yogwang.site/tags/CSS/"},{"name":"社群分享","slug":"社群分享","permalink":"https://yogwang.site/tags/%E7%A4%BE%E7%BE%A4%E5%88%86%E4%BA%AB/"},{"name":"HTML","slug":"HTML","permalink":"https://yogwang.site/tags/HTML/"},{"name":"SEO","slug":"SEO","permalink":"https://yogwang.site/tags/SEO/"},{"name":"Hexo","slug":"Hexo","permalink":"https://yogwang.site/tags/Hexo/"},{"name":"未完成","slug":"未完成","permalink":"https://yogwang.site/tags/%E6%9C%AA%E5%AE%8C%E6%88%90/"},{"name":"挖坑","slug":"挖坑","permalink":"https://yogwang.site/tags/%E6%8C%96%E5%9D%91/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"},{"name":"小程序","slug":"小程序","permalink":"https://yogwang.site/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"学习","slug":"学习","permalink":"https://yogwang.site/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"ECMAScript 6","slug":"ECMAScript-6","permalink":"https://yogwang.site/tags/ECMAScript-6/"},{"name":"VueJS","slug":"VueJS","permalink":"https://yogwang.site/tags/VueJS/"},{"name":"Gulp","slug":"Gulp","permalink":"https://yogwang.site/tags/Gulp/"},{"name":"总结","slug":"总结","permalink":"https://yogwang.site/tags/%E6%80%BB%E7%BB%93/"},{"name":"情感","slug":"情感","permalink":"https://yogwang.site/tags/%E6%83%85%E6%84%9F/"},{"name":"设计模式","slug":"设计模式","permalink":"https://yogwang.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"RaspberryPi","slug":"RaspberryPi","permalink":"https://yogwang.site/tags/RaspberryPi/"},{"name":"Coding","slug":"Coding","permalink":"https://yogwang.site/tags/Coding/"},{"name":"NVM","slug":"NVM","permalink":"https://yogwang.site/tags/NVM/"},{"name":"Caddy","slug":"Caddy","permalink":"https://yogwang.site/tags/Caddy/"},{"name":"Server","slug":"Server","permalink":"https://yogwang.site/tags/Server/"},{"name":"DigitalOcean","slug":"DigitalOcean","permalink":"https://yogwang.site/tags/DigitalOcean/"},{"name":"Jeecg-boot","slug":"Jeecg-boot","permalink":"https://yogwang.site/tags/Jeecg-boot/"},{"name":"ReactJS","slug":"ReactJS","permalink":"https://yogwang.site/tags/ReactJS/"},{"name":"Ant-Design-Vue","slug":"Ant-Design-Vue","permalink":"https://yogwang.site/tags/Ant-Design-Vue/"},{"name":"Webpack","slug":"Webpack","permalink":"https://yogwang.site/tags/Webpack/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://yogwang.site/tags/TypeScript/"},{"name":"ESlint","slug":"ESlint","permalink":"https://yogwang.site/tags/ESlint/"},{"name":"Node.js","slug":"Node-js","permalink":"https://yogwang.site/tags/Node-js/"},{"name":"Github","slug":"Github","permalink":"https://yogwang.site/tags/Github/"},{"name":"年会开发日记","slug":"年会开发日记","permalink":"https://yogwang.site/tags/%E5%B9%B4%E4%BC%9A%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0/"},{"name":"WebSocket","slug":"WebSocket","permalink":"https://yogwang.site/tags/WebSocket/"},{"name":"PHP","slug":"PHP","permalink":"https://yogwang.site/tags/PHP/"},{"name":"PHPOK","slug":"PHPOK","permalink":"https://yogwang.site/tags/PHPOK/"},{"name":"Canvas","slug":"Canvas","permalink":"https://yogwang.site/tags/Canvas/"},{"name":"Three.js","slug":"Three-js","permalink":"https://yogwang.site/tags/Three-js/"},{"name":"web","slug":"web","permalink":"https://yogwang.site/tags/web/"},{"name":"Vue-Router","slug":"Vue-Router","permalink":"https://yogwang.site/tags/Vue-Router/"},{"name":"tinyMCE","slug":"tinyMCE","permalink":"https://yogwang.site/tags/tinyMCE/"},{"name":"Axios","slug":"Axios","permalink":"https://yogwang.site/tags/Axios/"},{"name":"Apache","slug":"Apache","permalink":"https://yogwang.site/tags/Apache/"},{"name":"Electron","slug":"Electron","permalink":"https://yogwang.site/tags/Electron/"},{"name":"BetterScrol.js","slug":"BetterScrol-js","permalink":"https://yogwang.site/tags/BetterScrol-js/"},{"name":"问题","slug":"问题","permalink":"https://yogwang.site/tags/%E9%97%AE%E9%A2%98/"},{"name":"Git","slug":"Git","permalink":"https://yogwang.site/tags/Git/"},{"name":"Chrome","slug":"Chrome","permalink":"https://yogwang.site/tags/Chrome/"}]}