{"meta":{"title":"blog [ YOG WANG ]","subtitle":"blog","description":"Here is my blog, my notes and some thoughts","author":"YogWang","url":"https://yogwang.site","root":"/"},"pages":[{"title":"我","updated":"2026-01-05T05:39:58.524Z","comments":true,"path":"about/index.html","permalink":"https://yogwang.site/about/index.html","excerpt":"","text":"[Zhì Shàng Qíng Míng]你问我这个名字有没有什么特殊来由，那就点击一下看看？ 不知名菜鸡切图仔，从事前端开发7年，主要技术栈为 Vue 全家桶。准备在博客中记录我的日常学习和工作中遇到的一些问题，希望不要烂尾 23333。 职业生涯早期大部分时间钻研在 CSS 上面，可以说是原地踏步了好多年，直到 2019 年开始接触 SPA 项目后才算真正推开 JavaScript 的大门接触到真正的前端领域。所以 2019 年的重新开始，对我来说可谓是充满挑战和急速成长的一年，让我从一个萌新蜕变成长为一个称职的前端开发者。 2020年开始因为口罩原因日常娱乐活动开始受限，逐渐开始在开发者社区&#x2F;社群活跃，在不断的和其他开发者沟通中成长进步。日常工作生活中你可以在 SegmentFault 和 V2EX 看到我出没的身影。 今年2025年的目标是： 发布最少 12 篇笔记&#x2F;文章; 在思否回答 1000 个问题; 获得思否的2025年度 Top Writer; 成为思否社区综合贡献榜 TOP 20; 当然如果你愿意也可以在这些地方找到我： Github 新浪微博 网易云音乐 或者直接通过 📧 E-Mail 联系我。 很多人好奇我的社区ID 【陟上晴明】，想知道有没有什么特殊的来由 早些年有一个《汉字守护者》的活动，参与活动之后会随机分配一个“濒危汉字”，那个时候随机到的就是 【陟】zhì 这个字，寓意也很不错： 登，从低处走向高处，也有晋升和提拔的意思。 当时就在想应该怎么样去守护这个汉字，让更多人去知道和了解他的读音和含义。😂 因为我抽到这个字之后，一下子不知道应该怎么读，所以就想着那就用这个字作为昵称吧。 并且分配到这个字的时候也会给到一首古诗，就觉得搭配到这个字来源的古诗会更有画面一些。所以就用了【陟上晴明】，希望自己能够一路登上云顶，拨开云雾见光明。 扁舟水淼淼，曲岸复长塘。古寺春山上，登楼忆故乡。云烟横极浦，花木拥回廊。更有思归意，晴明陟上方。《题山寺》 - 刘商"}],"posts":[{"title":"HTML中的事件处理器和处理器属性","slug":"html-event-handler-properties","date":"2025-12-19T01:52:13.000Z","updated":"2026-01-05T05:39:58.490Z","comments":true,"path":"2025/html-event-handler-properties/","permalink":"https://yogwang.site/2025/html-event-handler-properties/","excerpt":"日常业务代码写久了，已经遗忘了除 addEventListener 之外的事件绑定方式。 所以在看到询问 “在 Vue3 中为什么使用 :onclick 也可以实现事件绑定，以及和 @click 的区别是什么” 的时候。 下意识会以为说是 v-bind 做了处理（其实Vue也确实做了一些处理，但不多）。 而完全没有意识到，其实不加 v-bind 也可以正常实现事件绑定的，比如说： &lt;template&gt; &lt;div onclick=&quot;alert(&#x27;Click!&#x27;)&quot;&gt;Click Me&lt;/div&gt; &lt;/template&gt; Vue Playground Online Demo","text":"日常业务代码写久了，已经遗忘了除 addEventListener 之外的事件绑定方式。 所以在看到询问 “在 Vue3 中为什么使用 :onclick 也可以实现事件绑定，以及和 @click 的区别是什么” 的时候。 下意识会以为说是 v-bind 做了处理（其实Vue也确实做了一些处理，但不多）。 而完全没有意识到，其实不加 v-bind 也可以正常实现事件绑定的，比如说： &lt;template&gt; &lt;div onclick=&quot;alert(&#x27;Click!&#x27;)&quot;&gt;Click Me&lt;/div&gt; &lt;/template&gt; Vue Playground Online Demo 所以其实就是HTML中的 内联事件处理器 在起作用，并不需要前端框架来介入。 除了以上这个，当然还有一个挂载元素实例上的 onclick 这样 事件处理器属性，这个日常会用的稍微多一些。特别是在手动操作DOM元素的时候。 🤖 关于 Vue 做的额外处理简单看了一下 vue/core 中关于 v-bind 的实现代码，其实没有做特殊的额外处理。 就是正常在 AST 解析后收集了使用 v-bind 动态绑定的属性，并且使用 createObjectProperty 函数组装成正常的 Property 属性返回。然后把这些收集了的 props 属性在 createVNode 创建HTML元素时，传入在第二个参数中，最后被处理成了 DOM Property 属性。 至于为什么是 DOM Property 而不是 DOM Attribute （也就是被当成上面提到的事件处理器属性，而不是内联事件处理器），就需要看 shouldSetAsProp 函数了，函数具体实现就不展开描述了。 如果想要转换成 DOM Attribute 也很简单，去掉 : 在解析时就会被直接标记成静态属性（NodeTypes.ATTRIBUTE）了，而不是动态绑定的指令类型（NodeTypes.DIRECTIVE）。最后在渲染时的 shouldSetAsProp 函数中就会被输出成 DOM Attribute ，显示在HTML元素上了 相关链接 #其他事件监听器机制 - 事件介绍 - 学习 Web 开发 | MDN #事件处理器属性 - HTML 属性参考 - HTML（超文本标记语言） | MDN 请问 vue3 的 onclick 和 @click 有什么区别 - V2EX","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://yogwang.site/tags/HTML/"},{"name":"VueJS","slug":"VueJS","permalink":"https://yogwang.site/tags/VueJS/"}]},{"title":"解决 Vue DevTools 中的 Open in Editor 错误唤起 Notepad 的问题","slug":"vue-devtools-open-in-editor-launches-notepad-instead","date":"2025-11-27T07:14:00.000Z","updated":"2026-01-05T05:39:58.521Z","comments":true,"path":"2025/vue-devtools-open-in-editor-launches-notepad-instead/","permalink":"https://yogwang.site/2025/vue-devtools-open-in-editor-launches-notepad-instead/","excerpt":"其实从 切换主力编辑器到 Cursor 开始，我的 Vue DevTools 插件中的 Open in Editor 功能一直都有问题。当时始想着都切换到 Cursor 了，再用 VS Code 来打开组件就不太合适了。所以就按照推荐的使用 Shell Commands 命令执行 Install &#39;code&#39; command 直接把 Cursor 注册进去，以为就搞定了就没有再去验证。实际上并没有注册成功（也不知道是不是因为我的受控账户所以没办法直接操作环境变量）。直到后面某一天调试的时候，突然发现并没有和预期的一样使用 Cursor 打开，而是直接通过 Notepad 记事本打开了对应的 .vue 文件！重新执行 Shell Command: Install &#39;code&#39; command 也没有效果。那我想着注册不行的话，我先恢复成 VS Code 打开拖动到 Cursor 里面先用着等有时间了再解决。结果执行完 uninstall 之后使用 Open in Editor 功能还是使用的 Notepad 打开的组件文件，我就裂开了 🤯。 但是当时开发任务又紧张，可以看到我有很长一段时间都没有更新博客也能发现。但是最近有时间了，就可以着手解决这个问题。","text":"其实从 切换主力编辑器到 Cursor 开始，我的 Vue DevTools 插件中的 Open in Editor 功能一直都有问题。当时始想着都切换到 Cursor 了，再用 VS Code 来打开组件就不太合适了。所以就按照推荐的使用 Shell Commands 命令执行 Install &#39;code&#39; command 直接把 Cursor 注册进去，以为就搞定了就没有再去验证。实际上并没有注册成功（也不知道是不是因为我的受控账户所以没办法直接操作环境变量）。直到后面某一天调试的时候，突然发现并没有和预期的一样使用 Cursor 打开，而是直接通过 Notepad 记事本打开了对应的 .vue 文件！重新执行 Shell Command: Install &#39;code&#39; command 也没有效果。那我想着注册不行的话，我先恢复成 VS Code 打开拖动到 Cursor 里面先用着等有时间了再解决。结果执行完 uninstall 之后使用 Open in Editor 功能还是使用的 Notepad 打开的组件文件，我就裂开了 🤯。 但是当时开发任务又紧张，可以看到我有很长一段时间都没有更新博客也能发现。但是最近有时间了，就可以着手解决这个问题。 一开始想着直接看 Vue DevTools 的文档，但是看到的都是安装一些依赖来实现，但其实我这个状况并不是缺少了插件导致的。所以应该是环境变量方面的问题，就想着从环境变量中入手。但是我在各个终端中检查 code 和 cursor 都正常执行的，所以并不是缺少了 PATH 信息。那么就需要从 Vue DevTools 中找答案了。 找了一圈 Issue 只有一个强相关的帖子，但是他是使用的 vite 插件，并不是浏览器插件。但是跟帖中发现了一个非常重要的信息。 我检查了一下 devtools 对于浏览器插件 api 的实现是进行了 fetch 请求 &#39;__open_in_enditor&#39;，该功能实际由 vite 实现的，所以可能在这里无法得到答案qq326943819 on Apr 11 正好，Open in Editor 这部分的文档中也提到了 /__open-in-editor。就可以从这部分提到的 launch-editor 这个包入手。打开项目阅读README还没几行就看到了这一段话： However, both expects env variables like EDITOR to be set in order to open files. This package infers the editor to open by checking current running processes before falling back to env variables. 但是对于环境变量（environment variable）的理解会有一些歧义，所以继续找了一下相关的Issue，明确了是系统的环境变量，而不是项目中的环境变量。 开始设置系统环境变量，但是由于是受控账户，没办法直接通过系统配置页面来设置。所以找了一下相关的 CMD 和 Powershell 两个终端中设置环境变量的命令。 setx EDITOR cursor 这个后面的 cursor 可以是 code 或者其他的编辑器名称，比如说 webstorm。 设置成功之后会提示。但是你仍然需要检查（需要重启终端）。 如果是 CMD 可以通过 echo %EDITOR% 来查看是否设置成功; 如果是 Powershell，可以用 echo $env:EDITOR 来查看。 如果没有输出你设置的值，那么就说明你没有关闭全部的终端。一般会在 Powershell 中遇到。那么就需要关闭所有已经打开的终端，再重新尝试。如果你的编辑器有打开终端也需要关闭。 如果可以正常看到输出了，那么重启项目再点击 Vue DevTools 中的 Open in Editor 就可以正常在你设置的编辑器中打开了。 🧐 进一步为什么 launch-editor 的 guessEditor 函数 没有正确返回编辑器名称，而需要使用兜底的环境变量呢？因为它是通过获取系统当前所有正在执行进程，去匹配对应的进程名是否在 预设好的编辑器列表 中。而 Cursor 是在 v2.10.0 才被添加到列表中的 👉 feat: add Cursor support for Windows · yyx990803&#x2F;launch-editor@3bac35b 我的项目使用的 vite@5.3.3 内置的 launch-editor-middleware 版本是 v2.8.0，这个时候 Cursor 并没有被添加到支持的列表中，自然就匹配失败了。 所以如果有定期迭代更新项目依赖的话，guessEditor 函数才会正确命中当前使用中的 Cursor 编辑器。 那么在我的案例中操作更新一下项目的依赖也可以解决这个问题，但是为了预防出现不必要的问题减少工作量，还是通过增加环境变量的方式更简单实用一些。 相关资源 Open component in editor | Vue DevTools vuejs&#x2F;devtools | Github webfansplz&#x2F;vite-plugin-vue-inspector | Github yyx990803&#x2F;launch-editor | Github Shell Commands | Cursor Docs","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"VueJS","slug":"VueJS","permalink":"https://yogwang.site/tags/VueJS/"},{"name":"VSCode","slug":"VSCode","permalink":"https://yogwang.site/tags/VSCode/"},{"name":"Cursor","slug":"Cursor","permalink":"https://yogwang.site/tags/Cursor/"},{"name":"DevTools","slug":"DevTools","permalink":"https://yogwang.site/tags/DevTools/"}]},{"title":"FireFox 真的不支持自定义滚动条样式吗？","slug":"CSS-not-ff-fault-custom-scrollbars","date":"2025-11-20T09:00:06.000Z","updated":"2026-01-05T05:39:58.457Z","comments":true,"path":"2025/CSS-not-ff-fault-custom-scrollbars/","permalink":"https://yogwang.site/2025/CSS-not-ff-fault-custom-scrollbars/","excerpt":"刷到一个帖子问 Firefox 是不支持网页的滚动条样式吗？，说有些网页会呈现自定义的滚动条，Chrome 和 Safari 打开是正常的，但是 Firefox 只会显示默认的样式。 我的映像里也是这样的，FF对于支持滚动条的样式自定义并不是特别好，有一些属性会有问题。但是为了回复更有价值和佐证，我还是去 MDN 上面检索了一下相关的 CSS 样式属性，但是查询出来的是 FF 是支持的而且是很早期就支持了，反而是 webkit 内核的浏览器早期对于滚动条样式的支持有问题！ 这就很奇怪了，难道是我记忆错误了？","text":"刷到一个帖子问 Firefox 是不支持网页的滚动条样式吗？，说有些网页会呈现自定义的滚动条，Chrome 和 Safari 打开是正常的，但是 Firefox 只会显示默认的样式。 我的映像里也是这样的，FF对于支持滚动条的样式自定义并不是特别好，有一些属性会有问题。但是为了回复更有价值和佐证，我还是去 MDN 上面检索了一下相关的 CSS 样式属性，但是查询出来的是 FF 是支持的而且是很早期就支持了，反而是 webkit 内核的浏览器早期对于滚动条样式的支持有问题！ 这就很奇怪了，难道是我记忆错误了？ 其实并不是记忆出错了，而是当时 Chrome 大行其道，开发者和用户都是使用的 Chrome 。所以很多网站直接用 ::-webkit-scrollbar-* 这样带有私有前缀的伪类选择器去自定义滚动条样式，而不是用 scrollbar 的样式属性。 反而导致我们觉得 FF 不支持滚动条样式的设置了。但却是如果按照大多数人使用的浏览器实现作为标准，确实是 FF 不支持 ::scrollbar-* 这几个伪类选择器。 所以其实FF是支持自定义滚动条样式的。只是说因为现实原因和开发者偷懒，只使用了 Chrome 支持的伪类选择器来自定义滚动条样式，主动放弃了对于FF的兼容性考虑。 现在我们可以直接用 scroll-* 和 scrollbar-* 这些属性来自定义滚动条样式了。 但是 scrollbar-* 并不能精细的设置滚动条样式，如果要更精细的控制滚动条样式的话，使用 scrollbar-* 还是会有限制，比如说滚动条宽度只支持 auto | thin | none 三个关键字，而不支持设置具体的 px宽度。 相关资源 CSS Scrollbars - CSS：层叠样式表 | MDN scrollbar-* - CSS：层叠样式表 | MDN scroll-* - CSS：层叠样式表 | MDN ::-webkit-scrollbar - CSS：层叠样式表 | MDN “scrollbar” | Can I use “::-webkit-scrollbar” | Can I use 还有完没完，怎么又来了个 scrollbar-gutter ？ « 张鑫旭-鑫空间-鑫生活","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://yogwang.site/tags/CSS/"}]},{"title":"关于八股文面试题","slug":"about-ba-gu-interview","date":"2025-11-18T03:24:36.000Z","updated":"2026-01-05T05:39:58.479Z","comments":true,"path":"2025/about-ba-gu-interview/","permalink":"https://yogwang.site/2025/about-ba-gu-interview/","excerpt":"这篇分享的起因是昨天在V站刷到一篇帖子，如何用 3–5 个高效问题快速识别 Golang 开发者的技术素养？ 里面提到了我对于八股文面试题的看法。 都要出来面试了，但八股文都不愿意花点时间背，态度很明显就是有问题的，被刷掉也很正常。 从前我也是很讨厌面试时遇到各种八股文面试题，会觉得很无聊和无趣。因为是纯靠背的东西，面试考这些就很蠢。但是慢慢接触了更多开发者之后，甚至自己面试别人多了之后，就会发现这些看起来很呆板的八股文面试题，其实起到了好几种作用，比如说： 筛选不做任何面试准备的面试者； 给初级开发在前期建立知识库。","text":"这篇分享的起因是昨天在V站刷到一篇帖子，如何用 3–5 个高效问题快速识别 Golang 开发者的技术素养？ 里面提到了我对于八股文面试题的看法。 都要出来面试了，但八股文都不愿意花点时间背，态度很明显就是有问题的，被刷掉也很正常。 从前我也是很讨厌面试时遇到各种八股文面试题，会觉得很无聊和无趣。因为是纯靠背的东西，面试考这些就很蠢。但是慢慢接触了更多开发者之后，甚至自己面试别人多了之后，就会发现这些看起来很呆板的八股文面试题，其实起到了好几种作用，比如说： 筛选不做任何面试准备的面试者； 给初级开发在前期建立知识库。 有人来找我聊如何准备面试的时候，我一般都会说需要看企业的业务内容和投递岗位的工作内容有针对性地去准备简历和准备会被问到的问题。而不是所有的企业都使用同一份模板简历，应该尽可能地给自己争取被看到的机会，增加获得面试邀约的几率。 在收到面试邀约之后，会建议别人去熟读八股文和准备JD中要求的技术栈相关的知识。不要因为面试时一些常见问题回答不上来，打乱自己面试节奏或者紧张，甚至面试失败。如果是的话就太可惜了。因为并不是要求原文背诵，其实只需要清楚是怎么一回事，问到的时候可以用自己的话描述出来就行，并不是一件多难的事情。 那么在充分准备的情况下，背八股文并不是真的在”背“，而是在复习很多已经不太用得到的基础知识，或者提前了解还没有在实际中接触到的基础问题。 所以说白了”背八股文”只是在给自己面试做准备，而不单纯只是背题。当初背八股文的时候可能不知道怎么一回事，慢慢你终于会在一些实践中运用到，随着记忆复现豁然开朗。这也就是”背八股文”这个行为在前期用”填鸭式”的方式给自己建立知识库。 而对于企业来说并没有一个简单且有效的方式去筛选候选者。毕竟经验积累没有那么多，项目经历也并没有那么丰富，做的工作大多也是一些简单的工作。考察基础的面试题就那么多，来来回回用多了自然就变成了套路的”八股文”。面试官需要做的是在问”八股文”的基础上去追问”为什么”去考察候选者的解题思路，适当的时候还需要去引导面试者。 但是对于候选者来说，给到的感觉就是在问八股文，而且一直在追问。那么对于很多候选者来说，直接背八股文就是最简单直接有效的操作了。那么在此之上就可以发掘出候选者对于面试的重视程度，是否为了面试做了足够的准备。再进一步就可以看出候选者处理一些重要的事情时，是否会做前期准备工作以应对可能出现的状况。 虽然很无聊，甚至有些问题在当初的你看来很没必要。问到了技术框架的底层实现，或者是一些网络通信协议和模型。这些实际上在给你建立最基本的知识体系，以最低限度地去了解一些未来伴随你日常工作的核心概念。","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://yogwang.site/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"为什么空白的 inline-block 元素会创建高度，而空白的 inline 和 block 元素不会？","slug":"CSS-empty-inline-block-create-height-but-inline-and-block-not","date":"2025-11-12T06:35:00.000Z","updated":"2026-01-05T05:39:58.450Z","comments":true,"path":"2025/CSS-empty-inline-block-create-height-but-inline-and-block-not/","permalink":"https://yogwang.site/2025/CSS-empty-inline-block-create-height-but-inline-and-block-not/","excerpt":"去年2月份的时候在思否刷到一个问题 👉 span的display为inline-block 和inline的时候对父级元素高度的影响?当时就觉得很奇怪，以为是一些其他的CSS属性影响导致的，但是问题后面提到了参考链接里面具体说了原因，只不过OP没有很好的理解，我也没有很好的理解。因为就算是IFC的问题，inline-block 和 inline 元素的表现应该是差不多的。但是实际情况并不是这样，只有 inline-block 是特殊的情况。 一年多的时光中有几次想捋清楚这个问题，但是又因为各种借口搁置了，今天终于逮起劲来准备解决掉这个疑惑。 以下是当时写的一个复现Demo，只会显示子元素是 inline-block 的 .container 会有高度（显示红色）。而子元素的 inline 和 block 的 .container 并没有高度，所以不会显示（蓝色和绿色）。 很奇怪是不是？","text":"去年2月份的时候在思否刷到一个问题 👉 span的display为inline-block 和inline的时候对父级元素高度的影响?当时就觉得很奇怪，以为是一些其他的CSS属性影响导致的，但是问题后面提到了参考链接里面具体说了原因，只不过OP没有很好的理解，我也没有很好的理解。因为就算是IFC的问题，inline-block 和 inline 元素的表现应该是差不多的。但是实际情况并不是这样，只有 inline-block 是特殊的情况。 一年多的时光中有几次想捋清楚这个问题，但是又因为各种借口搁置了，今天终于逮起劲来准备解决掉这个疑惑。 以下是当时写的一个复现Demo，只会显示子元素是 inline-block 的 .container 会有高度（显示红色）。而子元素的 inline 和 block 的 .container 并没有高度，所以不会显示（蓝色和绿色）。 很奇怪是不是？你也可以复制下面的简单HTML代码在自己的本地复现这个问题： &lt;div class=&quot;container red&quot;&gt; &lt;div style=&quot;display: inline-block&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;container blue&quot;&gt; &lt;div style=&quot;display: inline&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;container green&quot;&gt; &lt;div style=&quot;display: block&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;style&gt; .red &#123; background-color: red; &#125; .blue &#123; background-color: blue; &#125; .green &#123; background-color: green; &#125; &lt;/style&gt; 那么继续阅读问题中引用的文章内容。可以看到作者排查的思路: 外部的 &lt;div&gt; 元素的高度计算； 依赖内部包含的非块级元素高度； 非块级元素需要计算 line box 高度； line box 的高度依赖 line-height 的高度； 空的行内元素依赖 strut 的高度； strut 的高度计算 简略版的看起来是不是有点不明所以，具体可以 查看博客原文。 所以引起这个问题的原因是因为： Empty inline elements generate empty inline boxes, but these boxes still have margins, padding, borders and a line height, and thus influence these calculations just like elements with content.空的行内元素会生成空的行内框，但这些框仍然有边距、内边距、边框和行高，因此会像有内容的元素一样影响这些计算。 On a block container element whose content is composed of inline-level elements, ‘line-height’ specifies the minimal height of line boxes within the element. The minimum height consists of a minimum height above the baseline and a minimum depth below it, exactly as if each line box starts with a zero-width inline box with the element’s font and line height properties. We call that imaginary box a “strut.” (The name is inspired by TeX.).在块容器元素上 其内容 由内联级别组成 对于元素，line-height 属性指定元素内各行框的最小高度。最小高度由基线以上的最小高度和基线以下的最小深度组成，就像每个行框都以一个宽度为零的行内框开始，并应用元素的字体和行高属性一样。 我们将这个虚拟的框称为“支撑框”（strut）。（这个名称源自 TeX。） 那么聪明的你肯定会问了！ ❓ 那么同样为行内元素的 inline 不会撑开外部元素的高度呢？那是因为规范定义这部分的情况，被强制忽略了。 Line boxes are created as needed to hold inline-level content within an inline formatting context. Line boxes that contain no text, no preserved white space, no inline elements with non-zero margins, padding, or borders, and no other in-flow content (such as images, inline blocks or inline tables), and do not end with a preserved newline must be treated as zero-height line boxes for the purposes of determining the positions of any elements inside of them, and must be treated as not existing for any other purpose.行框根据需要创建，用于在行内格式上下文中容纳行内内容。如果行框不包含任何文本、不包含任何保留的空白、 不包含任何具有非零边距、内边距或边框的行内元素，也不包含任何其他内流内容（例如图像、行内块或行内表格），并且没有以保留的换行符结尾，则在确定其内部任何元素的位置时，必须将其视为零高度行框；在任何其他情况下，都应将其视为不存在。 📚 相关文档#10.6.3 Block-level non-replaced elements in normal flow when ‘overflow’ computes to ‘visible’ | Visual formatting model details - W3C Working Draft#9.4.2 Inline formatting contexts | Visual formatting model - W3C Working Draft#10.8 Line height calculations: the ‘line-height’ and ‘vertical-align’ properties | Visual formatting model - W3C Working Draft#strut | Visual formatting model details - W3C Working Draft 其他资源inline-block 元素高度为0，父级仍被撑起，问题元凶 —— strut - CSDN博客html - 没有高度的inline-block，父元素却有高度 - SegmentFault 思否html - Why Empty Display Inline Block Element Create Height But Display Inline and Display Block not? - Stack Overflowhtml - How to determine height of content-box of a block and inline element - Stack Overflow[css-display] Should ‘run-in flow-root’ blockify to ‘block’ or ‘flow-root’? · Issue #1715 · w3c&#x2F;csswg-drafts","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://yogwang.site/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"https://yogwang.site/tags/HTML/"}]},{"title":"【娱乐向】使用AI分析自己在社区中的用户画像","slug":"use-ai-agent-to-analyze-my-user-proflie-in-the-v2ex","date":"2025-10-31T10:17:50.000Z","updated":"2026-01-05T05:39:58.518Z","comments":true,"path":"2025/use-ai-agent-to-analyze-my-user-proflie-in-the-v2ex/","permalink":"https://yogwang.site/2025/use-ai-agent-to-analyze-my-user-proflie-in-the-v2ex/","excerpt":"在V站看到了一个有趣的分享提取用户在V站的回帖来分析用户画像。觉得很有意思，就把油猴脚本安装下来跑了数据，让AI来分析一下自己，看看自己在社区的形象是怎么样的。其实更早的时候有过一个 wordware-ai&#x2F;twitter 的项目，用于分析用户在 Twitter 上面的发言。但是我的 Twitter 就几乎没有发贴过，所以完美错过了那次的狂欢。 一边在跑数据，一边就在看其他用户的回帖。但是在陆陆续续看了多个用户分享的自己的用户画像分析析之后，明显感觉到了严重的隐私焦虑。 很明确的，用户在社区中活跃度越高，那么不可避免地暴露出来越多的隐私信息。 即便已经在各种回帖中模糊混淆了人物以及地区名词。虽然AI可以被误导，但大体上仍然可以分析出来很精准的用户画像。要是再结合一些其他的社交APP数据，我觉得很快可以精准的定位到现实中的某一个身上。 如果你对AI对于我在社区中的用户画像感兴趣，可以点击阅读全文查看。一共尝试了 DeepSeek、Kimi、GPT、Gemini、Grok 5款AI产品。","text":"在V站看到了一个有趣的分享提取用户在V站的回帖来分析用户画像。觉得很有意思，就把油猴脚本安装下来跑了数据，让AI来分析一下自己，看看自己在社区的形象是怎么样的。其实更早的时候有过一个 wordware-ai&#x2F;twitter 的项目，用于分析用户在 Twitter 上面的发言。但是我的 Twitter 就几乎没有发贴过，所以完美错过了那次的狂欢。 一边在跑数据，一边就在看其他用户的回帖。但是在陆陆续续看了多个用户分享的自己的用户画像分析析之后，明显感觉到了严重的隐私焦虑。 很明确的，用户在社区中活跃度越高，那么不可避免地暴露出来越多的隐私信息。 即便已经在各种回帖中模糊混淆了人物以及地区名词。虽然AI可以被误导，但大体上仍然可以分析出来很精准的用户画像。要是再结合一些其他的社交APP数据，我觉得很快可以精准的定位到现实中的某一个身上。 如果你对AI对于我在社区中的用户画像感兴趣，可以点击阅读全文查看。一共尝试了 DeepSeek、Kimi、GPT、Gemini、Grok 5款AI产品。 🧐 DeepSeek 用户画像总结用户”94”是一名30-40岁的男性技术从业者，推测居住在华东地区二线城市，职业为软件开发工程师或技术经理。核心特征包括技术能力强、乐于分享、情绪稳定理性。在V2EX社区中表现活跃，覆盖67个板块，尤其在职场话题和程序员板块参与度最高。兴趣爱好广泛，涵盖技术开发、健身运动、汽车、投资理财等多个领域，展现出良好的生活平衡感。性格理性务实，社交风格友善礼貌，经常帮助他人解决问题，在社区中有一定影响力。消费观念理性，注重性价比但也不排斥品质消费，对新技术保持高度敏感和快速适应能力。 📜 完整分析内容 ▶ 📊 量化用户画像报告 1. 技术能力评估 💻 量化指标: 技术相关回复占比: 32% (160&#x2F;500条) 提及的技术关键词数量: 68个 (包括AI编程工具、框架、语言等) 技术深度: 是 (经常讨论原理、架构、最佳实践) 分析要点: 主要技术栈: 前端开发(Vue&#x2F;React)、AI编程工具(Cursor&#x2F;Copilot)、Node.js、Git 技术广度与深度: 覆盖多个技术领域，深度中等偏上，能解决实际问题 专业技术背景: 职业开发者，有多年开发经验 对新技术的接受程度: 积极拥抱AI工具，快速适应新技术 评分: 8&#x2F;10 分 2. 消费能力评估 💰 量化指标: 提及的产品价格范围: ￥100 - ￥300,000 高价值物品(&gt;5000元)提及次数: 18次 投资&#x2F;理财相关讨论: 16次 分析要点: 具体产品及价格: iPhone Pro系列、MacBook、汽车(10-30万)、智能家居设备 消费观念: 理性消费，注重性价比，但愿意为品质付费 投资理财意识: 较强，关注加密货币、股票投资 经济压力感知: 偶尔提及但整体稳定 评分: 6&#x2F;10 分 3. 专业深度评估 🎓 量化指标: 专业术语使用频率: 高 深度分析回复占比: 42% 被@请教的次数: 23次(从上下文推断) 分析要点: 专业领域: 软件开发、项目管理、AI应用 知识深度与广度: 在技术和管理领域有深入见解 解答他人问题: 频繁提供专业建议和解决方案 专业表达能力: 逻辑清晰，表达详细准确 评分: 8&#x2F;10 分 4. 社交活跃度 👥 量化指标: 平均回复长度: 185字 @他人次数: 47次 回复情感倾向: 友善 活跃板块数量: 67个 分析要点: 交流主动性: 高，经常主动参与讨论 互动频率和质量: 高频互动，回复质量高 固定交流对象: 无特别固定，但广泛交流 社交风格: 友善、礼貌、乐于助人 评分: 8&#x2F;10 分 5. 兴趣广度评估 🎮 量化指标: 涉及的主题类别数: 14个 话题分散度: 高 跨领域讨论占比: 58% 分析要点: 主要兴趣点: 编程技术、健身运动、汽车、电子产品、投资理财、播客、旅行 兴趣深度: 在技术和健身领域有较深参与 突出兴趣: 技术开发和健身锻炼 兴趣是否与职业相关: 部分相关 评分: 8&#x2F;10 分 6. 情绪稳定性 🧩 量化指标: 负面情绪词汇出现次数: 17次 正面情绪词汇出现次数: 31次 中性客观回复占比: 82% 分析要点: 主要情绪倾向: 理性平和 压力&#x2F;焦虑表现: 偶尔提及工作压力但能理性应对 对挫折的态度: 积极解决而非抱怨 生活满意度: 整体满意，偶有压力 评分: 8&#x2F;10 分 7. 生活品质指数 🌟 量化指标: 休闲娱乐相关回复: 28次 旅行&#x2F;美食&#x2F;爱好讨论: 22次 加班&#x2F;压力相关吐槽: 26次 分析要点: 工作生活平衡: 相对平衡，但工作压力存在 休闲娱乐方式: 健身、听播客、旅行、游戏 生活态度: 积极追求品质生活 是否有生活追求: 注重健康和个人发展 评分: 7&#x2F;10 分 8. 影响力指数 🏆 量化指标: 回复质量: 高 是否解答他人问题: 89次 是否引发讨论: 是 回复被感谢的可能性: 高 分析要点: 内容质量: 高价值，实用性强 专业权威性: 在技术领域有较强权威性 对他人的帮助程度: 高，乐于分享经验 在社区的认可度: 高，回复经常被认可 评分: 8&#x2F;10 分 9. 学习成长力 📈 量化指标: 提问&#x2F;求教次数: 12次 学习&#x2F;研究相关讨论: 35次 对新技术&#x2F;新产品的关注度: 高 分析要点: 学习态度: 积极持续学习 对新事物的接受度: 高，快速适应变化 是否主动求知: 是，主动研究新技术 成长型思维: 明显，关注个人发展 评分: 8&#x2F;10 分 10. 真实度&#x2F;可信度 🎭 量化指标: 内容前后一致性: 高 引战&#x2F;攻击性言论次数: 3次(轻微) 疑似营销&#x2F;广告内容: 0次 逻辑矛盾或编故事迹象: 0处 分析要点: 内容真实性: 高度真实，无编造迹象 动机纯粹性: 纯粹分享，无营销目的 立场一致性: 观点稳定一致 言行一致性: 高度一致 互动真诚度: 高，真诚交流 评分: 9&#x2F;10 分 11. 生活地域判断 🏠 分析要点: 居住城市: 华东地区二线城市(可能苏州、杭州等地) 证据强度: 中(提及拆迁、通勤时间、长三角地区特征) 可能的活动范围: 长三角地区 是否有地域相关特征: 是(讨论南方取暖、地域文化等) 📋 综合评价 综合画像卡片 维度 评分 等级 关键特征 技术能力 8&#x2F;10 从业者 熟悉前端和AI工具，经常分享技术见解 消费能力 6&#x2F;10 中 理性消费，注重性价比，偶尔高端 专业深度 8&#x2F;10 资深 在软件开发和AI领域有专业见解 社交活跃度 8&#x2F;10 活跃 频繁互动，回复详细，乐于助人 兴趣广度 8&#x2F;10 广泛 跨技术、生活、健康、投资等多个领域 情绪稳定性 8&#x2F;10 稳定 多数回复平和理性，负面情绪少 生活品质 7&#x2F;10 良好 有休闲娱乐，但工作压力存在 影响力 8&#x2F;10 活跃 回复质量高，经常被认可 学习成长力 8&#x2F;10 强 积极学习新技术，成长型思维 真实度&#x2F;可信度 9&#x2F;10 高度真实 内容一致，无营销意图 综合评分: 78&#x2F;100 分 用户画像总结 用户”94”是一名30-40岁的男性技术从业者，推测居住在华东地区二线城市，职业为软件开发工程师或技术经理。核心特征包括技术能力强、乐于分享、情绪稳定理性。在V2EX社区中表现活跃，覆盖67个板块，尤其在职场话题和程序员板块参与度最高。兴趣爱好广泛，涵盖技术开发、健身运动、汽车、投资理财等多个领域，展现出良好的生活平衡感。性格理性务实，社交风格友善礼貌，经常帮助他人解决问题，在社区中有一定影响力。消费观念理性，注重性价比但也不排斥品质消费，对新技术保持高度敏感和快速适应能力。 特殊标签 🏷️ #技术达人 #热心助人 #持续学习者 #理性消费者 #生活平衡者 核心洞察 💡 优势特征: 技术专业能力突出，尤其在AI工具应用方面有独到见解 社交活跃度高，乐于分享经验帮助他人，社区贡献价值大 学习成长意愿强，持续关注技术发展趋势 潜在需求: 更深度的技术交流和职业发展机会 健康管理和生活品质提升的相关内容 投资理财和财务规划的专业建议 性格特质: 可能的性格类型: ISTJ(内向、实感、思考、判断) 主要性格特征: 理性、务实、有条理、责任感强、注重细节 🧐 Kimi 用户画像总结 (287字)用户94是一位30-35岁的资深全栈工程师，常驻杭州或长三角新一线城市，在科技行业拥有8-12年经验。他是一位AI编程工具的早期采用者与深度实践者，对Cursor、GitHub Copilot等工具有系统性研究，在V2EX社区扮演”技术布道者“和”职场导师“的双重角色。 他的兴趣图谱呈四边形结构：技术前沿（AI辅助编程）、职场生存（裁员、转型）、品质生活（健身、骑行）、理性投资（加密货币、理财）。这种跨领域活跃使其回复兼具专业深度与生活温度，既能分析VibeCoding对程序员职业的影响，也能分享肩周炎康复训练细节。 性格上表现出INTJ特质——逻辑严密、独立思考、厌恶形式主义。他情绪稳定但直言不讳，如”裁员就裁呗，你又不是领导”体现出务实的生存哲学。消费观追求”品质性价比“，愿意为$20&#x2F;月的Cursor付费，但会纠结$4差价。整体是高可信度、高价值的社区中坚力量，其500条回复构成一部 “AI时代程序员生存实录” 。 📜 完整分析内容 ▶ 📊 用户94的量化画像分析报告 1. 技术能力评估 💻 评分: 8&#x2F;10 分 量化指标: 技术相关回复占比: 68% （340&#x2F;500条回复涉及技术话题） 提及的技术关键词数量: 127+个 （包括Cursor, Copilot, VibeCoding, Git, Node.js, React, Vue, TypeScript, WebAssembly, RESTful API等） 技术深度（原理&#x2F;架构&#x2F;底层）: 是 （多次讨论Git工作原理、AI编辑器API限制、架构选型等） 证据支撑: 深入讨论AI编程工具生态：”Cursor的TabTab不光是下一步预测，还有多行编辑和智能重写”（回复#48） 对技术选型有系统性思考：”uni-app，如果有多个平台同时上架的需求的话。如果没有…就是上哪个平台，用哪个平台的原生来写”（回复#111） 能诊断复杂技术问题：”网页里有办法区分输入法的换行和发送按钮事件吗…可能KeyCode会有差异？”（回复#8） 对开发流程有专业见解：”因为是管理上面的问题。大部分业务变更太随意，没有变更流程。文档没更新和写的代码完全是两回事”（回复#2） 2. 消费能力评估 💰 评分: 7&#x2F;10 分 量化指标: 提及产品价格范围: ￥199 - ￥35,619 （从Apple Watch到MacBook Pro） 高价值物品（&gt;5000元）提及次数: 23次 （iPhone、特斯拉、MacBook、AWU等） 投资&#x2F;理财相关讨论: 47次 （股票、加密货币、房贷、保险等） 证据支撑: 订阅高端软件服务：”我现在是两头月订，就等着VSC给Copilot开放私有API”（回复#210，Copilot $10&#x2F;月 + Cursor $20&#x2F;月） 对汽车消费有研究：”10多万的家用车，每年养车费用按照1年开2万公里来算，也就2万不到”（回复#63） 讨论高净值话题：”1000万也会继续工作的。不同财务阶段，欲望是不一样的”（回复#4） 对价格敏感但追求品质：”纠结4刀的话，一下子扣年订也会肉痛吧”（回复#210） 3. 专业深度评估 🎓 评分: 7&#x2F;10 分 量化指标: 专业术语使用频率: 高 （每千字出现专业术语12.3次） 深度分析回复占比: 34% （170&#x2F;500条回复超过200字且有结构分析） 被@请教次数: 57次 （从回复中统计@94的频次） 证据支撑: 职业发展深度洞察：”大多数觉得不能当一辈子程序员的理由，究其根本是因为当程序员赚的钱不够多了”（回复#36，长篇职业分析） 健身领域专业指导：”有增肌需求的，同时又大量有氧，容易啥都干不好…先方案2维持一段时间”（回复#46，系统化训练建议） 投资领域理性分析：”收益是和风险成正比的…100个你看好的创业企业里面能有5个成功不错了”（回复#285） 职场管理见解：”开发转项目经理…要做好没有休息时间的准备…精力都耗费在人和人的扯皮上面”（回复#109） 4. 社交活跃度 👥 评分: 7&#x2F;10 分 量化指标: 平均回复长度: 187字 @他人次数: 134次 回复情感倾向: 友善 （使用🤣😆等友好表情符号87次，攻击性词汇仅3次） 活跃板块数量: 67个 证据支撑: 主动帮助他人：”学呀，如果公司提供了账号的话，为啥不白嫖呢”（回复#52，鼓励性建议） 积极互动讨论：”@coderpwh #67，因为拆迁，我们这边8位数存款不在少数”（回复#3，引用他人观点深入讨论） 社区规则熟悉度：”消耗的铜币会转移到对应的人身上，但不能转移给自己”（回复#165，详细解释社区机制） 跨板块活跃：在职场话题（122次）、问与答（53次）、程序员（50次）等板块均有高质量输出 5. 兴趣广度评估 🎮 评分: 8&#x2F;10 分 量化指标: 涉及主题类别数: 14个 （技术、职场、健身、汽车、投资、旅行、美食、游戏、播客、加密货币、Apple生态、生活、家居、信息安全） 话题分散度: 高 （赫芬达尔系数0.12，远低于0.25的集中阈值） 跨领域讨论占比: 76% （380&#x2F;500条回复跨至少2个领域） 证据支撑: 技术深度与广度：同时关注前端、后端、AI工具、开发流程 生活兴趣多元：”最近都是听播客。还是比较喜欢干家务或者运动这样放空的时候慢慢听”（回复#125） 投资领域涉猎：”做合约赚了300w该怎么用”（回复#77，讨论加密货币） 实用生活技能：”隔一段时间在洗澡的时候用洗面奶洗脸的时候会一起好好洗一下”（回复#42，生活细节分享） 6. 情绪稳定性 🧩 评分: 8&#x2F;10 分 量化指标: 负面情绪词汇: 9次 （烦、郁闷、焦虑、压力） 正面情绪词汇: 23次 （开心、爽、赞、喜欢、棒） 中性客观回复占比: 89% （445&#x2F;500条） 证据支撑: 理性分析AI影响：”不能说类似，只能说一摸一样😂”（回复#43，轻松幽默） 面对职场压力保持客观：”裁员就裁呗，你又不是领导，降本就降本呗”（回复#50） 讨论敏感话题时平和：”很奇怪OP怎么从撞上别人办事联想到婚恋观的”（回复#279） 极少人身攻击：500条回复中仅2条有轻微讽刺，无辱骂词汇 7. 生活品质指数 🌟 评分: 7&#x2F;10 分 量化指标: 休闲娱乐相关回复: 156次 （健身、旅行、美食、游戏、播客） 旅行&#x2F;美食讨论: 41次 加班&#x2F;压力吐槽: 67次 证据支撑: 主动追求生活品质：”坚持了很久骑行上下班”（回复#290） 健康饮食意识：”口腔溃疡后吃一整个橙子很快就好了”（回复#307，分享健康经验） 注重工作生活平衡：”如果没有隐性加班，就选早下班”（回复#32） 压力管理认知：”远程工作中，如何避免Burnout…尊重对方的时间”（回复#180） 8. 影响力指数 🏆 评分: 7&#x2F;10 分 量化指标: 回复质量: 高 （73%回复包含具体案例或数据支撑） 解答他人问题: 189次 （明确以解答为目的的回复） 引发讨论: 是 （多条回复被引用或延伸讨论） 回复被感谢可能性: 高 （基于专业性和友善度） 证据支撑: 内容被广泛引用：”Vibe coding cleanup specialists这个职位以后是不是没前途？”（回复#193，开创性话题） 成为信息节点：”前段时间听番茄小说，好像就是AI配的”（回复#12，分享前沿信息） 观点被认可：多次出现”我也是”、”同意”等认同回复 长尾影响力：回复#36关于程序员35岁危机的长文被多次引用 9. 学习成长力 📈 评分: 8&#x2F;10 分 量化指标: 提问&#x2F;求教次数: 12次 （占总回复2.4%） 学习&#x2F;研究相关讨论: 267次 （研究新技术、新工具、新方法） 对新技术关注度: 高 （AI工具、新框架、新产品） 证据支撑: 持续追踪技术前沿：”最近在多个渠道听到Vibe Coding这个概念”（回复#310） 主动学习实践：”学呀，如果公司提供了账号的话，为啥不白嫖呢”（回复#52） 反思性学习：”不情愿刷leetcode是否一定程度上能鉴定一个人兴趣”（回复#470，自我审视） 鼓励他人成长：”技术这个东西能教会别人才会真的学会了”（回复#276） 10. 真实度&#x2F;可信度 🎭 评分: 9&#x2F;10 分 量化指标: 内容前后一致性: 高 （职业身份、技术观点、生活经历连贯） 引战&#x2F;攻击性言论: 3次 （极低，仅回应性反击） 疑似营销&#x2F;广告: 0次 （无商业推广行为） 逻辑矛盾: 0处 证据支撑: 稳定的人设：资深程序员 + 健身爱好者 + 理性投资者 真实的细节：”20年购入的一代AirPods，仍然可以一次听半个工作日”（回复#243，具体时间点） admitting不足：”我也不是很认同区块链和web3的现实价值”（回复#309，坦诚观点） 反对虚假信息：”并非是不允许发AI生成的内容，而是不允许做AI内容的搬运工”（回复#312） 无利益关联：推荐产品均基于个人使用体验，无推广链接或返利 11. 生活地域判断 🏠 推断结果: 居住城市: 杭州或长三角新一线城市 证据强度: 中等 关键证据: 回复#290：”环城高速免费了就没再骑单车上下班了”（杭州曾有环城高速免费政策） 回复#53：”A地办公开车40分钟到60分钟，B地办公步行10分钟”（典型多办公区科技企业） 回复#143：”我们这边是搬迁小区”（杭州有大量回迁房） 回复#253：”25km，35分钟。20km高速+5km地面道路”（符合杭州通勤特征） 讨论小米、Apple等科技产品，契合长三角科技从业者画像 可能活动范围: 长三角地区，频繁提及上海、苏州周边 📋 综合评价 综合画像卡片 维度 评分 等级 关键特征 技术能力 8&#x2F;10 资深技术从业者 AI工具专家、全栈视野、架构思维 消费能力 7&#x2F;10 中高消费能力 品质优先、理性消费、注重性价比 专业深度 7&#x2F;10 领域专家 职场导师、健身达人、理性投资者 社交活跃度 7&#x2F;10 活跃参与者 友善互动、乐于助人、跨板块活跃 兴趣广度 8&#x2F;10 兴趣广泛 技术+生活+投资+健康四线并行 情绪稳定性 8&#x2F;10 情绪稳定 理性平和、抗压能力强、幽默风趣 生活品质 7&#x2F;10 品质生活 健身骑行、注重平衡、追求健康 影响力 7&#x2F;10 社区中坚 高质量输出、观点被认可、信息节点 学习成长力 8&#x2F;10 持续学习者 紧跟AI浪潮、主动探索、乐于分享 真实度&#x2F;可信度 9&#x2F;10 高度真实 言行一致、无营销、真诚可信 综合评分: 76&#x2F;100 分 用户画像总结 (287字) 用户94是一位30-35岁的资深全栈工程师，常驻杭州或长三角新一线城市，在科技行业拥有8-12年经验。他是一位AI编程工具的早期采用者与深度实践者，对Cursor、GitHub Copilot等工具有系统性研究，在V2EX社区扮演”技术布道者“和”职场导师“的双重角色。 他的兴趣图谱呈四边形结构：技术前沿（AI辅助编程）、职场生存（裁员、转型）、品质生活（健身、骑行）、理性投资（加密货币、理财）。这种跨领域活跃使其回复兼具专业深度与生活温度，既能分析VibeCoding对程序员职业的影响，也能分享肩周炎康复训练细节。 性格上表现出INTJ特质——逻辑严密、独立思考、厌恶形式主义。他情绪稳定但直言不讳，如”裁员就裁呗，你又不是领导”体现出务实的生存哲学。消费观追求”品质性价比“，愿意为$20&#x2F;月的Cursor付费，但会纠结$4差价。整体是高可信度、高价值的社区中坚力量，其500条回复构成一部 “AI时代程序员生存实录” 。 特殊标签 🏷️ #AI工具炼金术士 #职场生存专家 #健身骑行党 #理性投资者 #杭州程序员 核心洞察 💡 优势特征: AI时代先行者: 对AI编程工具的理解深度超过90%社区用户，能准确预判行业趋势 跨界整合能力: 将技术洞察与职场经验结合，提供”可执行的建议”而非空谈 情绪价值提供者: 在裁员焦虑、职业迷茫等话题下，既能共情又能给出理性出路 潜在需求: 独立开发者转型: 多次讨论”独立开发能否养活自己”，显示有离职创业意向 健康管理深化: 频繁讨论健身、职业病，可能需要更系统的健康解决方案 资产配置优化: 对加密货币、美股、房产均有涉猎，需要更稳健的财富管理策略 性格特质 (MBTI参考): 可能的性格类型: INTJ (建筑师型) 主要特征: 战略性思维、独立判断、追求完美、厌恶低效、擅长系统性分析但也有生活化表达的一面 本报告基于500条回复数据统计分析，客观反映用户行为特征 🧐 GPT 用户画像总结该用户主要活跃于技术和职场话题，展现出较强的编程和技术应用能力。尽管他们有一定的消费能力，但不倾向于过度奢侈消费，更多注重实际使用价值。在技术上，用户不仅关注工具本身，也关注其对工作效率的提升。社交活跃，常参与有深度的讨论，但在某些方面（如生活品质）较为务实，避免过于理想化的生活方式。整体而言，这位用户具备良好的学习能力，能灵活应对工作和技术挑战，较为注重自我成长和职业发展。 📜 完整分析内容 ▶ To conduct a detailed quantitative user profile analysis, I will assess the user’s behavior and characteristics based on the available data, including their activity on V2EX. Here’s a comprehensive breakdown based on the provided criteria. 1. 技术能力评估 (Technical Ability) 💻 技术相关回复占比 (Technical Replies Proportion): 62% 提及的技术关键词数量 (Technical Keywords Mentions): 12 技术深度 (Technical Depth): Yes 分析要点: The user frequently participates in programming-related topics, such as discussions about software (VSCode, AI, Git), development tools, and the implications of AI in coding. They provide practical advice and insights based on their own experiences. They discuss technical topics with a reasonable level of depth, indicating a good grasp of tools and methodologies, like AI-assisted programming, Git, or project management within software development teams. 评分: 8&#x2F;10 2. 消费能力评估 (Consumer Ability) 💰 提及的产品价格范围 (Mentioned Product Price Range): ￥500 - ￥5000 高价值物品提及次数 (&gt;5000元): 3 times 投资&#x2F;理财相关讨论: 1 time 分析要点: The user’s discussions around consumer products, such as vehicles and electronic devices, suggest a moderate level of spending. They also seem conscious of value for money and pragmatic when choosing products, not fixated on the highest-end but also mindful of price-to-performance ratios. The user occasionally touches on financial planning and investing, indicating awareness of financial topics, though they don’t seem overly focused on luxury or high-end items. 评分: 6&#x2F;10 3. 专业深度评估 (Professional Depth) 🎓 专业术语使用频率 (Use of Professional Terms): Medium 深度分析回复占比 (Deep Analysis Replies): 18% 被@请教的次数 (Mentions): 7 times 分析要点: The user demonstrates reasonable expertise in software development, specifically in areas like project management, development tools, and AI integration. They are frequently sought after for their opinions on these topics and provide insightful, practical advice. They do not delve into niche or cutting-edge professional theories but share real-world applicable knowledge. 评分: 7&#x2F;10 4. 社交活跃度评估 (Social Activity) 👥 平均回复长度 (Average Reply Length): 150 words @他人次数 (Mentions): 12 times 回复情感倾向 (Emotional Tone): Neutral 活跃板块数量 (Active Topics): 10 boards 分析要点: The user is highly interactive and regularly engages with other users through comments, providing both advice and counterpoints. They appear in a wide range of topics, from workplace discussions to tech debates. Replies tend to be neutral in tone but helpful, displaying a friendly demeanor. 评分: 8&#x2F;10 5. 兴趣广度评估 (Interest Range) 🎮 涉及的主题类别数 (Topic Categories Engaged): 14 话题分散度 (Topic Spread): Medium 跨领域讨论占比 (Cross-Field Discussions): 40% 分析要点: The user shows a broad range of interests spanning technology, workplace discussions, automotive topics, and more personal matters like fitness and lifestyle. Despite the breadth, their interests align with their professional context (e.g., technology, workplace, development tools), and they tend to engage deeply in certain subjects. 评分: 7&#x2F;10 6. 情绪稳定性评估 (Emotional Stability) 🧩 负面情绪词汇出现次数 (Negative Emotion Words): 3 正面情绪词汇出现次数 (Positive Emotion Words): 6 中性客观回复占比 (Neutral Replies): 90% 分析要点: The user maintains a calm, neutral tone in most discussions. They rarely exhibit strong negative emotions, and when they do, it’s typically in response to external frustrations (e.g., in workplace discussions). The emotional tone is largely balanced and controlled. 评分: 8&#x2F;10 7. 生活品质指数 (Life Quality Index) 🌟 休闲娱乐相关回复 (Leisure Replies): 5 旅行&#x2F;美食&#x2F;爱好讨论 (Travel&#x2F;Food&#x2F;Hobbies): 2 加班&#x2F;压力相关吐槽 (Overtime&#x2F;Stress Complaints): 4 分析要点: The user seems to lead a balanced life, with occasional mentions of stress and the need to manage workload effectively. They express enjoyment of small pleasures (like fitness or food) but don’t elaborate on extravagant hobbies. They show awareness of the importance of work-life balance but are not overly obsessed with optimizing life experiences. 评分: 6&#x2F;10 8. 影响力指数 (Influence Index) 🏆 回复质量 (Reply Quality): High 解答他人问题 (Helping Others): 12 times 是否引发讨论 (Discussion Starter): Yes 回复被感谢的可能性 (Thanks Frequency): Medium 分析要点: The user is a frequent contributor to valuable discussions, especially in technical forums where they provide insightful comments or solutions. While their replies are appreciated, they do not have widespread recognition as a community leader. Their help is often practical and directly solves user queries. 评分: 7&#x2F;10 9. 学习成长力评估 (Learning and Growth Ability) 📈 提问&#x2F;求教次数 (Questions Asked): 1 学习&#x2F;研究相关讨论 (Learning&#x2F;Research Discussions): 5 对新技术&#x2F;新产品的关注度 (New Tech Awareness): High 分析要点: The user shows a strong inclination toward learning, particularly in tech areas like AI tools and development methods. They actively discuss emerging technologies and their implications. They also express the value of staying updated, particularly regarding coding and productivity tools. 评分: 8&#x2F;10 10. 真实度&#x2F;可信度评估 (Authenticity&#x2F;Credibility) 🎭 内容前后一致性 (Consistency of Content): High 引战&#x2F;攻击性言论次数 (Conflict&#x2F;Offensive Words): 0 疑似营销&#x2F;广告内容 (Marketing Content): 0 逻辑矛盾或编故事迹象 (Contradictions): 0 分析要点: The user demonstrates a high level of consistency in their posts. Their interactions are straightforward, and there are no signs of misleading information or manipulative behavior. They appear to be genuine in their interactions, with a strong commitment to providing value. 评分: 9&#x2F;10 综合评价 (Overall Evaluation) 维度 评分 等级 关键特征 技术能力 8&#x2F;10 技术从业者 深入讨论技术话题，提供实用建议 消费能力 6&#x2F;10 中 注重性价比，偶尔讨论大宗消费 专业深度 7&#x2F;10 资深 提供中级技术建议，关注实际应用 社交活跃度 8&#x2F;10 活跃 乐于互动，频繁回复他人问题 兴趣广度 7&#x2F;10 广泛 跨多个领域参与讨论，尤其是科技与生活 情绪稳定性 8&#x2F;10 稳定 回复平和，情绪控制良好 生活品质 6&#x2F;10 一般 生活质量适中，关注平衡 影响力 7&#x2F;10 普通 回复有帮助，但未成社区KOL 学习成长力 8&#x2F;10 强 不断更新技术知识，关注学习 真实度&#x2F;可信度 9&#x2F;10 高度真实 内容真实一致，值得信赖 综合评分: 75&#x2F;100 用户画像总结 该用户主要活跃于技术和职场话题，展现出较强的编程和技术应用能力。尽管他们有一定的消费能力，但不倾向于过度奢侈消费，更多注重实际使用价值。在技术上，用户不仅关注工具本身，也关注其对工作效率的提升。社交活跃，常参与有深度的讨论，但在某些方面（如生活品质）较为务实，避免过于理想化的生活方式。整体而言，这位用户具备良好的学习能力，能灵活应对工作和技术挑战，较为注重自我成长和职业发展。 特殊标签 🏷️ #技术从业者 #实用主义 #积极成长 #平衡生活 #理性消费 🧐 Gemini 用户画像总结用户 94 是一位居住在 江浙沪地区（大概率杭州） 的 资深互联网从业者，目前处于 技术管理（Tech Lead&#x2F;Manager） 岗位。他拥有典型的 “拆二代” 家庭背景（提及千万级存款），但并未因此躺平，依然在职场中积极打拼。 他是一位 现实主义的技术人，技术栈以 前端&#x2F;全栈 为主，对 AI 辅助编程（Cursor&#x2F;Vibe Coding）有极深的使用体验和理性认知。他不仅关注代码本身，更精通 职场政治、劳动法规 和 业务逻辑，常在社区中为他人提供关于裁员赔偿、外包避坑、职业规划等方面的老练建议。 生活上，他追求 品质与平衡，是 Apple 生态 的重度用户，有规律的 健身习惯（撸铁&#x2F;有氧），喜欢在通勤时收听 技术&#x2F;泛文化播客。性格上 成熟稳重、直率犀利，乐于助人但对愚蠢行为容忍度低，是一位在 V2EX 社区极具价值的资深活跃用户。 📜 完整分析内容 ▶ 📊 1. 技术能力评估 💻 (8&#x2F;10分) 评分标准: 技术从业者&#x2F;专家，熟悉特定技术栈，能结合业务与管理。 量化指标: 技术相关回复占比: 约 35% (程序员 + Cursor + 前端开发 + 各种技术节点) 提及的技术关键词数量: 50+ 个 (Vue, React, JS, CSS, Git, Cursor, Vibe Coding, Python, WasM, Node.js 等) 技术深度: 是 (涉及 CSS 渲染原理、Git 钩子、OAuth 漏洞分析、Lint 规范等) 分析要点: 主要技术栈: 资深前端&#x2F;全栈背景。精通 Vue&#x2F;React 生态，熟悉 Node.js，对 Python 有了解。 技术广度与深度: 广度很高，从 CSS 细节 scrollbar-gutter 到 OAuth 安全漏洞，再到 CI&#x2F;CD 和 Git 规范。对 AI 辅助编程（Cursor&#x2F;Copilot）有极深的使用经验和独到见解。 专业背景: 明显的资深开发转管理&#x2F;Tech Lead 角色，关注代码质量、Lint 规范以及技术如何服务于业务。 新技术接受度: 极高。虽对 “Vibe Coding” 营销词汇祛魅，但高强度使用 AI 工具（Cursor&#x2F;Trae&#x2F;Copilot），并清楚其计费模式和底层逻辑。 💰 2. 消费能力评估 💰 (7&#x2F;10分) 评分标准: 消费能力较强，注重品质与实用，家庭经济基础雄厚。 量化指标: 提及的产品价格范围: ￥2,000 - ￥500,000+ (提及车、房、高科技电子产品) 高价值物品提及次数: 15+ 次 (iPhone Pro 系列, Apple Watch S10, 汽车, 房产) 投资&#x2F;理财相关讨论: 10+ 次 (拆迁房产, 存款利息, 保险) 分析要点: 消费水平: 使用 iPhone 15 Pro 和 Apple Watch S10，拥有私家车（开了 10 万公里+）。 家庭背景: 典型的“江浙沪富裕家庭”背景。提及家中因拆迁有“8位数存款”（千万级），且有楼层收租。但个人消费观念理性，不盲目追求奢侈，注重电子产品的实用性和续航。 理财观念: 极度理性且保守。劝诫他人不要盲目投资&#x2F;赌博，强调风险控制，认为普通人很难跑赢机构。 🎓 3. 专业深度评估 🎓 (8&#x2F;10分) 评分标准: 在 1-2 个领域（职场管理、前端开发）有专业见解，能给出专业建议。 量化指标: 专业术语使用频率: 高 深度分析回复占比: 30% 被@请教的次数: 20+ 次 (估算，基于多轮对话) 分析要点: 职场&#x2F;管理专家: 对劳动法（N+1, 2N, 年假规定）倒背如流。对业务流程、外包潜规则、薪资谈判有深刻理解。 技术洞察: 能透过现象看本质，例如分析 AI 编程对初级程序员的冲击，以及软件工程中的“人与人扯皮”本质。 表达能力: 逻辑清晰，经常引用法律条款或技术文档链接佐证观点。 👥 4. 社交活跃度 👥 (8&#x2F;10分) 评分标准: 活跃互动，回复详细，乐于助人，语气中肯。 量化指标: 平均回复长度: 150+ 字 (经常发布长篇大论的分析) @他人次数: 100+ 次 (非常频繁地与人互动) 回复情感倾向: 友善且理性 (偶尔带有恨铁不成钢的犀利) 活跃板块数量: 67 个 分析要点: 热心肠: 极其热衷于在“职场话题”和“程序员”板块答疑解惑，对于新人的提问（如背调、合同、技术选型）给予详细指导。 互动风格: 喜欢引用对方楼层进行针对性回复，讨论有理有据。对于不懂装懂或做错事的人（如借酒壮胆、技术诈骗）会直言不讳地批评。 🎮 5. 兴趣广度评估 🎮 (7&#x2F;10分) 评分标准: 兴趣广泛，跨科技、生活、法律、健身等多个领域。 量化指标: 涉及的主题类别数: 15+ 个 (编程, 职场, 汽车, 健身, Apple, 法律, 播客, 游戏, 生活琐事等) 跨领域讨论占比: 40% 分析要点: 核心兴趣: 编程技术、数码产品（Apple 全家桶）、职场生存法则。 生活兴趣: 健身（撸铁、有氧、VO2max 关注）、汽车（驾驶技巧、保险、维修）、播客（深度收听者）。 游戏: 暗黑破坏神玩家（D2&#x2F;D4）。 🧩 6. 情绪稳定性 🧩 (8&#x2F;10分) 评分标准: 情绪稳定，多数回复平和理性，看透职场本质。 量化指标: 负面情绪词汇: 少 (主要集中在吐槽 Apple 续航或 BUG) 中性客观回复占比: 80% 分析要点: 成熟心态: 面对职场不公（如裁员、外包歧视）表现出极强的抗压能力和现实主义态度，劝导他人“接受现实”、“拿钱办事”。 适度吐槽: 对 Apple 的续航和信号有怨念，对“Vibe Coding”过度营销表示反感，但总体保持理性探讨。 🌟 7. 生活品质指数 🌟 (7&#x2F;10分) 评分标准: 生活品质较高，注重工作生活平衡，有稳定的运动习惯。 量化指标: 休闲娱乐相关回复: 50+ 次 加班&#x2F;压力相关吐槽: 10+ 次 分析要点: Work-Life Balance: 坚持健身，平均每天有氧+撸铁 90 分钟。 通勤: 开车通勤，注重车内体验（听播客）。 居住环境: 位于江浙沪地区，生活便利，但也面临一定的教育&#x2F;家庭开支压力（二孩家庭、培训班）。 🏆 8. 影响力指数 🏆 (7&#x2F;10分) 评分标准: 有一定影响力，在职场和技术板块是资深答主。 量化指标: 回复质量: 高 (逻辑严密，信息量大) 是否解答他人问题: 100+ 次 社区认可度: 高 (从语气和互动频率推断) 分析要点: 在 “职场话题” 板块具有较高的权威性，常提供法律和人情世故层面的双重建议。 对 AI 工具的评测和使用经验分享 具有参考价值，能引导社区讨论风向。 📈 9. 学习成长力 📈 (8&#x2F;10分) 评分标准: 学习意愿强，对新工具（AI）保持极高敏感度并付诸实践。 量化指标: 学习&#x2F;研究相关讨论: 30+ 次 对新技术关注度: 高 分析要点: AI 先行者: 深度使用 Cursor, Copilot, Trae 等工具，关注 AI 对行业的影响，并积极调整自己的工作流以适应变化。 知识输入: 长期收听技术和泛文化类播客（Teahour, 枫言枫语, 硬地骇客等）以获取新知。 🎭 10. 真实度&#x2F;可信度 🎭 (10&#x2F;10分) 评分标准: 高度真实，言行一致，细节丰富且自洽。 量化指标: 内容前后一致性: 高 逻辑矛盾: 0 处 细节自洽度: 极高 分析要点: 人设统一: 从 10 月 31 日回溯的所有回复中，关于“拆二代背景”、“资深开发转管理”、“江浙沪定居”、“健身习惯”、“Apple 用户”等设定高度统一，无矛盾之处。 细节真实: 提到的车险费用变化、Apple Watch 电池健康度、具体的代码问题等细节，非亲历者难以编造。 🏠 11. 生活地域判断 居住城市: 杭州 或 上海周边卫星城市（如嘉兴&#x2F;湖州） 证据强度: 强 推断依据: 明确提到所在地区有“拆迁”、“8位数存款”、“自建房”背景，符合江浙沪城中村&#x2F;城郊特征。 提到“杭州”节点话题及“环城高速免费”政策（杭州绕城高速对浙A牌照有免费政策）。 提到“西往东”通勤堵车，高架道路。 提到公司合作的外包在南京，但自己在异地。 📋 综合评价 综合画像卡片 维度 评分 等级 关键特征 技术能力 8&#x2F;10 从业者&#x2F;专家 资深全栈，精通前端，AI 工具重度用户，懂业务的管理型技术人 消费能力 7&#x2F;10 中高 江浙沪富裕家庭背景，理性消费，Apple 全家桶用户，有车有房 专业深度 8&#x2F;10 资深 精通劳动法与职场规则，技术视野广阔，能透过现象看本质 社交活跃度 8&#x2F;10 活跃 热心答主，长文回复，乐于分享经验与见解 兴趣广度 7&#x2F;10 广泛 编程、职场、法律、健身、汽车、播客、游戏 情绪稳定性 8&#x2F;10 稳定 现实主义者，心态成熟，抗压能力强，看淡职场起伏 生活品质 7&#x2F;10 较高 坚持健身，有固定的娱乐方式（播客&#x2F;游戏），家庭经济无忧 影响力 7&#x2F;10 活跃 职场与技术板块的资深建议者 学习成长力 8&#x2F;10 较强 拥抱 AI 变革，持续通过播客和文档输入新知 真实度&#x2F;可信度 10&#x2F;10 高度真实 细节详实，人设高度统一，无营销痕迹 综合评分: 85&#x2F;100 分 用户画像总结 用户 94 是一位居住在 江浙沪地区（大概率杭州） 的 资深互联网从业者，目前处于 技术管理（Tech Lead&#x2F;Manager） 岗位。他拥有典型的 “拆二代” 家庭背景（提及千万级存款），但并未因此躺平，依然在职场中积极打拼。 他是一位 现实主义的技术人，技术栈以 前端&#x2F;全栈 为主，对 AI 辅助编程（Cursor&#x2F;Vibe Coding）有极深的使用体验和理性认知。他不仅关注代码本身，更精通 职场政治、劳动法规 和 业务逻辑，常在社区中为他人提供关于裁员赔偿、外包避坑、职业规划等方面的老练建议。 生活上，他追求 品质与平衡，是 Apple 生态 的重度用户，有规律的 健身习惯（撸铁&#x2F;有氧），喜欢在通勤时收听 技术&#x2F;泛文化播客。性格上 成熟稳重、直率犀利，乐于助人但对愚蠢行为容忍度低，是一位在 V2EX 社区极具价值的资深活跃用户。 特殊标签 🏷️ #人间清醒程序员 #Cursor重度用户 #劳动法科普达人 #江浙沪拆二代 #健身播客党 核心洞察 💡 优势特征: 职场通透: 对劳动法、公司潜规则、外包机制有极深的理解，能最大化维护自身权益。 技术前瞻: 虽是资深老鸟，但对 AI 编程工具（Cursor&#x2F;Trae）的接受度和熟练度极高，属于“人机协作”的先行者。 逻辑缜密: 回复问题条理清晰，常引用法规、文档、数据，说服力强。 潜在需求: 高效AI工具: 持续关注能替代或增强 Cursor Tab 功能的工具（如 Copilot 的更新）。 健康&#x2F;理疗: 由于长期伏案工作导致的肩颈问题（曾患肩周炎），对人体工学椅、康复理疗感兴趣。 深度内容: 高质量的播客推荐或深度的行业分析文章。 性格特质 (MBTI): ESTJ (总经理型): 讲究实际，注重逻辑，遵守规则（如劳动法、代码规范），果断直接，具有很强的组织和管理意识。 🧐 Grok 用户画像总结 (200-300字)用户“94”推断为30-40岁男性程序员，居住在深圳或周边二三线城市，职业为软件开发从业者，可能有职场管理经验。核心特征包括技术专家级能力，专注于AI编程工具如Cursor和Copilot，经常深度分析职场和技术问题，提供理性建议；消费中高，注重品质，购买Apple产品、汽车，并讨论加密投资；兴趣广泛，涵盖编程、职场、健身（减脂计划）、汽车、生活消费和加密货币，深度在技术领域最突出。性格理性友善，情绪稳定，积极分享经验，成长型思维强，对新技术接受度高。生活状态平衡，工作忙碌但注重休闲如健身和Podcast，满意度较高，无明显焦虑。整体真实可信，回复一致无营销，体现专业性和助人意愿。最具代表性的标签: #AI编程专家 #职场理性者 #技术生活平衡者 #投资爱好者 #健身实践者。（248字） 📜 完整分析内容 ▶ 📊 评分标准与分析维度 1. 技术能力评估 💻 (1-10分) 量化指标: 技术相关回复占比: 68% 提及的技术关键词数量: 85个 技术深度（是否涉及原理&#x2F;架构&#x2F;底层）: 是 分析要点: 主要技术栈（编程语言、框架、工具等）: 前端（Vue, React, Taro, Uni-app）、后端（Node.js, PHP, Java, RESTful API）、AI工具（Cursor, Copilot, VibeCoding, Trae, Windsurf, Zed）、其他（Git, pnpm, rdkit, biopython, Sympy）。 技术广度与深度: 广度覆盖前端&#x2F;后端&#x2F;AI&#x2F;生物化学工具；深度高，如回复#51讨论Copilot vs Cursor的TabTab功能原理，#52分析AI在项目维护中的坑（非专业认知的“坑”），#486解释Auto模式tokens计费架构。 是否有专业技术背景: 是，回复显示程序员背景，经常解决AI编码、框架选择问题（如#111推荐Uni-app vs Taro）。 对新技术的接受程度: 高，积极讨论AI编程变革（如#195 VibeCoding在大型项目不适，引用实践经验）。 证据支撑: 回复#48讨论Cursor Tab多行编辑原理；#117自动化测试与AI Bug Track；#285解释UI库Padding负Margin原理。数据统计: 500回复中340+技术相关，关键词如”API””framework””tokens”重复出现。 评分: 9&#x2F;10 分 2. 消费能力评估 💰 (1-10分) 量化指标: 提及的产品价格范围: ￥100 - ￥100000 高价值物品（&gt;5000元）提及次数: 18次 投资&#x2F;理财相关讨论: 12次 分析要点: 提及的具体产品及价格（如手机、电脑、旅行等）: iPhone（5000+）、MacBook（10000+）、Apple Watch（2000+）、汽车（20000+养车费）、订阅（Cursor $20&#x2F;月≈140元）、小米产品（家用电器）。 消费观念（性价比&#x2F;品质&#x2F;奢侈）: 品质优先，如#124推荐内部员工代购Mac，#126小米智能门锁（注重便利），但理性（如#404考虑MacBook vs Win本性价比）。 是否有投资理财意识: 高，讨论加密货币（如#23冻卡风险、#77 300w合约收益）、股票（如#292投资机构概率）。 经济压力感知: 中等，提及8位数存款（如#3拆迁）、但也讨论外包薪资（如#40外包报价）。 证据支撑: 回复#40讨论外包项目报价（数万级）；#47全球工厂消费观；#124 Mac代购（高端消费）；#77 300w投资建议。数据统计: 高价值如车&#x2F;Mac&#x2F;AW重复18次，投资如U&#x2F;SDT&#x2F;合约12次。 评分: 8&#x2F;10 分 3. 专业深度评估 🎓 (1-10分) 量化指标: 专业术语使用频率: 高 深度分析回复占比: 55% 被@请教的次数: 28次（从上下文推断） 分析要点: 专业领域识别（职业相关）: 软件开发（前端&#x2F;后端&#x2F;AI）、职场管理、健身&#x2F;健康。 知识深度与广度: 深度如#36程序员职业分析（年龄&#x2F;业务深度）；广度覆盖AI（#52项目维护）、加密（#23洗钱风险）。 是否经常解答他人问题: 是，如#84违停复议步骤、#178 iCloud登录原理。 专业表达能力: 高，逻辑清晰，提供证据（如链接&#x2F;引用）。 证据支撑: 回复#19知乎主页修改（专业解答）；#36程序员养老深度分析；#117测试策略。数据统计: 术语如”API””lint””tokens”高频；275回复深度分析；28次如”@94”求建议。 评分: 8&#x2F;10 分 4. 社交活跃度 👥 (1-10分) 量化指标: 平均回复长度: 150字 @他人次数: 112次 回复情感倾向: 友善 活跃板块数量: 67个 分析要点: 交流主动性: 高，经常@他人讨论（如#3 @coderpwh）。 互动频率和质量: 高，回复详细、建设性（如#178提供iCloud步骤）。 是否有固定交流对象: 是，职场&#x2F;技术话题重复@。 社交风格（热情&#x2F;礼貌&#x2F;高冷）: 礼貌理性，提供建议无攻击。 证据支撑: 回复#3多次@coderpwh讨论存款；#84@mascteen违停处理。数据统计: 长度中等偏长；@高频；板块如职场&#x2F;程序员&#x2F;问答。 评分: 8&#x2F;10 分 5. 兴趣广度评估 🎮 (1-10分) 量化指标: 涉及的主题类别数: 15个 话题分散度: 高 跨领域讨论占比: 45% 分析要点: 主要兴趣点列表: 技术（AI&#x2F;编程）、职场（薪资&#x2F;外包）、生活（消费&#x2F;拆迁）、健身（#45减脂计划）、汽车（#60买车理由）、Apple产品（#123 Watch使用）、加密货币（#23冻卡）。 兴趣深度（入门&#x2F;进阶&#x2F;专家）: 技术专家、健身进阶、生活入门。 是否有特别突出的兴趣: 技术&#x2F;AI最突出。 兴趣是否与职业相关: 大部分是（程序员相关）。 证据支撑: 回复#45健身瓶颈；#60买车讨论；#123 Watch接电话。数据统计: 类别如职场&#x2F;健身&#x2F;汽车&#x2F;加密；跨领域如技术转生活。 评分: 8&#x2F;10 分 6. 情绪稳定性 🧩 (1-10分) 量化指标: 负面情绪词汇出现次数: 18次（如“难受”“焦虑”“坑”） 正面情绪词汇出现次数: 45次（如“好”“棒”“推荐”） 中性客观回复占比: 70% 分析要点: 主要情绪倾向: 平和理性。 压力&#x2F;焦虑表现: 少，偶尔职场吐槽（如#70加班）。 对挫折的态度: 积极，提供建议（如#178解决iCloud）。 生活满意度: 高，无强烈负面。 证据支撑: 回复#55血压高焦虑；但多数如#36理性分析程序员生涯。数据统计: 负面少于正面；中性高。 评分: 8&#x2F;10 分 7. 生活品质指数 🌟 (1-10分) 量化指标: 休闲娱乐相关回复: 35次 旅行&#x2F;美食&#x2F;爱好讨论: 12次 加班&#x2F;压力相关吐槽: 15次 分析要点: 工作生活平衡: 中等，讨论加班但也健身&#x2F;消费。 休闲娱乐方式: 健身（#45）、Podcast（#13）、游戏（#275）。 生活态度（积极&#x2F;佛系&#x2F;焦虑）: 积极理性。 是否有生活追求: 是，追求品质（如#126智能锁）。 证据支撑: 回复#60买车便利；#13 Podcast推荐；#70加班吐槽。数据统计: 休闲&gt;压力。 评分: 7&#x2F;10 分 8. 影响力指数 🏆 (1-10分) 量化指标: 回复质量（是否有深度见解）: 高 是否解答他人问题: 120次 是否引发讨论: 是 回复被感谢的可能性: 高（从上下文推断） 分析要点: 内容质量: 高，详细解释（如#36程序员分析）。 专业权威性: 高，技术解答被认可。 对他人的帮助程度: 高，解答职场&#x2F;技术。 在社区的认可度: 中高，回复被引用。 证据支撑: 回复#84违停指导；#178 iCloud步骤。数据统计: 解答多；引发如职场讨论。 评分: 8&#x2F;10 分 9. 学习成长力 📈 (1-10分) 量化指标: 提问&#x2F;求教次数: 5次 学习&#x2F;研究相关讨论: 45次 对新技术&#x2F;新产品的关注度: 高 分析要点: 学习态度: 强，积极讨论AI工具。 对新事物的接受度: 高，尝试Cursor等。 是否主动求知: 是，分享学习（如#80 Podcast推荐）。 成长型&#x2F;固定型思维: 成长型。 证据支撑: 回复#51 Copilot学习；#52 AI工具研究。数据统计: 学习讨论高；提问少（更多分享）。 评分: 9&#x2F;10 分 10. 真实度&#x2F;可信度 🎭 (1-10分) 量化指标: 内容前后一致性: 高 引战&#x2F;攻击性言论次数: 2次 疑似营销&#x2F;广告内容: 0次 逻辑矛盾或编故事迹象: 0处 重点识别特征:🚩 发帖员&#x2F;水军特征: 无，回复分散非重复；无推广。🚩 故意引战特征: 低，偶有吐槽但理性。🚩 编故事&#x2F;造假特征: 无，经历一致（如程序员职场）。✅ 真实可信特征: 高，长期理性分享经验。 分析要点: 内容真实性（是否有明显编造迹象）: 高，无矛盾。 动机纯粹性（是否有营销&#x2F;引导目的）: 高，无广告。 立场一致性（观点是否前后矛盾）: 高，技术&#x2F;职场观点稳定。 言行一致性（说的和做的是否匹配）: 高，分享实践。 互动真诚度（回复是否真心还是套路）: 高，真诚解答。 证据支撑: 全回复一致，无营销；如#36职场分析前后逻辑稳。 评分: 10&#x2F;10 分 11. 生活地域判断 🏠 分析要点: 居住城市: 深圳或周边（二三线城市） 证据强度: 强 可能的活动范围: 深圳、杭州、上海周边 是否有地域相关特征: 是，回复#3提及拆迁8位数存款、二三线城市压力；#103深圳通勤；#116杭州工作机会。 📋 综合评价 综合画像卡片 维度 评分 等级 关键特征 技术能力 9&#x2F;10 专家 AI编程专家，深度工具讨论 消费能力 8&#x2F;10 中高 高端电子&#x2F;汽车消费，投资意识强 专业深度 8&#x2F;10 资深 开发&#x2F;职场专业解答 社交活跃度 8&#x2F;10 活跃 详细互动，友善理性 兴趣广度 8&#x2F;10 广泛 技术&#x2F;职场&#x2F;健身&#x2F;汽车 情绪稳定性 8&#x2F;10 稳定 平和理性，少负面 生活品质 7&#x2F;10 良好 平衡工作休闲，注重品质 影响力 8&#x2F;10 活跃 高质量解答，引发讨论 学习成长力 9&#x2F;10 强 高新技术接受，主动分享 真实度&#x2F;可信度 10&#x2F;10 高度真实 一致真实，无造假迹象 综合评分: 85&#x2F;100 分 用户画像总结 (200-300字) 用户“94”推断为30-40岁男性程序员，居住在深圳或周边二三线城市，职业为软件开发从业者，可能有职场管理经验。核心特征包括技术专家级能力，专注于AI编程工具如Cursor和Copilot，经常深度分析职场和技术问题，提供理性建议；消费中高，注重品质，购买Apple产品、汽车，并讨论加密投资；兴趣广泛，涵盖编程、职场、健身（减脂计划）、汽车、生活消费和加密货币，深度在技术领域最突出。性格理性友善，情绪稳定，积极分享经验，成长型思维强，对新技术接受度高。生活状态平衡，工作忙碌但注重休闲如健身和Podcast，满意度较高，无明显焦虑。整体真实可信，回复一致无营销，体现专业性和助人意愿。最具代表性的标签: #AI编程专家 #职场理性者 #技术生活平衡者 #投资爱好者 #健身实践者。（248字） 特殊标签 🏷️ #AI编程专家 #职场导师 #技术生活平衡 #投资理性 #健身爱好者 核心洞察 💡 优势特征（最突出的3个方面）: 技术深度与学习力强，AI工具专家级应用。 社交友善，高质量解答问题。 兴趣广度高，跨职场&#x2F;生活&#x2F;投资。 潜在需求（可能感兴趣的3个方向）: AI高级工具订阅&#x2F;优化。 职场管理&#x2F;投资咨询。 健身&#x2F;汽车高端产品。 性格特质（MBTI参考）: 可能的性格类型: INTJ 主要性格特征: 理性分析、规划长远、助人成长 相关链接 花了一小时写了个 v2 成分分析器，涵盖消费能力、情绪、贡献、影响力、真实度等方面 - V2EX details { padding-left: 20px; border-left: 4px solid transparent; } details[open]{ border-left-color: gray; } details summary { font-weight: bold; cursor: pointer; margin-left: -10px; }","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"AI","slug":"AI","permalink":"https://yogwang.site/tags/AI/"},{"name":"总结","slug":"总结","permalink":"https://yogwang.site/tags/%E6%80%BB%E7%BB%93/"},{"name":"V2EX","slug":"V2EX","permalink":"https://yogwang.site/tags/V2EX/"}]},{"title":"No Coding Today 和 Vibe Coding","slug":"about-vibe-coding","date":"2025-09-30T06:10:55.000Z","updated":"2026-01-05T05:39:58.479Z","comments":true,"path":"2025/about-vibe-coding/","permalink":"https://yogwang.site/2025/about-vibe-coding/","excerpt":"前些天在V站回复 远程工作中，如何避免 Burnout(过劳) 的时候提到了 Anthony Fu。突然发现了 AntFu 居然主持了一档播客节目 —— 尖不想寫扣 No Coding Today。就开始慢慢听这档播客，现在听到了他们在聊 Vibe Coding，突然就解开了我关于 Vibe Coding 的一些疑虑。 在此之前，我对于 Vibe Coding 的看法是： Vibe Coding 只需要关注需求实现，而不是具体代码实现。所以大部分的使用者会是非开发专业的用户。就好像我们使用AI去文生图一样，通过调整 Prompt 使得 AI 的产出实现 or 靠近自己期望目标，并不关注 AI 是怎么生成和具体的内部实现。 所以我一直觉得 Vibe Coding 的模式并不适合专业开发者，但非常适合快速 MVP 或者一次性工具类项目的场景。基本上只需要几句话就能在本地快速实现一个 Demo 去和客户 or 业务方确认需求，然后再在这个基础上去扩写功能。或者说像 JSON 数据处理和分析、图片 &amp; PDF 的合并压缩这样的一次性工具类小项目，而且可以随意调整各种配置，来获得一个符合预期的内容产出。这些原本需要交给一个实习生花费很多时间去处理的。","text":"前些天在V站回复 远程工作中，如何避免 Burnout(过劳) 的时候提到了 Anthony Fu。突然发现了 AntFu 居然主持了一档播客节目 —— 尖不想寫扣 No Coding Today。就开始慢慢听这档播客，现在听到了他们在聊 Vibe Coding，突然就解开了我关于 Vibe Coding 的一些疑虑。 在此之前，我对于 Vibe Coding 的看法是： Vibe Coding 只需要关注需求实现，而不是具体代码实现。所以大部分的使用者会是非开发专业的用户。就好像我们使用AI去文生图一样，通过调整 Prompt 使得 AI 的产出实现 or 靠近自己期望目标，并不关注 AI 是怎么生成和具体的内部实现。 所以我一直觉得 Vibe Coding 的模式并不适合专业开发者，但非常适合快速 MVP 或者一次性工具类项目的场景。基本上只需要几句话就能在本地快速实现一个 Demo 去和客户 or 业务方确认需求，然后再在这个基础上去扩写功能。或者说像 JSON 数据处理和分析、图片 &amp; PDF 的合并压缩这样的一次性工具类小项目，而且可以随意调整各种配置，来获得一个符合预期的内容产出。这些原本需要交给一个实习生花费很多时间去处理的。 从社区的很多 AI 工具推荐和使用反馈来看。大部分人并不会那么“尽心尽责”去 Review 产出的代码，AI 用得越多越深入 Review 的次数就会越少。都是在往无脑 Accept All 上面越走越远。 要不然也不会出现我在 V2ex 的这个帖子中吐槽的 #VibeCodingCleanupSpecialists# 这样的 “给 AI 擦屁股专家” 岗位了，会出现这样的岗位就说明这种现象并不是个例，而是已经造成项目管理上的困扰了。 所以看得出来我是比较反感开发人员追求在生产环境中 纯VibeCoding 这种不太负责的做法的。 Web Worker 最近一期关于 Vibe Coding 的节目中，我也提出关于这部分的困扰。很幸运抽中了 Caption 的新书 🛒 Vibe编程：探索AI时代编程新范式，可是还我没来得及拆开来看。不知道这本书会不会解答我的疑虑。 但听完听尖不想寫扣的两期节目之后(见文末链接中的 S1E5 &amp; S1E6)，我发现其实 Vibe Coding 并不一定需要说要完整的 Vibe 出来整个项目。可以把一些细小的功能拆分开来去让AI来实现，缩小它的影响范围。在自己有清晰概念、边界和规则时，在给AI安排任务它就可以十分完美的胜任了。 和 Mike Cheng 在节目中提到的一样，我最开始用 Vibe 的脚本也是在项目国际化改造时做的。把项目中的国际化JSON文件输出成Excel文件，然后给到专门的翻译人员去翻译。在明确知道自己想要什么，以及需要怎么做得时候，按照 1-2-3-4 得步骤去让AI来实现功能。自己做甩手掌柜，只需要检查它得产出是否符合自己的需求就可以了。不需要自己再去读 NodeJS 和 ExcelJS 的文档开发起来明显就轻松了许多。 如果它生成的结果和你预期的有问题，那么我就需要继续拆分任务明确细节，让它去接近我期望的样子。就和我们去安排工作给实习生的时候是一样的。 所以我之前就是这样使用 Vibe Coding 的，不过自己没有意识到。因为当时 Vibe Coding 这个名词还没有出现，我也还在使用 Github Copilot。 只是最近社区中各种各样的使用反馈所带来的噪声，反而影响到了我的感知和判断。觉得一定要和 Vibe Coding 的定义一样来使用它，不然就不是 Vibe Coding 了。让我产生了 “不写代码的甩手掌柜式” 的这种刻板印象。开始抗拒，甚至讨厌起来。 相关资源 S1E5 - 人人都可以 Vibe coding ! 到底是良藥還是毒藥 ？ - 尖不想寫扣 | Podcast on SoundOn S1E6 - 十年磨一劍，錢端變前端 ft. Alex宅幹嘛 - 尖不想寫扣 | Podcast on SoundOn No.83 “代码降权”时代，程序员会被AI取代吗？ - Web Worker-前端程序员都爱听 | 小宇宙 听众来信 #24 AI 会替代程序员吗？ - 代码之外 Beyond Code | 小宇宙 程序员将来会沦为专门给 AI 擦屁股的人吗？ - V2EX The Rise of “Vibe Code Cleanup Specialist”: A New Job Role | Oleg Boguslavskyi posted on the topic | LinkedIn","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"AI","slug":"AI","permalink":"https://yogwang.site/tags/AI/"},{"name":"VibeCoding","slug":"VibeCoding","permalink":"https://yogwang.site/tags/VibeCoding/"},{"name":"播客","slug":"播客","permalink":"https://yogwang.site/tags/%E6%92%AD%E5%AE%A2/"}]},{"title":"Vue3 中创建 useHooks 遇到的一个 TS 泛型和 Reactive 响应式类型冲突的问题","slug":"vue3-reactivity-system-with-ts-generic-argument-type","date":"2025-08-27T01:05:12.000Z","updated":"2026-01-05T05:39:58.523Z","comments":true,"path":"2025/vue3-reactivity-system-with-ts-generic-argument-type/","permalink":"https://yogwang.site/2025/vue3-reactivity-system-with-ts-generic-argument-type/","excerpt":"TIP不推荐使用 reactive() 的泛型参数，因为处理了深层次 ref 解包的返回值与泛型参数的类型不同。 这段时间总算是得空可以把早些时候快速开发时期挖的坑填一下了，所以准备着手改造一下前人遗留下来的 useTable 这个组合式函数。期望可以在使用 useTable 的时候可以正确推导出来 tableData 和 queryParams 对应的数据类型。 一开始的改造非常顺利，使用泛型可以正确的推导出来我需求的属性类型，直到我遇到了下面这两个TS告警： Cannot assign type &#x27;T[]&#x27; to type &#x27;UnwrapRefSimple&lt;T&gt;[]&#x27;. ts(2322) 不能将类型“T[]”分配给类型“UnwrapRefSimple&lt;T&gt;[]”。ts(2322) Argument of type &#x27;T&#x27; is not assignable to parameter of type &#x27;UnwrapRefSimple&lt;T&gt;&#x27;.ts(2345) 类型“T”的参数不能赋给类型“UnwrapRefSimple&lt;T&gt;”的参数。ts(2345) 当然可以选择简单暴力的使用 as 来解决这个问题，但是我总觉得是不是有一些其他更好的方式来解决。","text":"TIP不推荐使用 reactive() 的泛型参数，因为处理了深层次 ref 解包的返回值与泛型参数的类型不同。 这段时间总算是得空可以把早些时候快速开发时期挖的坑填一下了，所以准备着手改造一下前人遗留下来的 useTable 这个组合式函数。期望可以在使用 useTable 的时候可以正确推导出来 tableData 和 queryParams 对应的数据类型。 一开始的改造非常顺利，使用泛型可以正确的推导出来我需求的属性类型，直到我遇到了下面这两个TS告警： Cannot assign type &#x27;T[]&#x27; to type &#x27;UnwrapRefSimple&lt;T&gt;[]&#x27;. ts(2322) 不能将类型“T[]”分配给类型“UnwrapRefSimple&lt;T&gt;[]”。ts(2322) Argument of type &#x27;T&#x27; is not assignable to parameter of type &#x27;UnwrapRefSimple&lt;T&gt;&#x27;.ts(2345) 类型“T”的参数不能赋给类型“UnwrapRefSimple&lt;T&gt;”的参数。ts(2345) 当然可以选择简单暴力的使用 as 来解决这个问题，但是我总觉得是不是有一些其他更好的方式来解决。 从原因上来看是因为: The issue seems to stem from the fact that it is impossible for TypeScript to assert at compile time if the generic type T in UnwrapRefSimple&lt;T&gt; is going to be a Builtin, Ref, etc. which would affect the conditional type branching and thus generate a different type, so it leaves the UnwrapRefSimple&lt;T&gt; alone. 该问题似乎源于 TypeScript 无法在编译时断言泛型类型 T 在 UnwrapRefSimple&lt;T&gt; 中是否会成为 Builtin、Ref 等类型，这种类型判断会影响条件类型的分支选择进而生成不同的类型，因此编译器会保持 UnwrapRefSimple&lt;T&gt; 的原样不做处理。Parameters of type ‘T’ cannot be assigned to parameters of type ‘UnwrapRefSimple‘. ts(2345) · Issue #13755 · vuejs&#x2F;core 更具体的分析过程可以看 深入vue3为啥不推荐reactive使用泛型最近重新翻刷了官方文档，有那么一句话，不推荐在 reactive 使用泛型 这篇文章。 所以如果不需要保持 ref/reactive 深层响应来触发视图更新，那么可以使用 shallowRef/shallowReactive 来替换。这样就可以避免因为类型解包问题导致的类型不匹配。 以下是一个简易 Demo： export interface TableOptionType&lt;T = unknown, Q = Record&lt;string, unknown&gt;&gt; &#123; queryForm: Q, tableData: T[], &#125; export function useList&lt; T = unknown, Q = Record&lt;string, unknown&gt; &gt;(option: TableOptionType&lt;T, Q&gt;) &#123; // const state = reactive&lt;TableOptionType&lt;T, Q&gt;&gt;(option); const state = shallowReactive&lt;TableOptionType&lt;T, Q&gt;&gt;(option); // 使用 shallowReactive 替换 reactive const setData = (data: T[]) =&gt; &#123; state.tableData = data; &#125;; return &#123; state, setData, &#125;; &#125; 但是我不确定项目中是否有一些特殊的业务做了表格行编辑功能，或者未来是否会增加这个功能。为了向后兼容和避免造成开发上的困扰，我没有选择使用 shallowRef/shallowReactive 来替换。 当前的处理方式因为需要保持内部属性的深层响应式，所以暂时还是利用 as 断言来解决当前类型不匹配的问题。但是仍然会考虑在未来继续调整。 🚧 其他在查阅各种资料的时候，如果是简单的非嵌套对象，比如说下面这个 Demo import &#123; ref &#125; from &#x27;vue&#x27; function test&lt;T&gt;() &#123; const list = ref&lt;T[]&gt;([]); const li: T[] = []; // Argument of type &#x27;T&#x27; is not assignable to parameter of type &#x27;UnwrapRefSimple&lt;T&gt;&#x27;.ts(2345) list.value.push(...li); &#125; 可以调整类型声明的方式来解决 UnwrapRefSimple&lt;T&gt; 的类型问题： import &#123; ref &#125; from &#x27;vue&#x27; import type &#123; Ref &#125; from &#x27;vue&#x27; function test&lt;T&gt;() &#123; const list: Ref&lt;T[]&gt; = ref([]); const li: T[] = []; list.value.push(...li); &#125; 📚 相关资源 为什么 UnwrapRefSimple 会困扰你的 Vue + TS 项目？对 Vue 3 和 TypeScript - 掘金 深入vue3为啥不推荐reactive使用泛型最近重新翻刷了官方文档，有那么一句话，不推荐在 reactive 使用泛型 - 掘金 typescript - vue ref property not able to infer type correctly - Stack Overflow Type UnwrapRefSimple[] is not assignable to type T[] · vuejs · Discussion #9619 Parameters of type ‘T’ cannot be assigned to parameters of type ‘UnwrapRefSimple‘. ts(2345) · Issue #13755 · vuejs&#x2F;core Generic array type infer incorrect · Issue #2136 · vuejs&#x2F;core","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"挖坑","slug":"挖坑","permalink":"https://yogwang.site/tags/%E6%8C%96%E5%9D%91/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://yogwang.site/tags/TypeScript/"},{"name":"VueJS","slug":"VueJS","permalink":"https://yogwang.site/tags/VueJS/"}]},{"title":"复制文件并且保持文件Git变更历史","slug":"git-copy-file-and-preserving-change-history","date":"2025-08-21T03:00:15.000Z","updated":"2026-01-05T05:39:58.486Z","comments":true,"path":"2025/git-copy-file-and-preserving-change-history/","permalink":"https://yogwang.site/2025/git-copy-file-and-preserving-change-history/","excerpt":"几个月前在V站看到一个帖子。OP想要把文件复制出来一份，并且保留文件早前的变更历史。之前我还不理解为什么OP要这样做，直到最近我在改造一个公共 utils 文件时也突然冒出来了这个想法。所以也是想尝试一下看看。","text":"几个月前在V站看到一个帖子。OP想要把文件复制出来一份，并且保留文件早前的变更历史。之前我还不理解为什么OP要这样做，直到最近我在改造一个公共 utils 文件时也突然冒出来了这个想法。所以也是想尝试一下看看。 简单的实现按照帖子中的一些链接 🔗 How to duplicate a file while preserving git line history ，很快就能够实现保持提交历史的需求。简单来说就是先 rename 然后提交 commit，最后使用 git restore 来恢复文件再次提交 commit 就可以让两个文件都保持历史记录了。但是会有两个让人不愉快的 restore 和 rename 提交记录。 所以就想着是不是可以继续改进一下。又去翻了一下原帖子。发现 OP 补充了更简单的处理方式。就是复制文件，然后不做修改直接提交。 就很简单的保持了原本文件的变更历史。也不需要使用 git log --follow 来使本地的 Git 进行文件分析去完善追踪。直接可以在 GitLab 或者 Github 上看到对应的 History。 但是，文件的 Blame 中显示的信息会是拷贝的那一次操作，而不会是 History 中的具体修改操作信息。这是因为新文件是在复制时创建的，所以新文件每一行的“最后修改”信息都是来源自复制操作的提交。 相关资源 问个 Git 基操：怎么样复制一个文件，能保持历史记录？ - V2EX How to duplicate a file while preserving git line history - The Old New Thing","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://yogwang.site/tags/Git/"}]},{"title":"一个关于 Date() 构造函数的误解","slug":"JS-correct-a-mistake-with-date-constructor-value","date":"2025-08-20T06:59:02.000Z","updated":"2026-01-05T05:39:58.473Z","comments":true,"path":"2025/JS-correct-a-mistake-with-date-constructor-value/","permalink":"https://yogwang.site/2025/JS-correct-a-mistake-with-date-constructor-value/","excerpt":"最近在业务中遇到一个使用 Day.js 创建 UTC 时间再转换时区的异常。纠正了长久以来一个自己对于 Date() 构造函数的误解。展示一段示例代码，以便让大家来理解我的误解： // 引入 dayjs 并扩展 utc import dayjs from &#x27;dayjs&#x27; import utc from &#x27;dayjs/plugin/utc&#x27; dayjs.extend(utc) // 示例时间文本 const demoTimeStr = &#x27;2025-08-20 00:00:00&#x27; // 使用 dayjs 创建一个 UTC 模式的 dayjs 实例 const utcDayjsInst = dayjs.utc(demoTimeStr) // 输出格式化后的时间文本 console.log(&#x27;utcDayjsInst1.format:&#x27;, utcDayjsInst.format(&#x27;YYYY-MM-DD HH:mm:ss&#x27;)) // utcDayjsInst1.format: 2025-08-20 00:00:00 // 使用示例时间文本创建一个 Date 实例 const demoDateInst = new Date(demoTimeStr) // 使用 Date 实例创建一个 UTC 模式的 dayjs 实例 const utcDayjsInst2 = dayjs.utc(demoDateInst) // 输出格式化后的时间文本 console.log(&#x27;utcDayjsInst2.format:&#x27;, utcDayjsInst2.format(&#x27;YYYY-MM-DD HH:mm:ss&#x27;)) // utcDayjsInst2.format: 2025-08-19 16:00:00 可以非常直接明显的看到两个UTC模式下输出的时间文本是不一样的。 当然在事后写回顾的时候真的觉得自己特别的蠢 😂，但确实在当时困扰了我一段时间。","text":"最近在业务中遇到一个使用 Day.js 创建 UTC 时间再转换时区的异常。纠正了长久以来一个自己对于 Date() 构造函数的误解。展示一段示例代码，以便让大家来理解我的误解： // 引入 dayjs 并扩展 utc import dayjs from &#x27;dayjs&#x27; import utc from &#x27;dayjs/plugin/utc&#x27; dayjs.extend(utc) // 示例时间文本 const demoTimeStr = &#x27;2025-08-20 00:00:00&#x27; // 使用 dayjs 创建一个 UTC 模式的 dayjs 实例 const utcDayjsInst = dayjs.utc(demoTimeStr) // 输出格式化后的时间文本 console.log(&#x27;utcDayjsInst1.format:&#x27;, utcDayjsInst.format(&#x27;YYYY-MM-DD HH:mm:ss&#x27;)) // utcDayjsInst1.format: 2025-08-20 00:00:00 // 使用示例时间文本创建一个 Date 实例 const demoDateInst = new Date(demoTimeStr) // 使用 Date 实例创建一个 UTC 模式的 dayjs 实例 const utcDayjsInst2 = dayjs.utc(demoDateInst) // 输出格式化后的时间文本 console.log(&#x27;utcDayjsInst2.format:&#x27;, utcDayjsInst2.format(&#x27;YYYY-MM-DD HH:mm:ss&#x27;)) // utcDayjsInst2.format: 2025-08-19 16:00:00 可以非常直接明显的看到两个UTC模式下输出的时间文本是不一样的。 当然在事后写回顾的时候真的觉得自己特别的蠢 😂，但确实在当时困扰了我一段时间。 其实原因很简单，在 MDN 文档中就已经说明了： Date创建一个 JavaScript Date 实例，该实例呈现时间中的某个时刻。Date 对象则基于 Unix Time Stamp，即自 1970 年 1 月 1 日（UTC）起经过的毫秒数。 其实也就是说 Date 对象是 UTC 模式 的，那么自然返回值也都是 UTC 模式下经过的毫秒数。 但是我们在浏览器中调试时，工具会帮我们显示为本地化时间（并不是找借口甩锅）。也就是经常看到的 Date Wed Aug 20 2025 17:47:48 GMT+0800 (中国标准时间)所以实践比理论先行的我会有一个错误的认知，即：会获取的系统时间和时区去创建时间对象，而不是按照系统时间和时区创建一个UTC模式的时间对象，只是在调试工具中显示成本地时间。 🚧 发现其它问题在阅读 MDN 文档时，发现了一个需要注意的特殊提醒： 备注： 当用 Date 构造函数（和 Date.parse，它们是等价的）解析日期字符串时，一定要确保输入符合 ISO 8601 格式（YYYY-MM-DDTHH:mm:ss.ssZ），其他格式的解析行为是实现定义的，可能无法在所有浏览器上运行。对 RFC 2822 格式字符串的支持只是惯例。如果要适应许多不同的格式，库可以提供帮助。 仅有日期的字符串（例如 “1970-01-01“）被视为 UTC，而日期时间的字符串（例如 “1970-01-01T12:00“）被视为本地时间。因此，我们也建议你确保这两种类型的输入格式是一致的。 那么还是有一些特殊逻辑在里面的， new Date(&#x27;2025-08-20&#x27;) // Date Wed Aug 20 2025 08:00:00 GMT+0800 (中国标准时间) new Date(&#x27;2025-08-20 00:00:00&#x27;) // Date Wed Aug 20 2025 00:00:00 GMT+0800 (中国标准时间) 可以看到 new Date(&#39;2025-08-20&#39;) 创建的日期对象是 2025-08-20 08:00:00 GMT+0800，而 new Date(&#39;2025-08-20 00:00:00&#39;) 创建的日期对象是 2025-08-20 00:00:00 GMT+0800。这些细微的区别在使用 new Date() 时还是需要注意的。 不过在使用 Day.js 中并不会出现这些细微的特殊逻辑，结果是可预期的一致。 dayjs(&#x27;2025-08-20&#x27;).format(&quot;YYYY/MM/DD HH:mm:ss&quot;) // &quot;2025/08/20 00:00:00&quot; dayjs(&#x27;2025-08-20 00:00:00&#x27;).format(&quot;YYYY/MM/DD HH:mm:ss&quot;) // &quot;2025/08/20 00:00:00&quot; 相关资源 Date | MDN Date() 构造函数 | MDN UTC · Day.js","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"},{"name":"Day.js","slug":"Day-js","permalink":"https://yogwang.site/tags/Day-js/"}]},{"title":"记使用 VSCode 作为 Git 编辑器在 Rebase 时没有打开 GitLens Rebase Editor 的问题","slug":"cursor-vscode-gitlens-rebase-editor","date":"2025-05-13T09:34:34.000Z","updated":"2026-01-05T05:39:58.481Z","comments":true,"path":"2025/cursor-vscode-gitlens-rebase-editor/","permalink":"https://yogwang.site/2025/cursor-vscode-gitlens-rebase-editor/","excerpt":"设置默认Git编辑器 core.editor（ commit message 编辑时） 和 序列编辑器 sequence.editor（比如 rebase 时） git config --global core.editor &quot;code --wait&quot; git config --global sequence.editor &quot;code --wait&quot; 长久以来，我一直都是用的 GitLens 来操作的 Git，特别是在 rebase 的时候，可视化的界面真的比原本的文本编辑好用太多。 最近因为 Github Copilot 高级请求限制的调整，计算了一下高级请求的用量，其实改版后的 Copilot 价格和 Cursor 已经持平。所以准备迁移到 Cursor 开发一段时间（Cursor 的辅助编程体验要好太多了）。 但由于太久没有调整过 VS Code 的配置项了，在同步配置项到 Cursor 之后发现 git rebase 时，没有按照预期打开 GitLens Interactive Rebase Editor 就是上边的动图中的交互编辑器。一直都是在 Cursor 里面以文本编辑的形式打开了 git-rebase-todo 的内容。 所以记录一下如何调整和启用。","text":"设置默认Git编辑器 core.editor（ commit message 编辑时） 和 序列编辑器 sequence.editor（比如 rebase 时） git config --global core.editor &quot;code --wait&quot; git config --global sequence.editor &quot;code --wait&quot; 长久以来，我一直都是用的 GitLens 来操作的 Git，特别是在 rebase 的时候，可视化的界面真的比原本的文本编辑好用太多。 最近因为 Github Copilot 高级请求限制的调整，计算了一下高级请求的用量，其实改版后的 Copilot 价格和 Cursor 已经持平。所以准备迁移到 Cursor 开发一段时间（Cursor 的辅助编程体验要好太多了）。 但由于太久没有调整过 VS Code 的配置项了，在同步配置项到 Cursor 之后发现 git rebase 时，没有按照预期打开 GitLens Interactive Rebase Editor 就是上边的动图中的交互编辑器。一直都是在 Cursor 里面以文本编辑的形式打开了 git-rebase-todo 的内容。 所以记录一下如何调整和启用。 当时单纯只是在设置里面勾选了 Gitlens &gt; Terminal:Override Git Editor 这个配置项。 其实很简单，就是没有设置调整 Git 配置中的 sequence.editor，还是原本的 code，调整为 cursor 就好了 👇git config --global sequence.editor &quot;cursor --wait&quot; 我还以为是没有启动 GitLens:Enable Interactive Rebase Editor 这个配置项反反复复的禁用&#x2F;启用了好多回，也去 Gitlens 仓库 里面翻了好久。 顺便提一嘴，如果不知道怎么开打 Gitlens 设置面板的话，可以在 Ctrl + Shift + P 打开命令面板之后，键入 gitlens open settings 就可以打开了。 相关资源Core Features | GitLensHow do I enable&#x2F;disable the Interactive Rebase Editor? · gitkraken&#x2F;vscode-gitlens · Discussion #1260","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"VSCode","slug":"VSCode","permalink":"https://yogwang.site/tags/VSCode/"},{"name":"Cursor","slug":"Cursor","permalink":"https://yogwang.site/tags/Cursor/"},{"name":"Git","slug":"Git","permalink":"https://yogwang.site/tags/Git/"}]},{"title":"Element UI 中表单使用栅格实现多行多列布局会错位的问题","slug":"eleui-el-form-used-with-el-row-layout-will-be-unaligned","date":"2024-10-16T08:07:03.000Z","updated":"2026-01-05T05:39:58.486Z","comments":true,"path":"2024/eleui-el-form-used-with-el-row-layout-will-be-unaligned/","permalink":"https://yogwang.site/2024/eleui-el-form-used-with-el-row-layout-will-be-unaligned/","excerpt":"业务中经常会遇到多行多列展示的表单需求，所以我们会搭配着栅格组件来实现。利用栅格化布局 span 超过 24 会自动折行的功能。 &lt;el-form ref=&quot;form&quot; :model=&quot;form&quot; label-width=&quot;auto&quot;&gt; &lt;el-row :gutter=&quot;10&quot;&gt; &lt;el-col :span=&quot;12&quot;&gt; &lt;el-form-item label=&quot;字段A&quot;&gt; &lt;el-input v-model=&quot;form.a&quot; placeholder=&quot;请输入&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-col&gt; &lt;el-col :span=&#x27;12&#x27;&gt; &lt;el-form-item label=&quot;字段B&quot;&gt; &lt;el-input v-model=&quot;form.b&quot; placeholder=&quot;请输入&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/el-form&gt; 如果这样组合使用的同学，肯定会遇到过表单项错位的问题。因为 Element UI 是栅格组件默认是使用的 float 布局的，所以如果你的 &lt;el-form-item&gt; 元素高度不一致的话，就会出现下边截图中布局错位的问题。 字段C项并没有正确出现在字段A项的正下方，而是错开一列出现在了字段B的下方。","text":"业务中经常会遇到多行多列展示的表单需求，所以我们会搭配着栅格组件来实现。利用栅格化布局 span 超过 24 会自动折行的功能。 &lt;el-form ref=&quot;form&quot; :model=&quot;form&quot; label-width=&quot;auto&quot;&gt; &lt;el-row :gutter=&quot;10&quot;&gt; &lt;el-col :span=&quot;12&quot;&gt; &lt;el-form-item label=&quot;字段A&quot;&gt; &lt;el-input v-model=&quot;form.a&quot; placeholder=&quot;请输入&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-col&gt; &lt;el-col :span=&#x27;12&#x27;&gt; &lt;el-form-item label=&quot;字段B&quot;&gt; &lt;el-input v-model=&quot;form.b&quot; placeholder=&quot;请输入&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/el-form&gt; 如果这样组合使用的同学，肯定会遇到过表单项错位的问题。因为 Element UI 是栅格组件默认是使用的 float 布局的，所以如果你的 &lt;el-form-item&gt; 元素高度不一致的话，就会出现下边截图中布局错位的问题。 字段C项并没有正确出现在字段A项的正下方，而是错开一列出现在了字段B的下方。 简单实现一下会出现问题的模板结构： &lt;template&gt; &lt;el-form ref=&quot;form&quot; :model=&quot;form&quot; label-width=&quot;auto&quot;&gt; &lt;el-row :gutter=&quot;10&quot;&gt; &lt;el-col :span=&quot;12&quot;&gt; &lt;el-form-item label=&quot;字段A&quot;&gt; &lt;el-input v-model=&quot;form.a&quot; placeholder=&quot;请输入&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-col&gt; &lt;el-col :span=&#x27;12&#x27;&gt; &lt;el-form-item label=&quot;字段B&quot;&gt; &lt;el-radio-group v-model=&quot;form.b&quot;&gt; &lt;el-radio label=&quot;选项1&quot;&gt;&lt;/el-radio&gt; &lt;el-radio label=&quot;选项2&quot;&gt;&lt;/el-radio&gt; &lt;/el-radio-group&gt; &lt;/el-form-item&gt; &lt;/el-col&gt; &lt;el-col :span=&#x27;12&#x27;&gt; &lt;el-form-item label=&quot;字段C&quot;&gt; &lt;el-input v-model=&quot;form.c&quot; placeholder=&quot;请输入&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-col&gt; &lt;el-col :span=&quot;12&quot;&gt; &lt;el-form-item label=&quot;字段D&quot;&gt; &lt;el-input v-model=&quot;form.d&quot; placeholder=&quot;请输入&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;el-form-item&gt; &lt;el-row type=&quot;flex&quot; justify=&quot;end&quot;&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;onSubmit&quot;&gt;提交&lt;/el-button&gt; &lt;el-button&gt;取消&lt;/el-button&gt; &lt;el-row&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/template&gt; 可以看到字段B这一项，我使用了和其他项都不同的 &lt;el-radio&gt; 组件。所以字段B这一项的高度就会是比较“矮”，它比前一列字段A项的高度少了 1px。那么在使用 float 布局左对齐的时候，就会因为前置元素高度问题导致元素错位的情况。 错位原因示意图： 所以是不是只需要我们把 &lt;el-form-item&gt; 的高度统一就可以了？比如说简单覆盖一下原本表单组件的内置样式： .el-form-item__content &#123; line-height:45px; /* 原本是 40px */ position:relative; font-size:14px &#125; 可以是可以，但如果内容物并不是使用的 EleUI 提供的表单组件，而是一些客制化内容还是会有问题。 所以如果我们的表单是固定了每行几列的话，在写模板的时候麻烦一些，每一行都创建一个 &lt;el-row&gt; 来包裹内容物那么就没问题了。现在网络上大部分解决方案也是让你这样操作，就不需要我们去修改表单组件的内置样式了。 &lt;template&gt; &lt;el-form ref=&quot;form&quot; :model=&quot;form&quot; label-width=&quot;auto&quot;&gt; &lt;!-- 第一行 --&gt; &lt;el-row :gutter=&quot;10&quot;&gt; &lt;el-col :span=&quot;12&quot;&gt; &lt;el-form-item label=&quot;字段A&quot;&gt; &lt;el-input v-model=&quot;form.a&quot; placeholder=&quot;请输入&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-col&gt; &lt;el-col :span=&#x27;12&#x27;&gt; &lt;el-form-item label=&quot;字段B&quot;&gt; &lt;el-radio-group v-model=&quot;form.b&quot;&gt; &lt;el-radio label=&quot;选项1&quot;&gt;&lt;/el-radio&gt; &lt;el-radio label=&quot;选项2&quot;&gt;&lt;/el-radio&gt; &lt;/el-radio-group&gt; &lt;/el-form-item&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;!-- 第二行 --&gt; &lt;el-row :gutter=&quot;10&quot;&gt; &lt;el-col :span=&#x27;12&#x27;&gt; &lt;el-form-item label=&quot;字段C&quot;&gt; &lt;el-input v-model=&quot;form.c&quot; placeholder=&quot;请输入&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-col&gt; &lt;el-col :span=&quot;12&quot;&gt; &lt;el-form-item label=&quot;字段D&quot;&gt; &lt;el-input v-model=&quot;form.d&quot; placeholder=&quot;请输入&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/el-form&gt; &lt;/template&gt; 但是我们总是会遇到表单需要动态布局的场合对吧？比如说适配小屏幕设备，和表单项会按照权限判断来决定是否显示的情况。那么应该如何修改呢？ 其实也很简单，通过给 &lt;el-row&gt; 设置 type=&quot;flex&quot;，将其设置为 flex 布局，但是栅格组件的 flex 模式下是不允许内容物折行的，所以我们还需要手动给 &lt;el-row&gt; 添加上 flex-wrap:wrap 的样式允许 flex 元素换行： &lt;template&gt; &lt;el-form ref=&quot;form&quot; :model=&quot;form&quot; label-width=&quot;auto&quot;&gt; &lt;el-row type=&quot;flex&quot; style=&quot;flex-wrap:wrap&quot; :gutter=&quot;10&quot;&gt; &lt;el-col :span=&quot;12&quot;&gt; &lt;el-form-item label=&quot;字段A&quot;&gt; &lt;el-input v-model=&quot;form.a&quot; placeholder=&quot;请输入&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-col&gt; &lt;el-col :span=&#x27;12&#x27;&gt; &lt;el-form-item label=&quot;字段B&quot;&gt; &lt;el-radio-group v-model=&quot;form.b&quot;&gt; &lt;el-radio label=&quot;选项1&quot;&gt;&lt;/el-radio&gt; &lt;el-radio label=&quot;选项2&quot;&gt;&lt;/el-radio&gt; &lt;/el-radio-group&gt; &lt;/el-form-item&gt; &lt;/el-col&gt; &lt;el-col :span=&#x27;12&#x27;&gt; &lt;el-form-item label=&quot;字段C&quot;&gt; &lt;el-input v-model=&quot;form.c&quot; placeholder=&quot;请输入&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-col&gt; &lt;el-col :span=&quot;12&quot;&gt; &lt;el-form-item label=&quot;字段D&quot;&gt; &lt;el-input v-model=&quot;form.d&quot; placeholder=&quot;请输入&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/el-form&gt; &lt;/template&gt; 这样就没有问题了。","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"ElementUI","slug":"ElementUI","permalink":"https://yogwang.site/tags/ElementUI/"}]},{"title":"解决 VSCode 调试面板中隐藏调试配置选择器后没法重新显示的问题","slug":"vscode-debugger-configuration-dropdown-cannot-show-again","date":"2024-10-12T05:31:55.000Z","updated":"2026-01-05T05:39:58.518Z","comments":true,"path":"2024/vscode-debugger-configuration-dropdown-cannot-show-again/","permalink":"https://yogwang.site/2024/vscode-debugger-configuration-dropdown-cannot-show-again/","excerpt":"解决方式在【运行和调试】面板右侧的 齿轮（⚙） 或者 更多（···） 按钮上右键，勾选【开始调试】即可。 昨天在思否遇到一个问题 👉 VSCode启动调试控件被不小心隐藏了，如何恢复显示？开始以为是一个很初级的问题，就是问题主把【活动面板】中的【调式面板】隐藏了，不知道如何恢复显示了。 那么直接在【活动面板】中右键然后在弹出的菜单中勾选【运行和调试】就行了。","text":"解决方式在【运行和调试】面板右侧的 齿轮（⚙） 或者 更多（···） 按钮上右键，勾选【开始调试】即可。 昨天在思否遇到一个问题 👉 VSCode启动调试控件被不小心隐藏了，如何恢复显示？开始以为是一个很初级的问题，就是问题主把【活动面板】中的【调式面板】隐藏了，不知道如何恢复显示了。 那么直接在【活动面板】中右键然后在弹出的菜单中勾选【运行和调试】就行了。 按照这个理解下，会以为OP可能会把【活动面板】也给隐藏了，所以也贴了如何显示【活动面板】的操作。 但其实并不是这个问题，而是OP在【配置下拉菜单】上边右键后点选了【隐藏“开始调试”】选项，隐藏掉了【配置下拉菜单】。等OP隐藏掉了下拉菜单之后，发现不知道怎么切换调试配置，也不知道应该如何恢复显示了…… 确实，我隐藏之后也不知道如何恢复显示下拉菜单了😂。翻遍了所有配置项，都没有找到对应可以直接修改的配置项，所以只能去 VSCode 的仓库中寻找解决办法…… 很快找到了两个相关的 Issues： Launch Program in Debug Panel VSCode Insiders is missing · Issue #167254 · microsoft&#x2F;vscode Debugger dropdown can be hidden and cannot be shown again · Issue #187873 · microsoft&#x2F;vscode 但是！ 第一个 Issue 中的解决方案，看似非常简单直接的解决了问题。可是这个操作需要你右键在齿轮（⚙）或者更多（···）按钮上才行，其他位置右键并不会打开对应的菜单。 😭 所以我第一次尝试打开菜单发现并没有对应的选项，并且第二个 Issue 中也有人说没有找到对应的选项。就以为是错误的回答，就开始顺着第二个 Issue 中提供的操作解决 state.vscdb 方式来尝试了。 ❗ 注意：以下内容可以忽略不进行阅读，后续内容只是对我自己的尝试进行描述，正确的解决方案在上方！ 第二个 Issue 提供了2个解决方式： 一个是操作 VSCode 的状态数据DB文件 state.vscdb； 第二个唤起【命令面板】之后选择【查看：重置所有菜单】重置所有菜单配置。 使用【查看：重置所有菜单】肯定是没问题的，但是我觉得可能会影响到我在VSCode中配置的其他规则，所以即使第一种解决办法会更麻烦我还是愿意尝试的。 其实也很简单，在 globalStorage 目录中找到 state.vscdb 文件，使用DB编辑器操作数据即可。因为只是临时修改，所以选择在 VSCode 中安装一个 SQLite 扩展来操作 .vscdb 文件。 我安装的 SQLite3 Editor - Visual Studio Marketplace 这个扩展，它可以直接编辑 BD 文件。 如果提示 此文件是二进制文件或使用了不受支持的文本编码，所以无法在文本编辑器中显示。 在 VSCode 的【资源管理器】中右键 state.vscdb 文件选择【打开方式…】，再选择使用【SQLite3 Editor】打开。 state.vscdb 文件的位置： Mac 系统中位于 ~/Library/Application Support/Code/User/globalStorage 目录下; Win 系统中位于 %appdata%\\Code\\User\\globalStorage 目录下； 找到 key 为 menu.hiddenCommands 的项目（可以在 key 列中右键菜单中筛选 menu）双击编辑，修改右侧 value 中的值，把 ViewContainerTitle 这一项的 key 和 value 全部删除。比如说我打开之后对应的 value 值是 &#123;&quot;CommandCenter&quot;:[&quot;workbench.action.quickOpenWithModes&quot;],&quot;ViewContainerTitle&quot;:[&quot;workbench.action.debug.start&quot;]&#125;，删除后就是 &#123;&quot;CommandCenter&quot;:[&quot;workbench.action.quickOpenWithModes&quot;]&#125; 然后提交修改（Ctrl + Enter）。然后重新打开 VSCode 调试模式下的配置选择器就会恢复显示了（如果打开了多个 VSCode 需要全部关闭）。 😫 等我这一系列的操作全部操作完，确实也恢复了下拉菜单的显示。但是总觉得应该那么蠢，都那么多年过去了这个问题还是没解决。 就又仔细阅读了一下其他的回复内容，发现是我自己快速阅读的时候配合上下文理解错了： Sorry for the confusion. You can right click on either other button in the menu (the gear or the ...) to get it back or run the command “Reset All Menus”- roblourens on Jul 19, 2023 When I right click on the gear or the ..., I don’t see an item for “Reset All Menus”. I only see Hide (grayed out), Start Debugging, and Open ‘launch.json’. The solution @Hauntec provided worked though.- StarkillerX42 on Jul 21, 2023 跳着读的时候粗心的以为后续回复中的 [ I don’t see an item for “Reset All Menus” ] 是和我一样的情况，其实并不是。回复中提到的选项是和我不一样的，所以我按照 roblourens 的回答，又尝试了右键在齿轮（⚙）和 ··· 按钮上之后整个人都不好了…… 以上 相关阅读 Launch Program in Debug Panel VSCode Insiders is missing · Issue #167254 · microsoft&#x2F;vscode Debugger dropdown can be hidden and cannot be shown again · Issue #187873 · microsoft&#x2F;vscode Debugging in Visual Studio Code | VSCode Docs","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"VSCode","slug":"VSCode","permalink":"https://yogwang.site/tags/VSCode/"},{"name":"Debug","slug":"Debug","permalink":"https://yogwang.site/tags/Debug/"}]},{"title":"前端 Excel 导出的特殊需求","slug":"exceljs-a-excel-export-specialized-requirements","date":"2024-09-02T07:20:32.000Z","updated":"2026-01-05T05:39:58.486Z","comments":true,"path":"2024/exceljs-a-excel-export-specialized-requirements/","permalink":"https://yogwang.site/2024/exceljs-a-excel-export-specialized-requirements/","excerpt":"在内部系统开发时，经常会有业务部门会要求开发Excel导入&#x2F;导出的功能。这种需求非常的常见，如果只是基础的需求开发起来也比较容易。只是有一些特殊的业务下会有对导出的工作表样式会有要求以及会有锁定的需求。 一般来说这些相关的功能都会让后端同学来帮忙。后端同学忙不过来的时候我们也会使用 SheetJS 这个库来处理，社区也有很多基于它的各种增强。但因为社区版的样式处理非常麻烦，也经常会看到有小伙伴在社群里面吐槽自定义样式不好做。所以项目后期就切换到了 ExcelJS，开发体感更加友好且支持的功能更多。 对于 ExcelJS 介绍的部分就不过多赘述了，社区里面有很多相关的文章可以自行检索。 这篇笔记主要是解决日常业务开发中遇到的几个常见需求，比如说： 单元格的下拉选择 单元格的数据校验 单元格和工作表的编辑保护","text":"在内部系统开发时，经常会有业务部门会要求开发Excel导入&#x2F;导出的功能。这种需求非常的常见，如果只是基础的需求开发起来也比较容易。只是有一些特殊的业务下会有对导出的工作表样式会有要求以及会有锁定的需求。 一般来说这些相关的功能都会让后端同学来帮忙。后端同学忙不过来的时候我们也会使用 SheetJS 这个库来处理，社区也有很多基于它的各种增强。但因为社区版的样式处理非常麻烦，也经常会看到有小伙伴在社群里面吐槽自定义样式不好做。所以项目后期就切换到了 ExcelJS，开发体感更加友好且支持的功能更多。 对于 ExcelJS 介绍的部分就不过多赘述了，社区里面有很多相关的文章可以自行检索。 这篇笔记主要是解决日常业务开发中遇到的几个常见需求，比如说： 单元格的下拉选择 单元格的数据校验 单元格和工作表的编辑保护 💥 单元格的数据下拉功能我们最先遇到的特殊需求肯定就是单元格数据的下拉选择功能了。下拉功能需要借助单元格的 数据验证 来实现。 官方文档中的示例也非常的直截了当，很简单的就可以实现下拉功能。 // 指定有效值的列表（One，Two，Three，Four）。 // Excel 将提供一个包含这些值的下拉列表。 worksheet.getCell(&#x27;A1&#x27;).dataValidation = &#123; type: &#x27;list&#x27;, allowBlank: true, formulae: [&#x27;&quot;One,Two,Three,Four&quot;&#x27;] &#125;; // 指定范围内的有效值列表。 // Excel 将提供一个包含这些值的下拉列表。 worksheet.getCell(&#x27;A2&#x27;).dataValidation = &#123; type: &#x27;list&#x27;, allowBlank: true, formulae: [&#x27;$D$5:$F$5&#x27;] &#125;; 这就不需要多说了，属于是看一眼就能学会的功能。我们开发时遇到的问题其实时如何批量设置这个下拉功能。比如说某一列我都想设置为下拉的。 💥 批量设置下拉选择这个确实在 ExcelJS 的文档中并没有全部都提到。只是在样式的部分提到了 工作表的列、整列、整行 和 单元格 的几种设置方式。其他的一些API中，只是简单的写了两个示例。 比如说上面提到的数据验证功能就只有给单元格设置的Demo，并没有提供批量设置的示例。我们自己通过getRow()、getColumn() 给整行&#x2F;整列去设置并不会生效。所以很多人会自然而然的认为只能通过给单元格设置的方式。如果要批量设置就得使用 for/forEach 或者使用提供的 eachCell 方法循环单元格设置。 其实我们使用 addWorksheet 创建的 worksheet 工作表中是有一个 dataValidations 属性的，并提供了 add()、find()、remove() 这三个API，但是在文档中并没有提到。我们批量设置下拉选择（数据校验）功能时可以使用 ws.dataValidations.add(&#39;address&#39;, validation) 这样来批量设置： worksheet.dataValidations.add( &#x27;A2:A100&#x27;, // 就是&#123;列&#125;&#123;行&#125;:&#123;列&#125;&#123;行&#125; 框定作用范围 &#123; type: &#x27;list&#x27;, allowBlank: true, formulae: [&#x27;&quot;One,Two,Three,Four&quot;&#x27;] &#125; ) 💥 单元格的数据校验功能数据校验功能，除了可以给单元格设置实现下拉功能。还以对用户输入的内容做校验，并且在用户输入时和输入错误后提示用户。示例Demo： // 指定单元格必须为非5的整数。 // 向用户显示适当的错误消息（如果他们弄错了） worksheet.getCell(&#x27;A1&#x27;).dataValidation = &#123; type: &#x27;whole&#x27;, operator: &#x27;notEqual&#x27;, formulae: [5], showErrorMessage: true, errorStyle: &#x27;error&#x27;, errorTitle: &#x27;Five&#x27;, error: &#x27;The value must not be Five&#x27; &#125;; // 指定单元格必须为1.5到7之间的十进制数字。 // 添加“工具提示”以帮助指导用户 worksheet.getCell(&#x27;A2&#x27;).dataValidation = &#123; type: &#x27;decimal&#x27;, operator: &#x27;between&#x27;, formulae: [1.5, 7], allowBlank: true, showInputMessage: true, promptTitle: &#x27;Decimal&#x27;, prompt: &#x27;The value must between 1.5 and 7&#x27; &#125;; 按照示例代码设置输入的内容错误有提示，用户在输入的的时候也会有提示。 但是我自己在同时设置 error 和 prompt 相关属性后，只会在输入完成后弹出错误信息，并没有在用户输入时提示辅助信息。这是因为我把 showErrorMessage 和 showInputMessage 搞混了，如果要开启输入提示（ prompt 相关的属性）还需要把 showInputMessage 属性置为 true。 所以同时开启 error 和 prompt 的话就是下面这样： worksheet.getCell(&#x27;A2&#x27;).dataValidation = &#123; type: &#x27;decimal&#x27;, operator: &#x27;between&#x27;, formulae: [1.5, 7], allowBlank: true, // 输入时显示的提示 showInputMessage: true, promptTitle: &#x27;Decimal&#x27;, prompt: &#x27;The value must between 1.5 and 7&#x27;, // 输入后弹出的错误提醒 showErrorMessage: true, errorStyle: &#x27;error&#x27;, errorTitle: &#x27;Decimal&#x27;, error: &#x27;The value must between 1.5 and 7&#x27; &#125;; 这块的批量设置也是一样的，通过上方提到的 ws.dataValidations.add(&#39;address&#39;, validation) API设置即可。 💥 编辑保护功能工作表保护的设置也很简单，直接看文档就行了 👉 🔗 工作表保护但是保护开启之后会使整个 worksheet （工作表）用户都无法编辑了，会弹出提示：您试图更改的单元格或图表位于受保护的工作表中。若要进行更改，请取消工作表保护。您可能需要输入密码 一般我们只是需要做部分的单元格锁定使其不可编辑，或者只锁定单元格数据校验，用户还是可以正常编辑内容这样两个需求。那么就需要我们根据实际情况来组合使用 单元格保护 了。 👉 🔗 单元格保护 比如说我现在的一个需求： 用户可以正常编辑单元格内容，只保护单元的数据校验规则。防止用户在操作Excel时破坏掉单元格的数据校验。比如说用户复制粘贴其他Excel中的数据内容，就会破坏和覆盖掉下拉选项的情况。 我可以先使用 worksheet.protect(&#39;the-password&#39;) 锁定整个工作表，然后使用 worksheet.getCell(&#39;A1&#39;).protection = &#123; locked: false &#125; 给单元格设置解除锁定。这样就可以满足用户编辑时误操作也不会破坏掉我们预设的数据校验了。 但又遇到不知道如何批量设置单元格保护的问题了。尝试过使用 eachCell() 这个API给每一个单元格设置并不生效。因为大多数情况下我们导出的空白 Excel 模板，工作表中除了表头并没有实际数据。所以在使用 eachCell() 循环当前列单元格时只会循环表头这一格单元格。并不能如预想一般循环当前列的所有单元（即使设置了 eachCell(&#123; includeEmpty: true &#125;, fn(cell, rowNum))）。 我们可以在使用 worksheet.getColumn() 获取到整列之后，直接给返回的整列对象设置单元格保护属性。比如说： worksheet.getColumn(&#x27;id&#x27;).protection = &#123; locked: false &#125; await worksheet.protect(&#x27;the-password&#x27;) worksheet.xlsx.writeBuffer().then((buffer) =&gt; ....) 同理的，也可以使用 getRow() 获取到整行之后，给整行设置单元格保护。 暂时我能回想起来会在实际开发中就遇到那么多问题。如果后期又遇到新的问题了再单独补充。预计未来应该会补充一个我自己抽象封装好的导出和导入的utils。只需要和一些UI库的Table组件一样传入表头配置和表格数据就行了。 相关资源exceljs&#x2F;exceljs: Excel Workbook Manager这一定是前端导出Excel界的天花板~","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"ExcelJS","slug":"ExcelJS","permalink":"https://yogwang.site/tags/ExcelJS/"}]},{"title":"记录在 uni-app 中定义环境变量的方法","slug":"uni-app-define-env-variables","date":"2024-08-29T06:40:51.000Z","updated":"2026-01-05T05:39:58.517Z","comments":true,"path":"2024/uni-app-define-env-variables/","permalink":"https://yogwang.site/2024/uni-app-define-env-variables/","excerpt":"注意：文章中使用的 HBuilderX 版本为 4.24。 使用 HBX 创建的 uni-app 项目（非CLI创建），想要定义环境变量一直是一个让人非常困扰的事情。官方的文档 关于环境变量的说明也非常暧昧不清。 通过关键词 环境变量 检索会出现5篇相关文档： #配置环境变量 - vue.config.js | uni-app官网 #判断平台 - 开发环境和生产环境 | uni-app官网 #环境变量 - Vue2升3指南 | uni-app官网 编辑器配置 | uni-app官网 真机运行常见问题@run | uni-app官网 所以我早期定义环境变量就是使用的第一个文档链接中使用 DefinePlugin 来定义环境变量的方式 // vue.config.js module.exports = &#123; chainWebpack: config =&gt; &#123; config .plugin(&#x27;define&#x27;) .tap(args =&gt; &#123; args[0][&#x27;process.env&#x27;].MY_TEST = &#x27;&quot;test&quot;&#x27; // 注意需要多层引号包裹 return args &#125;) &#125; &#125; 注意：注意需要多层引号包裹自定义环境变量的值。 const test = process.env.MY_TEST // test console.table(process.env) // (索引) 值 // NODE_ENV development // VUE_APP_NAME Test-Project // VUE_APP_PLATFORM h5 // BASE_URL / // MY_TEST test 我这边在声明环境变量时，不需要使用 VUE_APP_ 这样的前缀，但是官方的示例中是有的。如果你无法在业务代码中正确获取到，可以尝试添加 VUE_APP_ 前缀（👉 VUE_APP_MY_TEST）","text":"注意：文章中使用的 HBuilderX 版本为 4.24。 使用 HBX 创建的 uni-app 项目（非CLI创建），想要定义环境变量一直是一个让人非常困扰的事情。官方的文档 关于环境变量的说明也非常暧昧不清。 通过关键词 环境变量 检索会出现5篇相关文档： #配置环境变量 - vue.config.js | uni-app官网 #判断平台 - 开发环境和生产环境 | uni-app官网 #环境变量 - Vue2升3指南 | uni-app官网 编辑器配置 | uni-app官网 真机运行常见问题@run | uni-app官网 所以我早期定义环境变量就是使用的第一个文档链接中使用 DefinePlugin 来定义环境变量的方式 // vue.config.js module.exports = &#123; chainWebpack: config =&gt; &#123; config .plugin(&#x27;define&#x27;) .tap(args =&gt; &#123; args[0][&#x27;process.env&#x27;].MY_TEST = &#x27;&quot;test&quot;&#x27; // 注意需要多层引号包裹 return args &#125;) &#125; &#125; 注意：注意需要多层引号包裹自定义环境变量的值。 const test = process.env.MY_TEST // test console.table(process.env) // (索引) 值 // NODE_ENV development // VUE_APP_NAME Test-Project // VUE_APP_PLATFORM h5 // BASE_URL / // MY_TEST test 我这边在声明环境变量时，不需要使用 VUE_APP_ 这样的前缀，但是官方的示例中是有的。如果你无法在业务代码中正确获取到，可以尝试添加 VUE_APP_ 前缀（👉 VUE_APP_MY_TEST） 😣 出现问题在 chainWebpack 链中使用 DefinePlugin 就能定义环境变量和使用了，并且项目正常运行了2年。直到现在有一个 比较大的需求变动 需要新增一个环境变量。 看起来很简单是吧，这不是只需要在原本定义环境变量的地方新增一个环境变量就行了吗？但这篇文章的出现就说明了并没有那么简单😂。 我在业务代码中使用新增环境变量时出现了问题，会抛出 xxx is not defined 的情况。不管我是直接使用 process.env.VUE_NEW_VAR 还是使用 console.log(process.env) 查看所有环境变量都会在控制台抛出异常。但是项目中之前已经声明的环境变量的使用并不会出现异常，只有我新增的环境变量后才会遇到。非常困扰 😭 配置如下： // vue.config.js module.exports = &#123; chainWebpack: config =&gt; &#123; config .plugin(&#x27;define&#x27;) .tap(args =&gt; &#123; args[0][&#x27;process.env&#x27;].BASE_URL = &#x27;&quot;/&quot;&#x27;; args[0][&#x27;process.env&#x27;].BASE_API_PREFIX = &#x27;&quot;/api&quot;&#x27;; args[0][&#x27;process.env&#x27;].BASE_APP_TITLE = &#x27;&quot;TEST PROJECT&quot;&#x27;; args[0][&#x27;process.env&#x27;].DEFAULT_SERVER = &#x27;cn&#x27;; // 👈 return args &#125;) &#125; &#125; 🤡 解决问题其实出现这个问题的原因非常简单，我相信细心的小伙伴已经发现了。就是我在声明新环境变量的时候没有使用多层引号包裹 &#39;&quot;cn&quot;&#39;，直接用的 &#39;cn&#39; 才导致的这个问题。所以稍作修改就可以修复这个异常了： - args[0][&#x27;process.env&#x27;].DEFAULT_SERVER = &#x27;cn&#x27; + args[0][&#x27;process.env&#x27;].DEFAULT_SERVER = &#x27;&quot;cn&quot;&#x27; 但！ 其实我在准备写这篇文章的时刻并没有发现。写到一半的时候才突然发现自己这个好蠢的错误😂 不过其实就算不遇到问题，其实使用 DefinePlugin 来设置环境变量的方式也已经满足不了我现在的业务需求了。需要改用 自定义编译平台配置 的方式来定义不同的环境变量。 🤲 在自定义编译平台配置中定义环境变量因为现在的需求是需要按照不同的服务器所在地区，做默认目标服务器的配置的。分流到国内服务的需要默认请求到国内服务上，分流到欧洲服务的需要默认请求到部署在欧洲的服务上。原本使用 DefinePlugin 来设置环境变量的方式，没办法在 HBX 发行时定义环境变量模式。只能基于 NODE_ENV 的不同来区分 development 和 production 两种编译模式来做一些业务判断。 改造起来也很简单，把原本在 vue.config.js 中定义的环境变量都迁移到 package.json 中就行了。 // package.json &#123; ... // 其他项目配置， &quot;uni-app&quot;: &#123;// 扩展配置 &quot;scripts&quot;: &#123; &quot;server-CN&quot;: &#123; //自定义编译平台配置，可通过cli方式调用 &quot;title&quot;: &quot;国内环境&quot;, // 在HBuilderX中会显示在 运行/发行 菜单中 &quot;env&quot;: &#123;// 环境变量 &quot;UNI_PLATFORM&quot;: &quot;h5&quot;, // 基准平台 // 自定义环境变量，注意：需要由 `UNI_` 前缀 &quot;UNI_BASE_URL&quot;: &quot;/&quot;, &quot;UNI_API_PREFIX&quot;: &quot;/api/cn&quot;, &quot;UNI_APP_TITLE&quot;: &quot;TEST PROJECT&quot;, &#125;, &#125;, &quot;server-EU&quot;: &#123; //自定义编译平台配置，可通过cli方式调用 &quot;title&quot;: &quot;欧洲环境&quot;, // 在HBuilderX中会显示在 运行/发行 菜单中 &quot;env&quot;: &#123;// 环境变量 &quot;UNI_PLATFORM&quot;: &quot;h5&quot;, // 基准平台 // 自定义环境变量，注意：需要由 `UNI_` 前缀 &quot;UNI_BASE_URL&quot;: &quot;/&quot;, &quot;UNI_API_PREFIX&quot;: &quot;/api/eu&quot;, &quot;UNI_APP_TITLE&quot;: &quot;TEST PROJECT&quot;, &#125;, &#125; &#125; &#125; &#125; 注意：自定义环境变量需要有 UNI_ 前缀，这个在官方文档中并没有提到。 声明好之后在 HBX 的菜单中选择 [运行 - 国内环境] 中启动对应的自定义编译配置，就可以在项目业务中获取到对应的环境变量了。 const test = process.env.UNI_API_PREFIX // /api/cn 但是并不会像在 DefinePlugin 中声明的环境变量那样，可以在 process.env 查看到所有定义的自定义环境变量信息。只会输出默认环境变量 👇 console.table(process.env) // (索引) 值 // NODE_ENV development // VUE_APP_NAME Test-Project // VUE_APP_PLATFORM h5 // BASE_URL / 可以看到并没有输出我定义的 UNI_BASE_URL、UNI_API_PREFIX 和 UNI_APP_TITLE 这三个环境变量。 这个部分没有能在文档中找到相关的说明。但是在一个 Vue3+Vite项目使用环境变量的问题 中，DCloud官方维护人员给出了一个解释： 应该直接访问 process.env.* 的具体内容，比如 process.env.NODE_ENV（要么是内置好了，要么是自己 define 了），不支持访问 process.env，因为 vite 里边除了 dev:h5，其他环境是直接替换完整的字符串。可以使用标准 vite 项目做测试 所以猜测使用自定义编译平台配置定义的环境变量，在项目运行和构建时 HBX 也是一样的方式通过 env-key 直接进行文本替换的。 在另外的一个问答中也验证了我的这个想法 👉 根据官方文档，在package.json定义了自定义环境变量，为什么在代码中获取不到呢，正确的获取方式是什么样的呢 - DCloud问答 P.S. 如果依然没有生效，可以尝试同时声明多个不同前缀的环境变量，看看哪一个可以在你使用的环境变量定义的方式中生效。比如说： &quot;UNI_API_PREFIX&quot;: &quot;/api/cn&quot;, &quot;VITE_API_PREFIX&quot;: &quot;/api/cn&quot;, &quot;VUE_APP_API_PREFIX&quot;: &quot;/api/cn&quot;, 并且直接在业务代码中使用 process.env.UNI_API_PREFIX，而不是输出整个 process.env 查看。 相关资源环境变量 | uni-app官网编辑器配置 | uni-app官网开发环境和生产环境 | uni-app官网package.json | uni-app官网#配置环境变量 - vue.config.js | uni-app官网#环境变量 - Vue2升3指南 | uni-app官网 【报Bug】通过CLI创建的vue3项目微信小程序，调用process.env报错 - DCloud问答根据官方文档，在package.json定义了自定义环境变量，为什么在代码中获取不到呢，正确的获取方式是什么样的呢 - DCloud问答","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"uni-app","slug":"uni-app","permalink":"https://yogwang.site/tags/uni-app/"}]},{"title":"单域名多服务器的本地化部署","slug":"L10n-localization-deployment-of-single-domain","date":"2024-08-27T02:00:29.000Z","updated":"2026-01-05T05:39:58.477Z","comments":true,"path":"2024/L10n-localization-deployment-of-single-domain/","permalink":"https://yogwang.site/2024/L10n-localization-deployment-of-single-domain/","excerpt":"工作中长期维护的项目提出了一个需求： 现在项目分为 国内版 和 欧洲版。使用的同一个域名的两个子域名，分别指向部署在国内和欧洲的服务。例如说 www.domain.com 和 eu.domain.com 这样两个应用入口。 虽然我们会在应用上标注清楚是国内版还是欧洲版。但是仍然会有不少的用户会打开错误的应用。所以想要把应用入口统一为一个。项目按照访问用户的IP所在地区自动切换到国内和欧洲的应用中。并且仍然允许用户手动切换服务器，允许跨境使用。 想了很多实现方案最后确定为在DNS上面按照IP归属做分流。通过访问用户的IP把在欧洲的用户定向到欧洲的服务，在国内的分流到国内的服务上。实质上还是一个地区部署一整套的服务。只不过说现在应用入口的统一了，域名也是统一成 www.domain.com 一个了。 然后在对应的服务器上做 Nginx 的接口代理转发，保证可以正常访问其他地区的服务。避免因为访问系统的用户IP是固定的，在DNS上直接就被分流掉了，导致无法访问到另一个地区服务的情况。","text":"工作中长期维护的项目提出了一个需求： 现在项目分为 国内版 和 欧洲版。使用的同一个域名的两个子域名，分别指向部署在国内和欧洲的服务。例如说 www.domain.com 和 eu.domain.com 这样两个应用入口。 虽然我们会在应用上标注清楚是国内版还是欧洲版。但是仍然会有不少的用户会打开错误的应用。所以想要把应用入口统一为一个。项目按照访问用户的IP所在地区自动切换到国内和欧洲的应用中。并且仍然允许用户手动切换服务器，允许跨境使用。 想了很多实现方案最后确定为在DNS上面按照IP归属做分流。通过访问用户的IP把在欧洲的用户定向到欧洲的服务，在国内的分流到国内的服务上。实质上还是一个地区部署一整套的服务。只不过说现在应用入口的统一了，域名也是统一成 www.domain.com 一个了。 然后在对应的服务器上做 Nginx 的接口代理转发，保证可以正常访问其他地区的服务。避免因为访问系统的用户IP是固定的，在DNS上直接就被分流掉了，导致无法访问到另一个地区服务的情况。 🌎 简单的方案概述#1. 在DNS层先按照用户IP归属分流，分别定向到部署在不同地区的服务器。#2. 前端项目默认请求当前地区的服务API。用户手动切换服务器地区，那么通过修改请求的API前缀，请求不同的API地址。#3. 通过 Nginx 中配置的代理转发，把API请求转发到正确的目标服务器的后端服务上。 前端还是使用的被DNS分流的当地服务器上返回的前端项目，并没有随用户切换服务器而改变。所以说实质上还是一个地区部署一整套的前后端服务。只不过对后端API的请求通过 Nginx 转发到对应的目标服务器上了。 💻 前端部分调整首先就是前端部分的调整。新增一个默认目标服务器的环境变量配置项。这个很简单应该不用多说了，在对应的 .env.xxx 文件中声明好就可以了。 因为有一些系统用户会全球异动，需要在境外处理境内的事物。所以不光需要指定默认的目标服务器，还需要在应用中增加手动切换服务器的功能。要不然系统也不需要做调整了，直接在域名解析好就完成需求了。 原本项目就有使用状态管理库（Vuex）。目标服务器的状态维护很简单，就在对应的 Store 模块中增加一个 targetServer 属性和对应的状态操作函数： // store/modules/app.js import Cookies from &#x27;js-cookie&#x27; import &#123; TARGET_SERVER &#125; from &#x27;@CONST_KEY&#x27; const state = &#123; // ... targetServer: Cookies.get(TARGET_SERVER) || process.env.VUE_APP_TARGET_SERVER_DEFAULT &#125; const mutations = &#123; // ... SET_TARGET_SERVER: (state, server) =&gt; &#123; state.targetServer = server Cookies.set(TARGET_SERVER, server) &#125; &#125; const actions = &#123; // ... setTargetServer(&#123; commit &#125;, server) &#123; commit(&#x27;SET_TARGET_SERVER&#x27;, server) &#125; &#125; export default &#123; namespaced: true, state, mutations, actions &#125; 同时修改一下 getters 方便获取状态: // store/getters.js const getters = &#123; // ... targetServer: state =&gt; state.app.targetServer &#125; export default getters 因为还需要在应用内给用户展示当前的选择的目标服务器。我的话就是在系统顶部导航中用户头像点击后的弹出菜单中增加了切换服务器选项。以下是脱敏后的示例代码： // src/layout/components/Navbar.vue &lt;template&gt; &lt;div class=&quot;navbar&quot;&gt; &lt;div class=&quot;left-menu&quot;&gt; &lt;!-- ... --&gt; &lt;div class=&quot;target-server-switch&quot;&gt; &#123;&#123; $t(&#x27;app.target-server-current&#x27;)&#125;&#125;: &lt;el-dropdown trigger=&quot;click&quot; @command=&quot;onChangeTargetServer&quot;&gt; &lt;span class=&quot;el-dropdown-link&quot;&gt; &#123;&#123; currentTargetServer &#125;&#125;&lt;i class=&quot;el-icon-arrow-down el-icon--right&quot;&gt;&lt;/i&gt; &lt;/span&gt; &lt;el-dropdown-menu slot=&quot;dropdown&quot;&gt; &lt;el-dropdown-item v-for=&quot;server in targetServerList&quot; :key=&quot;server.value&quot; :command=&quot;server.value&quot; :disabled=&quot;server.value === targetServer&quot;&gt; &#123;&#123;server.label&#125;&#125; &lt;/el-dropdown-item&gt; &lt;/el-dropdown-menu&gt; &lt;/el-dropdown&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;right-menu&quot;&gt; &lt;!-- ... --&gt; &lt;el-dropdown class=&quot;avatar-container right-menu-item hover-effect&quot; trigger=&quot;click&quot; @command=&quot;onDropdownCommand&quot;&gt; &lt;div class=&quot;avatar-wrapper&quot;&gt; &lt;img :src=&quot;avatar&quot; class=&quot;user-avatar&quot; /&gt;&lt;i class=&quot;el-icon-caret-bottom&quot; /&gt; &lt;/div&gt; &lt;el-dropdown-menu slot=&quot;dropdown&quot;&gt; &lt;!-- .... --&gt; &lt;el-dropdown-item command=&quot;server&quot;&gt; &lt;!-- 切换服务器 --&gt; &lt;el-dropdown class=&quot;block&quot; trigger=&quot;click&quot; @command=&quot;onChangeTargetServer&quot; @click.native.stop=&quot;() =&gt; (&#123;&#125;)&quot;&gt; &lt;div class=&quot;flex justify-between items-center&quot;&gt; &#123;&#123; $t(&#x27;app.target-server-switch&#x27;)&#125;&#125; &lt;i class=&quot;el-icon-arrow-down el-icon--right&quot; /&gt; &lt;/div&gt; &lt;el-dropdown-menu slot=&quot;dropdown&quot;&gt; &lt;el-dropdown-item v-for=&quot;server in targetServerList&quot; :key=&quot;server.value&quot; :command=&quot;server.value&quot; :disabled=&quot;server.value === targetServer&quot;&gt; &#123;&#123; server.label &#125;&#125; &lt;/el-dropdown-item&gt; &lt;/el-dropdown-menu&gt; &lt;/el-dropdown&gt; &lt;/el-dropdown-item&gt; &lt;!-- ... --&gt; &lt;/el-dropdown-menu&gt; &lt;/el-dropdown&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import &#123; mapGetters &#125; from &#x27;vuex&#x27; import &#123; targetServerList, getServerLocale &#125; from &#x27;@dict/app/targetServer&#x27; export default &#123; // ... data() &#123; return &#123; // ... targetServerList &#125; &#125;, computed: &#123; ...mapGetters([&#x27;targetServer&#x27;, &#x27;...&#x27;]), // 当前服务器 currentTargetServer() &#123; const target = getServerLocale(this.targetServer) return target.label &#125; &#125;, methods: &#123; // 切换目标服务器 onChangeTargetServer(serverKey) &#123; this.$loading(&#123; lock: true &#125;); const &#123; value &#125; = getServerLocale(serverKey) this.$store.dispatch(&#x27;app/setTargetServer&#x27;, value) // 切换目标服务器，重新加载页面 window.location.reload() &#125; &#125; &#125; &lt;/script&gt; 因为系统有域账户自动登录功能，我在切换目标服务器之后直接使用了 window.location.reload() 重新载入了项目。在另外一个地区的服务器上当前用户并没有登录，刷新后重新使用缓存中的 token 换取用户信息的请求必定会失败。就会重新尝试使用域账户免登录功能自动登录，对于用户来说是无感的。如果没有提供类似自动登录的功能，那么还需要有一个 CAS 服务，来处理不同服务器之间的登陆状态。 所以我的项目中HTTP请求库的调整也会非常简单，只需要读取一下是否本地 Cookie 中是否已经有存储，如果没有就使用默认值。例如，我使用的 Axios，直接调整在实例化时 baseURL 配置项即可： // utils/request.js import axios from &#x27;axios&#x27; import Cookies from &#x27;js-cookie&#x27; import &#123; TARGET_SERVER &#125; from &#x27;@CONST_KEY&#x27; const baseUrl = process.env.VUE_APP_BASE_URL const targetServer = Cookies.get(TARGET_SERVER) || process.env.VUE_APP_TARGET_SERVER_DEFAULT // 创建axios实例 const service = axios.create(&#123; baseURL: `$&#123;baseUrl&#125;/$&#123;targetServer&#125;`.replace(/\\/+/g, &#x27;/&#x27;), // ... &#125;) 那么前端部分已经调整的差不多了，接下来开始调整服务器端。 📦 服务端的调整服务端的调整并不多，只需要调整 Nginx 的配置做代理转发即可。 http &#123; # ... server &#123; listen 80; server_name example.com; # 前端项目 location / &#123; root /data/project_name; try_files $uri $uri/ /index.html; index index.html index.htm; location ~* \\.html$ &#123; add_header Cache-Control no-store; expires -1; &#125; location ~* \\.(jpg|jpeg|png|gif|ico|css|js)$ &#123; expires 72h; &#125; &#125; # 后端接口转发 - 默认 location /api/ &#123; proxy_pass http://localhost:9101/; # 使用真实的 domain:port 或者 ip:port 替换 proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header REMOTE-HOST $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; client_max_body_size 50m; &#125; # 后端接口转发 - 中国 location /api/cn/ &#123; proxy_pass http://localhost:9101/; # 使用真实的 domain:port 或者 ip:port 替换 proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header REMOTE-HOST $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; client_max_body_size 50m; &#125; # 后端接口转发 - 欧洲 location /api/eu/ &#123; proxy_pass http://example2.com:9101/; # 使用真实的 domain:port 或者 ip:port 替换 proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header REMOTE-HOST $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; client_max_body_size 50m; &#125; &#125; &#125; 配置完成后使用 nginx -t 测试配置文件是否正确。然后 nginx -s reload 重新载入配置文件就可以进行测试了。 💢 UPDATE当我做完了全部调整开始测试之后，发现实际业务中有大量各种没有通过封装好的HTTP请求库发起的请求。比如说一些历史的上转下载功能。得同步调整大量的历史业务代码，工作量会变的巨大无比。所以我想这是否可以有其他更便利的处理方案。 确实，其实可以通过把 TARGET_SERVER 放到请求头中，或者随 Cookies 传递给服务器。 因为会有图片请求之类的操作，所以我建议是放到 Cookies 中，让浏览器处理随着请求一起发送。而不是通过修改请求路径的方式，并且 Nginx 的代理转发也可以简化处理一下： http &#123; # ... server &#123; listen 80; server_name example.com; upstream server_cn &#123; server example1.com:9101; # 使用真实的 domain:port 或者 ip:port 替换 &#125; upstream server_eu &#123; server example2.com:9101; # 使用真实的 domain:port 或者 ip:port 替换 &#125; map $cookie_target_server $backend &#123; # 从 Cookies 中获取 # map $http_target_server $backend &#123; # 从 headers 中获取 &quot;cn&quot; server_cn; &quot;eu&quot; server_eu; default server_cn; &#125; # 前端项目 location / &#123; root /data/project_name; try_files $uri $uri/ /index.html; index index.html index.htm; location ~* \\.html$ &#123; add_header Cache-Control no-store; expires -1; &#125; location ~* \\.(jpg|jpeg|png|gif|ico|css|js)$ &#123; expires 72h; &#125; &#125; # 后端接口转发 location /api/ &#123; proxy_pass http://$backend; # 注意后面不能有 / 结尾，不然会丢失 path 信息 proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header REMOTE-HOST $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; client_max_body_size 50m; &#125; &#125; &#125; 这样处理的话，其实HTTP请求的修改也不需要了，接口还是原本的那个 /api，而不是改造后的 /api/[targetServer]。工作量就减少了非常多了。 💥 额外的一些细节在Nginx中使用 $cookie_ 获取 Cookie 信息时需要注意对应的 Key 键名称。 比如使用 短横线 的 CookieName，得在 map 映射 时单独匹配处理。 而使用 $http_ 获取 header 信息时，Nginx会帮你处理成全小写，并且短横线替换成下划线。 $cookie_namethe name cookie $http_name arbitrary request header field; the last part of a variable name is the field name converted to lower case with dashes replaced by underscores 所以如果有一些特殊的 Cookie 键名，比如说 Target-Server 这样的，你可以这样匹配： map $http_cookie $target_server &#123; &quot;~*Target-Server=([^;]+)&quot; $1; &#125; map $target_server $backend &#123; &quot;cn&quot; server_cn; &quot;eu&quot; server_eu; default server_cn; &#125; 当然也可以合并起来，但其实也差不多 map $http_cookie $backend &#123; &quot;~*Target-Server=cn&quot; server_cn; &quot;~*Target-Server=eu&quot; server_eu; default server_cn; &#125;","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"L10n","slug":"L10n","permalink":"https://yogwang.site/tags/L10n/"},{"name":"Nginx","slug":"Nginx","permalink":"https://yogwang.site/tags/Nginx/"}]},{"title":"ElementUI 的 Dropdown 组件键盘操控异常抛出","slug":"eleui-el-dropdown-keyboard-operation-error","date":"2024-08-26T02:10:58.000Z","updated":"2026-01-05T05:39:58.485Z","comments":true,"path":"2024/eleui-el-dropdown-keyboard-operation-error/","permalink":"https://yogwang.site/2024/eleui-el-dropdown-keyboard-operation-error/","excerpt":"前段时间把项目的脚手架升级到 VueCLI 5 同步也升级了一些依赖项。所以这几天都是在自测，看看是不是有一些很明显的 BUG，以及解决一些依赖升级之后的 WARN。 在测试一个下拉菜单（Dropdown）时，发现了一个问题：使用方向键操控会抛出一个异常：Uncaught TypeError: ele is undefined 查看控制台输出，对应异常抛出的位置是 resetTabindex 函数，在 ele.setAttribute(&#39;tabindex&#39;, &#39;0&#39;) 执行时 ele 是 undefined，所以抛出了这个异常。 那么看函数调用链看 ele 是怎么来的。👉 是 handleItemKeyDown 函数执行传入的 this.menuItems[nextIndex] 进入调试模式之后发现整个 menuItems 数组是空数组，并没有把我在模板中渲染的 el-dropdown-item 都包含进来。","text":"前段时间把项目的脚手架升级到 VueCLI 5 同步也升级了一些依赖项。所以这几天都是在自测，看看是不是有一些很明显的 BUG，以及解决一些依赖升级之后的 WARN。 在测试一个下拉菜单（Dropdown）时，发现了一个问题：使用方向键操控会抛出一个异常：Uncaught TypeError: ele is undefined 查看控制台输出，对应异常抛出的位置是 resetTabindex 函数，在 ele.setAttribute(&#39;tabindex&#39;, &#39;0&#39;) 执行时 ele 是 undefined，所以抛出了这个异常。 那么看函数调用链看 ele 是怎么来的。👉 是 handleItemKeyDown 函数执行传入的 this.menuItems[nextIndex] 进入调试模式之后发现整个 menuItems 数组是空数组，并没有把我在模板中渲染的 el-dropdown-item 都包含进来。 捋了一下 el-dropdown 组件的业务逻辑，发现 el-dropdown-menu 组件会在完成挂载之后（mounted）立即执行 dropdown 组件的 initDomOperation 函数。 #mounted - element&#x2F;packages&#x2F;dropdown&#x2F;src&#x2F;dropdown-menu.vue at v2.15.14 其他的任意时机都不会再次执行 initDomOperation 方法了。所以问题就是在 el-dropdown-menu 组件完成挂载时，我在模板中渲染的 el-dropdown-item 组件都没有被 querySelectorAll 方法查询到。也就是说并没有被正确渲染在DOM树上。 确实，业务中使用 v-for 循环的数据是通过接口返回的。el-dropdown-menu 组件完成挂载时接口数据是不可能及时返回，所以 querySelectorAll 获取不到任何的 el-dropdown-item 元素。 那么解决方案就很简单了： 使用 v-if 包裹 el-dropdown 或者 el-dropdown-menu 组件。 或者在接口返回数据后手动调用 el-dropdown 组件的 initDomOperation 方法。 最后再补充一个 Dropdown 组件使用中遇到的其他问题： 💥 在 el-dropdown 组件中使用 el-input 作为 el-dropdown-item 的内容物时，点击 el-input 元素或者回车都会导致 el-dropdown-menu 收起。 这个需求是为了长下拉菜单中，可以通过键入 keyword 过滤下拉菜单，并且可以使用回车快速选中筛选的第一项。 这个问题很简单把 el-dropdown 组件的 hide-on-click 属性置为 false 即可。 但是这样做会导致一个其他的问题：点击正常的 el-dropdown-item 元素（内容物不是 el-input 的菜单项）时，el-dropdown-menu 也不会收起了。 场景1：如果你不需要在 el-input 元素中回车可以选择第一项菜单这样的需求，那么只需要在 el-input 使用 .stop 修饰符拦截事件冒泡。 注意： 不需要将 el-dropdown 组件的 hide-on-click 属性置为 false &lt;el-dropdown&gt; &lt;span class=&quot;el-dropdown-link&quot;&gt; 下拉菜单&lt;i class=&quot;el-icon-arrow-down el-icon--right&quot;&gt;&lt;/i&gt; &lt;/span&gt; &lt;el-dropdown-menu slot=&quot;dropdown&quot;&gt; &lt;el-dropdown-item&gt; &lt;el-input v-model=&quot;keyword&quot; @click.native.stop=&quot;() =&gt; (&#123;&#125;)&quot; /&gt; &lt;/el-dropdown-item&gt; &lt;el-dropdown-item&gt;黄金糕&lt;/el-dropdown-item&gt; &lt;el-dropdown-item&gt;狮子头&lt;/el-dropdown-item&gt; &lt;/el-dropdown-menu&gt; &lt;/el-dropdown&gt; 场景2：和我的需求一样，期望在 el-input 中回车仍可以完成选择菜单第一项，那么就需要手动控制 el-dropdown 组件的 visible 属性。 完整的示例代码 👇 &lt;template&gt; &lt;el-dropdown ref=&quot;elDropdown&quot; trigger=&quot;click&quot; :hide-on-click=&quot;false&quot; @command=&quot;handleCommand&quot;&gt; &lt;span class=&quot;el-dropdown-link&quot;&gt; 点击展开菜单&lt;i class=&quot;el-icon-arrow-down el-icon--right&quot;&gt;&lt;/i&gt; &lt;/span&gt; &lt;el-dropdown-menu slot=&quot;dropdown&quot;&gt; &lt;el-dropdown-item&gt; &lt;el-input v-model=&quot;keyword&quot; /&gt; &lt;/el-dropdown-item&gt; &lt;el-dropdown-item v-for=&quot;item in displayOptionList&quot; :key=&quot;item&quot; :command=&quot;item&quot;&gt; &#123;&#123; item &#125;&#125; &lt;/el-dropdown-item&gt; &lt;/el-dropdown-menu&gt; &lt;/el-dropdown&gt; &lt;/template&gt; &lt;script&gt; export default &#123; name: &quot;TEST&quot;, data() &#123; return &#123; keyword: &#x27;&#x27;, optionList: [&#x27;黄金糕&#x27;, &#x27;狮子头&#x27;, &#x27;螺蛳粉&#x27;, &#x27;双皮奶&#x27;, &#x27;蚵仔煎&#x27;] &#125;; &#125;, computed: &#123; displayOptionList() &#123; if(this.keyword === &#x27;&#x27;) return this.optionList return this.optionList.filter(str =&gt; str.includes(this.keyword)) &#125; &#125;, methods: &#123; handleCommand(key) &#123; if (key) &#123; this.$refs.elDropdown.visible = false this.$nextTick(() =&gt; &#123; this.keyword = &#x27;&#x27; &#125;) alert(`您选择的是：$&#123;key&#125;`) &#125; else &#123; if (this.keyword !== &#x27;&#x27;) &#123; const firstOption = this.displayOptionList[0] if(firstOption) this.handleCommand(firstOption) &#125; &#125; &#125; &#125; &#125; &lt;/script&gt; 🔗 CodePen在线Demo 记得将 el-dropdown 组件的 hide-on-click 属性置为 false。如果不设置为 false，依靠 @click.native.stop=&quot;() =&gt; (&#123;&#125;)&quot; 来取消 el-input 元素的 click 事件冒泡。那么在 el-input 中回车并不会触发 el-dropdown 组件的 command 事件。并且因为 el-input 没有正确抛出 keydown/keyup 相关的事件，想要单独处理就会非常麻烦。el-dropdown 会注册 keydown 事件监听，并直接拦截掉事件冒泡和默认行为。 #handleItemKeyDown - element&#x2F;packages&#x2F;dropdown&#x2F;src&#x2F;dropdown.vue at v2.15.14 · ElemeFE&#x2F;element 相关资源 #initDomOperation - element&#x2F;packages&#x2F;dropdown&#x2F;src&#x2F;dropdown.vue at v2.15.14 · ElemeFE&#x2F;element #mounted - element&#x2F;packages&#x2F;dropdown&#x2F;src&#x2F;dropdown-menu.vue at v2.15.14 · ElemeFE&#x2F;element #handleItemKeyDown - element&#x2F;packages&#x2F;dropdown&#x2F;src&#x2F;dropdown.vue at v2.15.14 · ElemeFE&#x2F;element","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"ElementUI","slug":"ElementUI","permalink":"https://yogwang.site/tags/ElementUI/"}]},{"title":"在 JS 中引入并使用 SASS 变量","slug":"SASS-use-sass-variables-in-js","date":"2024-08-08T03:36:28.000Z","updated":"2026-01-05T05:39:58.479Z","comments":true,"path":"2024/SASS-use-sass-variables-in-js/","permalink":"https://yogwang.site/2024/SASS-use-sass-variables-in-js/","excerpt":"当前项目使用的后台管理模板的 layout 的部分是有直接引用 sass 文件暴露出来的变量在业务代码中使用的。比如说: 导出 👉 &#x2F;src&#x2F;styles&#x2F;variables.scss at v4.0.0 · PanJiaChen&#x2F;vue-element-admin 使用 👉 &#x2F;src&#x2F;layout&#x2F;components&#x2F;Sidebar&#x2F;index.vue at v4.0.0 · PanJiaChen&#x2F;vue-element-admin 也没有怎么了解过看这个魔法使用的来源文章 中也只说是 webpack 支持了 CSS Modules 的功能，可以直接使用 :export 功能。 只需要在 .scss 中使用 :export &#123; &#125; 把需要暴露的变量暴露出来就可以在 JS 中使用 import 导入了 :export &#123; menuText: $menuText; menuActiveText: $menuActiveText; subMenuActiveText: $subMenuActiveText; menuBg: $menuBg; menuHover: $menuHover; subMenuBg: $subMenuBg; subMenuHover: $subMenuHover; sideBarWidth: $sideBarWidth; &#125;","text":"当前项目使用的后台管理模板的 layout 的部分是有直接引用 sass 文件暴露出来的变量在业务代码中使用的。比如说: 导出 👉 &#x2F;src&#x2F;styles&#x2F;variables.scss at v4.0.0 · PanJiaChen&#x2F;vue-element-admin 使用 👉 &#x2F;src&#x2F;layout&#x2F;components&#x2F;Sidebar&#x2F;index.vue at v4.0.0 · PanJiaChen&#x2F;vue-element-admin 也没有怎么了解过看这个魔法使用的来源文章 中也只说是 webpack 支持了 CSS Modules 的功能，可以直接使用 :export 功能。 只需要在 .scss 中使用 :export &#123; &#125; 把需要暴露的变量暴露出来就可以在 JS 中使用 import 导入了 :export &#123; menuText: $menuText; menuActiveText: $menuActiveText; subMenuActiveText: $subMenuActiveText; menuBg: $menuBg; menuHover: $menuHover; subMenuBg: $subMenuBg; subMenuHover: $subMenuHover; sideBarWidth: $sideBarWidth; &#125; 但是最近我更新了一下这个后台管理模板的脚手架，从 VueCLI 4x 升级到了 5.x，就发现在控制台抛出了异常： export &#x27;default&#x27; (imported as &#x27;variables&#x27;) was not found in &#x27;@/styles/variables.scss&#x27; (module has no exports) 很明显升级到 VueCLI 5.x 之后引发了这个问题，一开始以为是升级了 VueCLI 之后 webpack 也会一并更新到 5.x，以为多半是 sass-load 版本的问题，遂一起升级到了最新版本，但是并没有解决问题。 但是很明显就是脚手架升级导致的问题。但是为何 4x 的时候支持，但是到 5x 就不支持了，所以去 Vue CLI 的文档中检索了一下 CSS Modules 相关的内容，找到了以下两个内容： #CSS Modules - CSS 相关 | Vue CLI #css.modules - 配置参考 | Vue CLI 修改 scss 文件的文件名，以 .module.scss 来结尾，比如说 variables.scss 修改为 variables.module.scss。 如果去掉文件名中的 .module，那么不能用 css.modules 这个属性了。现在需要改用 css.requireModuleExtension 属性，并设置为 false。 // vue.config.js module.exports = &#123; css: &#123; requireModuleExtension: false &#125; &#125; ❗ 但是中文文档有问题 实际上是 VueCLI 4.x 的文档，并没有更新到最新的文档。css.requireModuleExtension 属性在 VueCLI 5.x 版本和 css.modules 一样被废弃了。 #CSS Modules - Working with CSS | Vue CLI #css.modules - Configuration Reference | Vue CLI 也就是说配置 css.requireModuleExtension 其实是没有用的，现在需要配置 css-loader 来启用将所有样式文件视为CSS模块的功能： // vue.config.js module.exports = &#123; css: &#123; loaderOptions: &#123; css: &#123; modules: &#123; auto: () =&gt; true &#125; &#125; &#125; &#125; &#125; 也就是说原本默认脚手架配置的开启的配置项现在没有了，得自己手动去配置内置的 css-loader。 相关文档How to Share Variables Between Javascript and Sass记一次 sass 导出变量在 Webpack 5 不生效的解决过程 - 掘金 Migrate from v4 | Vue CLIMigrate from v3 | Vue CLI css-modules&#x2F;icss: Interoperable CSS — a standard for loadable, linkable CSSPanJiaChen&#x2F;vue-element-admin: :tada: A magical vue admin","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"SCSS","slug":"SCSS","permalink":"https://yogwang.site/tags/SCSS/"},{"name":"Webpack","slug":"Webpack","permalink":"https://yogwang.site/tags/Webpack/"},{"name":"VueCLI","slug":"VueCLI","permalink":"https://yogwang.site/tags/VueCLI/"}]},{"title":"AstroJS 启动！","slug":"astrojs-notes-00-start","date":"2024-07-10T03:30:38.000Z","updated":"2026-01-05T05:39:58.479Z","comments":true,"path":"2024/astrojs-notes-00-start/","permalink":"https://yogwang.site/2024/astrojs-notes-00-start/","excerpt":"最近有一个官网开发的需求，本来是准备利用老的技术栈，快速开发、快速结束。比如说找一个 PHP 或者 JSP 技术栈的成熟 CMS 框架。前端只需要写一个主题模板，然后用插值表达式做一下循环和动态内容的渲染就行了。 可团队内没有 PHP 技术栈。Java 小伙伴也忙的要死，没有时间现学一个 CMS 框架来配合我。但项目上线时间又安排的非常近，没办法一直等。就想着先使用有 SSG 功能的前端全栈框架先把项目搞起来，把需求先做完。后面再看情况是做 SSR 也行。如果不做 SEO 没有很多文章发布的场景，也可以仅靠 SSG 和钩子触发自动部署即可。 正巧在播客里面听到一个新的全栈框架 Astro，满足了我上便提到的 SSG 和 SSR 需求。前期可以通过撰写 markdown 文档作为 content 资源来满足项目前期的文章发布需求。 而且 Astro 提出的 群岛 概念非常让我感兴趣！","text":"最近有一个官网开发的需求，本来是准备利用老的技术栈，快速开发、快速结束。比如说找一个 PHP 或者 JSP 技术栈的成熟 CMS 框架。前端只需要写一个主题模板，然后用插值表达式做一下循环和动态内容的渲染就行了。 可团队内没有 PHP 技术栈。Java 小伙伴也忙的要死，没有时间现学一个 CMS 框架来配合我。但项目上线时间又安排的非常近，没办法一直等。就想着先使用有 SSG 功能的前端全栈框架先把项目搞起来，把需求先做完。后面再看情况是做 SSR 也行。如果不做 SEO 没有很多文章发布的场景，也可以仅靠 SSG 和钩子触发自动部署即可。 正巧在播客里面听到一个新的全栈框架 Astro，满足了我上便提到的 SSG 和 SSR 需求。前期可以通过撰写 markdown 文档作为 content 资源来满足项目前期的文章发布需求。 而且 Astro 提出的 群岛 概念非常让我感兴趣！ 可以在同一个项目中支持使用多个框架（如 Vue、React、Preact、Svelte 和 SolidJS）。 现阶段我还用不上 群岛 这个功能。虽然非常吸引我，但Astro 提供的基础功能就可以完全覆盖我的需求了。其实选择 Astro 也是因为被安利到了 群岛 功能。有了这次的开发经验，后面我也可以把博客迁移到 Astro，这样一些框架的学习和实践就直接可以在博客中应用上了。比如说使用新框架实现某一个小功能组件之类的。 🔨 Install and set upAstro 的安装和初始化非常的方便，就没有什么好说的了。直接 npm create astro@latest 之后按照引导创建项目就可以了。也可以 使用主题或起始模板 找一个符合心理预期的模板一步到位。 我的话，没有套用社区现有的主题模板，而是选择使用的官方的Blog模板。因为是当前的新项目有专门的UI设计，只能靠自己手撸主题和布局，有一个基础内容发布的目录结构即可。 🔧 配置 Astro配置项的部分就是直接看文档 👉 配置参考 | Docs找到一些自己需要的配置项开启就好了。因为我这边的现在需求是 SSG，那么主要就是配置 output 属性为 static，以及配置 trailingSlash 属性为 always（默认生成的URL有 尾斜杠）。 其他的就是按照自己的需求，开启扩展集成功能，比如说我需求的 Tailwind 集成 和 sitemap 集成，都有很完善的说明文档，按照指引完成配置就可以了。 👇我的项目的整体结构示意： │ astro.config.mjs │ package.json │ postcss.config.js │ tailwind.config.js │ tsconfig.json ├─public/ # 静态资源目录 │ │ favicon.webp │ │ logo.webp │ ├─img/ │ │ ... │ └─locales/ │ ... └─src/ # 项目代码目录 │ env.d.ts ├─components/ # 可重用组件目录 │ Pagination.astro │ ... ├─content/ # 内容集合目录 │ │ config.ts │ └─news/ │ └─news-title/ │ index.mdx ├─layouts/ # 布局组件目录 │ FooterBar.astro │ HeaderBar.astro │ Layout.astro │ ... └─pages/ # 页面组件目录 │ index.astro │ robots.txt.ts ├─about/ │ index.astro ├─news/ │ [...slug].astro │ [page].astro └─services/ └─page-title/ index.astro 从目录结构中可以看到特殊单页，比如说关于我们、服务介绍之类，就可以直接在 pages 里面创建对应的页面组件，就和我们现在开发 Vue SFC 组件是一样的。中间也可以使用 JSX 来做一些特殊处理（比如说分页列表页面）。当然你想直接使用 Vue SFC 的方式来开发也是可以的，安装 @astrojs&#x2F;vue 集成即可。 内容集合部分考虑到文章会有图片展示的需求，所以每一篇文章都是以目录形式创建的，这样图片资源在 markdown 内部直接用相对路径引用就行，在同一个文章目录下维护起来会方便很多。 🚗 运行和编译这个没有什么好说的，就是如果项目配置没有问题，按照 npm run dev 和 npm run build 编译就行了。 CLI 命令 | Docs 开发时会有一些基于TS类型检查的提醒，稍微注意一下就好（也可以配置不开启）。 🧰 遇到的问题！❔ 文章内容中的图片内容应该如何放置和使用就如同我在上面提到的这样使用目录管理的文章内容。直接就可以把文章图片放到对应的文章目录下，然后使用相对目录引用就行。Astro 会自动收集处理，我们不需要关注。 ![Alt text](./full/or/relative/path/of/image) 其他部分的图片内容，比如说 代码围栏 中声明的比如说封面图之类的。可以查看 内容集合中的图像 这部分了解具体使用和配置方法。 但是可能会遇到 Lint 不通过情况，比如说我就没办法使用内置的 &lt;Image /&gt; 组件在分页列表中渲染文章的封面图，就会提示异常： // 不能将类型“&#123; class: string; src: string; alt: string; &#125;”分配给类型“IntrinsicAttributes &amp; Props”。 // 不能将类型“&#123; class: string; src: string; alt: string; &#125;”分配给类型“IntrinsicAttributes &amp; &#123; [x: `data-$&#123;string&#125;`]: any; title?: string; children?: unknown; class?: string; &#x27;class:list&#x27;?: string | Record&lt;string, boolean&gt; | Record&lt;any, any&gt; | Iterable&lt;...&gt; | Iterable&lt;...&gt;; ... 203 more ...; inferSize?: false; &#125;”。ts(2322) (alias) const Image: (_props: Props) =&gt; any import Image 因为我在代码围栏中只是声明了一下文章目录下图片资源的相对路径，并不是使用 import 导入的图片，所以没通过TS的类型检查。这个可以在 #src (必须) - 属性 - 图像 | Docs 部分中查看到具体说明。 如果要解决的话得调整很多内容。并且使用 import 导入图片资源，也不方便非技术人员后期维护 markdown 文档。所以我就放弃了使用内置的 &lt;Image /&gt; 组件，直接使用HTML原生的 &lt;img /&gt; 组件了。 💡 但如果你提示不一样，如下方这样的警告。那么是你忘记使用 import &#123; Image &#125; from &#39;astro:assets&#39; 引入 Astro 内置的图片组件了。 // 不能将类型“&#123; src: string; alt: string; &#125;”分配给类型“IntrinsicAttributes &amp; number”。 // 不能将类型“&#123; src: string; alt: string; &#125;”分配给类型“number”。ts(2322) var Image: new (width?: number, height?: number) =&gt; HTMLImageElement 图像 | Docs ❔ 文章列表如何分页导出的 getStaticPaths 函数有一个 paginate 方法，使用 paginate 函数并传入 pageSize 参数，就可以实现分页效果了。 // src/news/[page].astro export const getStaticPaths = (async (&#123;paginate&#125;) =&gt; &#123; const posts = (await getCollection(&#x27;news&#x27;)).sort( (a, b) =&gt; a.data.publishDate.valueOf() - b.data.publishDate.valueOf() ); return paginate(posts, &#123; pageSize: 10 &#125;); &#125;) const &#123; page &#125; = Astro.props; #getStaticPaths() - API 参考 | Docs #paginate() - API 参考 | Docs #getCollection() - API 参考 | Docs ❔ 使用 @astrojs/sitemap 动态生成 robots.txt 没有生效@astrojs/sitemap 是支持动态生成 robots.txt 的，创建一个 robots.txt.ts 的文件就可以在编译时期在构建的产物中生成 robots.txt 文件了，内容物就是你自己书写的内容。👇 比如说文档中的示例，就是按照 astro.config.mjs 中配置的 site 作为基准URL来生成新的URL链接， import type &#123; APIRoute &#125; from &#x27;astro&#x27;; const robotsTxt = ` User-agent: * Allow: / Sitemap: $&#123;new URL(&#x27;sitemap-index.xml&#x27;, import.meta.env.SITE).href&#125; `.trim(); export const GET: APIRoute = () =&gt; &#123; return new Response(robotsTxt, &#123; headers: &#123; &#x27;Content-Type&#x27;: &#x27;text/plain; charset=utf-8&#x27;, &#125;, &#125;); &#125;; 如果没有在构建的时候生成，那么可能你的 robots.txt.ts 文件有问题。比如说我就很粗心的把 robots.txt.ts 文件放到了 /src 目录下，而不是 /src/pages/ 目录下。 ❔ SSG的内容如何国际化Astro 的国际化，官方是有内置的指引的 👉 添加 i18n 功能 | Docs。会按照目录结构生成多语言的编译后产物。 所以我们需要调整项目的目录结构，比如说 content 的目录，就需要调整为👇 src/ └─content/ └─news/ ├─en/ │ post-1.md │ post-2.md └─news/ post-1.md post-2.md 然后 pages 目录也需要同步调整增加一层 [lang] 目录。比如详情页： src/pages/news/[...slug].astro 👉 src/pages/[lang]/news/[...slug].astro 不过还有一些细节部分，我还没有实际运用到。比如说多语言的图片资源，语言改变之后图片也需要同步调整为对应本地化的图片内容。这些需要实际项目运用到的时候再补充完整了。项目是准备上多语言，但是还没有安排开发计划。 添加 i18n 功能 | Docs 国际化（i18n）路由 | Docs","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"AstroJS","slug":"AstroJS","permalink":"https://yogwang.site/tags/AstroJS/"}]},{"title":"Vue3 中关于 defineProps 的一些 “糖”","slug":"vue-setup-props-sugar","date":"2024-07-03T02:15:03.000Z","updated":"2026-01-05T05:39:58.522Z","comments":true,"path":"2024/vue-setup-props-sugar/","permalink":"https://yogwang.site/2024/vue-setup-props-sugar/","excerpt":"const &#123; foo, bar &#125; = defineProps([&#x27;foo&#x27;, &#x27;bar&#x27;]) 在思否刷到一个问题 🔗 Vue3: 响应式 props 解构得到的变量将不是响应式？也不会更新？ 按照问题中引用的文档描述来说确实是不能够解构返回值的。但是问题主提供的两个例子又说明了实际情况下，defineProps() 的返回值是能够被解构的。 VueJS 的 &lt;script setup&gt; 文档 中关于 defineProps() 的部分也没有针对其返回值是否能够解构做出说明。我在Vue3项目的开发过程中并没有考虑到过这个问题，一直都是通过 props.xx 的形式来使用的。一下子就命中了我的知识盲区，还是 Vue3 写的少了啊。 不过在问题主引用的文档开头有一个响应性语法糖被 移除 的提示，所以去看了一下提示中链接的 废弃原因。","text":"const &#123; foo, bar &#125; = defineProps([&#x27;foo&#x27;, &#x27;bar&#x27;]) 在思否刷到一个问题 🔗 Vue3: 响应式 props 解构得到的变量将不是响应式？也不会更新？ 按照问题中引用的文档描述来说确实是不能够解构返回值的。但是问题主提供的两个例子又说明了实际情况下，defineProps() 的返回值是能够被解构的。 VueJS 的 &lt;script setup&gt; 文档 中关于 defineProps() 的部分也没有针对其返回值是否能够解构做出说明。我在Vue3项目的开发过程中并没有考虑到过这个问题，一直都是通过 props.xx 的形式来使用的。一下子就命中了我的知识盲区，还是 Vue3 写的少了啊。 不过在问题主引用的文档开头有一个响应性语法糖被 移除 的提示，所以去看了一下提示中链接的 废弃原因。 在此RFC的 Unresolved Questions - defineProps destructure details 部分中提到了 non-reactive 的例子： const props = defineProps([&#x27;foo&#x27;, &#x27;bar&#x27;]) const &#123; foo &#125; = props // non-reactive props.bar // reactive access to `bar` 所以其实问题主的解构方式命中了正确的响应性语法糖书写方式，所以解构出来的变量是响应式的。 😥 但是文档和RFC中不是说已经被 “移除” 了吗，为什么还能继续使用？确实，文档和RFC中都已经明确的说明 响应性语法糖 这个方案被放弃了。但是不是完全放弃了整个提议 响应式 props 解构 部分被保留了下来。这个可以从相关的另外一个RFC中看到 👉 prop sugar · vuejs&#x2F;rfcs · Discussion #394，并且在 v3.2.20 中被合并。也可以在 Announcing Vue 3.3 | The Vue Point 中看到。 且不再是 ref: propsName 这样的写法，而是和文章开头提到的如使用原生解构语法一致的： const &#123; foo, bar = 123, // default value baz: qux = 234, // aliasing + default value ...rest // rest spread also supported &#125; = defineProps&lt;&#123; foo: string, bar?: number, baz?: number &#125;&gt;() watchEffect(() =&gt; &#123; console.log(foo) // will log every time foo changes &#125;) 🔨 defineProps我们在有 Vue2 开发经验的情况下编写 Vue3 的项目时，一般情况下上手就会使用 &lt;script setup&gt; 来开发（美名其曰Vue3怎么能不体验 script:setup 😂），并且经常会跳着阅读文档。 所以可能会遗漏如何在 defineProps 宏中进行额外校验的阅读。并且在文档的 &lt;script setup&gt; 部分中缺少了关于 defineProps 使用的详细说明。只简单说明了TS项目中的如何进行类型声明和搭配 withDefaults 的使用设置默认值 👇 export interface Props &#123; msg?: string labels?: string[] &#125; const props = withDefaults(defineProps&lt;Props&gt;(), &#123; msg: &#x27;hello&#x27;, labels: () =&gt; [&#x27;one&#x27;, &#x27;two&#x27;] &#125;) 那么就会不知道如何对 props 属性设置必填校验 required 和默认值 default。其实这部分的内容在文档的 Props 部分中已经详细说明了 👉 #Prop 校验 - Props | Vue.js 相关资源vue3 - Vue3: 响应式 props 解构得到的变量将不是响应式？也不会更新？ - SegmentFault 思否响应性语法糖 | Vue.js [⚠️ Dropped] Reactivity Transform · vuejs&#x2F;rfcs · Discussion #369prop sugar · vuejs&#x2F;rfcs · Discussion #394core&#x2F;changelogs&#x2F;CHANGELOG-3.2.md at main · vuejs&#x2F;core Vue: What to Expect in 2023 by Evan You - Vue.js Nation 2023Announcing Vue 3.3 | The Vue Point Props | Vue.js","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"VueJS","slug":"VueJS","permalink":"https://yogwang.site/tags/VueJS/"}]},{"title":"CSS中的元素样式还原属性 all:revert","slug":"CSS-shorthand-property-all-and-css-keyword","date":"2024-06-27T05:33:01.000Z","updated":"2026-01-05T05:39:58.461Z","comments":true,"path":"2024/CSS-shorthand-property-all-and-css-keyword/","permalink":"https://yogwang.site/2024/CSS-shorthand-property-all-and-css-keyword/","excerpt":"现在CSS写的是越来越少了，以至于刷到这样一个问题 👉 前端文章页的内容获取自后台编辑器，如何让他不受全局样式影响？。思维惯性下就开始考虑各种样式隔离方案，而完全忽略掉了还有一种使用CSS的样式还原方式（all: revert） 来避免全局样式对于富文本内容的样式污染问题。 相比于各种前端的CSS样式隔离方案的高成本，使用 all: revert 方式来简易实现局部区域的样式还原，仅仅需要配置一条这样的样式规则： &lt;template&gt; &lt;div id=&quot;test&quot;&gt; &lt;div v-html=&quot;html&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;style&gt; #test * &#123; all: revert; &#125; &lt;/style&gt; 但因为CSS样式的权重问题，你看到了我是使用的 ID选择器，而不是 Class选择器。所以如果说全局样式有使用 #app 来匹配的话，就没办法使用 all: revert 的方式来还原浏览器默认样式了。这也是这个方案的短板，不过大部分情况下的样式都是可以被重置的。","text":"现在CSS写的是越来越少了，以至于刷到这样一个问题 👉 前端文章页的内容获取自后台编辑器，如何让他不受全局样式影响？。思维惯性下就开始考虑各种样式隔离方案，而完全忽略掉了还有一种使用CSS的样式还原方式（all: revert） 来避免全局样式对于富文本内容的样式污染问题。 相比于各种前端的CSS样式隔离方案的高成本，使用 all: revert 方式来简易实现局部区域的样式还原，仅仅需要配置一条这样的样式规则： &lt;template&gt; &lt;div id=&quot;test&quot;&gt; &lt;div v-html=&quot;html&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;style&gt; #test * &#123; all: revert; &#125; &lt;/style&gt; 但因为CSS样式的权重问题，你看到了我是使用的 ID选择器，而不是 Class选择器。所以如果说全局样式有使用 #app 来匹配的话，就没办法使用 all: revert 的方式来还原浏览器默认样式了。这也是这个方案的短板，不过大部分情况下的样式都是可以被重置的。 相关文档 all - CSS | MDN revert - CSS | MDN 类型、类和 ID 选择器 - 学习 Web 开发 | MDN 了解CSS revert全局关键字 « 张鑫旭-鑫空间-鑫生活 CSS inherit是继承，那initial和unset呢？ « 张鑫旭-鑫空间-鑫生活 前端文章页的内容获取自后台编辑器，如何让他不受全局样式影响？ - SegmentFault 思否","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://yogwang.site/tags/CSS/"}]},{"title":"CSS 中 overflow 值的冲突和自动转换问题","slug":"CSS-overflow-x-y","date":"2024-06-21T00:49:34.000Z","updated":"2026-01-05T05:39:58.459Z","comments":true,"path":"2024/CSS-overflow-x-y/","permalink":"https://yogwang.site/2024/CSS-overflow-x-y/","excerpt":"如果 overflow-x 或 overflow-y 中的一个值不是 visible 或者 clip 的话，给 overflow 设置的 visible/clip 值会被自动处理成 auto/hidden。 昨天下班之前看了一眼思否问答，发现思否的导航栏出现BUG了。所以想着在官方修复前自己改CSS样式临时凑合一下。但看到 #sf-header 元素上面的 overflow-x:hidden 属性时候，我突然就卡壳了。开始困惑如果我给元素设置了 overflow-x: hidden 之后，垂直方向上的内容溢出时展现方式应该是怎么样的？是应该是如当前看到的出现滚动条还是应该超出显示。","text":"如果 overflow-x 或 overflow-y 中的一个值不是 visible 或者 clip 的话，给 overflow 设置的 visible/clip 值会被自动处理成 auto/hidden。 昨天下班之前看了一眼思否问答，发现思否的导航栏出现BUG了。所以想着在官方修复前自己改CSS样式临时凑合一下。但看到 #sf-header 元素上面的 overflow-x:hidden 属性时候，我突然就卡壳了。开始困惑如果我给元素设置了 overflow-x: hidden 之后，垂直方向上的内容溢出时展现方式应该是怎么样的？是应该是如当前看到的出现滚动条还是应该超出显示。 也不知道是不是因为正巧前几分钟，Meathill 在微信群里面问了一个 scrollbar 样式属性相关的问题。正好 overflow 这个样式属性表现出来的现象也正好和滚动条有关。所以一下子以为是标准有变动？去MDN上面看了一下 overflow 的文档。发现 欸！为啥MDN的示例代码上也有 overflow: hidden visible 这样的示例，难道是可以这样设置的？ 当然也可能是唤起了自己部分的编码回忆，有些时候也会单纯的使用 overflow-x:hidden 来隐藏横向的滚动条。但是不记得这样设置的目的的了，然后就把思路代入了。以为自己之前这样写是为了做导航条的横向超出隐藏，然后垂直方向的超出显示。 其实MDN文档再往下滚动就有一段描述信息： 设置一个轴为 visible（默认值），而设置另一个轴为 不同的值 时，visible 的行为会像 auto 一样。overflow - CSS | MDN 但是我已经开始陷入了自己预设的方向跳脱不出去了，当然就没有找到自己想要的结果。就开始检索 overflow: hidden visible 相关的内容，果然就有对应的内容了： After some serious searching it seems i’ve found the answer to my question:from: http://www.brunildo.org/test/Overflowxy2.html In Gecko, Safari, Opera, ‘visible’ becomes ‘auto’ also when combined with ‘hidden’ (in other words: ‘visible’ becomes ‘auto’ when combined with anything else different from ‘visible’). Gecko 1.8, Safari 3, Opera 9.5 are pretty consistent among them. also the W3C spec says: The computed values of ‘overflow-x’ and ‘overflow-y’ are the same as their specified values, except that some combinations with ‘visible’ are not possible: if one is specified as ‘visible’ and the other is ‘scroll’ or ‘auto’, then ‘visible’ is set to ‘auto’. The computed value of ‘overflow’ is equal to the computed value of ‘overflow-x’ if ‘overflow-y’ is the same; otherwise it is the pair of computed values of ‘overflow-x’ and ‘overflow-y’. Short Version:If you are using visible for either overflow-x or overflow-y and something other than visible for the other, the visible value is interpreted as auto.html - CSS overflow-x: visible; and overflow-y: hidden; causing scrollbar issue - Stack Overflow 可以看到浏览器在实现方向上确实是有一些特殊的处理，但是回答中引用的两个链接都已经失效了，只能自己去检索对应的内容。并且因为之前查看MDN文档的时候发现了示例代码中 overflow: hidden visible 这样的用法，所以我理所当然的认为MDN文档可能有落后，可能并没有提到这些特殊处理的内容。想要直接从 W3C 中去寻找答案。 当然从已经跨越了将近10年的时间，标准文档早就发生了很多的演变。文档中关于 overflow 属性的说明也从 CSS Box Model Module Level 3 部分独立到了 CSS Overflow Module Level 3 部分中。 不过还好，最终还是找到了当时的问答中中关于这部分的文档 👉 CSS basic box model | W3C Working Draft 9 August 2007 总结其实就是说 overflow 的 visible 属性会和其他的值有冲突。不能设置 visible 的同时设置另外一个值为非 visible。可能是和外部容器的高度计算有关？标准中关于这部分的说明并不是特别多，但应该能找到相关讨论的邮件。有想法的可通过文章下方的相关资源链接继续探索。但我不想深究下去了，毕竟只是自己的一个理解错误造成的困扰。 All values are treated the same as for ‘overflow‘, but on this property, they only affect whether or not the element is vertically clipped or has a vertical scrolling mechanism. The computed value is the specified value, except in the following case: combinations of ‘overflow-x‘ and ‘overflow-y‘ where one is ‘visible‘ and the other is ‘scroll‘ or ‘auto‘ are not possible. In that case the computed value of ‘visible‘ will be ‘auto‘. 相关资源 overflow - CSS | MDN CSS Overflow Module Level 3 | W3C Working Draft, 29 March 2023 CSS basic box model | W3C Working Draft 9 August 2007 CSS3 module: The box model | W3C Working Draft 24 October 2002 Popping Out of Hidden Overflow | CSS-Tricks html - CSS overflow-x: visible; and overflow-y: hidden; causing scrollbar issue - Stack Overflow 官网用户信息出现重大 bug - 思否社区建设","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://yogwang.site/tags/CSS/"}]},{"title":"使用 rrweb 录制和回放用户交互操作","slug":"rrweb-record-and-replay-users-interactions","date":"2024-06-20T02:52:08.000Z","updated":"2026-01-05T05:39:58.514Z","comments":true,"path":"2024/rrweb-record-and-replay-users-interactions/","permalink":"https://yogwang.site/2024/rrweb-record-and-replay-users-interactions/","excerpt":"一直以来项目的日志功能只记录了用户的登录和接口请求操作日志，用来辅助我们定位和解决反馈的异常问题。这些日志大多数情况下并不会记录用户是如进行操作的，只记录发起请求时携带的参数信息。大多数情况下这些日志已经足够帮助我们发现和解决问题了。但在一些非常独特的问题反馈中，我们没有办法了解到用户是如何触发这些异常请求的。还需要去主动联系用户询问当时的操作场步骤去复现，或者按照日志中的参数去猜测用户是如何操作的。 最近正在听 Web Worker 这档播客节目，有一期节目邀请到了 Aryu 大佬，就发现了 rrweb 这个项目。有兴趣的话可以从项目的主页中在线尝试录制和回放功能，预设了3个业务场景的录制体验Demo。 可以看到录制效果非常不错。能录制到鼠标轨迹、滚轮操作、各种元素的聚焦、下拉和光标位置等各种各样的操作记录。 但因为是DOM级别的录制，所以浏览器原生提供的功能，并不会被录制到。比如说 &lt;select&gt; 元素提供的下拉操作和 &lt;input type=&quot;file&quot;&gt; 提供的文件选择操作。 从 v1.0.0 开始以插件的形式增加了控制台录制的功能。 而且使用起来非常简单，只需要引入和执行 record 方法就可以启动录制了，然后按照自己的需求去存储即可。 import &#123; record &#125; from &#x27;rrweb&#x27; let events = []; record(&#123; emit(event) &#123; // 将用户操作的 event 存入 events 数组中 events.push(event); &#125;, &#125;);","text":"一直以来项目的日志功能只记录了用户的登录和接口请求操作日志，用来辅助我们定位和解决反馈的异常问题。这些日志大多数情况下并不会记录用户是如进行操作的，只记录发起请求时携带的参数信息。大多数情况下这些日志已经足够帮助我们发现和解决问题了。但在一些非常独特的问题反馈中，我们没有办法了解到用户是如何触发这些异常请求的。还需要去主动联系用户询问当时的操作场步骤去复现，或者按照日志中的参数去猜测用户是如何操作的。 最近正在听 Web Worker 这档播客节目，有一期节目邀请到了 Aryu 大佬，就发现了 rrweb 这个项目。有兴趣的话可以从项目的主页中在线尝试录制和回放功能，预设了3个业务场景的录制体验Demo。 可以看到录制效果非常不错。能录制到鼠标轨迹、滚轮操作、各种元素的聚焦、下拉和光标位置等各种各样的操作记录。 但因为是DOM级别的录制，所以浏览器原生提供的功能，并不会被录制到。比如说 &lt;select&gt; 元素提供的下拉操作和 &lt;input type=&quot;file&quot;&gt; 提供的文件选择操作。 从 v1.0.0 开始以插件的形式增加了控制台录制的功能。 而且使用起来非常简单，只需要引入和执行 record 方法就可以启动录制了，然后按照自己的需求去存储即可。 import &#123; record &#125; from &#x27;rrweb&#x27; let events = []; record(&#123; emit(event) &#123; // 将用户操作的 event 存入 events 数组中 events.push(event); &#125;, &#125;); 💥 不过！我们在实际使用过程中会发现 rrweb 的录制量会大的超出我们的预期很多。比如我现在的项目录制简单快速的完整操作下来记录的的 eventList 可能就会超过 3M ，就有点太大了。所以可以文档中关于 优化存储容量 的一些针对性优化。 其实简单的开启压缩之后就能将录制的 eventList 压缩到原本大概 1/4 的体积了，也非常的方便。 但是我的业务比较复杂会有 dialog 和 popup ，可能会同时会有多个组件的状态变更和渲染，所以 rrweb 录制时可能会出现顺序错位的情况，比如说 loading-mask 没有被关闭或者出现多个同样的 dialog。导致没办法很好的回放录制内容。 所以配合了 blockSelector 属性，配置了一些不需要被录制的元素选择器。 注意：在文章发布的时间节点上使用 npm i rrweb 安装的版本是 rrweb@2.0.0-alpha.4。这个版本中使用 blockSelector 是有BUG的，请确认安装的版本是否为 2.0.0-alpha.5 及以上的版本。 Fix: isBlocked throws on invalid element by dbseel · Pull Request #1032 · rrweb-io&#x2F;rrweb ❗ 还是觉得录制结果太大了如果你想要继续缩小录制结果。比如说我现在的业务场景，其实只需要在业务出现异常时录制前几个操作就好了，所以可以使用 checkoutEveryNth 或者 checkoutEveryNms 来定期重新制作一次全量快照。然后创建一个新的数组去存储新的 eventList。 比如说文档中的示例： // 使用二维数组来存放多个 event 数组 const eventsMatrix = [[]]; rrweb.record(&#123; emit(event, isCheckout) &#123; // isCheckout 是一个标识，告诉你重新制作了快照 if (isCheckout) &#123; eventsMatrix.push([]); &#125; const lastEvents = eventsMatrix[eventsMatrix.length - 1]; lastEvents.push(event); &#125;, checkoutEveryNms: 5 * 60 * 1000, // 每5分钟重新制作快照 &#125;); // 向后端传送最新的两个 event 数组 window.onerror = function () &#123; const len = eventsMatrix.length; const events = eventsMatrix[len - 2].concat(eventsMatrix[len - 1]); const body = JSON.stringify(&#123; events &#125;); fetch(&#x27;http://YOUR_BACKEND_API&#x27;, &#123; method: &#x27;POST&#x27;, headers: &#123; &#x27;Content-Type&#x27;: &#x27;application/json&#x27;, &#125;, body, &#125;); &#125;; 分片的时候需要注意的是不能直接截取我们记录的 eventList 数组，需要等 isCheckout 这个标识返回为 true 时去分片。因为我们录制的 event 时基于全量快照的变更产生的记录。所以如果你手动剪裁 eventList 数组（也就是没有记录全量快照的话），是没有办法正常回放录制的用户操作的。 如果 checkoutEveryNth 和 checkoutEveryNms 不能满足你的需求，你可能会想要在某一个特殊节点上产生一个全量快照，那么简单的实现是可以终止当前的 rrweb 实例的录制，然后重新开启录制。 💼 实际业务场景中的使用因为我只需要在用户进行表单编辑时开始录制，并且只需要记录用户端异常出现的前 30s 的操作即可。所以我会把 rrweb 的录制相关的操作放到 Vuex 之类状态管理库中维护。然后在通用的 onDialog 事件中去调用对应的 action 开启和结束录制。 以下是一个简单的实现思路会有一些边界情况没有覆盖： // /store/modules/app.js import &#123; record, pack &#125; from &#x27;rrweb&#x27; // 因为不需要监听改变，所以直接在外部声明 rrweb 相关变量 // rrweb 录制器 let rrwebRecorder = () =&gt; &#123;&#125; // rrweb 事件集合 let rrwebEventRecords = [] const state = &#123; // ... &#125; const mutations = &#123; // ... &#125; const actions = &#123; // 开启 RRWEB 录制 setRRWebStart() &#123; rrwebEventRecords = [] rrwebRecorder = record(&#123; emit(event, isCheckout) &#123; // 如果重新制作了快照，清空 rrwebEventRecords if (isCheckout) rrwebEventRecords = [] rrwebEventRecords.push(event) &#125;, packFn: pack, // 开启压缩 checkoutEveryNms: 30 * 1000, // 每 30 秒重新制作一次全量快照 blockSelector: &#x27;.navbar, .sidebar&#x27;, // 忽略 .navbar 和 。sidebar 元素的录制 sampling: &#123; mousemove: false, // 不录制鼠标移动事件 mouseInteraction: false, // 不录制鼠标交互事件 scroll: 150, // 每 150ms 最多触发一次滚动交互 media: false, // 关闭媒体录制 input: &#x27;last&#x27; // 连续输入时只录制最终值 &#125; &#125;) &#125;, // 停止 RRWEB 录制 setRRWebStop() &#123; rrwebRecorder() rrwebEventRecords = [] &#125;, // 获取屏幕录制结果 getRRWebRecordList(&#123; dispatch &#125;) &#123; const recordJSON = JSON.stringify(&#123; events: rrwebEventRecords &#125;) dispatch(&#x27;setRRWebStop&#x27;) return Promise.resolve(recordJSON) &#125; &#125; export default &#123; namespaced: true, state, mutations, actions &#125; 通用的弹窗控制函数，比如说 Vue2.x 经常会使用的 Mixins 方式 // /mixins.js export default &#123; // ... methods: &#123; // 打开编辑弹窗 onOpenEditDialog() &#123; // ... this.$store.dispatch(&#x27;app/setRRWebStart&#x27;) &#125;, // 编辑弹窗关闭时触发 handleEditDialogClose() &#123; // ... this.$store.dispatch(&#x27;app/setRRWebStop&#x27;) &#125; &#125; &#125; 封装好的请求拦截器中： import axios from &#x27;axios&#x27; import &#123; Message &#125; from &#x27;element-ui&#x27; import store from &#x27;@/store&#x27; import &#123; uploadClientEventRecord &#125; from &#x27;@/api/system&#x27; const service = axios.create(&#123; baseURL: process.env.VUE_APP_BASE_API, timeout: 30000 &#125;) service.interceptors.response.use( success =&gt; &#123; // ... &#125;, error =&gt; &#123; console.log(&#x27;err&#x27; + error) const &#123; message &#125; = error Message(&#123; message: message, type: &#x27;error&#x27;, duration: 5 * 1000 &#125;) store.dispatch(&#x27;app/getRRWebRecordList&#x27;).then(events =&gt; &#123; uploadClientEventRecord(&#123; ...error, events &#125;) &#125;) return Promise.reject(error) &#125; ) 其他当然如果你不嫌麻烦，还是可以看 rrweb 暴露出来的的一些函数，有一部分是没有在文档中体现的👉 rrweb&#x2F;packages&#x2F;rrweb&#x2F;src&#x2F;index.ts at master · rrweb-io&#x2F;rrweb 比如说: freezePage: Throttling&#x2F;pausing of Mutation Events · Issue #221 · rrweb-io&#x2F;rrweb takeFullSnapshot: rrweb&#x2F;guide.zh_CN.md at master · rrweb-io&#x2F;rrweb 都是一些非常实用的内部函数，避免自己重复造轮子。 相关资源rrweb-io&#x2F;rrweb: record and replay the webNo.47 和 rrweb 作者 aryu 聊从开源到技术商业化、低代码和 AI、职场软技能 - Web Worker | 小宇宙 Fix: isBlocked throws on invalid element by dbseel · Pull Request #1032 · rrweb-io&#x2F;rrwebHow to rebuild snapshot based on recorded events? · Issue #1153 · rrweb-io&#x2F;rrweb 前端技术分享：页面性能优化问题复盘 - 有道技术团队 - SegmentFault 思否","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"社群分享","slug":"社群分享","permalink":"https://yogwang.site/tags/%E7%A4%BE%E7%BE%A4%E5%88%86%E4%BA%AB/"},{"name":"rrweb","slug":"rrweb","permalink":"https://yogwang.site/tags/rrweb/"}]},{"title":"VueUse 中的 useTimeAgo 函数的国际化和浏览器内置国际化API","slug":"JS-i18n-relative-time-format","date":"2024-06-14T05:46:55.000Z","updated":"2026-01-05T05:39:58.473Z","comments":true,"path":"2024/JS-i18n-relative-time-format/","permalink":"https://yogwang.site/2024/JS-i18n-relative-time-format/","excerpt":"看到一个帖子提到了 VueUse 中的一个函数 useTimeAgo，比较好奇这个函数是干什么的就点开了帖子看了一下。其实就是一个相对时间对比的函数，输入一个目标时间（允许时间戳或者格式化日期字符串），返回目标距离现在的文本内容。 举个例子： import &#123; useTimeAgo &#125; from &#x27;@vueuse/core&#x27; useTimeAgo(new Date()) // just now useTimeAgo(new Date(&#x27;2024-06-01&#x27;)) // 2 weeks ago 但是 useTimeAgo 函数返回的文本内容是固定的英文字符串。所以，如果在中文环境下使用就可能会被挑战说需要展示中文的相对时间文本。🔗 vueuse&#x2F;packages&#x2F;core&#x2F;useTimeAgo&#x2F;index.ts at main · vueuse&#x2F;vueuse 看了一下 useTimeAgo 的实现，是支持自己做一份国际化配置，然后传入给 useTimeAgo 方法来使用的。","text":"看到一个帖子提到了 VueUse 中的一个函数 useTimeAgo，比较好奇这个函数是干什么的就点开了帖子看了一下。其实就是一个相对时间对比的函数，输入一个目标时间（允许时间戳或者格式化日期字符串），返回目标距离现在的文本内容。 举个例子： import &#123; useTimeAgo &#125; from &#x27;@vueuse/core&#x27; useTimeAgo(new Date()) // just now useTimeAgo(new Date(&#x27;2024-06-01&#x27;)) // 2 weeks ago 但是 useTimeAgo 函数返回的文本内容是固定的英文字符串。所以，如果在中文环境下使用就可能会被挑战说需要展示中文的相对时间文本。🔗 vueuse&#x2F;packages&#x2F;core&#x2F;useTimeAgo&#x2F;index.ts at main · vueuse&#x2F;vueuse 看了一下 useTimeAgo 的实现，是支持自己做一份国际化配置，然后传入给 useTimeAgo 方法来使用的。 👇 举个中文版本的例子（你也可以使用 vue-i18n 实现多语言的版本）： const options = &#123; messages: &#123; justNow: &#x27;刚刚&#x27;, past: n =&gt; n.match(/\\d/) ? `$&#123;n&#125;前` : n, future: n =&gt; n.match(/\\d/) ? `$&#123;n&#125;后` : n, month: (n, past) =&gt; n === 1 ? past ? &#x27;上个月&#x27; : &#x27;下个月&#x27; : `$&#123;n&#125;个月`, year: (n, past) =&gt; n === 1 ? past ? &#x27;去年&#x27; : &#x27;明年&#x27; : `$&#123;n&#125;年`, day: (n, past) =&gt; n === 1 ? past ? &#x27;昨天&#x27; : &#x27;明天&#x27; : `$&#123;n&#125;天`, week: (n, past) =&gt; n === 1 ? past ? &#x27;上周&#x27; : &#x27;下周&#x27; : `$&#123;n&#125;周`, hour: n =&gt; `$&#123;n&#125;小时`, minute: n =&gt; `$&#123;n&#125;分钟`, second: n =&gt; `$&#123;n&#125;秒`, invalid: &#x27;无效值&#x27;, &#125; &#125; const timeAgo = useTimeAgo(new Date(), options) // 刚刚 好的，在 VueUse 中的使用已经解决了。 并且我在寻找解决发现了一个浏览器内置的 API 👉 Intl.RelativeTimeFormat非常简单易用，使用 new Intl.RelativeTimeFormat() 创建好 Intl.RelativeTimeFormat 实例之后，使用实例上的 format(value, unit) 方法就可以输出转换好的相对时间文本。 value 是时间差值 unit 是时间单位 有效值有： year, quarter, month, week, day, hour, minute, second。 举个例子： const rtf = new Intl.RelativeTimeFormat(&#x27;zh&#x27;); rtf.format(3, &#x27;day&#x27;) // 3天后 rtf.format(0, &#x27;day&#x27;) // 0天后 rtf.format(-1, &#x27;day&#x27;) // 1天前 rtf.format(-1, &#x27;year&#x27;) // 1年前 但是就很回比较“傻”，不会自动转换成 “昨天”、“今天”、“明天”这样的。所以可以配置 numeric: auto 来改变输出的文本内容 👇 const rtf = new Intl.RelativeTimeFormat(&#x27;zh&#x27;, &#123; numeric: &#x27;auto&#x27; &#125;); rtf.format(3, &#x27;day&#x27;) // 3天后 rtf.format(1, &#x27;day&#x27;) // 明天 rtf.format(0, &#x27;day&#x27;) rtf.format(-1, &#x27;day&#x27;) // 昨天 rtf.format(-35, &#x27;day&#x27;) // 35天前 Using the auto optionIf numeric:auto option is passed, it will produce the string yesterday, today, or tomorrow instead of 1 day ago, in 0 days, or in 1 day. This allows to not always have to use numeric values in the output. 不过也会有一些问题，因为必须要传入 unit 参数，所以如果事固定值的话，就会出现 35天前 这样的文本，而不是 一个月前，但也足够使用了。 以上。 相关文档useTimeAgo | VueUsevueuse&#x2F;packages&#x2F;core&#x2F;useTimeAgo&#x2F;index.ts at main · vueuse&#x2F;vueuseIntl.RelativeTimeFormat - JavaScript | MDN How to use useTimeAgo to display in Chinese · Issue #3356 · vueuse&#x2F;vueuseTranslations for useTimeAgo · Issue #1592 · vueuse&#x2F;vueuse 前端大佬们有没有好用的 timeago 库 - V2EX","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"},{"name":"VueUse","slug":"VueUse","permalink":"https://yogwang.site/tags/VueUse/"}]},{"title":"在 pikaz-excel-js 中设置单元格样式","slug":"pikaz-excel-js-cell-style","date":"2024-03-19T07:12:31.000Z","updated":"2026-01-05T05:39:58.512Z","comments":true,"path":"2024/pikaz-excel-js-cell-style/","permalink":"https://yogwang.site/2024/pikaz-excel-js-cell-style/","excerpt":"pikaz-excel-js 是项目中已经使用的 Excel 导入导出库。简单的配置一下表头、表格数据就可以完成表格的导出操作了，使用起来非常简单。文档也非常的简单明了，并且有提供简单的参考示例模板： ver_1.x 的 JS 示例 ver_0.2.x 的 VueJS 示例 但是文档中关于单元格样式（cellStyle）的说明就有点 “太简单” 了 👇 参数 说明 类型 可选值 默认值 cellStyle 单元格样式，每个单元格对象配置具体参数查看下方单元格样式 object – – cell 单元格名称，支持 excel 单元格名称与数字行列格式，如 &#39;A3&#39; 或 &#39;3-1&#39; string – – 其他属性与表格全局样式设置方式一致 如果没有阅读示例代码，直接跳到文档中的这部分查看配置项就会有点不知道如何书写。","text":"pikaz-excel-js 是项目中已经使用的 Excel 导入导出库。简单的配置一下表头、表格数据就可以完成表格的导出操作了，使用起来非常简单。文档也非常的简单明了，并且有提供简单的参考示例模板： ver_1.x 的 JS 示例 ver_0.2.x 的 VueJS 示例 但是文档中关于单元格样式（cellStyle）的说明就有点 “太简单” 了 👇 参数 说明 类型 可选值 默认值 cellStyle 单元格样式，每个单元格对象配置具体参数查看下方单元格样式 object – – cell 单元格名称，支持 excel 单元格名称与数字行列格式，如 &#39;A3&#39; 或 &#39;3-1&#39; string – – 其他属性与表格全局样式设置方式一致 如果没有阅读示例代码，直接跳到文档中的这部分查看配置项就会有点不知道如何书写。 所以其实示例代码中已经有说明了关于单元格样式的配置： excelExport(&#123; // 表格数据 sheet: [ &#123; // 表名 sheetName: &quot;水果的产量&quot;, // 表格标题 title: &quot;水果的产量&quot;, // 表头 tHeader: [&quot;季度&quot;, &quot;月份&quot;, &quot;名称&quot;, &quot;A果园产量（万吨）&quot;, &quot;B果园产量（万吨）&quot;, &quot;总产量合计（万吨）&quot;], // 数据键名 keys: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;], // 合并项 merges: [ &quot;1-3:1-5&quot;, &quot;1-6:1-8&quot;, &quot;1-9:1-11&quot;, &quot;1-12:1-14&quot;, &quot;1-15:3-15&quot;], // 表格数据 table: [ &#123; a: &quot;第一季度&quot;, b: &quot;一月&quot;, c: &quot;番石榴&quot;, d: &quot;2&quot;, e: &quot;3&quot;, f: &quot;5&quot; &#125;, &#123; a: &quot;&quot;, b: &quot;二月&quot;, c: &quot;桑葚&quot;, d: &quot;3&quot;, e: &quot;3&quot;, f: &quot;6&quot; &#125;, &#123; a: &quot;&quot;, b: &quot;三月&quot;, c: &quot;樱桃&quot;, d: &quot;2&quot;, e: &quot;2&quot;, f: &quot;4&quot; &#125;, ], // 表格全局样式 globalStyle: &#123; font: &#123; sz: 16 &#125; &#125;, // 单元格样式 cellStyle: [ &#123; cell: &quot;1-1&quot;, fill: &#123; fgColor: &#123; rgb: &quot;B0C4DE&quot; &#125; &#125; &#125;, &#123; cell: &quot;1-3&quot;, fill: &#123; fgColor: &#123; rgb: &quot;7FFFAA&quot; &#125; &#125; &#125;, &#123; cell: &quot;1-6&quot;, fill: &#123; fgColor: &#123; rgb: &quot;FFA500&quot; &#125; &#125; &#125;, &#123; cell: &quot;1-9&quot;, fill: &#123; fgColor: &#123; rgb: &quot;F4A460&quot; &#125; &#125; &#125;, &#123; cell: &quot;1-12&quot;, fill: &#123; fgColor: &#123; rgb: &quot;00BFFF&quot; &#125; &#125; &#125;, &#123; cell: &quot;1-15&quot;, fill: &#123; fgColor: &#123; rgb: &quot;C0C0C0&quot; &#125; &#125; &#125;, ], &#125; ] &#125;) 所以 cellStyle 属性就是一个对象数组，可配置的样式属性就是和全局样式是一致的。 但是我在项目中配置 cellStyle 的时候，控制台抛出了异常： [Vue warn]: Error in v-on handler: &quot;TypeError: N[t.cell] is undefined&quot; found in ---&gt; &lt;ExcelExport&gt; TypeError: N[t.cell] is undefined exportExcel PikazJsExcel.umd.min.js:19 exportExcel PikazJsExcel.umd.min.js:19 exportExcel PikazJsExcel.umd.min.js:19 exportExcel PikazJsExcel.umd.min.js:19 click PikazJsExcel.umd.min.js:19 VueJS(5) 很明显单元格取值的时候出现错误了，因为我使用的是 v1.x 的支持的 cell 的数字行列名称写法： &#123; cell: &quot;1-1&quot;, fill: &#123; fgColor: &#123; rgb: &quot;B0C4DE&quot; &#125; &#125; &#125;，但是项目中使用的 pikaz-excel-js 的版本是 0.2.x，并不支持 数字行列格式 （如 3-1），仅支持 Excel单元格名称 （如 A3）。 那么就需要去转换成Excel单元格名称了，但是我又不想自己写一个函数，就去看了一下 v1.x 版本内部是怎么处理的。很快就找到了 numToLetter 这个函数 👉 pikaz-excel-js&#x2F;src&#x2F;excelExport&#x2F;index.js at master · pikaz-18&#x2F;pikaz-excel-js /** * @description: 纯数字转换为excel格式行列合并项 * @param &#123;*&#125; num * @return &#123;*&#125; */ const numToLetter = (merge = &quot;1-1:2-1&quot;) =&gt; &#123; const mergeArr = merge.split(&quot;:&quot;).map(item =&gt; &#123; const [row, column] = item.split(&quot;-&quot;).map(s =&gt; Number(s)) const stringArray = []; const numToLetters = (num) =&gt; &#123; const result = num - 1; const first = parseInt(result / 26); const second = result % 26; stringArray.push(String.fromCharCode(64 + parseInt(second + 1))); if (first &gt; 0) &#123; numToLetters(first); &#125; &#125; numToLetters(row); return stringArray.reverse().join(&quot;&quot;) + column; &#125;) return mergeArr.join(&quot;:&quot;) &#125; 如果不想升级版本的话，直接复制过来使用就可以处理成期望的结果了。 numToLetter(&#x27;33-1&#x27;) // =&gt; &quot;AG1&quot;","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"exceljs","slug":"exceljs","permalink":"https://yogwang.site/tags/exceljs/"}]},{"title":"国际化开发插件 i18n-Ally","slug":"i18n-vsc-extension-i18n-ally","date":"2024-03-15T02:19:12.000Z","updated":"2026-01-05T05:39:58.492Z","comments":true,"path":"2024/i18n-vsc-extension-i18n-ally/","permalink":"https://yogwang.site/2024/i18n-vsc-extension-i18n-ally/","excerpt":"i18n Ally 这个插件，很早之前就从各种的 VS Code 插件分享贴中了解到，但是一直都没有好好利用起来。特别是我当前开发的项目是我自己魔改的一个国际化维护方式 i18n Ally 并不能很好的支持。而我的一些个人项目，并不会使用到国际化。所以即使安装了这个插件已经有将近一年了，也没有使用起来。 这几天正巧要新增加一个语言到项目中，所以趁着这次机会就决定把插件使用起来。也可以做一次内部分享，方便一下同事。现在新增了很多国际化的需求，应该可以提供一些便利。","text":"i18n Ally 这个插件，很早之前就从各种的 VS Code 插件分享贴中了解到，但是一直都没有好好利用起来。特别是我当前开发的项目是我自己魔改的一个国际化维护方式 i18n Ally 并不能很好的支持。而我的一些个人项目，并不会使用到国际化。所以即使安装了这个插件已经有将近一年了，也没有使用起来。 这几天正巧要新增加一个语言到项目中，所以趁着这次机会就决定把插件使用起来。也可以做一次内部分享，方便一下同事。现在新增了很多国际化的需求，应该可以提供一些便利。 使用起来其实很方便，在 VS Code 当中安装完成，然后打开项目之后插件就会自动检测，要是当前项目已经有做国际化就可以直接在编辑器中看到效果了。 这个时候可能会遇到一些问题，比如说会提示： ⚠ 没有找到文案文件。项目配置可能存在问题。 这个问题可能是由于两个情况导致的： 国际化目录自动检测失败，需要手动指定一下目录位置。 但是一般来说都会自动识别到的，我们可以在项目下的配置文件（.vscode/settings.json 或者 my-project.code-workspace）中查看到，是否已经自动配置了 i18n-ally.localesPaths 项。所以最大的可能就是 👇 你的本地化语言配置文件是 .js 或者 .ts 后缀的（或者其他）。 这种情况的话，需要在上面提到的配置文件中配置 i18n-ally.enabledParsers 属性，开启对应的格式支持（当然也可以配置在全局）。 💡 From v2.0, formats other than JSON, YAML and JSON5 would be disabled by default.💡 从 v2.0 开始，除 JSON, YAML 和 JSON5 以外的格式将默认禁用。Locale Formats · lokalise&#x2F;i18n-ally Wiki 一般来说问题就解决了，可以直接在编辑器打开任意使用到国际化插值的文件中查看到预览效果。例如标识符 &#123;&#123; $t('common.hello') &#125;&#125; 显示成对应的本地化文本 &#123;&#123; $t(你好) &#125;&#125; 。 🤦‍♂️ 也许会有一些其他的问题有些同学会出现没有错误提示，但是在当前打开的文件中并没有查看到标识符被替换成为对应的语言文本内容。仍然显示的是 &#123;&#123; $t('common.hello') &#125;&#125; 这样的形式，并没有出现文本预览效果。 并且打开 i18n-Ally 面板检查 翻译树 和 翻译进度 也查看不到文案内容，或者只有一部分的文案内容。这个时候需要打开输出面板（Ctrl + Shift + U ），并且在右侧下拉栏中切换到 i18n-ally 来查看具体的异常信息输出。 比如说我当前的开发项目，就是我当时魔改的一个国际化方案，是以数组的方式来维护国际化文本的： // user.js import &#123; transferLocaleConfig &#125; from &#x27;@/i18n/config&#x27; const config = &#123; &#x27;account&#x27;: [&#x27;工号&#x27;, &#x27;No.&#x27;], &#x27;name&#x27;: [&#x27;姓名&#x27;, &#x27;Name&#x27;], &#x27;company&#x27;: [&#x27;公司&#x27;, &#x27;Company&#x27;], &#x27;dept&#x27;: [&#x27;部门&#x27;, &#x27;Department&#x27;], &#x27;tel&#x27;: [&#x27;电话&#x27;, &#x27;Tel&#x27;], &#x27;email&#x27;: [&#x27;邮箱&#x27;, &#x27;E-Mail&#x27;] &#125; export default transferLocaleConfig(config) 因为当时并没有了解到 i18n-ally 这个插件，如果像一开始的方式直接维护 json 文件，就总是会出现一些意外情况： 忘了翻译或者遗漏一些文本； 多个语言的国际化文本 key 键不一致，或者命名空间冲突； 所以我改造成这样的方式维护国际化文件的，这样就不会出现上面的两个问题了。但很明显我在引用的 config.js 文件的时候使用了别名 @，所以 i18n-ally 插件解析文件失败了。 可以从面板中看到这个报错信息： 🗃 Path Matcher Regex: /^(?&lt;locale&gt;[\\w-_]+)\\.(?&lt;ext&gt;m?js)$/ 📂 Loading locales under d:\\my_project\\src\\i18n 📑 Loading (index) index.js [1710479593993.5425] 🐛 Failed to load Error: Command failed: node &quot;c:\\Users\\yogwang\\.vscode\\extensions\\lokalise.i18n-ally-2.12.0\\node_modules\\ts-node\\dist\\bin.js&quot; --dir &quot;d:\\my_project&quot; --transpile-only --compiler-options &quot;&#123;\\&quot;importHelpers\\&quot;:false,\\&quot;allowJs\\&quot;:true,\\&quot;module\\&quot;:\\&quot;commonjs\\&quot;&#125;&quot; &quot;c:\\Users\\yogwang\\.vscode\\extensions\\lokalise.i18n-ally-2.12.0\\assets\\loader.js&quot; &quot;d:\\my_project\\src\\i18n\\index.js&quot; Error: Cannot find module &#x27;@/i18n/config&#x27; Require stack: - d:\\my_project\\src\\i18n\\modules\\user.js - d:\\my_project\\src\\i18n\\en.js 修改改为相对目录，不使用别名引入就可以了。 但是使用 .js 文件的方式来维护可能会缓存的情况，比如说： #1 当我添加了一些新的国际化字段之后，可能 i18n-ally 就不会对这些新增的文本做出更新响应。这个问题 antfu 大佬当时说没有好的解决方式来绕过 👉 Need to restart vs code to update · Issue #97 · lokalise&#x2F;i18n-ally不过最后看到有一个PR解决了这个问题，但是我这边并没有即时更新，仍然需要重新加载VSCode才可以看到更新。 #2 不能使用 i18n-ally 这个插件提供的一些辅助功能，比如说 提取硬编码 和 编辑模式在文档中可以看到对于各种格式的支持情况，对于 js 和 ts 是 read-only。所以我并不建议大家学我这样的方式来处理，antfu 大佬也是建议使用 json 文件，以获得更好的插件支持。👉 can’t make localepaths work · Issue #172 · lokalise&#x2F;i18n-ally Format Read Write Annotations Note JSON ✅ ✅ ✅ YAML ✅ ✅ ✅ Comments will NOT be preserved* JSON5 ✅ ✅ ❌ Comments will NOT be preserved* INI ✅ ✅ ❌ Comments will NOT be preserved* properties ✅ ✅ ❌ Comments will NOT be preserved* POT ✅ ✅ ❌ JavaScript ✅ ❌ ❌ Read-only TypeScript ✅ ❌ ❌ Read-only PHP ✅ ❌ ❌ Read-only 其实可以借鉴插件仓库中的各种样例找出一个适合自己的实践方式 👉 Examples - lokalise&#x2F;i18n-ally 另外的一些其他的常见问题可以查看文档中的 FAQ 👉 FAQ · lokalise&#x2F;i18n-ally Wiki 🏃‍♂️ 使用 &amp; 提速前面我展示了 i18n-ally 对于翻译预览的辅助功能，对于文案的提取和编辑只是提了一嘴并没说如何使用。插件对于文案的提取分为 手动提取 和 自动提取（单文件 和 目录提取都可以）。但是前提都是项目的国际化文件被正确识别到了，并且是支持写入的格式。 使用手动提取的方式就是插件文档中提到的提取方式。文案被识别到之后悬停并点击 快速修复 选择 提取文案到i18n，也可以在左侧活动区块找到翻译字段面板在 hard-coded string 中选择对应的文案提取。 这个时候如果文本有对应的翻译了，会直接在下方显示已存在的翻译文案，直接按序点选就完成提取和替换了。 如果没有被翻译过，那么就需要手动输入键名来创建词条 在输入键名的时候会在下方提示当前属性下的其他翻译文本，来辅助我们创建词条。 操作完成之后插件会自动在源语言配置文件中创建对应的词条了。如果还想编辑其他的翻译文本，那么可以继续悬停，选择对应的语言来编辑，或者选择自动翻译（谷歌翻译可能会出现翻译失败需要调整翻译API）。也可以进入审阅模式同时编辑多种语言的翻译文本。 自动提取的话，就是整个组件开发完成之后在左侧文件管理器中找到目标文件&#x2F;目录右键打开菜单选择 Extract all hard-coded strings(experimental) 就可以自动提取了。自动提取时如果已经存在的文本，会自动替换成已经存在的国际化标识。如果不存在的话，就会把中文自动转换成拼音来创建对应的词条。 这个时候就会遇到一个问题，全部的词条都是扁平化的，不能按照命名空间的方式来创建。因为默认 namespace 是关闭的，需要手动开启并且配置 pathMatcher 规则。 👉 Namespaces · lokalise&#x2F;i18n-ally Wiki这部分比较麻烦，还没有好好研究，但是应该有提供示例 👉 Path Matcher · lokalise&#x2F;i18n-ally Wiki 可以参考文档中给出的配置。 🌏 翻译进度 &amp; 使用情况分析项目开发到一定进度的时候，我们会不清楚是否所有的语言是否都已经完成了翻译工作，以及是否有一些翻译文本已经被删除了，但是业务组件中仍在使用。就需要用到 翻译进度 和 使用情况分析 两个面板了。 可以看到各个语言翻译的进度，会汇总全部语言的所有文本词条。如果有缺失没有翻译的，就可以在这里检查到。以及一些已经在组件中使用，但是并没有完成国际化翻译的词条。 最后可能有些人会好奇 /i18n/config.js 文件里面的内容，其实就是简单把数组结构替换成为对象的处理： // i18n/config.js const languageList = [&#x27;zh-cn&#x27;, &#x27;en&#x27;] // 创建一个空i18n对象 const createEmptyLocaleConfig = () =&gt; Object.fromEntries(languageList.map(key =&gt; [key, &#123;&#125;])) // 配置文件转i18n对象 export const transferLocaleConfig = (data) =&gt; &#123; const localeConfig = createEmptyLocaleConfig() for (const key in data) &#123; languageList.forEach((lang, index) =&gt; &#123; localeConfig[lang][key] = data[key][index] &#125;) &#125; return localeConfig &#125; 然后在 en.js 中引入和然后使用 export default 导出聚合后的内容，就可以在 i18n-ally 中被正确分析到了。 // en.js import common from &#x27;./modules/common&#x27; import user from &#x27;./modules/user&#x27; export default &#123; ...common[&#x27;en&#x27;], ...user[&#x27;en&#x27;], &#125; 至于在 vue-i18n 中如何使用就是简单的 import 之后使用就可以了 // i18n/index.js import Vue from &#x27;vue&#x27; import VueI18n from &#x27;vue-i18n&#x27; // ... import zhJson from &#x27;./zh_cn&#x27; import enJson from &#x27;./en&#x27; Vue.use(VueI18n) const messages = &#123; &#x27;zh-cn&#x27;: &#123; // ... ...zhJson &#125;, &#x27;en&#x27;: &#123; // ... ...enJson &#125; &#125; const i18n = new VueI18n(&#123; locale: localStorage.getItem(&#x27;language&#x27;) || process.env.VUE_APP_I18N_DEFAULT, messages &#125;) export default i18n 相关资源i18n Ally - Visual Studio MarketplaceExamples - lokalise&#x2F;i18n-ally","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Coding","slug":"Coding","permalink":"https://yogwang.site/tags/Coding/"},{"name":"VSCode","slug":"VSCode","permalink":"https://yogwang.site/tags/VSCode/"},{"name":"i18n","slug":"i18n","permalink":"https://yogwang.site/tags/i18n/"}]},{"title":"💪 2023 年，其实生活不只是编程","slug":"summary-at-the-end-of-2023","date":"2024-03-10T16:20:12.000Z","updated":"2026-01-05T05:39:58.515Z","comments":true,"path":"2024/summary-at-the-end-of-2023/","permalink":"https://yogwang.site/2024/summary-at-the-end-of-2023/","excerpt":"23年整体来说，还是按照计划稳步推进的正常年份，不管是工作还是工作之外。除了说 23Q2 出现过一波离职潮还是比较意外，其他的都算处于预料之内，所以其实今年没有什么好总结的内容。 ✋ Part1. 回顾先看一下年初立下的一些 Flag 🚩 开始AI辅助编程(Copilot、ChatGPT); 获得思否的2023年度 Top Writer; 完结掉2个自己的个人项目； 发布最少20篇笔记&#x2F;文章; 在思否回答1000个问题; 完成度其实很不怎么样，主要是笔记和文章的分享。比预期的完成度要低很多，原来是预期每个月能写2篇自己比较感兴趣的内容并且同步发布到各大社区平台。但是实际只完成了9篇，其中有4篇还是在12月底的时候急急忙忙完成的填坑……个人项目也是一样，本来是想着今年应该可以完成2个项目的开发。但其实只结束了一个项目，另一个迟迟不能完成交付进入运维阶段。并且开发周期已经从预计的2个季度，拉长到了以年来计算。","text":"23年整体来说，还是按照计划稳步推进的正常年份，不管是工作还是工作之外。除了说 23Q2 出现过一波离职潮还是比较意外，其他的都算处于预料之内，所以其实今年没有什么好总结的内容。 ✋ Part1. 回顾先看一下年初立下的一些 Flag 🚩 开始AI辅助编程(Copilot、ChatGPT); 获得思否的2023年度 Top Writer; 完结掉2个自己的个人项目； 发布最少20篇笔记&#x2F;文章; 在思否回答1000个问题; 完成度其实很不怎么样，主要是笔记和文章的分享。比预期的完成度要低很多，原来是预期每个月能写2篇自己比较感兴趣的内容并且同步发布到各大社区平台。但是实际只完成了9篇，其中有4篇还是在12月底的时候急急忙忙完成的填坑……个人项目也是一样，本来是想着今年应该可以完成2个项目的开发。但其实只结束了一个项目，另一个迟迟不能完成交付进入运维阶段。并且开发周期已经从预计的2个季度，拉长到了以年来计算。 📃 文章分享的部分，主要是因为 降本增效 之后工作量增加导致的。出现人员离职之后开发计划其实并没有做出调整，还是按照年初制定的里程碑在前进。中间还会夹杂着一些交接过来的项目，所以加班其实算是常态化了。全职的工作内容加上个人项目的开发工作，并没有多余的很多精力可以做内容分享了。其实也挖了蛮多坑的，后面有时间应该开始填坑。其实内容并不复杂，只是需要花时间去了解整理。比如说自动化和辅助工具这些提高工作效率的分享。 🛄 个人项目部分，应该算是个人开发者必定会踩坑的一次经历。就是没有明确开发的功能明细清单。一开始在沟通交流的过程中其实 需求方并没有非常清楚自己需要做的是什么功能 ，只给出了几个笼统的大致方向。因为在他当时的设想中并不会有那么多具体的细节设计。当然我在整理需求并且给到对方确认的环节中也有疏漏，并没有把具体的功能细节完整罗列出来。导致很多细枝末节的“小功能”进入了扯皮阶段。这些小功能其实很繁琐，并且需要投入大量的精力去做联动调整。 这些细节如果没有在一开始整理到并且留下书面证据，很容易进入扯皮导致开发进度停滞。并且由于是“朋友”找到我做的项目开发，并不想把事情处理得很难看，并且对方在工期方面一直很大度，几次因为我自身原因提出暂时停止开发也都非常爽快的同意。很多小功能我都没有单独计算费用。所以后期项目正常的功能需求调整和各种的“细节调整”混合到了一起，导致项目管控就开始爆炸。我们在工作中其实也会遇到这样的问题，所以需要尽可能的避免刷脸的情况出现。需要按照规范流程来的，不要简化和跳过流程。一旦出现这样的情况就很难再回到正轨了。因为需求方会觉得这样处理是没有成本的，而且非常高效。只会增加我们投入的成本，然后逐渐失控。 🤖 AI辅助编程2023年伊始 AI 就是非常的火热关键词，各种的文章、短视频铺天盖地的在宣传相关的内容。造成了很多人的职业焦虑，特别是我们这些码农们。但是实际使用起来不管是 ChatGPT 还是 Copilot 没有到惊艳的感觉。在一些重复劳作的内容上加速非常大，只要自己有思路，都能给出基本能用的结果。总体来说是值回票价的，非常建议有条件的同学利用起来，不愿意付费使用 Copilot 也可以把 ChatGPT 使用起来，毕竟 3.5 是免费的。 至于其他方面还没有过多的深入，和我当前的工作方向没有重叠。机器学习和深度学习都是隔壁组的同学在做，有一些产出但是也是面临类似的问题。现在能用的暂时只有一个小项目，可以给生产提供一些加速，但是只要模型到位其实使用Excel也能做到类似的效果。另外一个机器学习的大型项目，听说要开始在实际生产中开始测试运行，看看今年能不能有成果。 不是说有意去贬低，只是对于我这样的普通人来说，现阶段AI的实际使用情况有点低于预期。很多产品都是为了AI而去AI。 🐱 社区问答 社区问答部分和计划一致的，回答 1000 个问题，超量完成了 25%，整年一共回答了 1244 个问题。同时四个季度 Top Writer 全部拿到，所以年度的 Top Writer 也不出意料的收入囊中✌。 因为发现了思否还有年度 Maintainer 的评选，23Q2也开始参与社区审核和内容维护。相对于回答问题，社区维护相对来说轻松简单很多，更容易利用起来碎片化的时间。 🏃‍♂️ 技术之外正如标题所说，和我比较熟络的小伙伴应该已经发现了23年整年不管是社区，还是文章分享，我的活跃时长明显减少了。确实精力被更多的放到了生活中，因为三年来没有怎么运动过，之前运动积累的老本已经完全被消耗殆尽了，23年的体检中身体已经开始表现出各种不健康的信号（其实也不能让口罩背黑锅，单纯就是打破运动习惯之后是真的很难再重启。说白了就是犯懒了，毕竟都更愿意躺在沙发上刷手机）。 所以在年中开始就把更多的时间和精力分配到了身体健康当中，大概每天会分配 2 ~ 3 个小时在运动上面。经过半年的坚持运动，相对自律的运动生活习惯已经保持下来了，身体测量数值也都回归到正常，甚至良好水平: 体重： 83.68KG ➡️ 67.8KG 体脂率： 26.8% ➡️ 19.3% 有氧适能： 33.9 ➡️ 52.2 更具体的指标得过一段时间去体检了才能清楚了，不过应该是向好的。平时生活中体感没有那么劳累了，夜跑5公里也没有一开始那么喘了😂 2023年在思否社区获得了荣誉 “大满贯”，身体健康的目标也达成。😀希望24年可以保持下去，也希望可以补齐技术分享方面的短板。 ☀️ Part2. 未来今年做出一些改变，在对于过去的总结之后增加一些对于24年的计划。最近比较有想法的应该是对于英语能力的提升，从小我的英语水平一直都很差，在及格线徘徊，还考出过30分的成绩。毕业之后因为工作的缘故，虽然有一定的提升，但是也只是限于听读，对于说&amp;写都是非常差的，一个是没有好的使用环境，一个是词汇量的积累。因为我一直很排斥死记硬背，更喜欢去理解掌握。所以今年应该会在这方面对自己有所要求。 除此之外，会考虑的应该是一些提升工作效率方面的尝试，比如说各种插件和脚本的利用。工作中其实会有很多繁琐的重复劳作。即使把这些内容交给一线运维的同事来处理，也需要有一个相对友好的维护工具。而现在都是由运维人员一个一个手动录入，或者使用 Excel 来处理然后导入，也有一些是直接给到开发，我们再手工处理，相当的繁琐且麻烦。很多时候维护的数据也都是有问题的，来来回回的拉扯。虽然现在有在线文档了，数据同步不是问题了，但是还是非常得不方面。自动化测试也一直都是想要涉及的领域，现在因为组织结构的问题，测试环节全是靠开发和需求方自己进行的。并不能很好的覆盖测试。特别是在长期迭代之后一些功能已经有断层更新了。前端不像后端可以使用简单的单元测试来覆盖，如果测试环节遗漏了一些远程模块的测试。就可能会导致生产环境出现致命故障。 当然也需要回应主题，今年应该会比23年更多的走出去，计划是在周末2天的时间能够坐高铁到达的城市走一走，接触更多人和事。自律的运动让身体条件变好了，当然需要更好的去吃了！ 最后要立的 🚩Flag 还是要立的，2024年的目标是： 发布最少12篇笔记&#x2F;文章; 在思否回答1000个问题; 获得思否的2023年度 Top Writer; 体验其他5个城市的夜生活 hhhh，写的非常简单后面会做补充的。以上。 王阳阳 甲辰年 二月初二江南梅里","categories":[{"name":"代码之外","slug":"代码之外","permalink":"https://yogwang.site/categories/%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96/"}],"tags":[{"name":"总结","slug":"总结","permalink":"https://yogwang.site/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"淘宝镜像老域名SSL证书已过期","slug":"taobao-npm-mirror-certificate-expired","date":"2024-02-02T00:54:42.000Z","updated":"2026-01-05T05:39:58.517Z","comments":true,"path":"2024/taobao-npm-mirror-certificate-expired/","permalink":"https://yogwang.site/2024/taobao-npm-mirror-certificate-expired/","excerpt":"最近社区和社群里面有好多小伙伴在说怎么 npm 用不了，安装不了依赖了。一看报错信息：request to https://npm.taobao.org/xxx failed, reason: certificate has expired 😂 很明显就是 npm.taobao.org 的域名证书过期了，一看果然。已经在1月22日的时候过期了。 所以切换到的“新”的域名上面就好了： $ npm config set registry https://registry.npmmirror.com 也可以使用 NRM 来切换。","text":"最近社区和社群里面有好多小伙伴在说怎么 npm 用不了，安装不了依赖了。一看报错信息：request to https://npm.taobao.org/xxx failed, reason: certificate has expired 😂 很明显就是 npm.taobao.org 的域名证书过期了，一看果然。已经在1月22日的时候过期了。 所以切换到的“新”的域名上面就好了： $ npm config set registry https://registry.npmmirror.com 也可以使用 NRM 来切换。 顺便也检查了一下 registry.npm.taobao.org 这个域名，这个还是可以使用的，做了 301跳转 的。会直接重定向到 registry.npmmirror.com 上面。所以使用是没问题的，但还是早点切换吧。至于为什么一个做了 301 一个没做那就不得而知了😂 马上就想到了好多年前发布的一篇文章 👉 【望周知】淘宝 NPM 镜像站喊你切换新域名啦 各位前端同学，除了日常工作之外，还是需要多关注一下自己使用的工具链讯息的。我记得天猪大佬当时在各个平台都有发布切换域名通知的。 更具体地一些 受到的影响和处理方式 可以直接在链接的通知文章里面了解到。 Edit补充，有一些同学可能是给比较早期的项目更新迭代。在安装依赖的时候，即使使用 npm config set registry https://registry.npmmirror.com 切换到了正确的镜像域名上边，使用 npm install 安装依赖时仍旧会提示 certificate has expired 的情况。这个时候就需要使用 npm config get registry 查看是否正确切换了镜像地址。如果已经正确切换了，那么就需要检查当前项目下的依赖锁文件了（package-lock.json、 yarn.lock、pnpm-lock.yaml），多半是由于它们导致的，删除之后重新安装依赖即可。nn","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"NPM","slug":"NPM","permalink":"https://yogwang.site/tags/NPM/"}]},{"title":"在 Chrome 中使用 DevTools 限制CPU性能","slug":"make-cpu-slower-with-chrome-devtools","date":"2024-01-04T00:52:36.000Z","updated":"2026-01-05T05:39:58.502Z","comments":true,"path":"2024/make-cpu-slower-with-chrome-devtools/","permalink":"https://yogwang.site/2024/make-cpu-slower-with-chrome-devtools/","excerpt":"昨天刷到在思否遇到一个想要限制CPU性能的问题。在我的认知里对于 DevTools 的使用是没办法限制CPU性能的，认为只能够限制网络条件（也就是在 Network 面板中通过修改 throttling 设置来限制网络条件，也错误的把OP的截图当成了调整网络条件的设置了）。所以会想着通过系统自带的”节电模式”之类的来实现性能限制，或者借助外部的软件来调整CPU、GPU、内存相关的功率来实现性能限制。 但是OP在傍晚自己找到了解决办法，我才知道原来 DevTools 也可以限制CPU的。","text":"昨天刷到在思否遇到一个想要限制CPU性能的问题。在我的认知里对于 DevTools 的使用是没办法限制CPU性能的，认为只能够限制网络条件（也就是在 Network 面板中通过修改 throttling 设置来限制网络条件，也错误的把OP的截图当成了调整网络条件的设置了）。所以会想着通过系统自带的”节电模式”之类的来实现性能限制，或者借助外部的软件来调整CPU、GPU、内存相关的功率来实现性能限制。 但是OP在傍晚自己找到了解决办法，我才知道原来 DevTools 也可以限制CPU的。 对于限制的操作就很简单了，进入 Performance 面板就可以在CPU选项中调整了，如果没有看到CPU选项，就点击右上角的齿轮展开更多设置项就可以了。 至于更多的一些操作，可以直接看文末连接中的 Chrome DevTools 文档，我就不CV进来了。 相关链接如何在 Chrome DevTools 中模拟 10 倍性能降低? - SegmentFault 思否 #仅限制 CPU 占用率 - 使用 Device Mode 模拟移动设备 | DevTools | Chrome for DevelopersI wanna make CPU slower than default setting in chrome devtool 😣! - DEV CommunityChrome devtool で CPU を もっと制限したい - Zenn","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Chrome","slug":"Chrome","permalink":"https://yogwang.site/tags/Chrome/"}]},{"title":"HTTP缓存限制 和 Service Worker","slug":"http-cache-limit-and-service-worker-cache","date":"2023-12-28T03:21:43.000Z","updated":"2026-01-05T05:39:58.492Z","comments":true,"path":"2023/http-cache-limit-and-service-worker-cache/","permalink":"https://yogwang.site/2023/http-cache-limit-and-service-worker-cache/","excerpt":"一直以来只知道 HTTP Cache 是有缓存总量上限的，但是不知道对于单个文件的体积大小也是有限制的。 在这次接盘的3D可视化项目中就遇到了这个问题。因为模型文件体积比较大，在实际使用中经常会反馈说载入时间过长。所以在拿到服务器权限之后就改了一下 Nginx 的配置文件开启了静态资源的 HTTP cache，以为完事大吉就和一线说载入时间慢的问题解决好了。现在进入项目会使用本地缓存，在第一次载入的时候会慢一些，后面再次进入就会快很多了。 但是实际使用中反馈过来的时依旧会有很长的载入时间。以为是 Nginx 的配置项写错了，就又去确认了一下。确实是开启了缓存的，首页的各种静态资源也是会被缓存，但是等我进入到模型展示页的时候就发现问题了！最外层展示的模型是可以被缓存的，但是操作数据下钻之后开始展示内部模型从 Network 面板中看到的 glb 模型文件不是每一个都会从 disk cache 读取，有一些模型依旧会发起请求。 所以就想着浏览器是不是可以有配置项可以修改，但是并没有（可以通过给快捷方式添加启动命令来修改，但不可能要求所有设备都这样做）。所以只能想其他法子来解决这个问题，自然就找到了 Service Worker","text":"一直以来只知道 HTTP Cache 是有缓存总量上限的，但是不知道对于单个文件的体积大小也是有限制的。 在这次接盘的3D可视化项目中就遇到了这个问题。因为模型文件体积比较大，在实际使用中经常会反馈说载入时间过长。所以在拿到服务器权限之后就改了一下 Nginx 的配置文件开启了静态资源的 HTTP cache，以为完事大吉就和一线说载入时间慢的问题解决好了。现在进入项目会使用本地缓存，在第一次载入的时候会慢一些，后面再次进入就会快很多了。 但是实际使用中反馈过来的时依旧会有很长的载入时间。以为是 Nginx 的配置项写错了，就又去确认了一下。确实是开启了缓存的，首页的各种静态资源也是会被缓存，但是等我进入到模型展示页的时候就发现问题了！最外层展示的模型是可以被缓存的，但是操作数据下钻之后开始展示内部模型从 Network 面板中看到的 glb 模型文件不是每一个都会从 disk cache 读取，有一些模型依旧会发起请求。 所以就想着浏览器是不是可以有配置项可以修改，但是并没有（可以通过给快捷方式添加启动命令来修改，但不可能要求所有设备都这样做）。所以只能想其他法子来解决这个问题，自然就找到了 Service Worker 使用 Service Worker 其实很简单，一点也不麻烦，创建好 service-work.js 文件之后，注册一下就可以了直接在浏览器中看到效果了。 🌰 比如说创建这样的一个 service-work.js 文件： // service-work.js // 监听install事件 // self 就是 service worker self.addEventListener(&#x27;install&#x27;, event =&gt; &#123; // 安装完成后，使用 addAll 进行文件缓存 event.waitUntil( caches.open(&#x27;my-cache&#x27;).then(cache =&gt; &#123; return cache.addAll([ &#x27;/static/glb/workshop_a/base.glb&#x27;, &#x27;/static/glb/workshop_a/equipment_a.glb&#x27;, &#x27;/static/glb/workshop_a/equipment_b.glb&#x27;, &#x27;/static/glb/workshop_a/equipment_c.glb&#x27;, ]) &#125;) ) &#125;) // 监听fetch事件 self.addEventListener(&#x27;fetch&#x27;, event =&gt; &#123; event.respondWith( // 匹配缓存中是否有相同的请求资源 caches.match(event.request).then(response =&gt; &#123; // 如果有相同的资源，则直接返回。否则，通过fetch方法请求资源 return response || fetch(event.request).then(fetchResponse =&gt; &#123; // 如果是GLB文件，将其缓存到磁盘 if (event.request.url.endsWith(&#x27;.glb&#x27;)) &#123; return caches.open(&#x27;my-cache&#x27;).then(cache =&gt; &#123; // 将请求响应内容复制并添加到缓存中 cache.put(event.request, fetchResponse.clone()); // 返回请求响应内容 return fetchResponse; &#125;); &#125; else &#123; // 如果不是GLB文件，直接返回请求响应内容 return fetchResponse; &#125; &#125;) &#125;) ) &#125;) 上面使用了两种方式来缓存，一种是直接在注册的时候通过 cache.addAll 把对应的文件请求并缓存在本地。一种是通过监听 fetch 事件的发起，通过匹配请求的 url 中是否有对应的 .glb 后缀来实现缓存。 然后到 main.js 中注册一下： // main.js // ...其他业务代码 if (&#x27;serviceWorker&#x27; in navigator) &#123; navigator.serviceWorker.register(&#x27;/service-worker.js&#x27;) .then(registration =&gt; &#123; console.log(&#x27;Service Worker registered with scope:&#x27;, registration.scope); &#125;) .catch(error =&gt; &#123; console.error(&#x27;Service Worker registration failed:&#x27;, error); &#125;); &#125; // 其他业务代码... 然后就可以在浏览器的 Network 面板中看到效果了： 模型的加载缩减到了原本耗时的 1/10 左右，但是模型载入的解析事件还是会按照演示时的设备性能有一些编码，因为使用了压缩技术把模型压缩了。 😫 遇到的问题🎃 注册 service worker 时提示 The script has an unsupported MIME type (&#39;application/json&#39;).使用 navigator.serviceWorker.register(&#39;./service-worker.js&#39;) 注册时提示: Service Worker registration failed: DOMException: Failed to register a ServiceWorker for scope (&#x27;http://localhost/&#x27;) with script (&#x27;http://localhost/service-worker.js&#x27;): The script has an unsupported MIME type (&#x27;application/json&#x27;). 因为我使用的 Vue 项目，所以把 service-worker.js 移动到 public 目录下，并且改写为绝对路径（navigator.serviceWorker.register(&#39;/service-worker.js&#39;)）解决了问题。 🎃 需要注意 service worker 注册的作用域Service worker 是有作用域的，如果你把他放到 https://domain.com/js 目录下，那么 service worker 只会在 /js 目录中生效。除非你在注册时声明好 scope 作用域，比如说 navigator.serviceWorker.register(&quot;/service-worker.js&quot;, &#123; scope: &quot;/&quot; &#125;) 🎃 需要开启 HTTPSService worker 是需要开启 HTTPS 的，如果项目没有开启 HTTPS 那么 Service worker 并不会被激活注册。在本地开发的时候可以通过访问 localhost 这样的特殊域名来测试。 相关链接Service Worker API - Web APIs | MDNUsing Service Workers - Web APIs | MDNMaking PWAs work offline with Service workers - Progressive web apps | MDN Web Storage | Articles | web.devWhat is Chrome default cache size limit? - Super User","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"},{"name":"Cache","slug":"Cache","permalink":"https://yogwang.site/tags/Cache/"},{"name":"Service Worker","slug":"Service-Worker","permalink":"https://yogwang.site/tags/Service-Worker/"}]},{"title":"绑定的 value 值和元素的 value 值","slug":"bind-value-and-dom-value-is-difference-in-vue-react","date":"2023-12-04T04:35:25.000Z","updated":"2026-01-05T05:39:58.480Z","comments":true,"path":"2023/bind-value-and-dom-value-is-difference-in-vue-react/","permalink":"https://yogwang.site/2023/bind-value-and-dom-value-is-difference-in-vue-react/","excerpt":"今天在刷思否的时候遇到这样的一个问题： &lt;template&gt; &lt;input type=&quot;text&quot; :value=&quot;inputValue&quot; @input=&quot;handleInput&quot; /&gt; &lt;/template&gt; &lt;script setup&gt; import &#123; ref &#125; from &#x27;vue&#x27; const inputValue = ref(&#x27;&#x27;) const handleInput = (e) =&gt; &#123; const val = e.target.value const reg = /^\\d*$/ if (reg.test(val)) &#123; inputValue.value = val &#125; else &#123; inputValue.value = &#x27;&#x27; &#125; &#125; &lt;/script&gt; 题主希望通过正则校验去限制输入框只能输入数字类型的值，但是只有在先输入数字再输入非数字的情况下才会被正确置空。如果一开始就是输入非数字的内容，后续即使继续输入非数字内容，输入框中的内容并不会清空。 我们可以在 Vue SFC Playground 中体验这个现象。","text":"今天在刷思否的时候遇到这样的一个问题： &lt;template&gt; &lt;input type=&quot;text&quot; :value=&quot;inputValue&quot; @input=&quot;handleInput&quot; /&gt; &lt;/template&gt; &lt;script setup&gt; import &#123; ref &#125; from &#x27;vue&#x27; const inputValue = ref(&#x27;&#x27;) const handleInput = (e) =&gt; &#123; const val = e.target.value const reg = /^\\d*$/ if (reg.test(val)) &#123; inputValue.value = val &#125; else &#123; inputValue.value = &#x27;&#x27; &#125; &#125; &lt;/script&gt; 题主希望通过正则校验去限制输入框只能输入数字类型的值，但是只有在先输入数字再输入非数字的情况下才会被正确置空。如果一开始就是输入非数字的内容，后续即使继续输入非数字内容，输入框中的内容并不会清空。 我们可以在 Vue SFC Playground 中体验这个现象。 很明显问题是在给 inputValue 赋值为空之后出现了问题。所以我以为是更新时机导致的，就考虑使用强制更新看看。确实引入 $forceUpdate 之后问题解决了，但为什么强制该组件重新渲染才可以呢…… 在 Vue 的仓库中有人发起过一个类似的问题讨论 👉 vue3中input的value和绑定的ref存在不同的问题 · vuejs&#x2F;core · Discussion #7793虽然问题描述稍有差别，但是本质是一样的，都是在函数处理中操作绑定的 inputValue 值。 只不过他的问题是没有修改绑定的 inputValue，在输入的内容长度超过 5 之后直接 return 掉了。但其实使用 slice() 截断了也是一样的结果的。主要的原因出在了 inputValue 的值没有改变，值都没有改变 Vue 自然不会触发视图更新。 在 👆 上面的讨论贴中其他人解答了关于更新逻辑的解答： chenxch Feb 26, 2023你要知道这个整个更新逻辑1、input输入了，dom的vlaue发生变化了2、@input事件触发了3、然后更新inputValue4、当inputValue变化了，视图才会更新，input的value才会变成和inputValue一样 我们的问题也是类似的原因，在 inputValue 赋值为空之后，之后即使再有键入内容 inputValue 值一直都是空值，所以Vue并没有检测到改变，所以不会触发视图更新。所以使用强制更新就可以解决这个问题，但是我觉得这个解决方式并不合适。我们可以先给 inputValue 赋值，然后再做业务判断重新给赋值为空值。这样虽然修改了两次 inputValue 值，Vue 会合并两次操作为一次。 😕 那么为何React中的表现并不是这样？这个情况会比较特殊，在Vue中和React中的表现并不一致： 在 Vue 中输入框的内容会随着用户键入内容被改变； 在 React 中输入框的内容并不会随着用户键入内容而改变。 例如以下的 🌰Demo，也可以通过在线Demo尝试(CodeSandbox) import &#123; useState &#125; from &#x27;react&#x27;; function MyInput() &#123; const [value, setValue] = useState(&#x27;&#x27;) const handleInput = (e) =&gt; &#123; const val = e.target.value const reg = /^\\d*$/ if (reg.test(val)) &#123; setValue(val) &#125; else &#123; setValue(&#x27;&#x27;) &#125; &#125; return ( &lt;input value=&#123;value&#125; onInput=&#123;handleInput&#125; /&gt; ) &#125; export default function MyApp() &#123; return ( &lt;MyInput /&gt; ) &#125; 输入框的内容并不会随着用户键入内容而改变。会表现出类似 read-only 的状态，并不能继续输入错误内容。Vue 的表现有点类似于在 React 中使用 defaultvalue 的情况，但是又并不是完全相同。 我就很疑惑为什么会这样，怀疑 Vue 单独做了处理，但是在 Vue 文档中并没有找到关于这段的描写。转而怀疑是 React 做了处理，毕竟 defaultValue 是 React 提出的一个虚拟属性，随后就去翻了 React 的文档，就看到了这样一段提示： PitfallIf you pass value without onChange, it will be impossible to type into the input. When you control an input by passing some value to it, you force it to always have the value you passed. So if you pass a state variable as a value but forget to update that state variable synchronously during the onChange event handler, React will revert the input after every keystroke back to the value that you specified. 陷阱如果传递了 value 但没有传递 onChange，那么将无法输入内容。当你通过传递 value 来控制输入框时，你需要保证输入框始终具有你传递的值。因此，如果你将一个 state 作为 value 传递，但在 onChange 事件处理程序中忘记同步更新该状态变量，React 将在每次输入后将输入框恢复到指定的 value。 😂 所以确实是 React 它单独给给做了处理…… 并不是 Vue 表现得不一样，而是 React 不一样。Vue 维持了和原生HTML一样的情况。而 React 为了保持一致性操作了输入框的 Value 值。 并且如果你没有绑定 onInput 或者 onChange 事件，React 会在控制台抛出异常： Warning: You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`. React 引入了 受控组件 和 非受控组件 的概念，而 Vue 并没有强调这个概念。但是大部分的UI库在实现表单组件的时候会通过受控组件来实现。比如说 Element UI 在 Input 组件 的文档开头就说明了： Input 为受控组件，它总会显示 Vue 绑定值。 所以会出现我印象中某些情况下给输入框绑定了 value 值时会表现出只读的情况，有些时候又并不是这样。 至于受控组件和非受控组件就以后单独找一个时间来开坑了 😝 相关链接vue3中input的value和绑定的ref存在不同的问题 · vuejs&#x2F;core · Discussion #7793#使用 state 控制输入框 | &lt;input&gt; – ReactYou Probably Don’t Need Derived State – React Blog","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"VueJS","slug":"VueJS","permalink":"https://yogwang.site/tags/VueJS/"}]},{"title":"为什么v-model绑定的对象属性不是总是响应式？","slug":"why-vmodel-bind-object-props-not-always-reactive","date":"2023-11-28T05:33:16.000Z","updated":"2026-01-05T05:39:58.524Z","comments":true,"path":"2023/why-vmodel-bind-object-props-not-always-reactive/","permalink":"https://yogwang.site/2023/why-vmodel-bind-object-props-not-always-reactive/","excerpt":"v-model 仅仅只是 v-bind:value=&quot;value&quot; 和 @input=&quot;value = $event.target.value&quot; 的语法糖吗？ 一直以来我都喜欢在Vue中声明对象变量的时候给变量赋值一个空对象，而不是把所有的属性值一起声明好。比如说： // vue2.x form demo export default &#123; data() &#123; return &#123; // 我喜欢这样声明 formData: &#123;&#125;, // 而不是这样在声明时把所有的属性一起书写好 formData: &#123; username: &#x27;&#x27;, password: &#x27;&#x27; &#125; &#125; &#125; &#125; 也可以从我之前关于 props 属性的笔记中察觉到 👉 Vue中接收没有声明的Prop属性[null&#x2F;undefined]的接收问题 因为我在写业务的时候如果 props 的属性值不存在，传入的会是一个 undefined 而不是 null 或者 &#39;&#39; 这样的预设。因为我期望使用组件 props 中声明的默认值，而不是在外部预设的空值。所以一直以来我都在和小伙伴交流的时候也是推荐直接给变量一个空对象即可，除了一些数组属性需要单独声明。 但前段时间一位小伙伴向我提问：他在组件生命周期函数中给表单属性赋值了一个预设值，后续再使用 v-model 对表单属性修改时发现丢失了响应……","text":"v-model 仅仅只是 v-bind:value=&quot;value&quot; 和 @input=&quot;value = $event.target.value&quot; 的语法糖吗？ 一直以来我都喜欢在Vue中声明对象变量的时候给变量赋值一个空对象，而不是把所有的属性值一起声明好。比如说： // vue2.x form demo export default &#123; data() &#123; return &#123; // 我喜欢这样声明 formData: &#123;&#125;, // 而不是这样在声明时把所有的属性一起书写好 formData: &#123; username: &#x27;&#x27;, password: &#x27;&#x27; &#125; &#125; &#125; &#125; 也可以从我之前关于 props 属性的笔记中察觉到 👉 Vue中接收没有声明的Prop属性[null&#x2F;undefined]的接收问题 因为我在写业务的时候如果 props 的属性值不存在，传入的会是一个 undefined 而不是 null 或者 &#39;&#39; 这样的预设。因为我期望使用组件 props 中声明的默认值，而不是在外部预设的空值。所以一直以来我都在和小伙伴交流的时候也是推荐直接给变量一个空对象即可，除了一些数组属性需要单独声明。 但前段时间一位小伙伴向我提问：他在组件生命周期函数中给表单属性赋值了一个预设值，后续再使用 v-model 对表单属性修改时发现丢失了响应…… &lt;!-- 丢失响应的最小复现 --&gt; &lt;template&gt; &lt;form&gt; &lt;input v-model=&quot;formData.username&quot; /&gt; &lt;span&gt;&#123;&#123; formData.username &#125;&#125;&lt;/span&gt; &lt;/form&gt; &lt;/template&gt; &lt;script&gt; export default &#123; data() &#123; return &#123; formData: &#123;&#125;, &#125; &#125;, created() &#123; this.formData.username = &#x27;admin&#x27; &#125; &#125; &lt;/script&gt; 按照思维惯性，我就理所当然的说，如果是变量是属性数组的话，你需要通过 $set 去修改内部的值，一般遇到失去响应都是错误操作数组导致的。但是他说原因不是这个，他自己写了一个最小实现，赋值和修改的都是字符串也会丢失响应。就和我贴在上面的示例一样，就是简单直接的赋值操作。 那就很奇怪了，在我的理解里应该是不会丢失响应式的，所以我就去看了一下我业务中和他类似的操作： export default &#123; data() &#123; return &#123; formData: &#123;&#125;, &#125; &#125;, created() &#123; this.formData = &#123; username: &#x27;admin&#x27; &#125; &#125; &#125; 可以看到区别在于我是给 formData 整个重新赋值了，而小伙伴是单独给 formData.username 进行赋值操作，所以问题就是出现在这里。按照Vue手册中的说法是： Vue 无法检测 property 的添加或移除。 那么如何添加对象属性呢？ 对于已经创建的实例，Vue 不允许动态添加根级别的响应式 property。但是，可以使用 Vue.set(object, propertyName, value) 方法向嵌套对象添加响应式 property。例如，对于： Vue.set(vm.someObject, &#x27;b&#x27;, 2) 您还可以使用 vm.$set 实例方法，这也是全局 Vue.set 方法的别名： this.$set(this.someObject,&#x27;b&#x27;,2) 有时你可能需要为已有对象赋值多个新 property，比如使用 Object.assign() 或 _.extend()。但是，这样添加到对象上的新 property 不会触发更新。在这种情况下，你应该用原对象与要混合进去的对象的 property 一起创建一个新的对象。 // 代替 `Object.assign(this.someObject, &#123; a: 1, b: 2 &#125;)` this.someObject = Object.assign(&#123;&#125;, this.someObject, &#123; a: 1, b: 2 &#125;) 所以我给 formData 整体赋值方式可以，但是小伙伴单独给 formData 添加 username 不可以。小伙伴调整为 $set() 来赋值方式解决了问题。 但是小伙伴随后就问了第二个问题：为什么我们在 data 中声明 formData 为空对象 &#123;&#125;，但是在模板中直接使用 v-model 进行双向绑定时不会丢失响应式呢？比如说： &lt;template&gt; &lt;form&gt; &lt;input v-model=&quot;formData.username&quot; /&gt; &lt;span&gt;&#123;&#123; formData.username &#125;&#125;&lt;/span&gt; &lt;/form&gt; &lt;/template&gt; &lt;script&gt; export default &#123; data() &#123; return &#123; formData: &#123;&#125;, &#125; &#125; &#125; &lt;/script&gt; 这就问到我的知识盲区了，所以去翻了一下 Vue 仓库中关于 v-model 部分的源码 👉 vue&#x2F;src&#x2F;compiler&#x2F;directives&#x2F;model.ts at master · vuejs&#x2F;vue export function genAssignmentCode(value: string, assignment: string): string &#123; const res = parseModel(value) if (res.key === null) &#123; return `$&#123;value&#125;=$&#123;assignment&#125;` &#125; else &#123; return `$set($&#123;res.exp&#125;, $&#123;res.key&#125;, $&#123;assignment&#125;)` &#125; &#125; 可以看到其实内部是使用了 $set 去赋值了，而不是简单的使用赋值运算符(=)去赋值。至此，全部的疑惑都解开了。也纠正了我的一个错误理解，之前一直以为我们声明的变量被 Vue 在监听后，变量属性数量改变时也会触发更新的。但其实并不是，单纯只是因为自己的操作习惯正好命中了正确的添加属性操作。所以并不能简单的通过检查变量是否被挂载 ob 来判断是否具有响应式。 相关链接深入响应式原理 — Vue.js表单输入绑定 | Vue.jsvue&#x2F;src&#x2F;compiler&#x2F;directives&#x2F;model.ts at master · vuejs&#x2F;vue","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"VueJS","slug":"VueJS","permalink":"https://yogwang.site/tags/VueJS/"}]},{"title":"记一次旁观他人的技术面试","slug":"sf-observing-elses-tech-interview","date":"2023-03-25T18:03:45.000Z","updated":"2026-01-05T05:39:58.514Z","comments":true,"path":"2023/sf-observing-elses-tech-interview/","permalink":"https://yogwang.site/2023/sf-observing-elses-tech-interview/","excerpt":"最近没有什么面试经历，上一次面试已经是将近一年前了，所以没办法有效回忆到当时面试的状况。好在近期肉大(@meathill)有在做一个模拟面试的选题，就可以另辟蹊径写一篇旁观其他人面试的文章。 奥利奥同学 是一位能力非常强的前端开发者。最开始了解到他是他在群里分享了自己使用 ThreeJS 开发的一个可交互3D汽车展厅项目 的开发经历，非常吸引眼球并且完成了配套的讲解教程，可以说是非常用心和细致的一个开发者了。 所以这一次我们就来旁观他的一次模拟面试，🏃‍🏃‍🏃‍","text":"最近没有什么面试经历，上一次面试已经是将近一年前了，所以没办法有效回忆到当时面试的状况。好在近期肉大(@meathill)有在做一个模拟面试的选题，就可以另辟蹊径写一篇旁观其他人面试的文章。 奥利奥同学 是一位能力非常强的前端开发者。最开始了解到他是他在群里分享了自己使用 ThreeJS 开发的一个可交互3D汽车展厅项目 的开发经历，非常吸引眼球并且完成了配套的讲解教程，可以说是非常用心和细致的一个开发者了。 所以这一次我们就来旁观他的一次模拟面试，🏃‍🏃‍🏃‍Part 1. 简历点评奥利奥同学的简历可以说是很不错的，从 个人优势 和 项目经历 部分可以看出来，涉猎的范围也很多，虽然有夸大的成分在但总体来说还是非常不错的。特别是对于一个才参加工作一年多的新人来说，可以说是业务能力强、自学能力也非常强的一位前端开发者。其它的一些瑕疵有但都是新人写简历的一些通病，我记得我早年在刚开始找实习工作的时候也是这样，恨不得把我所有会的、做过的东西都写上来。 对于简历的部分我是比较建议大家看一下 超级简历WonderCV 这位Up主 从HR角度 的面试 Reaction，我觉得十分不错，特别是在HR初筛简历这关来说帮助会非常大。 总的来说就是聚合你的技术栈，在你还没有成为行业专家的时候。写上来的内容可以有一些夸大的成分，但是要在你自己可掌控的范围内。另外就是一些针对性的简历优化，特别是你想要面试一些大公司或者一个自己非常心仪企业的时候。比如说强调对应的技术栈和项目经历去迎合（提高你的匹配度）来抓HR的眼球。 Part 2. 技术问答基本功 - CSS部分奥利奥同学有一个新人前端的一个通病，就是 CSS 基本功不扎实。这可能和大环境比较有关系，当前环境下更重视面试者对于JS能力的考评，弱化了CSS部分。毕竟现在各大厂都有自己的UI库，一些中小厂也差不多，在渡过了项目伊始阶段基本都不会再怎么去调整样式部分了，因为UI风格和设计规范已经确定下来了，后续基本就是一些具体业务上面的工作了，真的有UI风格改变也都是一些大版本的迭代才会考虑的了。 但实际上 CSS 作为前端三大基本功之一还是属于必不可少的能力。你可以重视自己 JavaScript 的能力，但是也不能说忽略了对于 HTML 和 CSS 学习，一些很冷门的标签和样式属性可以不怎么了解，但是一些高频、常用的还是需要去掌握熟悉的。 基本功 - JS部分奥利奥同学可以说是大意了，没有去背八股文（毕竟是一个邀约的模拟面试）。虽然说我也是很讨厌被八股文的，但是要开始高频面试的时候背八股文是必要的一环。你不背的话就可能在展露拳脚之前就被淘汰下去了，这种况真的很让人遗憾和挫败。 Web基础 &amp; 软件工程这两块内容没什么可以说的，奥利奥同学吃了经验的亏，比如说专业名词没有能够很好的理解。但这些其实算是从业者自己造的壁垒去困扰一些新进的从业者。其实如果在自己不确定的时候可以询问一下面试官具体是想要问哪A和B中的哪一个，来避免自己答非所问。 哦，对了，面试的时候不要给自己增加难度，过度的自信很容易搬起石头砸自己的脚。 Part 3. 在线Coding在线Coding部分，肉大说的结对编程思路确实然我很意外，因为很多时候我们并不会考虑到面试官的视角，我们都会因为自己紧张或者其他原因，从而很难让聚光灯（自己的视角）从自身挪开，从而可以考虑其他人的感受。如果有提前书写伪代码(注释)和测试用例让面试官了解你思路的话，确实会是一个非常加分习惯。 Part 4. 面试回顾奥利奥同学犯了一些新人常犯的问题，基本功还有待加强，如果不是因为了解奥利奥同学的真实能力，可能我在面试一半的时候就已经终止了这次面试，因为确实有点低于预期。因为简历中的项目经历写的非常不错，涉猎的面非常广看起来不像是一个会犯如此低级错误的人，可会误导我去往简历造假的方向考虑。这块属于预期管理的部分不要过高的提高面试方对于自己的期待值，这样会给自己的面试增加不小的难度。虽然可能会让面试方在简历关更加的关注、留意到你，但是很可能会因为增加的难度被面试官问倒反而造成自己的失利。 另外一个问题也是属于新人常犯的，就是会给自己找说辞为自己开脱，但是这在我看来这种狡辩、试图逃避或掩盖错误的行为，会被我认为是一个扣分项（主观的）。因为未来在工作中遇到问题或者困难也多半会这样给自己开脱。但如果你大胆直面自己的错误，承认自己的错误，会让面试官感到你的坦率和诚实，这种积极的态度更能招来我的好感。 相关链接模拟面试帮你避坑：初中级前端奥利奥同学_哔哩哔哩_bilibiliThree.js打造可交互3D领克汽车，20分钟学会前端项目亮点！_哔哩哔哩_bilibili从招聘方的角度理解求职 – 山维空间oreo’s homepage | Github 本文参与了SegmentFault 思否面试闯关挑战赛，欢迎正在阅读的你也加入。","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"社群分享","slug":"社群分享","permalink":"https://yogwang.site/tags/%E7%A4%BE%E7%BE%A4%E5%88%86%E4%BA%AB/"},{"name":"面试","slug":"面试","permalink":"https://yogwang.site/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"思否有约｜陟上晴明：人生没有白走的路，每一步都算数","slug":"sf-community-interview-2023","date":"2023-03-24T14:49:37.000Z","updated":"2026-01-05T05:39:58.514Z","comments":true,"path":"2023/sf-community-interview-2023/","permalink":"https://yogwang.site/2023/sf-community-interview-2023/","excerpt":"","text":"最近我收到了来自 SegmentFault思否社区的采访邀约。非常荣幸让我有机会讲述自己的成长经历、分享我的经验和见解，并为那些也在这个行业奋斗的人提供一些有价值的建议。今天这篇采访文章已经上线了大家可以移步观看 🔗 思否有约｜陟上晴明：人生没有白走的路，每一步都算数","categories":[{"name":"代码之外","slug":"代码之外","permalink":"https://yogwang.site/categories/%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96/"}],"tags":[{"name":"社群分享","slug":"社群分享","permalink":"https://yogwang.site/tags/%E7%A4%BE%E7%BE%A4%E5%88%86%E4%BA%AB/"}]},{"title":"Element UI 2x 级联选择器组件动态 option 属性导致的异常抛出","slug":"eleui-el-cascader-cannot-read-property-level-of-null","date":"2023-03-03T01:11:07.000Z","updated":"2026-01-05T05:39:58.485Z","comments":true,"path":"2023/eleui-el-cascader-cannot-read-property-level-of-null/","permalink":"https://yogwang.site/2023/eleui-el-cascader-cannot-read-property-level-of-null/","excerpt":"业务上遇到一个UI的变更需求，要求是把一个 三层数据的级联选择器组件 拆分成 下拉选择组件 + 二层数据的级联选择器组件 的形式去展示。也就是把三层数据的第一层提出来赋值给下拉选择器组件，对应的二级三级数据依旧是在 级联选择组件 中选择。 需求其实很简单，也很快就处理掉了，但是自测的时候就总是会看到控制台会抛出一个异常：[Vue warn]: Error in callback for watcher &quot;options&quot;: &quot;TypeError: Cannot read property &#39;level&#39; of null 因为在测试环境就下意识以为是因为测试的假数据对不上级联选择器可选项 value 造成的匹配不到对应的层级导致的报错，就没有过多的关注。今天开发完手头上的主体业务回过头来收尾细节的时候发现并不是这么一回事。其实是由于 &lt;el-cascader&gt; 级联选择器的 options 属性被动态修改而造成的问题。 这边提前说一个简答解决方式： 给级联选择器增加 key 键，让每次 options 修改时重新渲染组件即可。","text":"业务上遇到一个UI的变更需求，要求是把一个 三层数据的级联选择器组件 拆分成 下拉选择组件 + 二层数据的级联选择器组件 的形式去展示。也就是把三层数据的第一层提出来赋值给下拉选择器组件，对应的二级三级数据依旧是在 级联选择组件 中选择。 需求其实很简单，也很快就处理掉了，但是自测的时候就总是会看到控制台会抛出一个异常：[Vue warn]: Error in callback for watcher &quot;options&quot;: &quot;TypeError: Cannot read property &#39;level&#39; of null 因为在测试环境就下意识以为是因为测试的假数据对不上级联选择器可选项 value 造成的匹配不到对应的层级导致的报错，就没有过多的关注。今天开发完手头上的主体业务回过头来收尾细节的时候发现并不是这么一回事。其实是由于 &lt;el-cascader&gt; 级联选择器的 options 属性被动态修改而造成的问题。 这边提前说一个简答解决方式： 给级联选择器增加 key 键，让每次 options 修改时重新渲染组件即可。 一开始这个报错信息是在弹窗关闭的时候出现的，所以我就简单的认为是关闭弹窗时使用 resetFields() 方法的把表单绑定的 model 重置导致的，以前遇到过使用 resetFields() 重置表单会时表单数据失去响应。所以修改为了手动置空表单再使用 clearValidate 清理校验结果，但是问题依旧任然会抛出 TypeError: Cannot read property &#39;level&#39; of null 的错误信息，所以并不是数据重置导致的异常。 又觉得可能是因为 el-caseader 组件的 value 需要是一个数组，重置完表单之后绑定的 value 会变成 undefined 所以修改手动置空表单是声明绑定的属性为 []（病急乱投医），并无果。 在反复折腾一番确认使用 v-model 绑定的变量在弹窗组件关闭后没有被错误赋值之后，祭出了谷歌大法： cascader 有选中项的绑定值 checkedValue 和点击的父节点（高亮）activePath ， 即便设置了 this.cascaderValue= [] ，cascader 中的 activePath 还是有值，也就是点击的父节点会被记录下来，再次加载 cascader 找不到就会报错。 最后提到的解决方案是 给级联选择器增加 key 键，让每次 options 修改时都是一个新的组件来渲染，然后同时修改绑定的 value 值。这样就会确保不会出现有选择值或者高亮路径值导致无法匹配到 option 层级。 中间提到了两种方式我就不具体说了。单独说一下文章中提到的：修改 value 并不能根本解决问题的部分。 我看了一下当前版本(2.15.13)的级联组件的源码部分，现在的级联选择器在 value 变更时会去同步修改 el-cascader-panel 的 value，如果 el-cascader-panel 组件的 value 和 checkedValue 不相等时则会去重置 activePath 为 []。所以可以通过修改 value 的方式来避免异常的抛出，但是一定要在 options 改变之前才行。 所以每次级联选择器 options 改变之前重置掉绑定的 value 值然就行，但是需要保证你业务代码的执行顺序，但很多时候我都是按照业务视图顺序的方式去书写代码，所以得调整一些赋值操作的前后循序。以及需要去放弃使用 v-model 转而使用 @change 去手动赋值和修改修改 options。 总而言之直接给级联选择器设置 key 依旧是是一个简单高效的方式，除非说当前的业务十分复杂并且需要考虑性能问题的情况。 以上 相关阅读Cascader 级联选择器 - 组件 | Elementelement&#x2F;cascader-panel.vue at v2.15.13 · ElemeFE&#x2F;element el-cascader的使用以及报错解决_大橙子额的博客","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"ElementUI","slug":"ElementUI","permalink":"https://yogwang.site/tags/ElementUI/"}]},{"title":"聊一个VueJS的DOM模板解析注意事项","slug":"vue-dom-template-parsing-caveats","date":"2023-02-24T14:08:18.000Z","updated":"2026-01-05T05:39:58.521Z","comments":true,"path":"2023/vue-dom-template-parsing-caveats/","permalink":"https://yogwang.site/2023/vue-dom-template-parsing-caveats/","excerpt":"今天在社区答题的时候，遇到一个题目 《CDN引入的 Vue3 和Element Plus 表格异常，怎么解决呢？》。在去复现的时候和提问者犯了一样的错误。没有显式地写出关闭标签，想当然的直接复制了官方的代码示例就粘贴上去运行了。 然后还以为是 CDN 上最新版本的包有问题，从 2.2.32 一路试到了 2.0.0 都还是一样情况，然后很果断地得出了一个结论：官方的演示 Demo 也有问题 😂。 其实问题就是在 没有显式地写出关闭标签……","text":"今天在社区答题的时候，遇到一个题目 《CDN引入的 Vue3 和Element Plus 表格异常，怎么解决呢？》。在去复现的时候和提问者犯了一样的错误。没有显式地写出关闭标签，想当然的直接复制了官方的代码示例就粘贴上去运行了。 然后还以为是 CDN 上最新版本的包有问题，从 2.2.32 一路试到了 2.0.0 都还是一样情况，然后很果断地得出了一个结论：官方的演示 Demo 也有问题 😂。 其实问题就是在 没有显式地写出关闭标签…… 所以我们显示地写出关闭标签就好了： 因为我们已经习惯于使用 CLI 创建项目了，从而忽略了 Vue 模板解析器的支持。以及 lint 的 vue&#x2F;html-self-closing 校验规则潜移默化的让自己以为所有的元素都可以使用自闭合标签。其实并不是这样的，HTML 只允许一小部分特殊的元素省略其关闭标签。 所以一开始的 HTML代码当中 &lt;el-table-column prop=&quot;date&quot; label=&quot;Date&quot; width=&quot;180&quot; /&gt; 写法就被解析为单个单个的 &lt;tr&gt; 元素从而变成单独占满一行的状态。显示地闭合标签之后，就会被正确地解析为 &lt;td&gt; 元素。 相关链接DOM 模板解析注意事项 - 组件基础 | Vue.js","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"VueJS","slug":"VueJS","permalink":"https://yogwang.site/tags/VueJS/"}]},{"title":"👋 告别挣扎的 2022 年","slug":"summary-at-the-end-of-2022","date":"2023-01-27T18:12:09.000Z","updated":"2026-01-05T05:39:58.514Z","comments":true,"path":"2023/summary-at-the-end-of-2022/","permalink":"https://yogwang.site/2023/summary-at-the-end-of-2022/","excerpt":"一拖再拖，22年结束之前思否小姐姐一直就在暗示我应该要写了，但是因为情绪的问题一直拖着，趁着今天有些情绪（负面）就决定手动写了吧，正好也赶在征文结束之前拉低一下中奖概率。 正如标题所说 2022 年是很多人感觉到挣扎的一年，看到很多小伙伴因为经济下滑而被辞退、或者被迫倒闭的消息。突然的解封也打了大家一个措手不及，陆陆续续也听到很多人离世的消息。 💼 失业&amp;面试&amp;入职自然我也没有躲过，刚刚过完年没多久就收到前公司决定解散的通知，虽然很突然但也算是意料之中。没有和前司纠结赔偿的问题，拿了离职证明休息了两天就开始找工作……","text":"一拖再拖，22年结束之前思否小姐姐一直就在暗示我应该要写了，但是因为情绪的问题一直拖着，趁着今天有些情绪（负面）就决定手动写了吧，正好也赶在征文结束之前拉低一下中奖概率。 正如标题所说 2022 年是很多人感觉到挣扎的一年，看到很多小伙伴因为经济下滑而被辞退、或者被迫倒闭的消息。突然的解封也打了大家一个措手不及，陆陆续续也听到很多人离世的消息。 💼 失业&amp;面试&amp;入职自然我也没有躲过，刚刚过完年没多久就收到前公司决定解散的通知，虽然很突然但也算是意料之中。没有和前司纠结赔偿的问题，拿了离职证明休息了两天就开始找工作…… 在招聘APP上初步沟通之后一共收到12场面试邀约，以每天 2 ~ 3 场的频率开始面试。强度其实挺高的，可以说几乎都是在这里渡过的白天，傍晚回到家瘫在沙发上都能睡着。现在回过头来认为确实应该多准备一下，不管是知识面的储备还是时间安排上面，准备充足之后再开始找工作。我只给自己安排了一周的时间，完全没有刷面试题，所以有两家比较中意的公司面试都不怎么满意，很多知识点记忆都很模糊了，回答的模棱两可。不过最终结果还是可以的，是本地的一家制造业公司的数字化转型部门。薪资待遇虽然比不上隔壁的沪苏杭，但是在本地也算是很高的了（涨了大概50%）。 第一次入职集团公司确实很不适应，特别是需要使用配发的电脑工作，受限账户是一个很大的问题，安装软件和脚本都需要授权，不方便的还有上网行为监控。IT管理员的办公室还特别的远，需要到另外一个大楼处理。但是园区环境十分不错，入职的第一天就被惊艳到了，简直是一个小型动物园，入职第一周拍好多好多的照片。大部分的动物还是放养的，特别想 Rua 🦌梅花鹿，但是比较怕人没办法。可以 Rua 的鸵鸟没那么怕生，但是会突然在你面前开闸泄洪会人惊慌失措。既然动物们那么可爱，工作上的一些不方便就都无所谓了。 然而参与的第一个项目的技术选型是我比较抗拒的技术栈 uni-app，面试当中有提到我也明确吐槽了相应的缺点，但 Leader 还是决定使用 uni-app 因为未来准备打包成APP（虽然这个未来已经过去快一年了都没有到来），也没有打算使用RN 再写一遍的考虑。不过很快适应了下来顺利开发完了首期需求。第二个参与的项目是数据可视化也就是经典的大屏项目了，比较不同的是使用的 ThreeJS 展示的 3D 园区模型，以及一些远程操控和监控视频推流。 两个项目稍微踩了一些坑，写了很多草稿笔记，但是因为精力的问题大部分都咕咕咕了，希望今年能把这些草稿都发布出来。 uni-app uViewUI Vue3(😂选项式，不是组合式) Vue-cesium ThreeJS ECharts Hikvision_H5player 🐟 部门重组&amp;新摸鱼方式 因为部门重组和项目人员调用，开始参与到项目一的桌面端项目当中，开发新的项目需求。中间一度需要面临人员调动人手不足的情况，同时还要负责移动端和桌面端的日常维护，导致工作压力剧增，周工时经常超 50h，下班一坐就是两三个小时。然而换了工作上班迟到的习惯我却一直保持着。所以每个月的加班时长并没有累积下来，都抵扣给迟到了😂。 不过需求还是一些老技术栈，只不过需要了解很多制造业相关的专业知识。比较能说道说道的就是页面打印的需求了，因为看到有很多小伙伴都在面对打印需求的时候是否苦恼。也简单写了一个打印控制的笔记，但是没有详细说只是说了一个大概。 因为上网行为管控的缘故，没办法像以前那样刷油管和听音乐了，所以我开启了另外一个摸鱼方式 —— 去思否刷问答。假装 “寻找问题解决方案” 摸鱼散心的同时顺利拿到了 思否 2022 年度的 Top Writer，还是比较得意的。 🍂 问题频发&amp;危机浮现 随着部门重组完成，人员也调动结束。问题开始出现，历史项目的维护开始出现断层，参与的第二个项目也就是那个3D数据可视化项目逐渐停止更新（没人负责），中台数据经常出现异常和同步失败，隔三岔五就会出线上数据读取不到的情况。参与的第一个项目开始出现开发需求不明确、开发进度推进缓慢的情况。以及加入新人员之后开始出现Git分支管理混乱的问题。项目进度追踪、测试反馈和问题&#x2F;缺陷管理之类的老问题任然没有得到解决，依旧靠项目经理和技术人员自己把关。 项目管理上面的问题其实都还能解决，但是另外感觉到的一些潜在危机反而比较让我不安。不只是我参与的项目，其它团队的项目也开始逐渐处于停滞的状态。可能是因为内部推广阻力的问题，可能是需求的重要性不高的缘故。入职之后了解到的几个项目还在进行中的只剩下来了4个还在更新迭代。但这些项目大部分都是准备内部孵化之后考虑对外出售的服务，停止更新和使用的结果不言而喻…… 🙌 尾声&amp;番外总结下来2022年写了4个项目，22篇笔记，800个思否问答。😂另外虽然收入提高了，但其实就是换了个场地用老技术栈写项目，汲取到的新技术除了 3D 相关的其实可以说没有。我觉得 uni-app 相关的知识并不算是，只不过是 Vue 的旧酒装新瓶还带着一堆没有什么用的兼容写法。 还有就是因为情感问题造成的持续大半年的负面情绪，以及🐏康之后明显的精力下滑。希望 2023 年可以有一个新的开始，甩开21年和22年积累的负面情绪，把新的期许和希望都化作现实！ 本文参与了 SegmentFault 思否年度征文「一名技术人的 2022」。","categories":[{"name":"代码之外","slug":"代码之外","permalink":"https://yogwang.site/categories/%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96/"}],"tags":[{"name":"总结","slug":"总结","permalink":"https://yogwang.site/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"生成UUID的方法 Crypto.randomUUID()","slug":"JS-crypto-random-uuid","date":"2023-01-14T05:22:27.000Z","updated":"2026-01-05T05:39:58.473Z","comments":true,"path":"2023/JS-crypto-random-uuid/","permalink":"https://yogwang.site/2023/JS-crypto-random-uuid/","excerpt":"对于我这种比较懒的人，一直以来都是直接用 new Date().valueOf() 或者 Math.random() 配合一些规则来生成唯一ID，不配置规则的话，出现重复的概率还是比较高的。前几天看到群里有人说起了这个新的API（也不新了21年夏天发布的了）就大概看了一下。 各个主流浏览器也都支持了。不过呢，开始支持的版本都比较高🔗 “randomUUID” | Can I use，所以在一些不喜欢更新软件版本的用户里面就会抛出错误比如说 &quot;crypto&quot; is not defined 或者 crypto.randomUUID is not a function。","text":"对于我这种比较懒的人，一直以来都是直接用 new Date().valueOf() 或者 Math.random() 配合一些规则来生成唯一ID，不配置规则的话，出现重复的概率还是比较高的。前几天看到群里有人说起了这个新的API（也不新了21年夏天发布的了）就大概看了一下。 各个主流浏览器也都支持了。不过呢，开始支持的版本都比较高🔗 “randomUUID” | Can I use，所以在一些不喜欢更新软件版本的用户里面就会抛出错误比如说 &quot;crypto&quot; is not defined 或者 crypto.randomUUID is not a function。 这个API使用起来就很方便了，直接 crypto.randomUUID() 就可以了。 crypto.randomUUID() // &#x27;40b3b1a6-dc1b-477a-bcb8-cadd550a7768&#x27; 从文档上面看到 crypto.randomUUID() 生成的 UUID 是 v4 版本的，所以在客户端浏览器普遍比较高的项目里面可以直接用了，比自己写规则或者引入 UUID 这个依赖更方便，生成速度也更快。 👀 一些问题#1. crypto.randomUUID() 生成的 UUID 出现重复的概率？ 碰撞机率： p(n) ≈ 1 - e-n2&#x2F;2x 246 个UUID当中，出现重复的概率为 4x10-16 （0.0000000004）。 所以使用 crypto.randomUUID() 不会有出现重复的情况，放心大胆用就行。如果是使用 Math.random() 和一定规则创建的 UUID 可能同时创建多条 UUID 的时候会有问题了，特别是一些为了兼容低版本的场景下。 #2. 是否可以在生产环境使用这个API？看情况，如果你的项目需要兼容低版本的客户端，那么就不能使用，还是需要使用 UUID 这个依赖项。如果只是面向自动更新的现代浏览器用户群体，那么就可以直接使用。像我厂都是用的 Chrome 和 Edge 所以未来我多半会在项目内应用起来。 有一些情况下浏览器更新到最新版本了，开发时没有问题。但是部署到线上环境时就会提示 crypto.randomUUID is not a function。多半是由于项目没有开启HTTPS导致的。 #3. NodeJS 是否也有 crypto.randomUUID() 这个API？有，从 14.17.0 开始就有 crypto.randomUUID() 这个方法了。 From version 14.17.0, a similar method is available as crypto.randomUUID(). 相关阅读Crypto.randomUUID() - Web API | MDN“randomUUID” | Can I use… Support tables for HTML5, CSS3, etcCrypto | Node.js v19.4.0 DocumentationCrypto | Node.js v14.21.2 Documentation UUID vs Crypto.randomUUID vs NanoID | Medium","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"}]},{"title":"使用 CSS 滤镜将站点置灰以及把如何排除图片","slug":"use-css-filter-remove-page-color","date":"2022-12-02T06:34:16.000Z","updated":"2026-01-05T05:39:58.518Z","comments":true,"path":"2022/use-css-filter-remove-page-color/","permalink":"https://yogwang.site/2022/use-css-filter-remove-page-color/","excerpt":"因为长者的逝世，最近不断有同学在问：应该怎么做站点置灰(去色)的需求。一般来说我都会转发张鑫旭大佬的 《小tip: 使用CSS将图片转换成黑白(灰色、置灰)》 这篇文章给对方，文章内详细的描述了应该如何处理。虽然 filter 属性还是草案阶段，但是几乎所有的现代浏览器都有很好支持，所以可以直接使用 html&#123;filter: grayscale(100%)&#125; 来实现这个需求。 但是今天在社区里面看到有人提到了这样的一个问题请教css网站置灰，排除图片的问题？，需求是使用 filter: grayscale(100%) 使全站置灰之后，如何排除网站中的图片的置灰。 一开始我认为这个需求有一些点不合理，随即答复了可以按照区块去实现置灰，如果要实现这样的需求需要通过遍历来实现，并让他去和PM沟通，具体为什么要实现这样的方式。但是后来有人补充了通过 :not() + :has() 伪类选择器实现的方式，但是还是有一定兼容性问题的。（FireFox 还未支持 :has() 伪类选择器_2022年12月）","text":"因为长者的逝世，最近不断有同学在问：应该怎么做站点置灰(去色)的需求。一般来说我都会转发张鑫旭大佬的 《小tip: 使用CSS将图片转换成黑白(灰色、置灰)》 这篇文章给对方，文章内详细的描述了应该如何处理。虽然 filter 属性还是草案阶段，但是几乎所有的现代浏览器都有很好支持，所以可以直接使用 html&#123;filter: grayscale(100%)&#125; 来实现这个需求。 但是今天在社区里面看到有人提到了这样的一个问题请教css网站置灰，排除图片的问题？，需求是使用 filter: grayscale(100%) 使全站置灰之后，如何排除网站中的图片的置灰。 一开始我认为这个需求有一些点不合理，随即答复了可以按照区块去实现置灰，如果要实现这样的需求需要通过遍历来实现，并让他去和PM沟通，具体为什么要实现这样的方式。但是后来有人补充了通过 :not() + :has() 伪类选择器实现的方式，但是还是有一定兼容性问题的。（FireFox 还未支持 :has() 伪类选择器_2022年12月） 其实就是通过我说的遍历匹配所有的元素，只是他通过了 :not(:has 去匹配了所有后代不包含 img 元素的所有元素。只不过 :has() 我只是粗略的看了一下张大佬早些时候些的相关文章，还不知道可以去搭配 :not() 来实现这样的效果。果然CSS需要脑洞大开啊，未来可能单独去写以下 :has() 和 :not() 两个伪类选择器的笔记。 好了废话不多说，直接贴上来实现的代码： :not(:has(img)):not(img) &#123; filter: grayscale(1); &#125; 所以其实不只是图片元素，其它的 canvas 和 video 元素也是可以的是使用这样的方法的。 你们也可以通过点击下方的这写按钮来体验效果。 页面全部都置灰 页面置灰，但排除图片元素 #test label { display: inline-flex; align-items: center; cursor: pointer; } #test label input { margin-right: 5px; } .gray-filter { filter: grayscale(1); } .gray-filter-exclude-img :not(:has(img)):not(img) { filter: grayscale(1); } $(\"#html-filter\").click(function(e){ if(e.target.checked) return $(\"html\").addClass(\"gray-filter\") $(\"html\").removeClass(\"gray-filter\") }) $(\"#exclude-img\").click(function(e){ if(e.target.checked) return $(\"html\").addClass(\"gray-filter-exclude-img\") $(\"html\").removeClass(\"gray-filter-exclude-img\") }) 这个效果我是通过 jQuery 来动态给 html 元素添加了一个CSS类名，CSS的代码是这样的： // 全部置灰 .gray-filter &#123; filter: grayscale(1); &#125; // 排除图片元素之外全部置灰 .gray-filter-exclude-img :not(:has(img)):not(img) &#123; filter: grayscale(1); &#125; ✍ 尾声下班之后在家里补完这篇文章的时候，发现了张大佬已经把这个如何实现除了图片以外都置灰的处理方法补充上来了。看了一下回复的时间，应该当初在思否问答贴内回复这个方法的人也是从这里看到的，我看描述的文案都是一样的。 好了，希望可以帮助到一些需要的同学。 相关阅读filter - CSS: Cascading Style Sheets | MDN:has() - CSS: Cascading Style Sheets | MDN:not() - CSS: Cascading Style Sheets | MDNCSS Filter Effects | Can I use:has() CSS relational pseudo-class | Can I use 请教css网站置灰，排除图片的问题？ - SegmentFault 思否小tip: 使用CSS将图片转换成黑白(灰色、置灰) « 张鑫旭-鑫空间-鑫生活来了，来了，CSS :has()伪类她来了 « 张鑫旭-鑫空间-鑫生活","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://yogwang.site/tags/CSS/"},{"name":"挖坑","slug":"挖坑","permalink":"https://yogwang.site/tags/%E6%8C%96%E5%9D%91/"}]},{"title":"记 RegExp.test() 方法使用全局匹配时一会返回 true 一会返回 false 的问题","slug":"regular-test-with-global-respectively-return-true-and-false","date":"2022-11-30T09:20:37.000Z","updated":"2026-01-05T05:39:58.514Z","comments":true,"path":"2022/regular-test-with-global-respectively-return-true-and-false/","permalink":"https://yogwang.site/2022/regular-test-with-global-respectively-return-true-and-false/","excerpt":"今天小伙伴问了一个奇怪的问题，他在使用 RegExp.test() 方法时使用全局匹配时会依次返回 true 和 false 的现象。比如说: var t = /#/g t.test(&quot;#&quot;) // true t.test(&quot;#&quot;) // false t.test(&quot;#&quot;) // true t.test(&quot;#&quot;) // false 我一开始以为是他正则写的不对，让他把其它的匹配规则都去掉再试试，结果问题还是依旧。后来让他把 /g 的 g 去掉试了下发现没问题了。但还是没有怀疑到全局匹配的问题上，以为是他哪里覆写掉了的 test() 方法。让他使用空白页测试，依旧有这样的问题。","text":"今天小伙伴问了一个奇怪的问题，他在使用 RegExp.test() 方法时使用全局匹配时会依次返回 true 和 false 的现象。比如说: var t = /#/g t.test(&quot;#&quot;) // true t.test(&quot;#&quot;) // false t.test(&quot;#&quot;) // true t.test(&quot;#&quot;) // false 我一开始以为是他正则写的不对，让他把其它的匹配规则都去掉再试试，结果问题还是依旧。后来让他把 /g 的 g 去掉试了下发现没问题了。但还是没有怀疑到全局匹配的问题上，以为是他哪里覆写掉了的 test() 方法。让他使用空白页测试，依旧有这样的问题。 所以应该就是全局匹配的问题。检索了以下相关问题，发现正则表达式使用了 g 全局检索是，其会内置一个 lastIndex 属性，并且这个属性并不会被重置，会在下一次使用时保留（如果index值小于或等于字符串长度时） 其实在 MDN 文档上面也提到了这个问题 Using test() on a regex with the “global” flag const regex = /foo/g; // the &quot;global&quot; flag is set // regex.lastIndex is at 0 regex.test(&quot;foo&quot;); // true // regex.lastIndex is now at 3 regex.test(&quot;foo&quot;); // false // regex.lastIndex is at 0 regex.test(&quot;barfoo&quot;); // true // regex.lastIndex is at 6 regex.test(&quot;foobar&quot;); // false // regex.lastIndex is at 0 regex.test(&quot;foobarfoo&quot;); // true // regex.lastIndex is at 3 regex.test(&quot;foobarfoo&quot;); // true // regex.lastIndex is at 9 regex.test(&quot;foobarfoo&quot;); // false // regex.lastIndex is at 0 // (...and so on) 所以可以通过每次调用后重置掉 lastIndex 值，比如说： var t = /#/g t.test(&quot;#&quot;) // true t.lastIndex = 0 t.test(&quot;#&quot;) // true t.lastIndex = 0 t.test(&quot;#&quot;) // true t.lastIndex = 0 但是我觉得很不优雅，可以使每次一都使用新的正则，或者封装在一个方法内来避免 /#/g.test(&quot;#&quot;) // true /#/g.test(&quot;#&quot;) // true /#/g.test(&quot;#&quot;) // true function fn(str)&#123; const regex = /#/g return regex.test(str) &#125; fn(&quot;#&quot;) // true fn(&quot;#&quot;) // true fn(&quot;#&quot;) // true 其实直接去掉 g 全局匹配的标识就可以了，因为大部分的时间，我们只是想要去测试一下字符串是否匹配我们预设规则而已。 同时大多数的时候我们并不会遇到这样的情况，因为书写在函数内是我们使用最多的情况，写在全局或者函数外部其实使很少见的。 相关阅读RegExp.prototype.test() - JavaScript | MDNRegExp: lastIndex - JavaScript | MDN为什么使用正则test( )第一次是 true,第二次是false？ - Andy_alone - 博客园","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"}]},{"title":"Set & Map 数据结构是无法被 Vue 监听的","slug":"vue-set-and-map-is-not-listened-data","date":"2022-09-14T08:45:06.000Z","updated":"2026-01-05T05:39:58.522Z","comments":true,"path":"2022/vue-set-and-map-is-not-listened-data/","permalink":"https://yogwang.site/2022/vue-set-and-map-is-not-listened-data/","excerpt":"这次在写业务的时候因为是无限层级的递归表单，用了 provide/inject 来暴露注册以便收集数据。所以就想要用 Map 数据结构来处理数据的收集等等功能。直接使用 记录ID 作为键名就可以了，这样也可以直接去重。但是写完了业务代码之后发现我把后代的表单注册进来并没有触发响应，导致数据回填失败。 所以想着是不是 Vue 2x 无法监听 Map 或者 Set 的数据变更的。就去检索了一下相关的信息，发现 Vue 2x 真的无法监听 Map 以及 Set 俩兄弟。只能够通过修改其他变量来曲线救国。 Vue 3x 通过 Proxy 来代理就没有了这个问题。","text":"这次在写业务的时候因为是无限层级的递归表单，用了 provide/inject 来暴露注册以便收集数据。所以就想要用 Map 数据结构来处理数据的收集等等功能。直接使用 记录ID 作为键名就可以了，这样也可以直接去重。但是写完了业务代码之后发现我把后代的表单注册进来并没有触发响应，导致数据回填失败。 所以想着是不是 Vue 2x 无法监听 Map 或者 Set 的数据变更的。就去检索了一下相关的信息，发现 Vue 2x 真的无法监听 Map 以及 Set 俩兄弟。只能够通过修改其他变量来曲线救国。 Vue 3x 通过 Proxy 来代理就没有了这个问题。 想要在 Vue2 中来实现我上面的需求的话： #方法1. 改写成 数组 对象。每次去 find 一下是否已经存在上级元素，然后插入到 child 中，但是对于层级比较深的就不是特别好使了，需要递归才行。所以我先 const list = [] 声明了一个数组对象，同时也 const tmpMapper = new Map() 声明一个 Map 数据对象把这些 一级祖先 .set 进去，因为是同一个引用所以 数组内的数据 和 Map 内的数是同一个，直接修改 Map 内的属性 数组内的元素也会变更。然后开始遍历通过 parentId 关联的平级结构列表，因为是从前往后正序排列的，所以直接通过 tmpMapper.get(item.parentId) 就可以获取到父级了，然后 push 当前元素到父级的 child 当中，同时也 .set 到 tmpMapper 当中。如此往复，这样就可以把通过 parentId 关联的平级结构列表转成树结构了。最后再把 list 赋值给在 data 中提前声明好的数组变量就可以了。 只是后续操作修改的时候都会比较麻烦。不过好在我只有初始化的时候需要这样创建一次就行了。之后通过转换成树状的数组递归渲染即可。 #方法2. 添加一个标识符，在每次操作 Map 对象的时候去给这个标识符 +1，这样通过监听数字标识符的变更来触发更新。一般来说这样都是通过 computed 来把 Map 对象转为数组。因为其实最终在 template 中循环的时候其实也是一个可递归的变量，所以使用 Array.form() 直接转换成数组使用就行了。 data() &#123; mySetChangeTracker: 1, mySet: new Set(), &#125;, computed: &#123; mySetAsList() &#123; // By using `mySetChangeTracker` we tell Vue that this property depends on it, // so it gets re-evaluated whenever `mySetChangeTracker` changes return this.mySetChangeTracker &amp;&amp; Array.from(this.mySet); &#125;, &#125;, methods: &#123; add(item) &#123; this.mySet.add(item); // Trigger Vue updates this.mySetChangeTracker += 1; &#125; &#125; 相关阅读[Feature]: Add support of the iterator protocol (es6) for v-for directive (map, weakset, weakmap) · Issue #1319 · vuejs&#x2F;vuevuejs doesn’t support Sets as backing fields for binding (nor maps, weakmap, weakset reactivity) · Issue #5241 · vuejs&#x2F;vueSupport more collection data types in v-for · Issue #2410 · vuejs&#x2F;vue","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"VueJS","slug":"VueJS","permalink":"https://yogwang.site/tags/VueJS/"}]},{"title":"Vue 中的样式穿透 v-deep、/deep/ 和 >>>","slug":"vue-style-inner-selector-v-deep","date":"2022-09-07T07:11:47.000Z","updated":"2026-01-05T05:39:58.523Z","comments":true,"path":"2022/vue-style-inner-selector-v-deep/","permalink":"https://yogwang.site/2022/vue-style-inner-selector-v-deep/","excerpt":"在 Vue 项目的开发中，很多人都因为想要限制 CSS 样式的作用范围（避免样式污染的问题）去使用 scope 属性。 但是很多的情况下都会去修改分装好的子组件以及UI库中的组件样式，所以经常会用到 样式穿透 这个东西，因为我以前是使用的 Stylus 作为样式预处理器的，所以并没有感觉到什么困惑的地方，但是有很多同学是使用的 Scss 以及 Less 的，对于他们来说什么时候使用 /deep/ 什么时候使用 ::v-deep 是很困扰的。特别是对于一些刚刚进入前端圈的小伙伴们。 正好最近在思否也遇到了很多人来问这样的问题，就像一次性都把相关的疑问都回答了。","text":"在 Vue 项目的开发中，很多人都因为想要限制 CSS 样式的作用范围（避免样式污染的问题）去使用 scope 属性。 但是很多的情况下都会去修改分装好的子组件以及UI库中的组件样式，所以经常会用到 样式穿透 这个东西，因为我以前是使用的 Stylus 作为样式预处理器的，所以并没有感觉到什么困惑的地方，但是有很多同学是使用的 Scss 以及 Less 的，对于他们来说什么时候使用 /deep/ 什么时候使用 ::v-deep 是很困扰的。特别是对于一些刚刚进入前端圈的小伙伴们。 正好最近在思否也遇到了很多人来问这样的问题，就像一次性都把相关的疑问都回答了。 💡 我想要书写样式穿透的时候应该怎么办？在 Vue2 版本中： 如果你是使用的 Stylus 以及 CSS 那么不用考虑直接使用 CSS 所支持的 &gt;&gt;&gt; 来穿透就可以了。 如果说你使用的是 Less 以及 Sass 的话，那么推荐使用 ::v-deep 来实现样式穿透的效果。 为什么不使用 /deep 呢，因为现在的 Sass 默认安装的是 dart-sass 如果你使用 /deep/ 会提示错误：SassError: expected selector. /deep/，所以直接使用 ::v-deep 预防可能会出现的问题。 并且最好不要直接使用 ::v-deep 等样式穿透来书写，比如说： &lt;style scoped lang=&quot;scss&quot;&gt; ::v-deep .className &#123; ... &#125; &lt;/style&gt; 这样的话，其实就和你没有添加 scope 的结果是一样的了，并不会只限制在当前组件内。而会污染到全局样式当中。并且直接使用 /deep/ .className 可能无法通过 loader 的编译。 如果说你使用的是 Vue3 的话，就需要把 ::v-deep 替换成 :deep() 了 💡 如果是添加到 body 元素上的组件怎么办，比如说 el-dialog 这种弹窗组件。一般都会提供一个 custom-class 给你使用，可以借助这个来起一个 className 来给它们添加样式，或者可以直接使用 class 来给当前页面中的弹窗元素起一个CSS类名。然后写在全局就可以了，没有必要通过样式穿穿透来覆写。当然也可以写在 scope 内，因为第一级会被添加上当前组件的 hash 值。来起到限制作用域的要求。 相关阅读Scoped CSS | Vue Loaderrfcs&#x2F;0023-scoped-styles-changes.md at master · vuejs&#x2F;rfcsvue 深度选择器前世今生 - guangzan - 博客园","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"VueJS","slug":"VueJS","permalink":"https://yogwang.site/tags/VueJS/"}]},{"title":"Vue中接收没有声明的Prop属性[null/undefined]的接收问题","slug":"vue-props-type-validation-with-Null-and-undefined","date":"2022-08-29T01:59:42.000Z","updated":"2026-01-05T05:39:58.522Z","comments":true,"path":"2022/vue-props-type-validation-with-Null-and-undefined/","permalink":"https://yogwang.site/2022/vue-props-type-validation-with-Null-and-undefined/","excerpt":"最近在写基础组件，同事一直反馈说组件总是提示警告： [Vue warn]: Invalid prop: type check failed for prop &quot;value&quot;. Expected String, Array, got Null 一开始以为是接收的问题，把定义的props加上了工厂函数后没有报异常就没再管了。今天再去看的时候发现还是有报错，检查了一下组件代码没发现问题，在查看业务代码的时候发现同事喜欢给声明的变量默认赋值为 null。而不是声明正确的基础类型。所以我就想应该如何把这个问题彻底解决掉。 🔔 其实这个提示为了提醒可能你绑定的变量并不一定存在。","text":"最近在写基础组件，同事一直反馈说组件总是提示警告： [Vue warn]: Invalid prop: type check failed for prop &quot;value&quot;. Expected String, Array, got Null 一开始以为是接收的问题，把定义的props加上了工厂函数后没有报异常就没再管了。今天再去看的时候发现还是有报错，检查了一下组件代码没发现问题，在查看业务代码的时候发现同事喜欢给声明的变量默认赋值为 null。而不是声明正确的基础类型。所以我就想应该如何把这个问题彻底解决掉。 🔔 其实这个提示为了提醒可能你绑定的变量并不一定存在。 可以看到 Vue 官方提供的文档中明确提到了: null 和 undefined 会通过任何类型验证 但是实际上如果你给 props 属性声明了必填（required） 的话，那么 null 将无法通过类型验证。 尤大也在相关的Issue里面说明了这个情况： This is because your prop doesn’t have required: true. For optional props, null will bypass the type check.yyx990803 - Issue #6768 · vuejs&#x2F;vue 所以要解决我开头的这个问题，只要把 required 声明去掉就可以了。但是如果我确实需要这个属性必填呢，那么就没办法了需要你在父级声明合法默认值或者直接不声明。因为在没有声明具体属性的时会传入的时 undefined，而 undefined 是会使用预设的默认值的。 👀 尾声既然提了那么就说一下 null 和 undefined 的一些区别。 首先是如果你声明了属性为必填，那么 null 将无法通过类型校验并且在控制台警告 Invalid prop。 而 undefined 则有些不一样: 如果你设置了默认值，那么将会使用预设的默认值，并且可以通过类型校验。 如果没有设置默认值，那么将无法通过类型校验，并且与 null 一样在控制台提示异常: [Vue warn]: Invalid prop: type check failed for prop &quot;value&quot;. Expected String, Array, got Undefined 按照尤大的原话的话: null indicates the value is explicitly marked as not present and it should remain null. undefined indicates the value is not present and a default value should be used if available. required: true indicates neither null or undefined are allowed (unless a default is used) 从源码层面也可以看到 value === undefined 时才会去获取声明的默认值。 文档资源#props | API — Vue.jsProp — Vue.js VueJS Using Prop Type Validation With NULL and ‘undefined’ Values? - Stack OverflowVue Prop中的 null vs undefined_PrinciplesMan的博客-CSDN博客No warning when string property value is `null` · Issue #6768 · vuejs&#x2F;vuevue的props接收object类型的变量，当该变量为null的时候默认值是不生效的吗？ - SegmentFault 思否vue&#x2F;props.ts at d6bdff890322bc87792094a1690bcd16373cf82d · vuejs&#x2F;vue","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"VueJS","slug":"VueJS","permalink":"https://yogwang.site/tags/VueJS/"}]},{"title":"聊一个复用组件中使用debounce时遇到的问题","slug":"vue-reused-components-debounce-problem","date":"2022-08-26T05:19:55.000Z","updated":"2026-01-05T05:39:58.522Z","comments":true,"path":"2022/vue-reused-components-debounce-problem/","permalink":"https://yogwang.site/2022/vue-reused-components-debounce-problem/","excerpt":"今天我中遇到了一个这样的场景，发现触发复用的自定义组件中添加了防抖的函数，发现只执行了一次，并没有如预期的那样每个组件内的函数都执行一次。 一开始以为是没有同步赋值，检查了一下没问题，才把关注点转移到 debounce 上面。移除防抖之后果然解决问题了，但防抖又不能去去掉。 所以查了一下相关的问题，发现是因为多个组件实例是共享同一个预置防抖的函数，并不是相互独立的。","text":"今天我中遇到了一个这样的场景，发现触发复用的自定义组件中添加了防抖的函数，发现只执行了一次，并没有如预期的那样每个组件内的函数都执行一次。 一开始以为是没有同步赋值，检查了一下没问题，才把关注点转移到 debounce 上面。移除防抖之后果然解决问题了，但防抖又不能去去掉。 所以查了一下相关的问题，发现是因为多个组件实例是共享同一个预置防抖的函数，并不是相互独立的。 一直以来都是直接如 Vue 文档中演示的这样来写的，加上请求接口就会是下面这样： import debounce from &quot;lodash.debounce&quot;; import &#123; remoteSearchAPI &#125; from &#x27;xxxx&#x27;; export default &#123; // ... methods: &#123; remoteMethod: debounce(function (value = &quot;&quot;) &#123; const params = &#123; keywords: value, &#125;; this.fetching = true; remoteSearchAPI(params) .then((res) =&gt; &#123; // ... &#125;) .finally(() =&gt; &#123; this.fetching = false; &#125;); &#125;, 350, &#123; maxWait: 1000 &#125;), &#125;, &#125;; 这样写的话就会有一个问题： 这种方法对于被重用的组件来说是有问题的，因为这个预置防抖的函数是 有状态的：它在运行时维护着一个内部状态。如果多个组件实例都共享这同一个预置防抖的函数，那么它们之间将会互相影响。响应式基础 | Vue.js # 那么如何解决这个问题呢？Vue的文档中也给出了相应的解决方案。 要保持每个组件实例的防抖函数都彼此独立，我们可以改为在 created 生命周期钩子中创建这个预置防抖的函数： export default &#123; created() &#123; // 每个实例都有了自己的预置防抖的处理函数 this.debouncedClick = _.debounce(this.click, 500) &#125;, unmounted() &#123; // 最好是在组件卸载时 // 清除掉防抖计时器 this.debouncedClick.cancel() &#125;, methods: &#123; click() &#123; // ... 对点击的响应 ... &#125; &#125; &#125; 参考资源vue 踩坑小记 - 如何正确的使用 debounce#有状态方法 响应式基础 | Vue.js","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"VueJS","slug":"VueJS","permalink":"https://yogwang.site/tags/VueJS/"}]},{"title":"CSS实现毛玻璃效果的一种新方式","slug":"CSS-frosted-glass","date":"2022-07-26T13:00:21.000Z","updated":"2026-01-05T05:39:58.454Z","comments":true,"path":"2022/CSS-frosted-glass/","permalink":"https://yogwang.site/2022/CSS-frosted-glass/","excerpt":"今天在逛V站看到一个自推UI组件库的帖子，我觉得很不错，在查看组件样例的时候呢，发现了他的抽屉组件的遮罩可以把整个页面添加毛玻璃效果！我就很惊讶。马上就 F12查看了一下他的实现方式，因为在我映像里还没有一个很简单的的可以直接实现背景元素毛玻璃效果的方式。 其实不光是抽屉组件，其它的一些类 Modal 带有遮罩的组件都有这个毛玻璃的效果，大伙可以点点看看。 好了，不多废话直接开始正题。","text":"今天在逛V站看到一个自推UI组件库的帖子，我觉得很不错，在查看组件样例的时候呢，发现了他的抽屉组件的遮罩可以把整个页面添加毛玻璃效果！我就很惊讶。马上就 F12查看了一下他的实现方式，因为在我映像里还没有一个很简单的的可以直接实现背景元素毛玻璃效果的方式。 其实不光是抽屉组件，其它的一些类 Modal 带有遮罩的组件都有这个毛玻璃的效果，大伙可以点点看看。 好了，不多废话直接开始正题。 CodePen 上的 原 Demo 写的比较杂乱，有很多无关的样式内容，我简化处理了一下。 早年最初的毛玻璃效果就是上面的 Demo 这样的，先在外部容器上添加背景图，并且在当前 “窗口” 上设置一样的背景图，再利用 filter: blur() 属性模糊遮罩层的背景。 但是这个会有一个问题，就是需要把滤镜属性 filter: blur() 设置在一个单独的背景元素或者伪类上，不然会把 窗口 内部的内容也给模糊了。并且会受限制这个我们在后面说。 而是使用新滤镜属性 backdrop-filter: blur() 后的呢，就十分的简单了，可以看下方 演示Demo： 可以看到，比最初的毛玻璃实现方式少了一个伪类元素，并且他会直接把遮住的部分添加滤镜效果，不需要考虑被遮住的内容了，也不会影响内部元素。也就是说可以“不受限制”的实现毛玻璃效果。例如在文章最开始提到的，给整个页面元素都加上遮罩。 这在以前只能通过 canvas 成当前页面快照的方式生来实现，可以很明显的感觉到早些时候投入和回报的不成比例，但是现在使用 filter: blur() 可以很轻松的就实现了，投入产出比极高！ 😍 那这么棒的CSS属性是什么时候被提出的呢？从张鑫旭大佬的 《CSS新世界》 中了解到： 毛玻璃效果在前端圈形成讨论是在 iOS 7 面世的时候，和高斯模糊不同，毛玻璃的效果不是让当前元素模糊，而是让当前元素所在区域后面的内容模糊…… iOS 7 面世两年后，iOS 9 支持了一个名为 backdrop-filter 的 CSS 属性，它可以非常方便的实现毛玻璃效果….. 可以看到因为苹果提出的特性，所以在 Safari 上的实现会很早（iOS 9 也就是说 2015 年就已经支持了 😱），之后其他浏览器对于该属性的支持都是在 2019 年左右。 关于使用方面，虽然还是处于草案阶段，但是各个现代浏览器已经不同程度的支持了这个属性（2022年07月26日）： Chrome 76+ 、 Edge 17+ 和 Opera 63+ 已经完美支持(Full support)， Safari 9+ 和 iOS Safari 9+ 需要使用 -webkit- 前缀； Firefox 70+ 比较特别需要打开 layout.css.backdrop-filter.enabled 和 gfx.webrender.all 首选项才行； 一般不会有问题，所以请大家放心。不过最好的实现呢，还是先给元素设置一个半透明的背景色再加上这个 backdrop-filter 属性，这样即使用户的浏览器太陈旧不支持这个属性或者使用的是 Firefox，也可以看到半透明的背景来兜底。 具体也可以查看 MDN 上该属性对于各浏览器兼容度的说明。 以至于为什么唯独 Firefox 有些问题，应该是早些版本的时候 WebRender 引发的一个BUG，所以一直没有默认启用。我现在看帖子内还在讨论所以短期内无望了（优先级也已经从P1降为P3）。可以看这篇BUG反馈贴了解。 文章最后推荐一下那位同学肝的UI组件库，我觉得挺不错的，大伙可以去点个Star打个Call。 👉 Lew Design 如果不是他的组件库，我到现在都不知道已经有一个那么简单好用可以实现毛玻璃效果的CSS属性了。 最后的最后，张大佬在他的新书中提了一嘴： 限制 backdrop-filter 属性大规模使用的唯一因素就是性能。如果你的页面非常复杂，有很多动画和频繁的交互行为，则 backdrop-filter 属性可能会造成卡顿，此时就需要酌情使用。 📚 文档filter - CSS | MDNbackdrop-filter - CSS | MDNFilter Effects Module Level 2 | W3C Editor’s Draft CSS backdrop-filter简介与苹果iOS毛玻璃效果 « 张鑫旭-鑫空间-鑫生活CSS - Frosted Glass | CodePenCSS - Frosted Glass - Simplified | CodePenLew Design Enable the CSS backdrop-filter property by default (letting it ride the trains to release)","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://yogwang.site/tags/CSS/"}]},{"title":"使用Alt+Tab切换窗口时会显示Edge打开的所有页签","slug":"MSEdge-alt-tab-display-all-browser-tabs","date":"2022-07-25T01:27:03.000Z","updated":"2026-01-05T05:39:58.477Z","comments":true,"path":"2022/MSEdge-alt-tab-display-all-browser-tabs/","permalink":"https://yogwang.site/2022/MSEdge-alt-tab-display-all-browser-tabs/","excerpt":"自从入职新公司之后默认浏览器是 Edge 一直都没有切换，发现一个事情就是每次使用 Alt+Tab 切换应用的时候总是会把当前 Edge 打开的网页都展示出来，就很麻烦。明明我应用内使用 Ctrl+Tab&#x2F;Ctrl+Shift+Tab 就可以前后切换页签。不知道为啥就要把单个页签也当成一个应用来展示，所以就想关闭这个功能。 一开始想当然的从 Edge 的设置内，但是找了一圈没有找到。就去问度娘了，发现是要从系统设置里去修改的。操作步骤为： 在桌面右键后选择 显示设置 然后在侧边栏找到 多任务处理 选项 将 按Alt + Tab将显示 项修改成 仅打开的窗口 即可。","text":"自从入职新公司之后默认浏览器是 Edge 一直都没有切换，发现一个事情就是每次使用 Alt+Tab 切换应用的时候总是会把当前 Edge 打开的网页都展示出来，就很麻烦。明明我应用内使用 Ctrl+Tab&#x2F;Ctrl+Shift+Tab 就可以前后切换页签。不知道为啥就要把单个页签也当成一个应用来展示，所以就想关闭这个功能。 一开始想当然的从 Edge 的设置内，但是找了一圈没有找到。就去问度娘了，发现是要从系统设置里去修改的。操作步骤为： 在桌面右键后选择 显示设置 然后在侧边栏找到 多任务处理 选项 将 按Alt + Tab将显示 项修改成 仅打开的窗口 即可。 也可以通过以下两种方式打开 使用快捷键（Win + i）打开 Windows设置： 在 查找设置 中键入 alt，选择 选择按下Alt+Tab时显示的窗口和选项卡 选项； 点击 系统 卡片，在侧边栏找到 多任务处理 选项； 将 按Alt + Tab将显示 项修改成 仅打开的窗口 。 这个属性是 Win10 20H2 版本带来的，但是我自己一直使用的都是 Chrome 就一直没有发现。记录一下方便其他也遇到这样困扰的人解决问题吧。 文档How to customize Alt + Tab for Microsoft Edge open tabs on Windows 10 October 2020 Update | Windows Central","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"MSEdge","slug":"MSEdge","permalink":"https://yogwang.site/tags/MSEdge/"}]},{"title":"HTML API + CSS 控制页面打印内容和样式","slug":"html-css-ctrl-page-print","date":"2022-07-22T08:35:21.000Z","updated":"2026-01-05T05:39:58.490Z","comments":true,"path":"2022/html-css-ctrl-page-print/","permalink":"https://yogwang.site/2022/html-css-ctrl-page-print/","excerpt":"本周来了一个新的需求，需要前端生成打印内容，每一项数据占据一张 A4 纸，选择多项就是分多张打印，所以需要打印指定内容区域，并且使用 page-break 来控制打印区域的分页。以前就只使用 CSS 控制过打印时样式，隐藏一些不需要打印的区域，还尝没有试过打印指定区域内容，并且控制打印内容强制分页，所以记录一下。","text":"本周来了一个新的需求，需要前端生成打印内容，每一项数据占据一张 A4 纸，选择多项就是分多张打印，所以需要打印指定内容区域，并且使用 page-break 来控制打印区域的分页。以前就只使用 CSS 控制过打印时样式，隐藏一些不需要打印的区域，还尝没有试过打印指定区域内容，并且控制打印内容强制分页，所以记录一下。 #1 选择打印区域局部打印的方式据我了解到的有三种： 通过开始、结束标记来控制打印范围； &lt;!--startprint--&gt; 和 &lt;!--endprint--&gt; 通过把局部内容赋值给body，打印整个页面，而后再把原页面内容重复覆盖回来； 通过动态创建&lt;iframe&gt;来打印；window.print()局部打印三种方式 - 硅谷工具人 比较推荐的是第一种和第三种方法。不过我选择去NPM上找一个现成的轮子 😁。其实也不是我找的，其实小伙伴再之前已经做完了局部打印功能，只是后来提了新的需求这回要求打印内容的样式，所以由我来接手了。选择的库是 vue-print-nb，我看了一下源码其实现方式是上面提到的第三种。 首先通过 documentCreateElement(&#39;iframe&#39;) 创建一个 &lt;iframe&gt; 元素；再通过 document.getElementById() 拿到需要打印的区域内容，同时把获取到需要打印的区域内容通过 Node.cloneNode() 复制到创建的 &lt;iframe&gt; 当中；最后用 window.print() 这个API打开打印对话框打印当前文档，就可以实现打印原先指定的区域内容了。 更详细的方法可以查看仓库源码或者查看文章尾部的参考资源中的对应文章，我这里就不现学现卖了。 #2 配置页面打印样式通过 CSS 的 @page 规则可以控制打印时的页面样式，但是可配置的内容不多。 @page 规则用于在打印文档时修改某些 CSS 属性。你不能用 @page 规则来修改所有的 CSS 属性，而是只能修改 margin,orphans,widow 和 page breaks of the document。对其他属性的修改是无效的。@page - MDN 暂时我能用到的就只有 margin 、 size 以及 page-break 了，使用方式很简单和正常的CSS一样使用，例如： @page &#123; margin: 1cm; // 设置打印页边距； size: A4 portrait; // 指定打印时纸张大小和方向 break-after: page; // 分页属性 &#125; 可以把 @page 规则理解成打印时的对象去设置，并不和 @media print 相似。并且我在尝试使用 size 指定纸张的大小时（别名）， Chrome、 FireFox 和 Edge 都没有生效。指定纸张方向是可以的。 使用别名指定纸张大小时， Edge 中甚至影响到了 margin 属性的生效，所以最好 size 只指定方向 (2022 年 7 月 25 日)。 使用具体数值指定纸张大小时，Chrome 和 FireFox 中指定的纸张方向失效了 (2022 年 7 月 25 日)。 简单配置一下页面打印样式，然后开始写打印内容样式。因为实际上可以配置的属性真的不多，而且各浏览器支持的程度也参差不齐，如果高定制化的话会很容易自闭。 #3 页面内容样式这块内容就是正常写CSS样式了，有一部分在打印时的特殊样式搭配使用 @media print 来匹配就可以了，一遍调整一边使用浏览器的打印预览功能查看实际效果即可，所以就不赘述了。 #4 分页打印内容分页的话，使用在前文中提到的 page-break，给占据整页&#x2F;整块区域的内容增加 break-before 或者 break-after 属性即可。也可以给单独的类似 &lt;hr /&gt; 这样的水平线元素增加 page-break 属性。然后再搭配 @media print 给水平线在打印时隐藏，这样的话可以在查看页面的时候就知道哪些部分他会分页，并且在打印时也不会印象打印内容排版。 注意：如果要在打印时隐藏 &lt;hr/&gt; 元素并且保持分页功能，需要使用 visibility: hidden; 来隐藏，不能使用 display:none 不然分页属性不会生效。 💥 遇到问题1. 使用 page-break-after 是内容分页但在打印时不生效因为 page-break-after 被 break-after 替代了。相对应的 page-break-before 也被 break-before 属性替代了。也有可能是因为你的值设置错了，设置为 page 就好了。 常规中断值有：auto,avoid,always,all; 分页使用的值有：avoid-page,page,left,right,recto,verso; 分栏使用的值有：avoid-column,column; 分区使用的值有：avoid-region,region;《CSS新世界》 我看张鑫旭大佬说 region 相关的属性现代浏览器已经不再支持了，所以可以忽略。 2. 设置的背景色没有被打印。因为默认打印页面时为了节约墨水，所以默认情况下是不会打印背景色的，如果希望打印的时候保留背景色可以只用 color-adjust 属性来控制。 但 color-adjust 属性并非一个标准属性，所以在使用时需要查看一下各浏览器的兼容程度。有的浏览器需要增加私有前缀（比如 -webkit-print-color-adjust)。 3. 打印页面的时候，在打印预览窗口选择了彩色模式但是实际打印出来还是黑白的。浏览器弹出的打印预览设置了彩色模式，并不一定代表了打印机设置的首选项内是彩色的，可以打开对应的打印机查看首选项设置内的色彩模式是否为彩色。具体步骤为： 在打印预览弹窗内点击 使用系统对话框打印； 如果没有该项，可在浏览器中使用 Ctrl+Shift+P 的组合键打开 在弹出的打印窗口中找到对应的打印机设备，点击首选项； 选择纸张&#x2F;输出卡片，找到色彩模式修改为彩色； 最后点击确定保存并应用设置，再点击打印尝试打印； 尾声现在很多和打印相关的规则和API还都是草案，很多规则都没有固定下来成为标准，不同的浏览器也有自己的实现方式，有些属性还是部分支持（比如：size 属性）或者需要私有前缀。尽量先查看一下最新的文档，不要照搬笔记或者文章，因为谁也不知道啥时候就改变了，我在写这篇笔记时看到草案的修订时间是 2022年5月24日，不知道你们看到的时候会是第几个版本了。 那就这样吧，以上。 📚 文档Paged media - CSS | MDN@page - CSS | MDNsize - CSS | MDNpage-break-after - CSS | MDNbreak-after - CSS | MDNprint-color-adjust - CSS | MDNwindow.print - Web API | MDNCSS Paged Media Module Level 3 | W3C Editor’s Draft page-break | CSS-Tricks - CSS-TricksCan I force a page break in HTML printing? - Stack OverflowCSS 打印 - SegmentFault 思否记CSS中break-after的一个坑 - 知乎window.print()局部打印三种方式 - 硅谷工具人 - 博客园window.print()打印时根据页面高度设置居中显示、设置打印布局（纵向、横向）_清云青云的博客 - CSDN","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://yogwang.site/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"https://yogwang.site/tags/HTML/"}]},{"title":"迁移到NVS(NodeVersionSwitcher)来管理NodeJS版本","slug":"NVS-Node-Version-Switcher","date":"2022-07-22T03:37:35.000Z","updated":"2026-01-05T05:39:58.477Z","comments":true,"path":"2022/NVS-Node-Version-Switcher/","permalink":"https://yogwang.site/2022/NVS-Node-Version-Switcher/","excerpt":"最近工作在有信息管控的厂内，配发的电脑是受限用户账户，使用 NVM for Windows 来切换版本的话，会有访问被拒绝的情况，需要使用管理员权限来切换。这在日常工作中会是一件十分麻烦的事情，每次切换版本都需要去找IT Admin授权。 之前刚入职配置开发环境的时候就遇到过使用 NVM4W 切换版本的时候会出现访问被拒绝的问题（提示 exit status 1: Access is denied.），需要管理员权限才可以切换，只不过现在负责的都是新项目不需要切换 NodeJS 的版本，所以当时指定完当前 Node 版本为 LTS 之后就放弃纠结了。 昨天小伙伴也遇到了需要切换版本的情况，我也因为时间间隔太久了就和他说可以使用NVM4W来切换，他尝试之后发现并不行。 正好我手头上也忙完了大部分工作内容就研究了一下如果来解决这个情况。在浏览 NVM4W 的 Discussions 时，看到了 一篇帖子，其中有人提到了 NVS，所以在V2EX提问之后就去了解了一下，以下步骤皆为 Win10 环境下，Mac 及 Linux 可以查看仓库的 README。","text":"最近工作在有信息管控的厂内，配发的电脑是受限用户账户，使用 NVM for Windows 来切换版本的话，会有访问被拒绝的情况，需要使用管理员权限来切换。这在日常工作中会是一件十分麻烦的事情，每次切换版本都需要去找IT Admin授权。 之前刚入职配置开发环境的时候就遇到过使用 NVM4W 切换版本的时候会出现访问被拒绝的问题（提示 exit status 1: Access is denied.），需要管理员权限才可以切换，只不过现在负责的都是新项目不需要切换 NodeJS 的版本，所以当时指定完当前 Node 版本为 LTS 之后就放弃纠结了。 昨天小伙伴也遇到了需要切换版本的情况，我也因为时间间隔太久了就和他说可以使用NVM4W来切换，他尝试之后发现并不行。 正好我手头上也忙完了大部分工作内容就研究了一下如果来解决这个情况。在浏览 NVM4W 的 Discussions 时，看到了 一篇帖子，其中有人提到了 NVS，所以在V2EX提问之后就去了解了一下，以下步骤皆为 Win10 环境下，Mac 及 Linux 可以查看仓库的 README。 💾 安装安装很简单，通过仓库的 releases 直接下载最新的 .msi 文件就可以了，双击运行即可，默认安装到当前用户下（既不会出现受限用户账户的授权弹窗）。 - 原来安装的 NVM4W 和 NodeJS 可以不用卸载，如果有强迫症可以先删除再安装 NVS （发文时最新版本为 v1.6.2 ）。- 记得先查看一下全局依赖项，避免之后因为卸载 NodeJS 之后记不起来装了些什么，如果是维护在外部目录的可以不用管，之后重新设置到旧目录即可。 📥 下载 Node 版本 可以直接在终端键入 nvs 通过终端操作界面来下载和切换Node版本。 使用 nvs ls-remove 查看可用版本后使用 nvs add x.y.z 来下载指定版本。 使用 nvs add lts 通过别名快速下载对应版本，可用别名：lts、latest、Argon 等。 🔓 切换&#x2F;指定 Node 版本 指定当前终端的 Node 版本 nvs use [version] 指定全局环境下的 Node 版本 nvs link [version] 根据项目自动切换 Node 版本 项目目录下如果有 .node-version 或者 .nvmrc，NVS 会自动切换 Node 为指定版本； 文件中直接指定版本号或者别名都可，具体可以查看 doc&#x2F;AUTO Command; 例如直接在文件中键入 lts 并保存。 该功能默认是关闭的，需要手动键入 nvs auto on 打开； 该功能在CMD终端中并不支持，需要在 PowerShell 中使用。 🌏 指定 npm 全局依赖位置一般来说我会直接指定一个外部目录为全局依赖安装目录，这样的话在切换不同版本的 Node 时，不需要重新安装全局依赖了。 NVS 提供了一个 nvs migrate 命令可以指定某一个版本的全局模块，但是这个命令还没接触过就不多阐述了，想要了解的可以直接查看文档。 遇到问题# 使用 nvs ls-remote 查看可用版本时提示超时远程节点切换到阿里镜像就可以了: nvs remote node https://npmmirror.com/mirrors/node/ 📚 文档Node Version Switcher - A cross-platform tool for switching between versions and forks of Node.js科普文：使用 nvs 管理本地 Node.js 版本 - 知乎从 nvm 迁移到 nvs | Unknown Me[node]nvs使用的注意事项 - 掘金在信息管控的厂内如何使用比如说 NVM 之类会执行脚本的工具 - V2EX","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"NVS","slug":"NVS","permalink":"https://yogwang.site/tags/NVS/"},{"name":"Node.js","slug":"Node-js","permalink":"https://yogwang.site/tags/Node-js/"}]},{"title":"AntD of Vue 中 <AForm> 表单域组件化使用的尝试","slug":"antd-aform-magic-usage","date":"2022-07-09T13:04:16.000Z","updated":"2026-01-05T05:39:58.479Z","comments":true,"path":"2022/antd-aform-magic-usage/","permalink":"https://yogwang.site/2022/antd-aform-magic-usage/","excerpt":"最近有一个项目，我发现有一些表单内容高度重复的情况，几张页面的表单虽有些细微差，但还是有很多同样的表单内容，或者 表单域A 和 表单域B 同时出现在一个页面中的这种情况。 我就想着能不能把他们都提出来，单独的做成组件在再使用到这些内容的时直接引入对应的表单域组件，并且可以把下拉菜单的远程查询也放到组件中，这样就会精简点很多重复的代码。","text":"最近有一个项目，我发现有一些表单内容高度重复的情况，几张页面的表单虽有些细微差，但还是有很多同样的表单内容，或者 表单域A 和 表单域B 同时出现在一个页面中的这种情况。 我就想着能不能把他们都提出来，单独的做成组件在再使用到这些内容的时直接引入对应的表单域组件，并且可以把下拉菜单的远程查询也放到组件中，这样就会精简点很多重复的代码。 说做就做嘛，先简单把一个弹出框组件内的表单内容提取出来，然后再引入这个表单域组件。 （因为Vue我没做高亮，所以就暂且用HTML的高亮替代了） &lt;template&gt; &lt;div&gt; &lt;a-form-item label=&quot;客户姓名&quot;&gt; &lt;a-input placeholder=&quot;请输入客户姓名&quot; v-decorator=&quot;[&#x27;name&#x27;, validatorRules.name]&quot; /&gt; &lt;/a-form-item&gt; &lt;a-form-item label=&quot;性别&quot;&gt; &lt;a-radio-group v-decorator=&quot;[&#x27;gender&#x27;, validatorRules.gender]&quot;&gt; &lt;a-radio-button :value=&quot;1&quot;&gt;男&lt;/a-radio-button&gt; &lt;a-radio-button :value=&quot;0&quot;&gt;女&lt;/a-radio-button&gt; &lt;/a-radio-group&gt; &lt;/a-form-item&gt; &lt;a-form-item label=&quot;联系电话&quot;&gt; &lt;a-input placeholder=&quot;请输入客户联系电话&quot; v-decorator=&quot;[&#x27;phone&#x27;, validatorRules.phone]&quot; /&gt; &lt;/a-form-item&gt; &lt;a-form-item label=&quot;备注信息&quot;&gt; &lt;a-input placeholder=&quot;请输入备注信息&quot; v-decorator=&quot;[&#x27;remark&#x27;, validatorRules.remark]&quot; /&gt; &lt;/a-form-item&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default &#123; name:&quot;MemberForm&quot;, data()&#123; return &#123; validatorRules: &#123; name: &#123; rules: [&#123; required: true, whitespace: true, message: &#x27;请填写客户姓名&#x27; &#125;] &#125;, gender: &#123; rules: [], initialValue: 1 &#125;, phone: &#123; rules: [ &#123; required: true, whitespace: true, message: &#x27;请填写客户联系电话&#x27; &#125;, &#123; pattern: /^((0\\d&#123;2,3&#125;-\\d&#123;7,8&#125;)|(1\\d&#123;10&#125;))$/, message: &#x27;请输入正确联系电话! 例：010-8888888/13888888888&#x27; &#125; ] &#125;, remark: &#123; rules: [&#123; max: 120, message:&#x27;备注信息最多为120字&#x27; &#125;] &#125;, &#125; &#125; &#125;, &#125; &lt;/script&gt; &lt;template&gt; &lt;a-modal title=&quot;客户信息&quot; :width=&quot;600&quot; :visible=&quot;visible&quot; :confirmLoading=&quot;confirmLoading&quot; cancelText=&quot;关闭&quot; @ok=&quot;handleOk&quot; @cancel=&quot;handleCancel&quot; &gt; &lt;a-spin :spinning=&quot;confirmLoading&quot;&gt; &lt;a-form :form=&quot;form&quot; :labelCol=&quot;labelCol&quot; :wrapperCol=&quot;wrapperCol&quot;&gt; &lt;MemberFormBase /&gt; &lt;/a-form&gt; &lt;/a-spin&gt; &lt;/-modal&gt; &lt;/template&gt; &lt;script&gt; import pick from &#x27;lodash.pick&#x27; import &#123; getAction, httpAction &#125; from &#x27;@/api/manage&#x27; import MemberFormBase from &#x27;./components/MemberForm&#x27; export default &#123; name: &#x27;MemberEditModal&#x27;, components:&#123; MemberFormBase &#125;, data() &#123; return &#123; visible: false, model: &#123;&#125;, form: this.$form.createForm(this), labelCol: &#123; xs: &#123; span: 24 &#125;, sm: &#123; span: 5 &#125; &#125;, wrapperCol: &#123; xs: &#123; span: 24 &#125;, sm: &#123; span: 16 &#125; &#125;, offsetWrapperCol: &#123; xs: &#123; span: 24 &#125;, sm: &#123; span: 16, offset: 5 &#125; &#125;, confirmLoading: false, url: &#123; add: &#x27;/member/add&#x27;, edit: &#x27;/member/edit&#x27; &#125; &#125; &#125;, methods: &#123; add() &#123; this.edit(&#123;&#125;) &#125;, edit(record) &#123; this.form.resetFields() this.model = Object.assign(&#123;&#125;, record) this.visible = true this.$nextTick(() =&gt; &#123; this.form.setFieldsValue(pick(this.model, &#x27;name&#x27;, &#x27;gender&#x27;, &#x27;phone&#x27;, &#x27;remark&#x27;)) &#125;) &#125;, close() &#123; this.$emit(&#x27;close&#x27;) this.visible = false &#125;, handleCancel() &#123; this.close() &#125;, handleOk() &#123; this.form.validateFields((err, values) =&gt; &#123; if (!err) &#123; this.confirmLoading = true let httpurl = &#x27;&#x27; let method = &#x27;&#x27; if (!this.model.id) &#123; httpurl += this.url.add method = &#x27;post&#x27; &#125; else &#123; httpurl += this.url.edit method = &#x27;put&#x27; &#125; let formData = Object.assign(this.model, values) httpAction(httpurl, formData, method) .then((res) =&gt; &#123; console.log(res) if (res.success) &#123; this.$message.success(res.message) this.$emit(&#x27;ok&#x27;) &#125; else &#123; this.$message.warning(res.message) &#125; &#125;) .finally(() =&gt; &#123; this.confirmLoading = false this.close() &#125;) &#125; &#125;) &#125; &#125; &#125; &lt;/script&gt; 点击提交居然没问题，可以收集到表单数据。有点出乎意料的顺利，我还以为需要调整一些内容，比如说把 $form.createForm 创建的表单 prop 进子组件。 因为使用了 v-decorator 来注册的表单控件，但当前组件并没有 Form 我想这可能会有数据接管的问题。 具体原因呢还没有看到，不过多半是和 Form.create 有关系。等有时间了再确定一下吧。","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Ant-Design-Vue","slug":"Ant-Design-Vue","permalink":"https://yogwang.site/tags/Ant-Design-Vue/"},{"name":"VueJS","slug":"VueJS","permalink":"https://yogwang.site/tags/VueJS/"}]},{"title":"JS中的数字格式化和大位数缩写","slug":"JS-i18n-number-format","date":"2022-06-21T12:42:00.000Z","updated":"2026-01-05T05:39:58.473Z","comments":true,"path":"2022/JS-i18n-number-format/","permalink":"https://yogwang.site/2022/JS-i18n-number-format/","excerpt":"以前因为项目需要 i18n ，一直以来都是自己写了一个格式化函数来处理，会使用 replace 配合正则对数字进行千位分割来展示，并且搭配 Vue.filter 来实现快速格式化。但是对于大位数处理就会比较麻烦了，因为在境内就需要使用 万位分割，大位数使用 万、亿、万亿 来缩，而在英语系国家就会使用 千分分隔，比如说: K、M、B 来缩写数额。 正巧最近开始了一个需要国际化的项目，在一开始编写数字格式化过滤器的时候偶尔发现了 Intl.NumberFormat().format() 这个API，原来现在 原生JS就支持了对数字的格式化，并且不光可以千位分隔，还可以将大位数缩写。","text":"以前因为项目需要 i18n ，一直以来都是自己写了一个格式化函数来处理，会使用 replace 配合正则对数字进行千位分割来展示，并且搭配 Vue.filter 来实现快速格式化。但是对于大位数处理就会比较麻烦了，因为在境内就需要使用 万位分割，大位数使用 万、亿、万亿 来缩，而在英语系国家就会使用 千分分隔，比如说: K、M、B 来缩写数额。 正巧最近开始了一个需要国际化的项目，在一开始编写数字格式化过滤器的时候偶尔发现了 Intl.NumberFormat().format() 这个API，原来现在 原生JS就支持了对数字的格式化，并且不光可以千位分隔，还可以将大位数缩写。 简单的看一下这个API： Intl.NumberFormat 是对语言敏感的格式化数字类的构造器类。语法：new Intl.NumberFormat([locales[, options]]) 是不是很简单，并且可以从参数中看到，这个API是支持设置本地化的，那就快速来过一遍示例： // 直接格式化 new Intl.NumberFormat().format(123456789) // ’123,456,789 使用 locales 本地化数字： // 英语环境下的数字格式化 new Intl.NumberFormat(&#x27;en&#x27;).format(123456.789); // &#x27;123,456.789&#x27; // 中文环境下的数字格式化 new Intl.NumberFormat(&#x27;zh&#x27;).format(123456.789); // &#x27;123,456.789&#x27; // 德语环境使用逗号(,)作为小数点，使用句号(.)作为千位分隔符 new Intl.NumberFormat(&#x27;de-DE&#x27;).format(123456.789) // &#x27;123.456,789&#x27; // 阿拉伯语国家使用阿拉伯语数字 new Intl.NumberFormat(&#x27;ar-EG&#x27;).format(123456.789); // &#x27;١٢٣٬٤٥٦٫٧٨٩&#x27; 配置紧凑型(&#123;notation:&quot;compact&quot;&#125;) 可以将大位数缩写: new Intl.NumberFormat(&#x27;en&#x27;, &#123;notation:&quot;compact&quot;&#125;).format(123456789) // &#x27;123M&#x27; new Intl.NumberFormat(&#x27;en&#x27;, &#123;notation:&quot;compact&quot;, compactDisplay: &quot;long&quot;&#125;).format(123456789) // &#x27;123 million&#x27; new Intl.NumberFormat(&#x27;zh&#x27;, &#123;notation:&quot;compact&quot;&#125;).format(123456789) // &#x27;1.2亿&#x27; new Intl.NumberFormat(&#x27;zh&#x27;, &#123;notation:&quot;compact&quot;, compactDisplay: &quot;long&quot;&#125;).format(123456789) // &#x27;1.2亿&#x27; new Intl.NumberFormat(&#x27;zh-Hans-CN-u-nu-hanidec&#x27;, &#123;notation: &quot;compact&quot;&#125;).format(123456789) // 一.二亿 new Intl.NumberFormat(&#x27;zh-Hans-CN-u-nu-hanidec&#x27;, &#123;notation: &quot;compact&quot;&#125;).format(1234567890) // &#x27;一二亿&#x27; 可以看到使用中文十进制数字，还是稍微有点问题的，不过直接使用阿拉伯数字展示也不是不行对吧。 其他扩展用法查看MDN的文档就行，里面有详细的示例，我就不一一举例了。 😫 关于兼容性兼容性问题是有很多人关注的，作为一个在2012年被提出的规范（ECMA-402 1.0），从 IE 11 开始被支持（不持支大位数缩写），其它的现代浏览器都是支持的，当然处在实验阶段的属性实现程度不一致，不过 format 和 locales 以及 notation 都是支持的，所以正常使用已经足够了。 📚 参考文档：Intl.NumberFormat - JavaScript | MDNIntl.NumberFormat.prototype.format() - JavaScript | MDNIntl.NumberFormat.prototype.format - ECMAScript Internationalization API Specification – ECMA-402 Edition 1.0","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"}]},{"title":"记录在 uni-app 中使用 uViewUI 的图标组件使用 @click.stop 拦截冒泡事件报错","slug":"uni-app-u-icon-onclick-stop-propagation-error","date":"2022-06-14T01:41:44.000Z","updated":"2026-01-05T05:39:58.517Z","comments":true,"path":"2022/uni-app-u-icon-onclick-stop-propagation-error/","permalink":"https://yogwang.site/2022/uni-app-u-icon-onclick-stop-propagation-error/","excerpt":"嗨呀，我也开始写 uni-app 了 😂，这次在使用 uView 这个UI库的时候遇到了一个问题，就是 &lt;u-icon&gt; 组件使用 @click.stop 阻止冒泡事件使会提示异常：TypeError: e.stopPropagation is not a function 去看了一下组件的源码，发现 u-icon 组件的 click 事件是自定义事件，没有 event，只返回了一个 this.index，所以不能使用 .stop 来阻止冒泡，","text":"嗨呀，我也开始写 uni-app 了 😂，这次在使用 uView 这个UI库的时候遇到了一个问题，就是 &lt;u-icon&gt; 组件使用 @click.stop 阻止冒泡事件使会提示异常：TypeError: e.stopPropagation is not a function 去看了一下组件的源码，发现 u-icon 组件的 click 事件是自定义事件，没有 event，只返回了一个 this.index，所以不能使用 .stop 来阻止冒泡， 但是看到它有 stop 属性可以来设置是否阻止事件传播，所以如果单纯直接用 u-icon 组件的话，可以通过设置 stop 属性来解决问题。 遇到其他情况后来的开发过程中遇到：如果在 u-input 组件的的 slot 中插入 u-icon 组件依旧还是有问题，最后只能转为使用 @click.native.stop 来解决事件冒泡的问题。","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"uni-app","slug":"uni-app","permalink":"https://yogwang.site/tags/uni-app/"},{"name":"uViewUI","slug":"uViewUI","permalink":"https://yogwang.site/tags/uViewUI/"}]},{"title":"JS中的字符串前后补全（补位）","slug":"JS-padStart-padEnd","date":"2022-06-01T10:22:58.000Z","updated":"2026-01-05T05:39:58.475Z","comments":true,"path":"2022/JS-padStart-padEnd/","permalink":"https://yogwang.site/2022/JS-padStart-padEnd/","excerpt":"在日常项目中经常会遇到需要对字符串补位的操作，比如 向前补0：例如日期，经常会需要YYYY-MM-DD 的格式， 如果不使用日期库，直接获取月份和日期前面是没有0的，需要手动拼接字符串。 正巧今天要搞日历组件，前面缺一个0总感觉少了点感觉，当时懒得自己写补全了，想着百度一个吧，就搜到了张鑫旭大佬的这篇文章 《JS字符串补全方法padStart()和padEnd()简介》，然后就惊了，原来早在4年前 JS 就原生支持了前后补全了（我这几年在干嘛😢）","text":"在日常项目中经常会遇到需要对字符串补位的操作，比如 向前补0：例如日期，经常会需要YYYY-MM-DD 的格式， 如果不使用日期库，直接获取月份和日期前面是没有0的，需要手动拼接字符串。 正巧今天要搞日历组件，前面缺一个0总感觉少了点感觉，当时懒得自己写补全了，想着百度一个吧，就搜到了张鑫旭大佬的这篇文章 《JS字符串补全方法padStart()和padEnd()简介》，然后就惊了，原来早在4年前 JS 就原生支持了前后补全了（我这几年在干嘛😢） # String.padStart()如果是以前的话我们就会，先判断一下是参否入小于10，然后再去补全字符串 &quot;0&quot;，而现在就不需要了直接用 .padStart() 就行，他会自己判断输入的字符串长度是否小于指定长度再去补全。而且用法就很简单啊，如果你要在字符串前面补位像下面这样使用就行了： let month = new Date().getMonth() + 1 month = String(month).padStart(2, &#x27;0&#x27;) // 其实第二位使用数字 0 也是可以的 console.log(month) // 06 # String.padEnd()和 padStart() 一样，直接这样使用就可以了 &#39;字符串&#39;.padEnd(7,&#39;补全&#39;) 就会把字符串补全为 字符串补全补全，其实我一直没想到向后补位的一个具体示例，这边我使用张大佬的例子： 在JS前端我们处理时间戳的时候单位都是ms毫秒，但是，后端同学返回的时间戳则不一样是毫秒，可能只有10位，以s秒为单位。所以，我们在前端处理这个时间戳的时候，保险起见，要先做一个13位的补全，保证单位是毫秒。使用示意： timestamp = +String(timestamp).padEnd(13, &#x27;0&#x27;); 关于兼容性 😫作为一个ES2017(ES8) 的内容，兼容IE肯定是不用考虑的，其它现代浏览器都是支持 padStart 和 padEnd 的。如果一定要考虑兼容性问题的话，可以使用 lodash 库中的 _.padStart 和 _.padEnd 来实现前后补全，一直可以兼容到IE9。当然也可以和张大佬一样使用垫片(polyfill)来实现，可以兼容到更低版本的IE 📚 参考文档：String.prototype.padStart() - JavaScript | MDNString.prototype.padEnd() - JavaScript | MDN JS字符串补全方法padStart()和padEnd()简介 « 张鑫旭-鑫空间-鑫生活","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"},{"name":"ECMAScript 8","slug":"ECMAScript-8","permalink":"https://yogwang.site/tags/ECMAScript-8/"}]},{"title":"数组的 .map() 和 .forEach() 是否会修改原数组","slug":"JS-array-map-and-foreach-will-be-change-source-data","date":"2022-05-11T11:57:46.000Z","updated":"2026-01-05T05:39:58.472Z","comments":true,"path":"2022/JS-array-map-and-foreach-will-be-change-source-data/","permalink":"https://yogwang.site/2022/JS-array-map-and-foreach-will-be-change-source-data/","excerpt":"面试的时候也算是进场会遇到的一个题目了，结论就是 可以也不可以，看原始数据是什么结构的，也看你如何是操作的。 如果说数组元素是基本类型的，比如说是数字类型、字符串、布尔类型的，那么不管是用 .map() 还是 .forEach() 都是无法修改原数组的。如果说是集合类型的，比如说数组、对象，那么直接操作内部的元素或者属性都是会修改原数组的。","text":"面试的时候也算是进场会遇到的一个题目了，结论就是 可以也不可以，看原始数据是什么结构的，也看你如何是操作的。 如果说数组元素是基本类型的，比如说是数字类型、字符串、布尔类型的，那么不管是用 .map() 还是 .forEach() 都是无法修改原数组的。如果说是集合类型的，比如说数组、对象，那么直接操作内部的元素或者属性都是会修改原数组的。 简单上一个 .forEach 的例子 const arr1 = [1, 2, 3] arr1.forEach(item =&gt; item = &#x27;a&#x27;) console.log(arr1) // (3) [1, 2, 3] const arr2 = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;] arr2.forEach(item =&gt; item = 1) console.log(arr2) // (3) [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;] const arr3 = [&#123;a:1&#125;, &#123;a:2&#125;, &#123;a:3&#125;] arr3.forEach(item =&gt; item.a = &#x27;a&#x27;) console.log(arr3) // (3) [&#123;a: &#x27;a&#x27;&#125;, &#123;a: &#x27;a&#x27;&#125;, &#123;a: &#x27;a&#x27;&#125;] const arr4 = [[1], [2], [3]] arr4.forEach(item =&gt; item[0] = &#x27;a&#x27;) console.log(arr4) // (3) [[&#x27;a&#x27;], [&#x27;a&#x27;], [&#x27;a&#x27;]] 从以上例子里面可以很直接的看到结果，把 .forEach() 替换成 .map() 是一样的效果。说简单的一点就是深浅拷贝的问题， .forEach() 和 .map() 都只对第一层进行了复制，其内部的属性还是引用的内存地址。所以其实是如果你是直接修改的整个元素就不会影响到原数组，比如说： const arr = [&#123;a:1&#125;, &#123;a:2&#125;, &#123;a:3&#125;] arr.forEach(item =&gt; item = &#123;a:&#x27;a&#x27;&#125;) console.log(arr) // (3) [&#123;a: 1&#125;, &#123;a: 2&#125;, &#123;a: 3&#125;] 最开始的例子当中基本类型的修改不会影响到原数组也是由于这个机制，基本数据类型的复制是值的复制，复制后两者互相独立。 所以其实不只是 .map() 和 .forEach()，其他的会对数组进行遍历操作的API（.find()、.filter()、.every()、.some()）也都有类似的问题。 相关阅读Array.prototype.map() - JavaScript | MDNArray.prototype.forEach() - JavaScript | MDN ES6中forEach、map等方法会修改原数组吗？ - 简书","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"},{"name":"面试","slug":"面试","permalink":"https://yogwang.site/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"总是记不清的重排/回流(reflow)和重绘(repaint)","slug":"what-the-repaint-and-reflow","date":"2022-05-11T11:55:33.000Z","updated":"2026-01-05T05:39:58.523Z","comments":true,"path":"2022/what-the-repaint-and-reflow/","permalink":"https://yogwang.site/2022/what-the-repaint-and-reflow/","excerpt":"重排会导致重绘，重绘不会导致重排 。 中文环境下面的 重排 会有另外一种称呼方式叫做 回流。以前一直不理解为什么重排叫回流（直译的 reflow），导致我在记忆的过程中我总是会把他们混在一起，分不清回流是重排还是重绘。 他们对应的含义我倒是分的还是比较清楚的。简单来说就是，牵扯页面布局的页面更新是重排，重绘就只是一些不影响布局的样式更新……","text":"重排会导致重绘，重绘不会导致重排 。 中文环境下面的 重排 会有另外一种称呼方式叫做 回流。以前一直不理解为什么重排叫回流（直译的 reflow），导致我在记忆的过程中我总是会把他们混在一起，分不清回流是重排还是重绘。 他们对应的含义我倒是分的还是比较清楚的。简单来说就是，牵扯页面布局的页面更新是重排，重绘就只是一些不影响布局的样式更新…… 💥 触发机制重排的触发机制我归类为以下三类： 视窗大小发生改变； DOM的操作（可见元素）； 元素几何样式和定位方式被改变； 部分获取元素属性和API的调用； 视窗大小发生改变 和 DOM的操作 都很容易理解，可视区域的改变、DOM元素的增&#x2F;删&#x2F;改都会触发重排。 需要注意的是 元素几何样式的改变 和 获取元素属性和API的调用 这两块。 1. 元素几何样式的改变元素宽高和位置这些属性的变更肯定会触发重排，但是修改字体和字号也是会触发重排的。因为会改变容器的宽高，从而影响到页面布局。 2. 部分获取元素属性和API的调用分为两类，一类是访问特定属性，比如说获取元素的盒模型信息。一类是API的访问，例如 getClientRects()、scrollTo()、、getComputedStyle() 这类API，它们会访问某个元素尺寸和定位的属性，为了保证拿到的是精确值，不得不提前触发一次重排。 更详细的可以阅读 精读《web reflow》 这篇文章。 当然也不是每次访问元素位置都会触发 reflow，在浏览器触发 reflow 后，所有已有元素位置都会记录快照，只要不再触发位置等变化，第二次开始访问位置就不会触发 reflow。精读《web reflow》 🎨 关于重绘的部分关于重绘我认为其实就是影响布局的样式修改的元素外观更新，都可以认为是重绘。但是有部分会影响到元素位置&#x2F;宽高的变更、显示&#x2F;隐藏的CSS属性并不会触发重排。比如说： 使用 transform 属性使元素平移、形变等变换； 使用 visible 和 opacity 属性显示&#x2F;隐藏元素； 甚至有一部分的属性可以使直接跳过重排重绘的步骤，直接进入合成(Composite)阶段，还有关于重排重绘的优化我就不过多赘述了，感兴趣可以直接查看 《你真的了解回流和重绘吗》 这篇文章。 🧐 一些疑问使用 absolute 或 fixed 脱离文档流后，修改元素定位等原来会触发重排属性还会触发重排吗？会，但是因为不会影响父级和兄弟元素的定位，所以它的重排会非常的快。但是使用 float 来脱离文档流还使其它元素内的文本进行环绕，所以可能会发生大规模重排。具体可以参看这篇问答 修改浮动元素宽高之后是否会触发重排？ 相关文档Rendering: repaint, reflow&#x2F;relayout, restyle &#x2F; Stoyan’s phpied.comweekly&#x2F;242.精读《web reflow》 · ascoders&#x2F;weeklyweekly&#x2F;221.精读《深入了解现代浏览器三》 · ascoders&#x2F;weekly渲染流水线：CSS如何影响首次加载时的白屏时间？| 浏览器工作原理与实践分层和合成机制：为什么CSS动画比JavaScript高效？| 浏览器工作原理与实践HTML回流与重绘_ 空城机介绍回流与重绘（Reflow &amp; Repaint），以及如何进行优化? - 知乎你真的了解回流和重绘吗 - 掘金既不要重排也不要重绘，合成：transform如何实现动画效果？ - 掘金","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://yogwang.site/tags/HTML/"},{"name":"面试","slug":"面试","permalink":"https://yogwang.site/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"Provide/Inject - 我在Vue中很少使用到的一种父子通讯方式","slug":"vue-provide-inject","date":"2022-05-10T15:16:42.000Z","updated":"2026-01-05T05:39:58.522Z","comments":true,"path":"2022/vue-provide-inject/","permalink":"https://yogwang.site/2022/vue-provide-inject/","excerpt":"也算是经典面试题的一部分了，对于父子间的通讯很多时候的使用我都是限于 props&#x2F;$emit 来处理，或者 Vuex&#x2F;EventBus 这种方式，很少会用到 Provide&#x2F;Inject 来处理。其实这是一个很实用的跨级组件间通讯的方式。 这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在其上下游关系成立的时间里始终生效。 看文档中关于这对API的解释就可以看到，向其所有后代 注入一个依赖，所以在跨级组件间通讯，或者 单父多子组件间通讯就会很方便了。 简单的使用可以查看官方文档中的示例，我就不举例了，因为使用起来真的很简单。 最直白的（但是错误的）可以理解为 props 的强化版本，暴露一个可以无视子组件的嵌套层级属性来进行注入。","text":"也算是经典面试题的一部分了，对于父子间的通讯很多时候的使用我都是限于 props&#x2F;$emit 来处理，或者 Vuex&#x2F;EventBus 这种方式，很少会用到 Provide&#x2F;Inject 来处理。其实这是一个很实用的跨级组件间通讯的方式。 这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在其上下游关系成立的时间里始终生效。 看文档中关于这对API的解释就可以看到，向其所有后代 注入一个依赖，所以在跨级组件间通讯，或者 单父多子组件间通讯就会很方便了。 简单的使用可以查看官方文档中的示例，我就不举例了，因为使用起来真的很简单。 最直白的（但是错误的）可以理解为 props 的强化版本，暴露一个可以无视子组件的嵌套层级属性来进行注入。 在使用的过程中主要会遇到的问题基本上是以下两种： #1 注入一个方法给后代组件使用：注入一个方法给后代组件使用，只需要在 provide 返回的对象中声明想要暴露的方法即可。 // 父级组件提供 &#x27;fn&#x27; export default &#123; // 如果想要提供当前组件中的一些属性和方法，需要使用 return 一个对象来指定 this 的指向. // 不然会提示 `Cannot read properties of undefined` 或者 `xxx is not defined`。 provide() &#123; return &#123; fn: this.customFn &#125; &#125;, methods:&#123; customFn()&#123; // .... &#125; &#125; // ... &#125; // 子组件注入 &#x27;fn&#x27; export default &#123; inject: [&#x27;fn&#x27;], // ... &#125; #2 注入一个可响应的对象给后代组件使用：其实也不复杂，查看官网的提示就可以知道应该如何操作了。 提示：provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的 property 还是可响应的。 注入一个被监听的对象即可，比如说在 data 或者 computed 中声明的 对象、对象数组。 // 父级组件提供被监听的对象 export default &#123; provide() &#123; return &#123; testObj: this.testObj, testObjArray: this.testObjArray &#125; &#125;, data()&#123; return &#123; // 对象 testObj:&#123; a:&#x27;aa&#x27;, b:&#x27;bb&#x27; &#125;, // 对象数组 testObjArray: [&#123; c:&#x27;ccc&#x27; &#125;, &#123; d:&#x27;ddd&#x27; &#125;] &#125; &#125;, mounted()&#123; // 子组件初始化后修改变量值 this.$nextTick(()=&gt;&#123; this.changeData() &#125;) &#125;, methods:&#123; // 修改变量值 changeData()&#123; this.testObj.a = &#x27;Lorem Ipsum&#x27; this.$set(this.testObjArray, 0, &#123; c: &#x27;new Value&#x27;&#125;) &#125; &#125; &#125; // 子组件注入并监听 export default &#123; inject: [&#x27;testObj&#x27;,&#x27;testObjArray&#x27;], watch:&#123; testObj:&#123; handler(val)&#123; console.log(&#x27;child watcher: testObj changed&#x27;, val); &#125;, deep:true &#125;, testObjArray(val)&#123; console.log(&#x27;child watcher: testObjArray changed&#x27;, val); &#125; &#125; &#125; 😣 遇到问题#1 有些人可能会问为啥我修改了被监听的对象，但是没有触发子组件的监听事件？一看问出这个问题的就是没有好好读文档，建议重新读一遍关于 watch 的文档。其实通过 deep 或者传入回调数组监听某一个用到的属性值即就行了，我上方的示例中也写了 watch 监听对象的方式，多仔细看看好吧。 文档provide&#x2F;inject - API — Vue.js 2.xProvide&#x2F;Inject - 组合式 API | Vue.js 3.x","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://yogwang.site/tags/%E9%9D%A2%E8%AF%95/"},{"name":"VueJS","slug":"VueJS","permalink":"https://yogwang.site/tags/VueJS/"}]},{"title":"如何判定一个变量是数组","slug":"how-to-determine-variable-is-array","date":"2022-05-10T14:26:05.000Z","updated":"2026-01-05T05:39:58.490Z","comments":true,"path":"2022/how-to-determine-variable-is-array/","permalink":"https://yogwang.site/2022/how-to-determine-variable-is-array/","excerpt":"一个不幸的消息，最近我厂因为资金的问题凉凉了，所以我得开始重新找工作了，最近应该会分享一些和面试题有关并且我觉得有意思的内容，😁 正巧今天面试的时候被问到的一个面试题我觉得就挺有意思的题目： 你如何判断一个变量是数组？ 因为得知公司要解散的消息后比较仓促，也就没有好好刷面试题直接就出去面了（无缝衔接实属渣男了），所以被问道这还算是比较经典面试题的时候，下意识就回答了使用 typeof 来判断，但是想起来不对啊，数组他是对象类型嘛！ 😱 卧槽，踩坑里了。 就马上补充了一句：“emmmm….好像用 typeof 不行，数组返回的是 Object ，应该可以通过原型链上的 constructor 来判断….噢，通过 instanceof 也可以！” 不出意料因为踩坑了，紧接着面试官就追问了一句 “还有其它的方式吗？”考虑了5秒左右答 “没有了，暂时想不起来更多的方式。”，面试官回：“还有一种 isArray 可以判断” 以前一直没有考虑过这种问题，去判断一个对象是否为数组的场景。所以我觉得就还蛮有意思的，所以回来之后想看看还有哪几种方式可以判断是否为数组。","text":"一个不幸的消息，最近我厂因为资金的问题凉凉了，所以我得开始重新找工作了，最近应该会分享一些和面试题有关并且我觉得有意思的内容，😁 正巧今天面试的时候被问到的一个面试题我觉得就挺有意思的题目： 你如何判断一个变量是数组？ 因为得知公司要解散的消息后比较仓促，也就没有好好刷面试题直接就出去面了（无缝衔接实属渣男了），所以被问道这还算是比较经典面试题的时候，下意识就回答了使用 typeof 来判断，但是想起来不对啊，数组他是对象类型嘛！ 😱 卧槽，踩坑里了。 就马上补充了一句：“emmmm….好像用 typeof 不行，数组返回的是 Object ，应该可以通过原型链上的 constructor 来判断….噢，通过 instanceof 也可以！” 不出意料因为踩坑了，紧接着面试官就追问了一句 “还有其它的方式吗？”考虑了5秒左右答 “没有了，暂时想不起来更多的方式。”，面试官回：“还有一种 isArray 可以判断” 以前一直没有考虑过这种问题，去判断一个对象是否为数组的场景。所以我觉得就还蛮有意思的，所以回来之后想看看还有哪几种方式可以判断是否为数组。 按照谷歌出来的答案，一共有4种判断方式，那就按照我回答的和我后续了解到的顺序来列举吧！ 第一种，就是通过原型链上的 constructor 来判断：var a = [] a.constructor === Array // true 就很简单，其实不加上 === Array 直接使用 a.constructor 就会输出 ƒ Array() &#123; [native code] &#125; 就可以知道是否会是数组了，不过是为了判断嘛，所以还是加上了。 第二种，通过 instanceof 来判断：var a = [] a instanceof Array // true 这个也很容易，其实其原理就和我上面提到的通过原型链上的 constructor 来判断类似，instanceof 会去检测构造函数的 prototype 属性是否出现在实例对象的原型链上。 第三种，通过 isArray 来判断var a = [] Array.isArray(a) // true 😄 和 instanceof 一样简单，但 isArray 是优于 instanceof 的。其原因是不同的全局环境（页面、frame）下 Array 构造函数是不同的，使用 instanceof 来判断是否为数组得保证创建数组的 Array 构造函数是同一个才可以。 不过无伤大雅一般都不会出现这种问题，大家知道即可。 第四种，通过 Object.prototype.toString 来判断：var a = []; Object.prototype.toString.call(a) === &#x27;[object Array]&#x27; // true 这种就是属于比较花里胡哨的了，用到了 Object.prototype.toString 方法，再使用 call 来指定 this 的指向。虽然他很强，可以判断几乎所有类型，但是我觉得不是很靠谱。毕竟 instanceof 都可能因为不同全局环境而导致判断出错。让我觉得依赖于原型上的属性和方法都有可能会有问题。 不过现在已经有了 Array.isArray() 了，就不用再考虑再纠结这些问题了，实践中使用它就行了。我们大概知道有过多少种判断数组的方式即可。以上。 参考文档typeof - JavaScript | MDNObject.prototype.constructor - JavaScript | MDNinstanceof - JavaScript | MDNArray.isArray() - JavaScript | MDNObject.prototype.toString() - JavaScript | MDNFunction.prototype.call() - JavaScript | MDN javascript 判断变量是否是数组（Array） - SegmentFault 思否JavaScript:Object.prototype.toString方法的原理 - 紫云飞 - 博客园JS判断是否是数组的四种做法 - 听风是风 - 博客园Determining with absolute accuracy whether or not a JavaScript object is an array","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"},{"name":"面试","slug":"面试","permalink":"https://yogwang.site/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"微信小程序学习日记 L09 消息推送","slug":"miniprogram-devDiary-09-subscribe-message","date":"2022-02-28T08:31:02.000Z","updated":"2026-01-05T05:39:58.502Z","comments":true,"path":"2022/miniprogram-devDiary-09-subscribe-message/","permalink":"https://yogwang.site/2022/miniprogram-devDiary-09-subscribe-message/","excerpt":"项目新增了一个过期提醒的需求，需要增加定时推送消息的功能，查看文档了解到消息推送可以选择两种推送方式，一种是 小程序订阅消息，另一种是 服务号模板消息。 最简单的肯定是小程序直接拉起订阅消息，不需要做很多的准备，在开放平台设置好订阅消息模板之后直接使用就可以了。 服务号订阅则会麻烦一些，需要从小程序跳转到公众号引导用户关注，然后绑定公众号的OpenID到账户上。 所以肯定是先尝试最简单的小程序订阅消息啦！","text":"项目新增了一个过期提醒的需求，需要增加定时推送消息的功能，查看文档了解到消息推送可以选择两种推送方式，一种是 小程序订阅消息，另一种是 服务号模板消息。 最简单的肯定是小程序直接拉起订阅消息，不需要做很多的准备，在开放平台设置好订阅消息模板之后直接使用就可以了。 服务号订阅则会麻烦一些，需要从小程序跳转到公众号引导用户关注，然后绑定公众号的OpenID到账户上。 所以肯定是先尝试最简单的小程序订阅消息啦！ 🍕 小程序订阅消息首先在公众号平台登陆小程序管理后台，从侧边栏找到 【功能】栏目下的【订阅消息】，首次进入使用需要开启一下功能。 开启功能之后在【公共模板库】里边找到自己需要的消息模板。 不知道为什么我开启之后看不到添加消息模板的按钮，只能从模板库里选择。 选择好之后可以看到模板提供了一些关键字，可以选择自己需要用到的展示字段，我这边用到了3个。填写完 “场景说明” 之后就可以提交保存了。 添加完成之后模板列表中，找到刚刚添加的模板点击【详情】，就可以看到消息模板的ID 和 消息参数字段了 后端如何使用订阅消息参数，可以查看这篇文档 🔗 subscribeMessage.send | 微信开放文档 拿到消息模板ID之后，回到小程序需要使用的页面当中，使用以下 API 就可以唤起订阅授权了。 wx.requestSubscribeMessage(&#123; tmplIds: [&#x27;&#x27;], // 息模板的id的集合，一次调用最多可订阅3条消息 success (res) &#123; &#125; &#125;) 是不是很简单，这样小程序部分的就结束了，通知后端可以发送订阅消息就可行，用户授权完成之后，后端可以 不限时间 地下发一条或对应的服务消息了。需要关注的是，比如说唤起首全弹窗之后所有的操作都会执行 success 回调，其实用户点击了取消，所以需要区分一下res 参数内消息模板的不同状态 wx.requestSubscribeMessage(&#123; tmplIds: [&#x27;abcdefg&#x27;], // 消息模板的id的集合，一次调用最多可订阅3条消息 success (res) &#123; console.log(res.errMsg) // log &#x27;requestSubscribeMessage:ok&#x27; console.log(res[&#x27;abcdefg&#x27;]) // 为什么需要把模板id当成键名，因为可能会同时订阅多个消息模板 // log &#x27;accept&#x27;、&#x27;reject&#x27;、&#x27;ban&#x27; 或 &#x27;filter&#x27;。 // &#x27;accept&#x27;表示用户同意订阅该条id对应的模板消息，&#x27;reject&#x27;表示用户拒绝订阅该条id对应的模板消息，&#x27;ban&#x27;表示已被后台封禁，&#x27;filter&#x27;表示该模板因为模板标题同名被后台过滤。 &#125; &#125;) 但是我们的需求是要推送 1~3 的消息，所以小程序订阅消息就没办法完全满足需求，只能考虑使用服务号模板消息来实现了。 🙄 疑惑1. 如果了用户勾选 “总是保持以上选择，不再询问” 之后，下次调用订阅API还会不会弹窗勾选之后，下次调用将不会弹窗，除非用户进入 【小程序 - 右上角 “···” - 设置 - 订阅消息】 内修改设置。 2. 小程序订阅消息 为什么只有一次性订阅消息，没有找到长期订阅消息我也没有找到，并且我只能从消息模板库里边添加订阅消息模板，不能自定义添加消息模板。可能是因为非民生，非政务的缘故吧。微信官方暂时仅向政务民生、医疗、交通、金融、教育等线下公共服务开放长期提醒。 3. 小程序订阅消息 只能出现在 服务通知 内吗只会出现在服务通知内，如果需要展示在服务号内需要使用 服务号模板消息。 🍕 服务号模板消息这个也简单，和小程序设置订阅消息的步骤一样，只是额外增加引导用户关注公众号的步骤即可。 用户关注服务号之后后端会接收到推送（需要在微信公众平台进行服务器配置），后端接收到请求就可以解密获取用户的 OpenID 进行关联了，获取 UnionID 需要单独请求接口获取。 这些操作交给后端同学就好了，我们并不需要过多的关注，大概知晓即可。我们的重心是引导用户关注服务号，现在有4种方式可以选择： 使用微信官方的 公众号关注组件 &lt;official-account /&gt;（需要关联公众号）official-account | 微信开放文档 使用 &lt;image /&gt; 组件展示公众号二维码图片引导用户长按关注 如果没办法长按扫码，在图片标签增加 show-menu-by-longpress 属性即可（小程序2.7.0开始支持 🔗 文档链接） 使用 客服消息按钮组件 &lt;button open-type=&quot;contact&quot;&gt; 推送关注消息(需要开启服务) 客服消息 | 微信开放文档 使用 &lt;webview /&gt; 组件展示公众号中引导用户关注的文章（里边的图片可以长按扫码）。 具体方式我就不赘述了，网上一抓一大把。 需要注意的是使用公众号关注组件的话进入场景要求的只有符合的场景才会展示，比如说从APP唤起小程序的话就不会展示关注卡片，需要考虑使用其它三种方式来适配。 在线客服会话开启之后服务端不能主动推送消息了，需要用户发送消息之后才可以向用户下发客服消息 引导用户关注完成之后，后端同学就可以凭借消息模板 template_id 及用户 openId 来推送模板消息了。 P.S. 现在新增自定义模板消息时审核不通过，会提醒让使用服务号的订阅消息。但是如果使用订阅消息会特别麻烦，用户点击授权之后才可以发送一次性订阅消息，长期订阅依旧如小程序非民生类不可使用。 噢，对了，需要让后端同学为用户增加一个是否已经关注公众号的 flag，不然每次都提示用户去关注就太不友好了。 剩下的就是我这边需求内的多端数据关联了……就不再这篇文章中展开描述了 🙄 疑惑1. 服务号模板消息 是否需要授权模板消息不需要，但是如果使用 服务号订阅通知 需要用户主动订阅。 2. 已拥有用户OpenID，但用户未关注服务号消息是否会推送不能推送，需要引导用户关注服务号。 4. 小程序客服消息能否判断不同进入场景可以，后端会接收到4种类型的请求： 开启会话、发送小程序卡片、发送文本消息、发送图片消息开启会话会有 SessionFrom 字段可以自定义，文本消息就是发送的文本内容 Content、图片消息会有一个 PicUrl 和 MediaId 来获取图片、小程序卡片会有 AppId、Title、PagePath之类的字段可以获取。以下是三种请求的 xml 数据截图，图片消息忘记要截图了：具体每个字段对应的什么意思，可以看这篇文档 👉 接收消息和事件 | 微信开放文档如果要做到开启会话就自动回复指定消息，可以在开启会话的按钮上设置指定的 session-from 值来让后端判断。 5. “如果用户在会话中点击了小程序消息，则会返回到小程序” 中的小程序消息是什么意思其实就是客服会话中客服发送了小程序卡片，用户点击之后会直接返回打开会话之前的页面（如果如果是页面中点击按钮开启的会话），并不会直接跳转到目标页面，需要开发者自己去做跳转。但如果之前没有打开会小程序会进入到卡片对应的页面。 6. APP唤起小程序是否可以打开指定页面并携带参数？可以，在 path 参数中填写路径即可打开指定页面，需要携带参数可以在路径后以 query 的形式拼接，例如 /pages/test?foo=bar 🍕 服务号订阅消息这个我就不说了，和模板消息的步骤一样的，而且只能发送一次性订阅消息，而且订阅过程很麻烦，需要在公号文章中添加订阅按钮用户主动订阅才可以推送 1次 消息。 📌 相关文档及参考文章小程序订阅消息 小程序订阅消息 | 微信开放文档 wx.requestSubscribeMessage(Object object) | 微信开放文档 subscribeMessage.send | 微信开放文档 公众号消息 模板消息 | 微信开放文档 订阅通知介绍 | 微信开放文档 客服消息 客服消息 | 微信开放文档 消息推送 | 微信开放文档 接收消息和事件 | 微信开放文档 新增临时素材 | 微信开放文档 customerServiceMessage.uploadTempMedia | 微信开放文档 上传图片获取 media_id 客服消息使用指南 | 微信开放文档 APP唤起 APP拉起小程序功能 | 微信开放文档 参考文章 微信小程序订阅消息 - 掘金 微信小程序订阅消息开发总结 - 不忘初心dbsdxq - 博客园 如何实现长期订阅推送的功能 | 微信开放社区","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://yogwang.site/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"小程序","slug":"小程序","permalink":"https://yogwang.site/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"简写的 flex:1 具体简写了些什么？","slug":"CSS-what-happens-when-set-flex-1","date":"2022-02-16T09:53:27.000Z","updated":"2026-01-05T05:39:58.463Z","comments":true,"path":"2022/CSS-what-happens-when-set-flex-1/","permalink":"https://yogwang.site/2022/CSS-what-happens-when-set-flex-1/","excerpt":"前几天写 flex 容器宽度被内容撑开的问题 查文章的时候，看到了一篇 flex:1 到底代表什么?，确实很多时候只是知道 flex:1 的作用，并不清楚他具体代表了什么。和那篇帖子一样，我原先理解的也是 flex:1 应该是 flex:1 1 auto 的简写。因为设置了 flex:1 之后就可以让容器扩张了。既然 flex 的默认值是 0 1 auto 那么理所当然的就这样认为了。 看完了这个帖子之后发现其实并不是这样。简写的 flex:1 其实是 flex:1 1 0%，其中的 flex-basis 的值从默认值变成了 0% ，但是文章并没有说明为什么会这样。 确实这个东西不值得深入研究为什么，只需要知道和理解就可以了。但，正好昨天在翻《CSS新世界》的时候看到了这部分内容！","text":"前几天写 flex 容器宽度被内容撑开的问题 查文章的时候，看到了一篇 flex:1 到底代表什么?，确实很多时候只是知道 flex:1 的作用，并不清楚他具体代表了什么。和那篇帖子一样，我原先理解的也是 flex:1 应该是 flex:1 1 auto 的简写。因为设置了 flex:1 之后就可以让容器扩张了。既然 flex 的默认值是 0 1 auto 那么理所当然的就这样认为了。 看完了这个帖子之后发现其实并不是这样。简写的 flex:1 其实是 flex:1 1 0%，其中的 flex-basis 的值从默认值变成了 0% ，但是文章并没有说明为什么会这样。 确实这个东西不值得深入研究为什么，只需要知道和理解就可以了。但，正好昨天在翻《CSS新世界》的时候看到了这部分内容！ 为何 flex 属性会有这样与众不同的行为呢？按照CSS规范的说法，这样设计的目的是为了让 flex 属性的表现更符合我们日常开发需要的效果。意思就是，当我们使用 flex:1 的时候，正常情况就是需要 flex-basis 为 0%，即基础尺寸为 0；当我们使用 flex:100px 的时候，正常情况就是需要 flex-grow 为 1，也就是尺寸保持向外的弹性。flex 属性站在实用主义的角度对计算值进行了优化， 我认为这是 CSS 规范一种友善的处理，而这种友善在 flex 的关键字属性值中体现的更加明显。——《CSS新世界》 正如书里说的，真正使用 flex 的时候没有几个人可以记清楚哪个值对应哪一个属性，flex 单值缩写语法的作用就是为了让 flex 属性的作用语义化和表面化。 比如说 flex 的正式语法为：flex: none | [ &lt;&#39;flex-grow&#39;&gt; &lt;&#39;flex-shrink&#39;&gt;? || &lt;&#39;flex-basis&#39;&gt; ] flex: none 很好理解，元素会根据自身宽高来设置尺寸。它是完全非弹性的：既不会缩短，也不会伸长来适应 flex 容器。相当于将属性设置为 flex: 0 0 auto。 我们关注书内的重点说明的 flex 属性的多值语法：&lt;&#39;flex-grow&#39;&gt; &lt;&#39;flex-shrink&#39;&gt;? || &lt;&#39;flex-basis&#39;&gt; (1) 如果 flex 的属性值只有 1 个值，则具体规则如下： 如果是数值，如 flex:1，则这个 1 为 flex-grow 属性的值，此时 flex-shrink 属性和 flex-basis 属性的值分别是 1 和 0%。注意，这里的 flex-basis 属性是 0%，而不是默认值 auto。 如果是长度值，如 flex:100px，则这个 100px 显然为 flex-basis 属性的值，因为 3 个缩写的 CSS 属性中只有 flex-basis 的属性值支持长度值。此时 flex-grow 属性和 flex-shrink 属性的值都是 1，注意，这里的 flex-grow 属性的值是 1，而不是默认值 0。 (2) 如果 flex 的属性值有 2 个值，则第一个值一定是 flex-grow 属性值（因为表示0个或1个的问号 ? 在 flex-shrink 的后面 [CSS属性值定义语法可以看这里]），第二个值根据值的类型不同对应不同的CSS属性，具体规则如下。 如果第二个值是数值，例如 flex:1 2，则这个 2 是 flex-shrink 属性的值，此时 flex-basis 属性计算值是 0%，并非默认值 auto。 如果第二个值是长度值，例如 flex:1 100px，则这个 100px 为 flex-basis 属性值。 (3) 如果 flex 属性值有 3 个值，则长度值为 flex-basis 属性值，其余两个数值分别为 flex-grow 和 flex-shrink 的属性值。下面两行CSS语法都是合法的，且含义也是一样的： /* 下面两行的CSS语句含义是一样的 */ flex: 1 2 50%; flex:50% 1 2; 所以在简写的时候其实对应的计算值是这样的 简写 等同于 flex: initial flex: 0 1 auto flex: 0 flex: 0 1 0% flex: none flex: 0 0 auto flex: 1 flex: 1 1 0% flex: auto flex: 1 1 auto 具体效果可以查看张大佬随书写的这个例子 🔗 flex关键字属性值基本效果示意实例页面 简单来说： 如果想保持元素按照其宽度平铺换行的话，可以使用 flex:initial，比如说不定宽的小标签、小图标列表； 如果想保持元素不随容器宽度放大和缩小，可以使用 flex:none 来实现，比如说上一篇文章中的定宽侧边栏； 如果想要让各元素之间等比放大和缩小的话，可以使用 flex:1 来实现； 如果想要元素根据内容的宽度来占据容器剩余空间或者缩小的话，可以使用 flex:auto 来实现； flex:0 暂时没有想到应用场景。 尾声🎈 问题1：不同的 flex-basis 的值，会对元素造成什么影响？对比1： flex:0 和 flex:initial 的区别 他们都不会扩张，即都不会占据剩余空间。 flex:0 的元素宽度为 最小内容宽度，缩放时按照 最小内容宽度 占据空间。 flex:initial 的元素宽度为 最大内容宽度，缩放时按照自身内容的宽度缩小自身宽度。 对比2： flex:1 和 flex:auto 的区别 他们都会扩张和缩小，即都会占据剩余空间。 flex:1 的元素宽度，可视为等分剩余空间，或者各元素之间等比缩小。 flex:auto 的元素宽度，按照自身内容的宽度进行分配剩余空间，或者缩小自身宽度。 看着有些懵逼的话，可以看如下具体示例: 比较不容易理解的是，如果同时设置了 flex-basis 属性的值和 width 属性的值时，具体是哪一个属性来应用。这个我需要再挖一个坑来说明了，因为内容还是比较多的，或者可以直接看 《CSS新世界》 第六章 中的 6.2.12 节。 文档flex:1 到底代表什么?《CSS新世界》- 张鑫旭 flex - CSS（层叠样式表） | MDNflex-grow - CSS（层叠样式表） | MDNflex-basis - CSS（层叠样式表） | MDNCSS Flexible Box Layout Module Level 1 CSS属性值定义语法 - CSS（层叠样式表） | MDN","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://yogwang.site/tags/CSS/"},{"name":"挖坑","slug":"挖坑","permalink":"https://yogwang.site/tags/%E6%8C%96%E5%9D%91/"}]},{"title":"flex 容器宽度被内容撑开的问题","slug":"CSS-flex-container-stretched-by-content","date":"2022-02-15T07:49:17.000Z","updated":"2026-01-05T05:39:58.450Z","comments":true,"path":"2022/CSS-flex-container-stretched-by-content/","permalink":"https://yogwang.site/2022/CSS-flex-container-stretched-by-content/","excerpt":"在弹性布局中，一个 flex 子项的最终尺寸是基础尺寸（或内容尺寸）、弹性增长或收缩、最大最小尺寸共同作用的结果。最终尺寸计算的优先级是：最大最小尺寸限制 &gt; 弹性增长或收缩 &gt; 基础尺寸 基础尺寸由 flex-base 属性或 width 属性，以及 box-sizing 盒模型共同决定； 内容尺寸最指最大内容宽度，当没有设置基础尺寸是会顶替基础尺寸的角色； 弹性增长指的是 flex-grow 属性，弹性收缩指的是 flex-shrink 属性； 最大尺寸主要受 max-width 属性限制；最小尺寸则比较复杂，受最小内容宽度、width 属性和 min-width 属性共同影响。 很早之前就遇到过这个问题但没有整理，当时处理完问题之后就没有管了。昨天又遇到了同样的问题，因为嵌套的层次很深折腾了有2个小时，所以还是需要记录下来以免未来又忘了。 其实很简单，容器使用 width:0;flex:1; 即可解决问题。 但是稍微有点没有理解的是：为什么设置宽度为 0 时，使用 flex-grow:1 可以使容器放大，但是设置宽度为 100% 时，使用 flex-shrink:1 并不会让容器缩小。","text":"在弹性布局中，一个 flex 子项的最终尺寸是基础尺寸（或内容尺寸）、弹性增长或收缩、最大最小尺寸共同作用的结果。最终尺寸计算的优先级是：最大最小尺寸限制 &gt; 弹性增长或收缩 &gt; 基础尺寸 基础尺寸由 flex-base 属性或 width 属性，以及 box-sizing 盒模型共同决定； 内容尺寸最指最大内容宽度，当没有设置基础尺寸是会顶替基础尺寸的角色； 弹性增长指的是 flex-grow 属性，弹性收缩指的是 flex-shrink 属性； 最大尺寸主要受 max-width 属性限制；最小尺寸则比较复杂，受最小内容宽度、width 属性和 min-width 属性共同影响。 很早之前就遇到过这个问题但没有整理，当时处理完问题之后就没有管了。昨天又遇到了同样的问题，因为嵌套的层次很深折腾了有2个小时，所以还是需要记录下来以免未来又忘了。 其实很简单，容器使用 width:0;flex:1; 即可解决问题。 但是稍微有点没有理解的是：为什么设置宽度为 0 时，使用 flex-grow:1 可以使容器放大，但是设置宽度为 100% 时，使用 flex-shrink:1 并不会让容器缩小。 先来看一下问题复现吧: 在正常内容的时候不会出现问题（可以点击 Demo 的 EDIT ON CODEPEN 最大化预览正常情况），但当元素内部的文字内容增多时，或者视窗缩小时 flex 容器的宽度就会被内容撑开。 看起来是不是十分复杂？因为我嵌套了 2 层 flex 容器，最内部的容器 .list-item 因为内容太多被撑开了，并没有如愿按照剩余空间缩小子元素 .text 的宽度，同时宽度变大的 .list-item 导致外部的 .container 和 .wrap 也被撑开了。 被撑开的 flex 容器比较多，不好说明，那么看一下简略版的复现 Demo 👇 这个就很简单明了了，因为 .text 的内容太多，致使 .container 容器被撑开了，并且 .container 的宽度变大使 .wrap 的宽度也增大了，并不是按照设想的 100vw。同时文本标题超出省略的样式也没有应用到。 其实解决问题很简单，容器使用 width:0;flex:1; 即可解决问题。 但是我疑惑的是，为什么宽度设置为 0，flex布局可以使容器放大，设置为 100% 就不能实现缩小了。找了一圈也没见原因，问了一下肉大，他说可能和内容宽度有关系，让我看看张大佬的《CSS新世界》。 🎉 果然在 6.2.12 这一节找到了类似的例子，并在 6.3 这一节中找到了具体解释。那设置了 flex:1 属性（简写的 flex:1 具体简写了些什么？）后，容器为什么和预期表现不一致？因为设置了 flex-basis 属性的元素的最小尺寸是最小内容的宽度（文字内容在所有换行点换行后的尺寸），而我设置了标题不换行导致最小尺寸比较大，最终尺寸大于 flex:1 给到的 flex-basis:0%。(如果我们把标题设置会换行容器就不会被撑开了）。具体解释为： flex-basis 属性下的最小尺寸是由内容决定的，而 width 属性下的最小尺寸是由 width 属性的计算值决定的。 这里出现的 “最小尺寸” 表示最终尺寸的最小值，所以在标题不换行的时候如果不设置 width 为 0 那么，flex 容器的宽度就会被内容撑开。当设置 width:0 之后，最小尺寸就为设置的 width 值了，就可以被 flex-grow:1 放大。 ok，以上就是 flex 容器被内容撑开的全部内容了，有条件的小伙伴可以入手一本 《CSS新世界》 看看，里边的内容有很多讲些CSS新特性的实用例子，确实可以节约不少时间。 文档《CSS新世界》- 张鑫旭flex - CSS（层叠样式表） | MDNflex-basis - CSS（层叠样式表） | MDN","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://yogwang.site/tags/CSS/"}]},{"title":"微信小程序返回键被劫持点击无效","slug":"miniprogram-fail-navigate-back-intercepted","date":"2022-01-17T06:32:38.000Z","updated":"2026-01-05T05:39:58.509Z","comments":true,"path":"2022/miniprogram-fail-navigate-back-intercepted/","permalink":"https://yogwang.site/2022/miniprogram-fail-navigate-back-intercepted/","excerpt":"今天小程序完成了一个新功能，在自测的时候发现了一个问题，小程序的返回按钮点击没反应了，一开始以为是模拟器的问题，结果使用实机测试同样复现了这个问题。 具体跳转路由为：首页 =&gt; wx.navigateTo =&gt; 新功能列表页 =&gt; wx.navigateTo =&gt; 新功能添加页 =&gt; wx.redirectTo =&gt; 新功能详情页 =&gt; 返回按钮 =&gt; 新功能列表页 =&gt; 返回按钮 =&gt; 首页 结果从 详情页 返回 列表页 之后，返回按钮点上去没反应了！！！页面中添加一个自定义按钮调用 wx.navigateBack 返回也不行。 监听了 wx.navigateBack 的 success、fail、complete 三个回调之后发现，success 和 fail 都不执行，只执行了 complete 的回调，输出为： complete: &#123;errMsg: &quot;fail:navigateBack intercepted&quot;&#125;","text":"今天小程序完成了一个新功能，在自测的时候发现了一个问题，小程序的返回按钮点击没反应了，一开始以为是模拟器的问题，结果使用实机测试同样复现了这个问题。 具体跳转路由为：首页 =&gt; wx.navigateTo =&gt; 新功能列表页 =&gt; wx.navigateTo =&gt; 新功能添加页 =&gt; wx.redirectTo =&gt; 新功能详情页 =&gt; 返回按钮 =&gt; 新功能列表页 =&gt; 返回按钮 =&gt; 首页 结果从 详情页 返回 列表页 之后，返回按钮点上去没反应了！！！页面中添加一个自定义按钮调用 wx.navigateBack 返回也不行。 监听了 wx.navigateBack 的 success、fail、complete 三个回调之后发现，success 和 fail 都不执行，只执行了 complete 的回调，输出为： complete: &#123;errMsg: &quot;fail:navigateBack intercepted&quot;&#125; 很明显，返回按钮被劫持了，但是我这几个页面都没有劫持过路由，就在我一筹莫展之时，从微信社区找到了一个问题反馈 关于page-container，返回键被锁死？。 确实，我在 新功能列表页 中使用了 page-container 来做半屏弹窗，通过 show 属性来控制组件显示，返回按钮被劫持多半就是因为这个了，原因如下： 页面内存在该容器（page-container）时，当用户进行返回操作，关闭该容器不关闭页面。返回操作包括三种情形，右滑手势、安卓物理返回键和调用 navigateBack 接口。 但是为什么已经操作 show 属性关闭 page-container 返回按钮还是被锁定，就不清楚了。 🧠 解决问题把跳转到添加页的业务修改成先执行 wx.navigateBack 之后再跳转，发现还是有这个问题，放在 wx.navigateBack() 的回调里边执行，依旧有这个问题。 重新尝试把路由跳转放到 wx.setData() 的回调中执行也不能解决问题。说明不能同时去执行这两个操作，即使通过回调来执行。 所以只能按照这个 问题贴 中的办法，使用 setTimeout 来避免返回按钮被 page-container 劫持。 📑 解决方案：// 关闭半屏弹出 onCloseDialog () &#123; this.setData(&#123; dialogVisible: false, &#125;) &#125;, // 跳转到添加页面 navigateToAddPage () &#123; this.onCloseDialog() const timer = setTimeout(() =&gt; &#123; clearTimeout(timer) wx.navigateTo(&#123; url: addPagesPath, &#125;) &#125;,200) &#125; 具体为什么 page-container 通过修改 show 关闭，或者是通过 navigateBack 关闭，页面返回操作还是会被劫持，我就没办法解答了。看看微信官方是否后续会解决这个问题吧。 参考资源 page-container | 微信开放文档 关于page-container，返回键被锁死？ | 微信开放社区","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://yogwang.site/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"编程中的\"副作用\"是什么意思？","slug":"what-do-side-effect-mean","date":"2022-01-05T08:43:18.000Z","updated":"2026-01-05T05:39:58.523Z","comments":true,"path":"2022/what-do-side-effect-mean/","permalink":"https://yogwang.site/2022/what-do-side-effect-mean/","excerpt":"副作用，是相对于主要作用的，并不只是“坏”作用 因为“药物的副作用”，一直以来都没有很好的理解编程中 “副作用” 一词，想当然的把它理解为了 一些“负面”的作用。 对于 “副作用” 科书版的解答就是： “副作用”（side effect），指的是函数内部与外部互动，产生运算以外的其他结果。 但是很笼统，对于已经有刻板影响的中文世界，还是很容易曲解的。正巧今天在水群的时候提到了这个词，发现其实还有很多人和我有一样的问题，并没有很好的理解。","text":"副作用，是相对于主要作用的，并不只是“坏”作用 因为“药物的副作用”，一直以来都没有很好的理解编程中 “副作用” 一词，想当然的把它理解为了 一些“负面”的作用。 对于 “副作用” 科书版的解答就是： “副作用”（side effect），指的是函数内部与外部互动，产生运算以外的其他结果。 但是很笼统，对于已经有刻板影响的中文世界，还是很容易曲解的。正巧今天在水群的时候提到了这个词，发现其实还有很多人和我有一样的问题，并没有很好的理解。 特别是在 React 文档 中也提到了 副作用，虽然我现在看来其实很好理解，但是当时确实给我造成了一些困扰。 那我就用上边的这篇文档中提到的副作用来举例吧。import React, &#123; useState, useEffect &#125; from &#x27;react&#x27;; function Example() &#123; const [count, setCount] = useState(0); // Similar to componentDidMount and componentDidUpdate: useEffect(() =&gt; &#123; // Update the document title using the browser API document.title = `You clicked $&#123;count&#125; times`; &#125;); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; ); &#125; 这个示例主要功能是实现一个按钮点击累计 count，并且展示 count 的需求，然后使用 useEffect() 在DOM更新后修改页面标题，这个修改页面标题就是这个函数的副作用。 另外一个例子就是群里边提到的 tree-shaking 中的副作用，表示的是项目不影响全局，不会增加减少全局的变量，也不会改变某个原型。工具可以可以放心地优化掉代码，不需要考虑因为外部代码可能使用到了，该项目附加的属性方法而没办法进行优化。 总而言之，想表达意思其实是除了函数执行的主要目的（primary effect）之外，额外产生的一些附加的影响(side effect)，这些附加的影响可能是无法预期的，会给程序带来不必要的麻烦，也可能是特意为止的，为了实现一些额外的操作。所以并不是简单的字面理解为 “坏作用”，这个副作用可能会是正面的。 文档副作用 (计算机科学) - 维基百科","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[]},{"title":"微信小程序学习日记 L08 分包加载","slug":"miniprogram-devDiary-08-subpackages","date":"2021-12-04T07:19:12.000Z","updated":"2026-01-05T05:39:58.502Z","comments":true,"path":"2021/miniprogram-devDiary-08-subpackages/","permalink":"https://yogwang.site/2021/miniprogram-devDiary-08-subpackages/","excerpt":"目前小程序分包大小有以下限制： 整个小程序所有分包大小不超过 20M 单个分包&#x2F;主包大小不能超过 2M 随着项目的不断迭代，小程序的主包会越来越大， 终究会有一天会超过 2M 的主包限制，首先考虑到的就是图片资源放到 CDN 或者 OSS，起初会很奏效，但是随着一些JS库的加入就没办法了，即使使用了 .min 版本，或者精简了类库代码，主包还会很大，这时候就会用到项目分包了。","text":"目前小程序分包大小有以下限制： 整个小程序所有分包大小不超过 20M 单个分包&#x2F;主包大小不能超过 2M 随着项目的不断迭代，小程序的主包会越来越大， 终究会有一天会超过 2M 的主包限制，首先考虑到的就是图片资源放到 CDN 或者 OSS，起初会很奏效，但是随着一些JS库的加入就没办法了，即使使用了 .min 版本，或者精简了类库代码，主包还会很大，这时候就会用到项目分包了。 使用分包使用分包很简单，在 app.json 当中使用 subpackages 声明项目分包结构就可以。 &#123; &quot;pages&quot;:[ &quot;pages/index&quot;, &quot;pages/logs&quot; ], &quot;subpackages&quot;: [ &#123; &quot;root&quot;: &quot;packageA&quot;, // 子包根目录 &quot;name&quot;: &quot;pack1&quot;, // 别名，预下载时使用 &quot;pages&quot;: [ // 子包页面（相对于子包根目录） &quot;pages/cat&quot;, &quot;pages/dog&quot; ] &#125;, &#123; &quot;root&quot;: &quot;packageB&quot;, &quot;name&quot;: &quot;pack2&quot;, &quot;pages&quot;: [ &quot;pages/apple&quot;, &quot;pages/banana&quot; ] &#125; ] &#125; 然后只需要注意2点就好了： subpackage 的根目录不能是另外一个 subpackage 内的子目录(可以在主包目录下)； tabBar 页面必须在主包内； 不同 subpackage 间的资源无法相互引用，公共的部分可以放在主包内，或者使用 分包异步化 来解决。 有点迷糊的可以直接看官方给到的 分包加载版示例源码 独立分包 独立分包是小程序中一种特殊类型的分包，可以独立于主包和其他分包运行。从独立分包中页面进入小程序时，不需要下载主包。当用户进入普通分包或主包内页面时，主包才会被下载。 在上边的分包基础上，给独立分包的子包增加 independent 属性既可。 &#123; &quot;pages&quot;:[ &quot;pages/index&quot;, &quot;pages/logs&quot; ], &quot;subpackages&quot;: [ &#123; &quot;root&quot;: &quot;packageA&quot;, // 子包根目录 &quot;name&quot;: &quot;pack1&quot;, // 别名，可在预下载时使用 &quot;pages&quot;: [ // 子包页面（相对于子包根目录） &quot;pages/cat&quot;, &quot;pages/dog&quot; ] &#125;, &#123; &quot;root&quot;: &quot;packageB&quot;, &quot;name&quot;: &quot;pack2&quot;, &quot;pages&quot;: [ &quot;pages/apple&quot;, &quot;pages/banana&quot; ], &quot;independent&quot;: true &#125; ] &#125; 限制和分包一直，并且额外的有3个条件： 独立分包中不能依赖主包中的内容，即不能使用公共的库和公共样式等资源; 在主包加载前无法使用 getApp(); 独立分包中暂时不支持使用插件。 这个我暂时还没有用到，具体注意事项可以查看文档 独立分包 | 微信开放文档 分包预下载 开发者可以通过配置，在进入小程序某个页面时，由框架自动预下载可能需要的分包，提升进入后续分包页面时的启动速度。对于独立分包，也可以预下载主包 预下载分包行为在 进入某个页面时触发，通过在 app.json 增加 preloadRule 项来配置。 &#123; &quot;pages&quot;: [ &quot;pages/index&quot; ], &quot;subpackages&quot;: [ &#123; &quot;root&quot;: &quot;subpackage1&quot;, &quot;pages&quot;: [ &quot;index&quot; ], &#125;, &#123; &quot;root&quot;: &quot;subpackage2&quot;, &quot;name&quot;: &quot;sub2&quot;, &quot;pages&quot;: [ &quot;index&quot; ], &#125;, &#123; &quot;root&quot;: &quot;subpackage3&quot;, &quot;name&quot;: &quot;sub3&quot;, &quot;pages&quot;: [ &quot;index&quot; ] &#125;, &#123; &quot;root&quot;: &quot;indep&quot;, &quot;pages&quot;: [ &quot;index&quot; ], &quot;independent&quot;: true &#125; ], &quot;preloadRule&quot;: &#123; &quot;pages/index&quot;: &#123; &quot;network&quot;: &quot;all&quot;, // 所有网络环境均进行预加载 &quot;packages&quot;: [&quot;subpackage1&quot;] // 进入 pages/index 时加载 subpackage1 的内容 &#125;, &quot;subpackage1/index&quot;: &#123; &quot;packages&quot;: [&quot;sub2&quot;, &quot;sub3&quot;] // 进入 subpackage1/index 时加载 subpackage2 和 subpackage3 的内容 &#125;, &quot;indep/index&quot;: &#123; &quot;network&quot;: &quot;wifi&quot;, // 仅在wifi环境下预加载 &quot;packages&quot;: [&quot;__APP__&quot;] // 进入独立分包 indep/index 时加载 主包内容 &#125; &#125; &#125; 📍 注意：同一个分包中的页面享有共同的预下载大小限额 2M，限额会在工具中打包时校验。 如，页面 A 和 B 都在同一个分包中，A 中预下载总大小 0.5M 的分包，B中最多只能预下载总大小 1.5M 的分包。 分包异步化在小程序中，不同的分包对应不同的下载单元；因此，除了非独立分包可以依赖主包外，分包之间不能互相使用自定义组件或进行 require。「分包异步化」特性将允许通过一些配置和新的接口，使部分跨分包的内容可以等待下载后异步使用，从而一定程度上解决这个限制。 ✨ 可以先打开官方给的 🔗代码片段 然后对照着看。 1. 跨分包自定义组件的引用首先是跨分包自定义组件引用，我们看示例代码当中并没有提到 分包下载 的内容，演示的代码片段中也没有，只是使用到了 占位组件 进行替代。 // subPackageA/pages/index.json &#123; &quot;usingComponents&quot;: &#123; &quot;button&quot;: &quot;../../commonPackage/components/button&quot;, &quot;list&quot;: &quot;../../subPackageB/components/full-list&quot;, &quot;simple-list&quot;: &quot;../components/simple-list&quot; &#125;, &quot;componentPlaceholder&quot;: &#123; &quot;button&quot;: &quot;view&quot;, &quot;list&quot;: &quot;simple-list&quot; &#125; &#125; 说明 跨分包引用自定义组件 是不需要单独处理的，小程序会自行下载使用到的跨包组件。我们只需要关注在跨包组件下载完成之前的占位和展示即可了。 2. 跨分包 JS 代码的引用跨分包 JS 代码引用和上边的跨包组件引用不一样了，提供了专门的 async 方法 或者 使用回调的方式解决。 // subPackageA/index.js // 使用回调函数风格的调用 require(&#x27;../subPackageB/utils.js&#x27;, utils =&gt; &#123; console.log(utils.whoami) // Wechat MiniProgram &#125;) // 或者使用 Promise 风格的调用 require.async(&#x27;../commonPackage/index.js&#x27;).then(pkg =&gt; &#123; pkg.getPackageName() // &#x27;common&#x27; &#125;) 这个就很容易理解了，需要等待代码加载完成，所以是异步操作，和跨包组件一样，这个也是自动完成的，不需要单独在外部申明。 尾声其实小程序分包还挺简单的，就是对已经开发完成的项目再进行分包就会比较麻烦，所有的路由和资源加载路径都需要相应调整一遍。 Q1：主包使用到的分包组件是否只能放到主包内？其实可以从 分包异步化 部分看到，并不需要把跨包调用的内容全部放到公共组件下，对于这些 自定义组件 和 JS 文件 ，我们可以直接放到子包目录下减少主包的体积，然后使用占位组件去预展示就行了，小程序会自动的加载这些内容。 Q2: 主包与分包的体积都在 1M 以内，上传时提示体积过大不是分包过大，是分包预加载规则设定的有问题，分包设置预加载的分包超过规定大小了，同一个分包中的页面享有共同的预下载大小限额 2M，这个限制在上边的 分包预下载 中提到了 - 问题来源：主包与分包的体积都在1M以内，上传时为什么会提示体积过大？ | 微信开放社区 文档分包加载 | 微信开放文档独立分包 | 微信开放文档分包预下载 | 微信开放文档占位组件 | 微信开放文档滴滴出行小程序体积优化实践 - 掘金","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://yogwang.site/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"小程序","slug":"小程序","permalink":"https://yogwang.site/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"记小程序flex布局垂直排列出现高度崩塌的问题","slug":"miniprogram-flex-height-collapse-in-ios","date":"2021-11-01T06:44:01.000Z","updated":"2026-01-05T05:39:58.509Z","comments":true,"path":"2021/miniprogram-flex-height-collapse-in-ios/","permalink":"https://yogwang.site/2021/miniprogram-flex-height-collapse-in-ios/","excerpt":"今天开发的小程序遇到了一个问题，在 iPhone8 iOS 12.2 的设备上访问出现了高度崩塌的问题，但是在其它的型号的 iOS 和 Android 设备上没有复现，一开始以为是 微信版本 的问题，但是更新到了最新还是出现该问题。调试了一下发现问题出在子元素的 display:flex 上，修改为 block 之后高度就不会崩塌了，但是元素的样式就没办法做了。","text":"今天开发的小程序遇到了一个问题，在 iPhone8 iOS 12.2 的设备上访问出现了高度崩塌的问题，但是在其它的型号的 iOS 和 Android 设备上没有复现，一开始以为是 微信版本 的问题，但是更新到了最新还是出现该问题。调试了一下发现问题出在子元素的 display:flex 上，修改为 block 之后高度就不会崩塌了，但是元素的样式就没办法做了。 具体的示例点击 🔗查看代码片段，可以尝试复现看看，暂且只发现能在 iPhone8 iOS 12.2 的设备(实机)上会复现。 一下子不知道该如何解决，暂且Google到了一个解决方案： // 给会出现高度坍缩的元素加上 flex-shrink: 0; .item&#123; // ...其他样式 flex-shrink: 0; &#125; 如果知道为什么会崩塌的大佬，可以前往我在 思否的提问 或者 Mail 📧给我 参考微信小程序 iOS flex布局高度塌陷 - s_qiu 小程序flex容器竖向排列高度崩塌的问题","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://yogwang.site/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"页面的缓存到底应该怎么做?","slug":"what-to-do-with-cache-control","date":"2021-09-19T16:31:26.000Z","updated":"2026-01-05T05:39:58.523Z","comments":true,"path":"2021/what-to-do-with-cache-control/","permalink":"https://yogwang.site/2021/what-to-do-with-cache-control/","excerpt":"&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-cache, no-store, must-revalidate&quot; /&gt; &lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot; /&gt; &lt;meta http-equiv=&quot;Expires&quot; content=&quot;0&quot; /&gt; 赶巧不巧，正好在假期第一天遇到了修改接口地址的问题 —— 节前最后一个工作日后端兄弟自己修改了编译后的 Js 文件中的接口地址，但是并没有生效，只不过当时没发现，今天电话过来问应该怎么处理，奈何电脑没带在身边，只能让他修改了接口地址之后重新编辑被修改的 Js 文件名中的 hash 值随便改一位，同时修改一下 index.html 中的引入路径。可是没多久又发来消息说，不行还是请求旧地址，没有被修改。我怀疑是页面被缓存了，于是让他确认了一下页面源代码中是否有 no-cache 的 meta ，他说有，但是页面还是被缓存了，看到引入 Js 文件的路径还是他修改前的旧路径。于是我就纳闷了，好像浏览器跳过了设置的机制，并没有重新请求服务器获取最新的 index 文件。","text":"&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-cache, no-store, must-revalidate&quot; /&gt; &lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot; /&gt; &lt;meta http-equiv=&quot;Expires&quot; content=&quot;0&quot; /&gt; 赶巧不巧，正好在假期第一天遇到了修改接口地址的问题 —— 节前最后一个工作日后端兄弟自己修改了编译后的 Js 文件中的接口地址，但是并没有生效，只不过当时没发现，今天电话过来问应该怎么处理，奈何电脑没带在身边，只能让他修改了接口地址之后重新编辑被修改的 Js 文件名中的 hash 值随便改一位，同时修改一下 index.html 中的引入路径。可是没多久又发来消息说，不行还是请求旧地址，没有被修改。我怀疑是页面被缓存了，于是让他确认了一下页面源代码中是否有 no-cache 的 meta ，他说有，但是页面还是被缓存了，看到引入 Js 文件的路径还是他修改前的旧路径。于是我就纳闷了，好像浏览器跳过了设置的机制，并没有重新请求服务器获取最新的 index 文件。 正常来说，前端为了加快页面加载，只会在 index.html 页面的 &lt;meta&gt; 中设置 不缓存，而其他类型的资源文件再HTTP服务上设为一个缓存时间，从而加快首屏加载速度。如果资源文件有变动则通过修改资源文件路径的 hash 值来让浏览器认为是新文件，从而重新请求服务器获取最新的资源。 其实都需要在 HTTP Server 上配置缓存策略，这个配置项贴在文章末尾。 所以遇到这个问题的时候我是很懵逼的，我很早之前就已经给 HTML 页面添加上了不缓存的 &lt;meta&gt; 头，当时自测的时候是正常的。就一边翻文档一边写DEMO，不论怎么做都一直复现不了，实在是研究不好了，又问了一下后端兄弟，答：客户使用的微信打开的链接。 ，他暂时先改了一下把页面重定向到了二级目录解决了问题。 所以问题其实是因为微信内置的X5浏览器，马上去微信社区找了一下，果然！一下就找到了，微信公众号页面缓存问题 | 微信开放社区 大概反馈如下： x5内核好像没有协商缓存 点刷新就访问到新的网页了，第二次进来又是旧的 微信内置的浏览器他不按套路出牌啊，没有协商缓存的同时为了加快访问速度还直接给你缓存了页面。所以之前可能是后端小伙伴没有去配置HTTP服务的不缓存，结果用户访问了页面被缓存起来了。一般来说服务器端后续把不缓存的配置添加上就好了，结果后期添加上了不缓存的响应头还是没有办法获取到最新的 HTML 入口文件。暂时没有什么好的解决办法了，后端小伙伴已经暂时解决了就先不管了。 🎈 其它问题1. HTML的 &lt;meta&gt; 标签中设置了不缓存，后端返回头中设置了缓存时间页面会缓存吗？会被缓存，理论上应该是 Response Headers 的优先级更高。 Meta tags are easy to use, but aren’t very effective. That’s because they’re only honored by a few browser caches, not proxy caches (which almost never read the HTML in the document).译: meta 标签很容易使用，但并不十分有效。这是因为它们只被少数浏览器的缓存所尊重，而不是代理缓存（几乎从不读取文档中的HTML）。 详情可以参看这个问答 HTML页面 中设置了不缓存，后端返回头中设置了缓存时间页面会缓存吗？ 2. HTML的 &lt;meta&gt; 的不缓存设置的应用范围？HTML 页面中的 &lt;meta&gt; 信息头只会应用在当前 HTML 页面的请求头上，并不会影响 HTML 页面发起的其他 HTTP 请求 ✨ Update - 07&#x2F;03&#x2F;2024隔了那么多年，才发现之前的笔记中没有完整的描述好应该如何配置项目的缓存，除了在页面的 meta 头中配置 Cache-Control（其实并没有多少作用）。 更重要的是在服务器的 HTTP Server 中配置缓存规则。那么，简单的用 Nginx 的配置来举例： http &#123; ... server &#123; listen 80; listen 443; server_name localhost; location / &#123; root /test/your-dist-path; # 开启回退路由适配 History 路由模式 try_files $uri $uri/ /index.html; index index.html index.htm; # 静态文件配置不缓存 location ~* \\.html$ &#123; add_header Cache-Control no-store; expires -1; &#125; # 资源文件配置缓存72小时 location ~* \\.(jpg|jpeg|png|gif|ico|css|js)$ &#123; expires 72h; &#125; &#125; &#125; &#125; 最后记得使用 nginx -s reload 让 Nginx 重新加载配置文件（重新加载前程序会自动检测配置文件是否正确，如果有错误会提示并且停止应用新的配置文件）。 参考资源Cache-Control - HTTP | MDNHTTP 缓存 - HTTP | MDN http - How do we control web page caching, across all browsers? - Stack Overflowgoogle chrome - “Cache-Control: max-age&#x3D;0, no-cache” but browser bypasses server query (and hits cache)? - Stack Overflowhttp - What’s the difference between Cache-Control: max-age&#x3D;0 and no-cache? - Stack Overflowhttp - Difference between no-cache and must-revalidate - Stack OverflowCache Control Directives Demystified : PalisadeCaching Tutorial for Web Authors and Webmasters - mnot浅谈浏览器http的缓存机制 - vajoy - 博客园理解浏览器缓存机制 [ 没事儿 ] 微信服务号H5开发去除缓存方案 Wechat WebCache Killer - 掘金","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://yogwang.site/tags/HTML/"},{"name":"Cache","slug":"Cache","permalink":"https://yogwang.site/tags/Cache/"}]},{"title":"微信小程序学习日记 L07 eventChannel 页面事件通信通道","slug":"miniprogram-devDiary-07-eventChannel","date":"2021-08-16T06:36:25.000Z","updated":"2026-01-05T05:39:58.502Z","comments":true,"path":"2021/miniprogram-devDiary-07-eventChannel/","permalink":"https://yogwang.site/2021/miniprogram-devDiary-07-eventChannel/","excerpt":"页面间的通信在各种项目中都是很常见的功能，在小程序中如何在不同页面中使用组件间通信，其实很简单，懒得看我叨叨的可以直接查看 🔗 官方的DEMO","text":"页面间的通信在各种项目中都是很常见的功能，在小程序中如何在不同页面中使用组件间通信，其实很简单，懒得看我叨叨的可以直接查看 🔗 官方的DEMO 首先我们需要通过 wx.navigateTo 打开下一个页面，然后看你需要做怎么样的功能， 如果是想下一个页面传递数据，那么简单的几个参数你可以 query 的形式拼接在 url 上，然后在 被打开的页面中 的 onLoad 中接受 option 中接收 query 数据 如果需要传递复杂的数据，那么可以在 success 回调中执行 eventChannel.emit() 向打开的页面传递。然后在 被打开的页面中 的中使用 this.getOpenerEventChannel() 方法来获得一个 EventChannel 对象，通过该对象的 on 方法获取上一页面通过 eventChannel 传送到当前页面的数据 具体示例如下： // Opener wx.navigateTo(&#123; url: &#x27;test?id=1&#x27;, // 增加query参数 success: function(e) &#123; // 通过eventChannel向被打开页面传送数据 // 这个 acceptDataFromOpenerPage 事件名可以自定义 e.eventChannel.emit(&#x27;acceptDataFromOpenerPage&#x27;, &#123; data: &#x27;test&#x27; &#125;) &#125; &#125;) // Opened Page(&#123; onLoad: function(option)&#123; console.log(option.query) // 接收上一级页面传递的query参数 const eventChannel = this.getOpenerEventChannel() // 监听 Opener 页面 emit 的时间名称 &quot;acceptDataFromOpenerPage&quot; 事件， // 来获取上一页面通过eventChannel传送到当前页面的数据 eventChannel.on(&#x27;acceptDataFromOpenerPage&#x27;, function(data) &#123; console.log(data) // log =&gt; &#123; data: &#x27;text&#x27; &#125; &#125;) &#125; &#125;) 如果想要从 被打开的页面(Opened) 向 上一页(Opener) 传递数据，和 接受 上一页 传递过来的参数 一样使用 this.getOpenerEventChannel() 方法来获得一个 EventChannel 对象，然后通过emit 事件向上一页提交数据。然后再上一页的 wx.navigateTo 方法中的 events 属性中添加一个监听器，获取被打开页面传送到当前页面的数据。 具体示例如下： // Opener wx.navigateTo(&#123; events: &#123; // 为指定事件添加一个监听器，获取被打开页面传送到当前页面的数据 acceptDataFromOpenedPage: function(data) &#123; console.log(data) // log =&gt; &#123; data: &#x27;text&#x27; &#125; &#125;, someEvent: function(data) &#123; console.log(data) // log =&gt; &#123; data: &#x27;text&#x27; &#125; &#125; ... &#125;, &#125;) // Opened Page(&#123; onLoad: function()&#123; const eventChannel = this.getOpenerEventChannel() eventChannel.emit(&#x27;acceptDataFromOpenedPage&#x27;, &#123;data: &#x27;test&#x27;&#125;); eventChannel.emit(&#x27;someEvent&#x27;, &#123;data: &#x27;test&#x27;&#125;); &#125; &#125;) 其实就那么简单 如果一个页面由另一个页面通过 wx.navigateTo 打开，这两个页面间将建立一条数据通道： 被打开的页面可以通过 this.getOpenerEventChannel() 方法来获得一个 EventChannel 对象 wx.navigateTo 的 success 回调中也包含一个 EventChannel 对象。 这两个 EventChannel 对象间可以使用 emit 和 on 方法相互发送、监听事件。 并且被打开的页面中 this.getOpenerEventChannel() 方法，可以在 生命周期 中使用，也可以在 自定义函数 中使用，并不是一定要在生命周期中使用这个方法。 P.S. 如果不是通过 wx.navigateTo 打开的页面是是没办法和上级页面通信的，这个需要稍微注意一下，比如说在开发过程中，直接编译了当前页，而不是从上级页面进入会报错。 文档EventChannel | 微信开放文档 Page(Object object) #页面间通信 | 微信开放文档wx.navigateTo(Object object) | 微信开放文档","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://yogwang.site/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"小程序","slug":"小程序","permalink":"https://yogwang.site/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"微信小程序学习日记 L06 组件插槽","slug":"miniprogram-devDiary-06-slot","date":"2021-08-16T06:35:34.000Z","updated":"2026-01-05T05:39:58.502Z","comments":true,"path":"2021/miniprogram-devDiary-06-slot/","permalink":"https://yogwang.site/2021/miniprogram-devDiary-06-slot/","excerpt":"小程序的插槽用法和 Vue 的 slot 几乎一模一样，现在组件内需要的地方加入插槽（&lt;slot&gt;）节点就行了。也可以直接查看小程序提供的 🔗 代码片段 &lt;!-- 组件模板 P.S. 设置语言类型为html是因为wxml没有高亮 --&gt; &lt;view class=&quot;wrapper&quot;&gt; &lt;view&gt;这里是组件的内部节点&lt;/view&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/view&gt; &lt;!-- 引用组件的页面模板 --&gt; &lt;view&gt; &lt;component-tag-name&gt; &lt;!-- 这部分内容将被放置在组件 &lt;slot&gt; 的位置上 --&gt; &lt;view&gt;这里是插入到组件slot中的内容&lt;/view&gt; &lt;/component-tag-name&gt; &lt;/view&gt; 是不是很简单，需要使用到具名插槽的话，只需要在组件的 options 中开启 多slot支持 multipleSlots 就可以了。","text":"小程序的插槽用法和 Vue 的 slot 几乎一模一样，现在组件内需要的地方加入插槽（&lt;slot&gt;）节点就行了。也可以直接查看小程序提供的 🔗 代码片段 &lt;!-- 组件模板 P.S. 设置语言类型为html是因为wxml没有高亮 --&gt; &lt;view class=&quot;wrapper&quot;&gt; &lt;view&gt;这里是组件的内部节点&lt;/view&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/view&gt; &lt;!-- 引用组件的页面模板 --&gt; &lt;view&gt; &lt;component-tag-name&gt; &lt;!-- 这部分内容将被放置在组件 &lt;slot&gt; 的位置上 --&gt; &lt;view&gt;这里是插入到组件slot中的内容&lt;/view&gt; &lt;/component-tag-name&gt; &lt;/view&gt; 是不是很简单，需要使用到具名插槽的话，只需要在组件的 options 中开启 多slot支持 multipleSlots 就可以了。 // 组件js Component(&#123; options: &#123; multipleSlots: true // 在组件定义时的选项中启用多slot支持 &#125;, properties: &#123; /* ... */ &#125;, methods: &#123; /* ... */ &#125; &#125;) &lt;!-- 组件模板 --&gt; &lt;view class=&quot;wrapper&quot;&gt; &lt;slot name=&quot;before&quot;&gt;&lt;/slot&gt; &lt;view&gt;这里是组件的内部细节&lt;/view&gt; &lt;slot name=&quot;after&quot;&gt;&lt;/slot&gt; &lt;/view&gt; 然后就和在 Vue 中使用具名插槽一样了： &lt;!-- 引用组件的页面模板 --&gt; &lt;view&gt; &lt;component-tag-name&gt; &lt;!-- 这部分内容将被放置在组件 &lt;slot name=&quot;before&quot;&gt; 的位置上 --&gt; &lt;view slot=&quot;before&quot;&gt;这里是插入到组件slot name=&quot;before&quot;中的内容&lt;/view&gt; &lt;!-- 这部分内容将被放置在组件 &lt;slot name=&quot;after&quot;&gt; 的位置上 --&gt; &lt;view slot=&quot;after&quot;&gt;这里是插入到组件slot name=&quot;after&quot;中的内容&lt;/view&gt; &lt;/component-tag-name&gt; &lt;/view&gt; 启用 多slot支持 之后，匿名插槽还是可以继续使用的。 🤗 尾声抽象节点在微信开放文档中提到了一个名词 抽象节点，查看具体的文档之后可以将其理解为 Vue 中的 动态组件，具体可以对比两个文档中关于这两个名词的解释以及示例： 抽象节点 | 微信开放文档 动态组件 — Vue.js 文档组件模板和样式 | 微信开放文档抽象节点 | 微信开放文档","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://yogwang.site/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"小程序","slug":"小程序","permalink":"https://yogwang.site/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"分享会 只用CSS实现轮播图","slug":"CSS-only-carousel","date":"2021-08-06T07:22:36.000Z","updated":"2026-01-05T05:39:58.459Z","comments":true,"path":"2021/CSS-only-carousel/","permalink":"https://yogwang.site/2021/CSS-only-carousel/","excerpt":"早些时候有看到过一个 纯CSS轮播图 的文章，当时有研究过实现，大概是利用了 hash (锚标记) 和 scroll-snap 来实现的，但是具体实现已经回忆不起来了。 正好现在分享群组里边暂时没有主题了，就想着可以当成一个常驻的补位小环节，大家一起浏览 CodePen 之类的社区找一个大家都感兴趣的 Demo 来研究。在分享前还是需要自己重新研究一遍的，不然在讲述的时候出错可太 “甜蜜的” 尴尬了。","text":"早些时候有看到过一个 纯CSS轮播图 的文章，当时有研究过实现，大概是利用了 hash (锚标记) 和 scroll-snap 来实现的，但是具体实现已经回忆不起来了。 正好现在分享群组里边暂时没有主题了，就想着可以当成一个常驻的补位小环节，大家一起浏览 CodePen 之类的社区找一个大家都感兴趣的 Demo 来研究。在分享前还是需要自己重新研究一遍的，不然在讲述的时候出错可太 “甜蜜的” 尴尬了。 首先呢，先实现一个简易的的可控轮播示例 在样例的实现中我将会使用到一下技术栈，希望你可以稍微了解一下 Pug (HTML预处理器) Stylus (CSS预处理器) P.S. 以下笔记内容将逐步实现目标文章示例，会复原目标文章内的元素样式，稍微有点改动但变化不大，因为自己想的样式太丑了。 讲解：可以点开上方示例中的选项卡查看实现代码， 在 html 中书写了 5 个 &lt;div 并且声明了对应的 ID； 并且在后续添加了 &lt;a&gt; 标签来改变URL当中的 hash 值来控制卡片的切换； 在 css 利用 scroll-behavior:smooth 这个属性，来达到切换卡片的平滑滚动效果。 但是缺少了切换前进后退按钮，接下来我们就来实现这个功能 讲解:其实很憨，直接为每一个卡片添加了前进后退按钮的 &lt;a&gt; 标签而已。稍微有点麻烦的就是 如何让这两个按钮随着卡片的切换而改变，而不被后一个卡片的按钮所覆盖，因为这两个按钮是不会随着卡片切换所移动的，这里就需要脑洞大开了！ 正常思路来说，肯定是会尝试修改 前进后退按钮 的父级的定位方式。确实，会需要修改成 position:relative，但是这个其实是为了每次切换卡片后变更对应的锚链接的。 原示例是从轮播组件的最外层容器创建了 ::before 和 ::after 两个伪类，给他们设置的切换按钮的样式，并且设置为点击穿透，然后把轮播卡片内的 前进后退按钮 为 透明 底色。这样所展示的 “按钮” 就不会随卡片所以移动了，而实际的切换按钮会随着卡片所移动，只是不会被浏览者发现。 功能基本实现了，然后我们复原一下原示例的样式。 对照一下原示例，除了自动播放外还差了些什么呢？emmmm…..自动播放！ 💥 尾关BOSS 💥 自动轮播最后来看一下她是如何实现自动播放的，这里的实现方式如果他不讲我直接就蒙圈了，但是确实很赞！👍 First I slowly offset the scroll snap points to the right, making the scroll area follow along due to being snapped to them.首先我缓慢地将滚动捕捉点向右偏移，使滚动区域由于捕捉它们而跟随。 After having scrolled the width of a whole slide, I deactivate the snapping. The scroll area is now untied from the scroll snap points.在滚动整个幻灯片宽度后，我停用了捕捉。 滚动区域现在与滚动捕捉点解除绑定。 Now I let the scroll snap points jump back to their initial positions without them “snap-dragging” the scroll area back with them现在我让滚动捕捉点跳回到它们的初始位置，而不用它们 “捕捉拖动” 滚动区域 Then I re-engage the snapping which now lets the scroll area snap to a different snap point 🤯然后我重新启用捕捉，让滚动区域捕捉到不同的捕捉点 看起来有点不易懂，但是其实并不复杂的。 其实就是利用了 scroll-snap 会使滚动容器的捕捉点变更为你设定的元素对齐位置(scroll-snap-align)，然后通过修改 left 属性值使滚动容器向右滚动实现向后滚动的效果，然后通过修改当前元素的对齐位置为 none, 让滚动容器捕捉到下一个元素的对齐位置，以此来达到自动轮播的效果，那么让我们来实现一下吧！ 但是我还没有增加悬停停止自动轮播和一些其他的优化，有兴趣的可以自己实现一下，用到的CSS属性： @media (hover: hover) - CSS | MDN :focus-within - CSS | MDN prefers-reduced-motion - CSS | MDN 完整复现一下原示例吧！ 尾声其实一开始我是不知道他如何实现的视差滚动的，结果在研究自动轮播的时候，突然就通了，所以就加上来了 通过 transform:translate3d() 给中间的元素，增加了 Z轴 属性，使其脱离了平面 “悬浮” 在轮播卡片上，然后在最外层容器的 “轮播器” 设置了 perspective 指定了容器平面与 视窗 的 Z轴 距离。 但是有点问题，只有在自动播放动画执行时才会体现出来，手动控制切换是感觉不出来的，因为手动滚动时无法应用 scroll-snap。 ⚡ 兼容性 什么？你问我兼容性？友尽了啊！ 别想了，scroll-snap 属性都是 CR 阶段，也就是候选，具体正式上线还有2个阶段要走，并且scroll-behavior (平滑滚动)属性 Safari 是不支持的， “scroll-behavior” | Can I use“scroll-snap” | Can I use 所以移动端的兼容有很大问题，毕竟还有一个毒瘤 —— 微信内置浏览器，也是不支持这些属性的,我在制作的过程中都没有考虑过移动端的适配，直接放弃了，PC端还是可以玩玩的。 自动轮播实现不了，那么视差滚动也就没办法实现了， 闹这么大一圈，其实就是个图个乐子，不过尝一下鲜，学习到别人的脑洞就好了。 文档链接scroll-behavior - CSS | MDNperspective - CSS | MDNscroll-snap-type - CSS | MDNscroll-snap-align - CSS | MDNhover - CSS | MDN:focus-within - CSS | MDNprefers-reduced-motion - CSS | MDN CSS-Only Carousel | CSS-TricksYou can get pretty far in making a slider with just HTML and CSS | CSS-Tricks大侠，请留步，要不过来了解下CSS Scroll Snap？ « 张鑫旭-鑫空间-鑫生活","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://yogwang.site/tags/CSS/"},{"name":"社群分享","slug":"社群分享","permalink":"https://yogwang.site/tags/%E7%A4%BE%E7%BE%A4%E5%88%86%E4%BA%AB/"}]},{"title":"网页链接里的 noopener、noreferrer 和 nofollow","slug":"rel-value-noopener-noreferrer-nofollow","date":"2021-08-05T09:39:56.000Z","updated":"2026-01-05T05:39:58.514Z","comments":true,"path":"2021/rel-value-noopener-noreferrer-nofollow/","permalink":"https://yogwang.site/2021/rel-value-noopener-noreferrer-nofollow/","excerpt":"之前在一篇 帖子 中看到了一个名词 【阻断权重传递】，进而去了解一下这个名词。 阅读相关资料的过程中，收集了3个 no 开头的关键词(noopener、noreferrer 和 nofollow)，并且作为相似内容整理成这篇笔记。 太长不看版： noopener: 使用target=&quot;_blank&quot;所打开的页面，将无法获取 window.opener 对象。 noreferrer: 使打开的页面无法获取 document.referrer 信息。 nofollow: 表明对该链接不认可，不传递权重。 如果有兴趣可以接着看下去","text":"之前在一篇 帖子 中看到了一个名词 【阻断权重传递】，进而去了解一下这个名词。 阅读相关资料的过程中，收集了3个 no 开头的关键词(noopener、noreferrer 和 nofollow)，并且作为相似内容整理成这篇笔记。 太长不看版： noopener: 使用target=&quot;_blank&quot;所打开的页面，将无法获取 window.opener 对象。 noreferrer: 使打开的页面无法获取 document.referrer 信息。 nofollow: 表明对该链接不认可，不传递权重。 如果有兴趣可以接着看下去 先顺着开头的 阻断权重传递 聊聊叭，老前端都知道，如果要做SEO，就会需要投放大量的站外链接到自己的站点，作为引流以及获得权重。在开发者社群中，也会相互交换友链来达到这个目的。但是在一些比较大型的社交平台中，他们并不希望这些链接被搜索引擎的 spider 所爬取，并且将权重传递给那些可能是低质量&#x2F;违法的页面。 开头那篇帖子中提到的 “安全中心” 就是为了达到上述目的，我们可以从案例 “知乎” 当中看到 UGC 中的外链其实是这样的： &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//yogwang.site&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot; data-za-detail-view-id=&quot;1234&quot;&gt;一个测试外链&lt;/a&gt; 我们添加的外链其实已经变成了指向到 “安全中心” 页面，彻底就封死了权重传递的问题，并且避免了直接跳转链接导致的意外的安全问题，比如说钓鱼网站以及不合规内容的免责。 🔖 nofollow告知搜索引擎这是一个不被认可的链接，并且不想把权重传递给此页面。( P.S. 其实就算使用了 nofollow 其实也并不是完全没有排名影响，具体可以查看 这篇文章 其中有举了例子) 🔖 noreferrer这个值其实已经在上边的 “安全中心” 链接当中看到了这个属性的出现，起到的 目的 也就是为了去除头部中的 referrer (来源)信息，说是另外限制了部分 window.opener 的访问权限，但是我感觉和没有限制一样。 🔖 noopener声明在新页面中打开页面，并且不授权新页面对于源页面的访问权限，但是仍提供 referrer 头，所以一般来说会和 noreferrer 合用。 因为通过 target=&quot;_blank&quot; 打开的新页面可以通过修改 window.opener 的部分属性来造成安全问题。 Using the window.opener.location it navigates to the new site – say, a login form emulating the Facebook login screen with a message: “Your previous Facebook session expired. Please log in again to continue using Facebook”.使用 window.opener.location 导航到新站点 ———— 比如说，一个模拟 Facebook 登录屏幕的登录表单，其中包含一条消息：“您之前的 Facebook 会话已过期。 请重新登录以继续使用 Facebook”。 Explained: noopener, noreferrer, and nofollow Values 附 在 Chrome 78 最近的几个版本，如果A、B页面跨域，A页面中打开B页面，在B页面使用 console.log 在控制台打印 window.opener 会报跨域的错误。window.opener - Web API 接口参考 | MDN 并且我发现在 Chrome 93 中打开新页面中输出 window.opener 为 null，即使我没有使用 noopener，需要特意声明 rel=&quot;opener&quot; 才可以获取 opener 对象，但是我还没有找到明确的变更日志，只在后续的查阅的过程中找到一个疑似的工作组 PR。 Make target&#x3D;_blank imply noopener; support opener by annevk · Pull Request #4330 · whatwg&#x2F;html 参考资料HTML attribute: rel - HTML: HyperText Markup Language | MDNLink types: noopener - HTML: HyperText Markup Language | MDN What Is a Nofollow Link? Here’s A Simple Plain English AnswerExplained: noopener, noreferrer, and nofollow Values - Point Jupiter外链用了 target&#x3D;”_blank” 结果悲剧了 | 1024译站The Hidden Dangers You Have Never Noticed: target &#x3D; “_blank” and “opener” - TutorialDocsWhen to use target&#x3D;”_blank” | CSS-TricksAbout rel&#x3D;noopener","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://yogwang.site/tags/HTML/"},{"name":"SEO","slug":"SEO","permalink":"https://yogwang.site/tags/SEO/"}]},{"title":"使用属性选择器为 Markdown 里的图片添加样式","slug":"CSS-use-attribute-selector-add-style-to-the-image","date":"2021-08-03T07:23:58.000Z","updated":"2026-01-05T05:39:58.462Z","comments":true,"path":"2021/CSS-use-attribute-selector-add-style-to-the-image/","permalink":"https://yogwang.site/2021/CSS-use-attribute-selector-add-style-to-the-image/","excerpt":"在写 上一篇文章 的时，文章开头有一张示例图，为了节省空间，我用的图片一般都不会很大，并且那张图只是Google出来的，没有调整就直接放上来了。 在列表页看着图片居左就很难受，想要把它居中放置，但是不想用 HTML 的方式来写，就突然想起来早前有看到过 肉大的一篇分享，是通过 CSS 的 属性选择器 来实现的，就想着自己也可以整理一下，然后放到博客的主题当中使用，以后图片排版就会方便很多。","text":"在写 上一篇文章 的时，文章开头有一张示例图，为了节省空间，我用的图片一般都不会很大，并且那张图只是Google出来的，没有调整就直接放上来了。 在列表页看着图片居左就很难受，想要把它居中放置，但是不想用 HTML 的方式来写，就突然想起来早前有看到过 肉大的一篇分享，是通过 CSS 的 属性选择器 来实现的，就想着自己也可以整理一下，然后放到博客的主题当中使用，以后图片排版就会方便很多。 首先 就是讲述一下 Markdown 语法当中的图片标记： ![alt text](/src/of/image.jpg &quot;title&quot;) 说实话，我在写这篇分享之前，完全不知道 图片标记 是有一个可选的 title 属性的，一直以为只有 path 和 alt 两个属性。(当然我是知道有一些 Markdown 扩展&#x2F;转换器提供了一些额外的拓展属性，比如 Kramdown) 按照 肉大 以及 Baron Schwartz 的说法，可以使用 #hash、?query 或者直接使用 alt 和 title 属性的形式来实现。但使用 alt 和 title 来实现，我的想法与 Baron 一致并不赞同以及提倡滥用 alt 和 title 属性。 所以还是考虑使用 #hash 的方式来实现，为何不使用 ?query 的形式，因为我国内的镜像是放在 Aliyun OSS 当中，一些多余的 query 参数可能会影响资源的加载。 实现 img[src*=\"#center\"]{ margin-left: auto; margin-right: auto; } img[src*=\"#border\"] { border: 2px solid black } 实现的部分其实不用多说，其实就是在语法当中的 path 部分加上 #hash 值，然后使用 CSS 的属性选择起来匹配： ![test](/test.jpg#center &quot;test&quot;) img[src$=&quot;#center&quot;]&#123; margin-left: auto; margin-right: auto; &#125; 结果预览 👉 但是如果想使用多个属性就会有一些问题，比如说我该怎么去 分隔 他们。 Baron 的想法是使用 空格分隔 (space-delimited)，并且修改 $ 使用 ~ 来匹配： ![test](/test.jpg# center border &quot;test&quot;) img[src~=&quot;center&quot;]&#123; margin-left: auto; margin-right: auto; &#125; img[src~=&quot;border&quot;] &#123; border: 2px solid black &#125; 但是 Hexo 在编译时，会认为语法错误，直接输出成为文本内容。👉 ![test](/test.jpg# center border &quot;test&quot;) 所以需要改成转义后的 空格（%20）来书写，才可以被编译为图片，但是这样书写就不能被属性选择器的 ~ 符所匹配到。 而且我觉得 %20 也不便于记忆，所以我继续选择使用 # 来分隔，并且在每个样式之前都加上 #，例如： ![test](/test.jpg#center#border &quot;test&quot;) 同样的，属性选择器也需要变更，因为多个样式，就不能使用 $ 或 ~ 来匹配了，需改成 * 来匹配。具体可以查看 属性选择器 | MDN img[src*=&quot;#center&quot;]&#123; margin-left: auto; margin-right: auto; &#125; img[src*=&quot;#border&quot;] &#123; border: 2px solid black &#125; 结果预览 👉 暂时还没有发现任何影响，如果你知道这样书写会有问题，那么请 📧 Mail 给我吧 ！ 尾声✨ 为什么不用书写 HTML 的方式来实现，不是更加自由吗？ 因为编译会有问题，如果在 markdown 中书写了，HTML 标签，那么在标签闭合之前，其中所有的内容都不会被处理，比如说 Baron Schwartz 在文中提到的： &lt;div style=&quot;width:150px; height:100px&quot;&gt; ![Kitten](/media/2018/08/kitten.jpg) &lt;/div&gt; 会被直接输出到页面中，所以结果如下，会直接输出 ![Kitten](/media/2018/08/kitten.jpg)，并不会把中间的 markdown 图片语法 转换成 &lt;img&gt; 标签 &lt;div style=&quot;width:150px; height:100px&quot;&gt; ![Kitten](/media/2018/08/kitten.jpg) &lt;/div&gt; 参考文档：给 Markdown 里的图片增加样式 – 山维空间How to Style Images With Markdown 属性选择器 - CSS | MDN Update 03&#x2F;06&#x2F;2024因为 淘宝镜像证书过期 的缘故，借机升级了一下博客的依赖项。发现 hexo-renderer-marked 在 3.1.0 之后其实已经支持了 postAsset 选项，开启后会将文章内的图片自动解析为其对应文章的路径。 🔗 资源文件夹 | Hexo # _config.yml post_asset_folder: true marked: prependRoot: true postAsset: true 所以我就移除了 hexo-asset-image 这个依赖项（本来就有小BUG多年没有修复了）。 但是其内部使用 findById 这个方法在数据文件（db.json）中寻找资源时，并没有移除文件路径中的 hash 值。所以如果我们在图片路径中使用 hash 值来实现额外样式时就会查询不到文件资源。导致路径解析失败，直接返回未处理的资源路径。","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://yogwang.site/tags/CSS/"},{"name":"Hexo","slug":"Hexo","permalink":"https://yogwang.site/tags/Hexo/"}]},{"title":"聊聊数据大屏 “炫酷” 容器边框的实现","slug":"border-style-of-special-border-box","date":"2021-07-29T03:07:29.000Z","updated":"2026-01-05T05:39:58.480Z","comments":true,"path":"2021/border-style-of-special-border-box/","permalink":"https://yogwang.site/2021/border-style-of-special-border-box/","excerpt":"最近大屏又开始火了，群里好多人又开始捡起来了数据可视化，我也一样遇到了新得是数据可视化项目，但是这次不是说 ECharts，而是数据大屏上的所谓 “科技感” 容器，比如下图： 可以看到很多的边框，虽然说可以直接让 UI 小姐姐 切给我们出来所有不同规格的背景图片来解决问题，但是就需要 UI 一份一份切给我们，就很麻烦，而且占用首屏加载的资源。我就想是否可以用一些精灵图来完成，或者一些简单的边框可以直接使用一些 CSS 的奇技淫巧来完成。 我从花瓣上找了一些示例，然后通过CSS复现，接下来上实例","text":"最近大屏又开始火了，群里好多人又开始捡起来了数据可视化，我也一样遇到了新得是数据可视化项目，但是这次不是说 ECharts，而是数据大屏上的所谓 “科技感” 容器，比如下图： 可以看到很多的边框，虽然说可以直接让 UI 小姐姐 切给我们出来所有不同规格的背景图片来解决问题，但是就需要 UI 一份一份切给我们，就很麻烦，而且占用首屏加载的资源。我就想是否可以用一些精灵图来完成，或者一些简单的边框可以直接使用一些 CSS 的奇技淫巧来完成。 我从花瓣上找了一些示例，然后通过CSS复现，接下来上实例 📊 实例 1 直线边框第一个示例就上最简单的好了，就是简简单单的直线容器边框，使用伪类来给容器增加4个发光包角 📊 实例 2 倾斜边框其实还好，使用 transform 来实现就可以了，只不过因为形变的问题，最好单独起一个边框容器来做。 📊 实例 3 断点直线线框这个的话，就比较麻烦了，一般都是用背景图片来实现，但是如果盒子大小固定的话，就需要切很多背景图，特别是宽高都不定的时候。所以这部分我只切了3块内容：左上角和右下角的图形 然后是 1px * 1px 的线框，搭配上多 background 就可以实现下边这个示例了。（需要了解一下background-position与background-size的混用） 📊 实例 4 内角边框这个就比较麻烦了，因为想要实现的是内发光的样式，如下图： 但是纯CSS来实现内凹角的话，就不能使用 box-shadow 来设置内发光了，会有断层（其实可以实现没有断层，但是需要一点一点的调整阴影的offset、模糊半径和透明度），如果使用 filter:drop-shadow() 则没办法实现内发光，而且扩散半径现在还没有浏览器支持。 filter:drop-shadow()-spread-radius | MDN。 奈何 filter:drop-shadow() 不支持扩散半径的设置，所以发光我真的没办法了（懒得调 box-shadow），暂时能想到的就是双层 mask 来模拟一个近似的，但是从中心发光了，而不是边框发光（内阴影） 其实可以用上一个例子的方式用背景图来实现，但是我觉得应该有其它更好的方式实现，容我再考虑考虑。 如果你有好的想法，📧 Mail给我吧！ 参考文档：background - CSS | MDNbackground-position - CSS | MDNbackground-size - CSS | MDNmask - CSS | MDNdrop-shadow() - CSS | MDNbox-shadow - CSS | MDN","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://yogwang.site/tags/CSS/"},{"name":"挖坑","slug":"挖坑","permalink":"https://yogwang.site/tags/%E6%8C%96%E5%9D%91/"},{"name":"未完成","slug":"未完成","permalink":"https://yogwang.site/tags/%E6%9C%AA%E5%AE%8C%E6%88%90/"}]},{"title":"CSS 中的遮罩属性 mask/masks","slug":"CSS-mask","date":"2021-07-08T09:15:38.000Z","updated":"2026-01-05T05:39:58.454Z","comments":true,"path":"2021/CSS-mask/","permalink":"https://yogwang.site/2021/CSS-mask/","excerpt":"最近有点忙，于是又停更了一个月😂，前两天在 V2 上看到 一个帖子，需求是要做一个镂空遮罩。 回答的过程中想起来有一个 mask 属性来着，好像可以试试，但是快下班了，也没有找到合适的遮罩图，也不想打开PS自己画一个再传图床，就还是用的 clip-path 做了一个 CodePen Demo。这两天稍微有点时间，可以考虑研究一下这个遮罩属性，以及能否搭配 filter:drop-shadow() 使用。","text":"最近有点忙，于是又停更了一个月😂，前两天在 V2 上看到 一个帖子，需求是要做一个镂空遮罩。 回答的过程中想起来有一个 mask 属性来着，好像可以试试，但是快下班了，也没有找到合适的遮罩图，也不想打开PS自己画一个再传图床，就还是用的 clip-path 做了一个 CodePen Demo。这两天稍微有点时间，可以考虑研究一下这个遮罩属性，以及能否搭配 filter:drop-shadow() 使用。 先来看一下 mask 属性的介绍 mask 属性允许使用者通过遮罩或者裁切特定区域的图片的方式来隐藏一个元素的部分或者全部可见区域。mask: [mask-image] [mask-repeat] [mask-position] / [ mask-size]; 最简单的直接使用 mask 然后配置一下 url 就可以应用上遮罩层了。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .mask&#123; width:100vw; height:100vh; -webkit-mask: url(./mask.png); mask: url(./mask.png); display: block; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;img class=&quot;mask&quot; src=&quot;./picture.jpg&quot;&gt; &lt;/body&gt; &lt;/html&gt; 效果截图 👇 可以看到需要设置 -webkit- 私有前缀（Firefox不需要），然后遮罩图片的话，我尝试以下两张图，A:黑白JPG图片；B:黑色圆形透明底PNG图片。 只有透明底的PNG图片才可以应用上遮罩，图片A尝试多次都不可以应用上【测试时间：2021年7月9日】，因为是 chrome 通过遮罩层的 alpha (透明)通道来实现遮罩功能的，并不是通过亮度和颜色差值 ❓ 那么 SVG 图形呢？&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt; &lt;circle cx=&quot;400&quot; cy=&quot;400&quot; r=&quot;300&quot; fill=&quot;black&quot;/&gt; &lt;/svg&gt; 也可以直接使用，截图就不加了，和上方的差不多只是没有 repeat，可能是因为绘制得太大了😂 - 追加：因为 &lt;svg&gt; 上没有设置 width 和 height 属性😐，设置上就会 repeat 了 然后是8个具体属性 mask-image: 遮罩图像; mask-mode: 遮罩图像的模式; mask-repeat: 遮罩图像的重复方式(同bg-repeat); mask-position: 遮罩图像的定位(同bg-position); mask-clip: 遮罩图像应用区域(同bg-clip); mask-origin: 遮罩图像应用原点(同bg-origin); mask-size: 遮罩图像尺寸大小(同bg-size); mask-composite: 遮罩图像的叠加方式。 基本上可以与 background 属性一样来理解并且语法相通，只有两个属性需要单独去尝试 mask-mode - 遮罩图像的模式; mask-composite - 遮罩图像的叠加方式。 因为只有 firefox 支持 mask-mode 和 mask-composite 属性，所以后边的示例都是在 firefox 下尝试的 Can I use results 2021年7月12日 🧷 1. 按顺序先来讲 mask-mode 属性直接读文档 mask-mode - CSS | MDN，可以看到： alpha: 使用遮罩层图像的透明度(alpha)值作为掩码值; luminance: 遮罩层图像的亮度值应用作掩码值; match-source: 资源的类型自动采用合适的遮罩模式。 如果 mask-image 属性是 &lt;mask-source&gt; 类型，遮罩层的亮度值会被作为掩码值; 如果它是类型 &lt;image&gt;，遮罩层的 alpha 值作为掩码值。 👇 MDN示例，在 CodePen 中打开 （记得使用FireFox打开） 嗯？？？为什么少了 mask-mode:match-source ?因为他只是 auto 的意思… 例如，如果我们的遮罩使用的是SVG中的&lt;defs&gt;中的&lt;mask&gt;元素，则此时的mask-mode属性的计算值是luminance，表示基于亮度遮罩。如果是其他场景，则计算值是alpha，表示基于透明度遮罩。张鑫旭 - 鑫空间 🧷 2. mask-composite 属性mask-composite 表示当同时使用多个图片进行遮罩时候的混合方式。 mask-composite: add; // 叠加(遮罩累加/并集) mask-composite: subtract; // 相减(遮罩相减/补集) mask-composite: intersect; // 相交(遮罩重叠部分/交集) mask-composite: exclude; // 排除（非重叠区域的合并/对称差） 还是使用MDN上的实例演示哈，在 CodePen 中打开 因为实例的star.svg是半透明的，所以mask-composite: subtract 和 mask-composite: exclude 看起来会有一些疑问，从现象来描述是： 相减：与后面遮罩图片重合的地方不显示，前一个遮罩结果之上继续应用后一个遮罩，遮罩互相应用。意味着遮罩图片越多，遮罩的区域越小。 排除：与后面遮罩图片重合的地方排除，也就是非重叠区域的合并，反向的相交 &#x3D;&gt; 对称差 使用没有透明度的遮罩示例来对照以下应用后的结果 尾声可以看到就算是2021年了，浏览器对于 mask 属性的实现还是有一些争议，chrome 还需要加私有前缀（-webkit-）才可以应用上，而且部分属性也不支持，吐槽一下已经 CR 5年了….. 虽然可以用，但是毕竟是一个处于 候选标准(CR)阶段 的属性，MDN也给予了提示，尽量控制适用范围。 这是一个实验中的功能此功能某些浏览器尚在开发中，请参考浏览器兼容性表格以得到在不同浏览器中适合使用的前缀。由于该功能对应的标准文档可能被重新修订，所以在未来版本的浏览器中该功能的语法和行为可能随之改变。 然后文章开头所提到的提问，通过 mask 属性的实现： 和 clip-path 一样，使用了 mask 属性之后会对所有内容进行裁剪，所以 filter drop-shadow() 应用的投影会被隐藏，所以需要在父级应用投影效果。 追加本来写完上边之后就结束了这篇笔记，但是看到了一个使用 element(#id) 作为遮罩层的例子，例如： &lt;div class=&quot;wrap&quot;&gt; &lt;img id=&quot;mask&quot; src=&quot;./mask.png&quot;&gt; &lt;img id=&quot;picture&quot; src=&quot;./picture.jpg&quot;&gt; &lt;/div&gt; &lt;style&gt; #picture &#123; width: 300px; mask-image: -moz-element(#mask); &#125; #mask &#123; display: none; &#125; &lt;/style&gt; 可以使用文字等 DOM元素 作为遮罩元素，但如果不想要遮罩层展示的话，还需要隐藏遮罩的 DOM，而且这个特性只有 FireFox 才支持 Can I use，大概了解一下就好了。 附mask - CSS（层叠样式表） | MDNCSS Masks | Can I useCSS Masking Module Level 1 - W3C Candidate Recommendation 客栈说书：CSS遮罩CSS3 mask&#x2F;masks详细介绍 - 张鑫旭mask-mode | CSS-Trickscss:mask浅析 - SegmentFaultJELLY | CSS3 Mask 安利报告 - JELLY element() - CSS: Cascading Style Sheets | MDN“-moz-element” | Can I useCSS Image Values and Replaced Content Module Level 4 - W3C Working Draft","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://yogwang.site/tags/CSS/"}]},{"title":"在 Flex 布局中使用 gap 属性","slug":"CSS-use-gap-in-flex-layout","date":"2021-05-29T07:02:19.000Z","updated":"2026-01-05T05:39:58.462Z","comments":true,"path":"2021/CSS-use-gap-in-flex-layout/","permalink":"https://yogwang.site/2021/CSS-use-gap-in-flex-layout/","excerpt":"最近在更新博客的样式，突然想到现在的flex布局已经可以定义间距了，所以大概整理了一下关于gap这个新属性资料。 gap 属性是用来设置网格行与列之间的间隙（gutters），该属性是 row-gap 与 column-gap 的简写形式。 起初是在 Grid 布局中用 grid-gap 来设置行间距和列间距的，后来意识到 Multi-column 布局中有一个 column-gap 属性，同时存在 grid-column-gap 和 column-gap 对于开发者来说是一个很疑惑的问题。并且在大范围应用的 Flex 布局中，并没有一个很好的方法来设置行间距和列间距。 于是CSS齐属属性规范开始调整，gap 代替了grid-gap 属性，并且规范对间隙属性进行了大统一，三种布局只需要使用 gap 属性就可以设置间距样式了。","text":"最近在更新博客的样式，突然想到现在的flex布局已经可以定义间距了，所以大概整理了一下关于gap这个新属性资料。 gap 属性是用来设置网格行与列之间的间隙（gutters），该属性是 row-gap 与 column-gap 的简写形式。 起初是在 Grid 布局中用 grid-gap 来设置行间距和列间距的，后来意识到 Multi-column 布局中有一个 column-gap 属性，同时存在 grid-column-gap 和 column-gap 对于开发者来说是一个很疑惑的问题。并且在大范围应用的 Flex 布局中，并没有一个很好的方法来设置行间距和列间距。 于是CSS齐属属性规范开始调整，gap 代替了grid-gap 属性，并且规范对间隙属性进行了大统一，三种布局只需要使用 gap 属性就可以设置间距样式了。 我一直觉得 Grid 布局的属性太多，而且早期的兼容性很差，相对于 Flex 布局 我觉得最好用的属性就是 grid-gap，因为 flex 只有 5 种对齐属性，如果需要做间距的话就很麻烦，只能使用 margin。今年年初的时候一大波的公众号在推送 flex 已经可以使用 gap 属性了，正好趁着这段时间博客主题改版，正好有用上。 🔨 使用方式在 grid 与 multi-column 种使用、表现形式是和原先是一样的 #grid-box &#123; display: grid; height: 200px; grid-template: repeat(3, 1fr) / repeat(3, 1fr); gap: 15px 20px; &#125; #column-box &#123; column-count: 3; gap: 20px; &#125; 在 flex 中用法与 grid 中一样，并且同时可以使用 justify-content 和 align-content #flex-box &#123; display: flex; flex-wrap: wrap; gap: 20px 20px; justify-content: space-between; &#125; ✨ gap 可接收的值： normal：默认值，默认为0px，在 multi-column-layout 中为 1em; &lt;length&gt;: 精确值，例如：px, em, rem, vw, vmin 之类的精确值； &lt;percentage&gt;: 百分比值，表示相对栅格容器的百分比； calc(): 计算值，经过计算函数来指定间距大小； inherit： 继承自父级； initial： 初始（或默认）值； unset： 设为未设定。 🚫 兼容性 Grid布局 还是支持 grid-gap 属性，但这是为了兼容那些不支持 gap 属性的浏览器，处于类似于私有前缀的状态了，MDN上是建议使用 gap 属性。 CSS property: gap: Supported in Grid Layout Flex布局 对于 gap 属性的支持，还处于草案阶段 [2021&#x2F;6&#x2F;3] ，如果需要在生产环境使用，可能需要进行考量，虽说主流浏览器全部都已经支持了。 CSS property: gap: Supported in Flex Layout Multi-column布局 已经支持了 gap 属性，但是只有列间距，没有行间距的概念，所以设置 row-gap 是没有效果的。 CSS property: gap: Supported in Multi-column Layout 🎃 一些疑惑 根据谁的大小来计算百分比？依据布局容器的 content-box 来确认百分比，与 padding/margin 的计算方式一致。 为何有时会失效？需要容器有对应确定的宽高值，否则为 0。 Safari 中已经支持了 gap 的 百分比值 和 calc()值2021年6月3日测试 资源gap (grid-gap) - CSS（层叠样式表） | MDNCSS Box Alignment Module Level 3 - W3C Editor’s Draft gap | CSS-TricksCSS gap属性进化史 « 张鑫旭-鑫空间-鑫生活","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://yogwang.site/tags/CSS/"}]},{"title":"Hexo 主题开发","slug":"hexo-theme-edit","date":"2021-05-27T06:01:41.000Z","updated":"2026-01-05T05:39:58.490Z","comments":true,"path":"2021/hexo-theme-edit/","permalink":"https://yogwang.site/2021/hexo-theme-edit/","excerpt":"去年就开始说要更新博客主题了，拖到现在终于有点空闲时间和动力了，相信大家已经使用过 Hexo 了，安装之类的我都不多废话了，直接开始。 想要自定义一个 Hexo 主题大概需要了解一个 模板引擎，Hexo 内置了 Swig，我所用的是默认安装的 EJS，反正都差不多，都提供了一些模板语法，书写还是按照Js的方法来的。然后先按照文档创建完主体目录结构和模板组件，就可以开始开发了，我比较偷懒没有使用 yeoman + generator-hexo-theme 来创建，直接复制了原先的 landscape 主题。 哦，对了！还要选择一个CSS预编译器，我还是没有选择适用了默认安装的 Stylus，你也可以按照习惯去安装，并且 install 对应的 Hexo 插件。","text":"去年就开始说要更新博客主题了，拖到现在终于有点空闲时间和动力了，相信大家已经使用过 Hexo 了，安装之类的我都不多废话了，直接开始。 想要自定义一个 Hexo 主题大概需要了解一个 模板引擎，Hexo 内置了 Swig，我所用的是默认安装的 EJS，反正都差不多，都提供了一些模板语法，书写还是按照Js的方法来的。然后先按照文档创建完主体目录结构和模板组件，就可以开始开发了，我比较偷懒没有使用 yeoman + generator-hexo-theme 来创建，直接复制了原先的 landscape 主题。 哦，对了！还要选择一个CSS预编译器，我还是没有选择适用了默认安装的 Stylus，你也可以按照习惯去安装，并且 install 对应的 Hexo 插件。 # Templates $ npm install --save hexo-renderer-ejs $ npm install --save hexo-renderer-pug $ npm install --save hexo-renderer-haml # Styles $ npm install --save hexo-renderer-less $ npm install --save hexo-renderer-sass $ npm install --save hexo-renderer-stylus 然后不需要配置，Hexo 会自动按照文件后缀名使用对应的拓展编译文件。 📚 前置学习 了解主题目录结构 👉 主题 | Hexo 模板页名称、局部变量的使用 👉 模版 | Hexo 全局变量和页面变量 👉 变量 | Hexo Hexo 内置辅助函数 👉 辅助函数（Helpers） | Hexo 以上四个文档希望你可以阅读完，特别是辅助函数，会在制作过程中反复用到，也是最关键的部分，我相信大家已经对 [html, css, js] 三剑客很熟悉了，所以就不提他们了。 完整目录如下： │ ├─ layout # 布局文件夹 │ ├─ partials # 局部模版 │ │ └─ recent-posts.ejs # 列表页文章Item │ ├─ index.ejs # 首页模板 │ ├─ layout.ejs # html结构 │ ├─ post.ejs # 文章列表模板 │ ├─ archive.ejs # 归档列表模板 │ ├─ category.ejs # 分类归档列表模板 │ ├─ tag.ejs # 标签归档列表模板 │ └─ page.ejs # 单页模板 │ ├─ scripts # 脚本文件夹 │ ├─ source # 资源文件夹 │ ├─ css │ ├─ js │ └─ favicon.ico │ ├─ .editorconfig # 编辑器配置文件 ├─ _config.yml # 主题配置文件 └─ package.json # 项目包管理文件 Part1. 主题模板开发首先会想到要着手的肯定是首页，但是直接开发首页肯定是不行的，还需要先把网页的结构搭完，好比现在 SPA 项目的 index.html 文件。那么就会先就需要调整 layout.ejs 这个模板文件，打开的话，可以看到一个简单的 html 结构，这个时候就是需要按照自己的想法来搭建主题的公共部分了，比如说 页首 与 页尾，然后使用 &lt;%- partial(path, [locals], [option]) %&gt; 来引入组件 locals和option的可接收参数文档。我把 meta 信息也提取成部件了，完成大概是这样的结构。 &lt;!-- layout page --&gt; &lt;!DOCTYPE html&gt; &lt;html lang=&quot;&lt;%= config.language =&gt;&quot;&gt; &lt;%- partial(&#x27;_partial/meta&#x27;) %&gt; &lt;body&gt; &lt;%- partial(&#x27;_partial/header&#x27;, null, &#123;cache: true&#125;) %&gt; &lt;div id=&quot;wrap&quot;&gt; &lt;%- body %&gt;&lt;!-- body变量，用于输出页面内容 --&gt; &lt;/div&gt; &lt;%- partial(&#x27;_partial/footer&#x27;, null, &#123;cache: true&#125;) %&gt; &lt;/body&gt; &lt;/html&gt; 然后开始编辑 index.ejs 这个文件，开始可以按照自己的喜好编辑首页了，记得使用 hexo s 命令开打开发模式查看效果。我是顺着上一版本的主页，只是展示文章，所以直接把文章卡片抽成组件了，从 page.posts 接收到文章列表，使用 forEach() 循环出列表，然后使用 paginator()函数 把分页组件也写好了 呃….好像也没有什么好说的，就是和过去 CMS 时代用模板语法来写 template 那样，只是以前是嵌入 php 的代码然后用 php 来执行渲染，而 Hexo 是用 JS 来编译成静态文件。 我这边大概完成主题之后的目录结构如下： layout ├─_partial # 小部件 │ │ archive.ejs # 文章分类列表组件 │ │ archive_post.ejs # 列表页文章卡片组件 │ │ article.ejs # 文章详情组件 │ │ footer.ejs # 页尾组件 │ │ header.ejs # 页头组件 │ │ meta.ejs # meta组件 │ │ sidebar.ejs # 侧边栏组件 │ │ soliloquy.ejs # 关于我组件 │ │ │ ├─_post # 文章组件 │ │ article_body.ejs # 文章内容部件 │ │ category.ejs # 文章分类部件 │ │ date.ejs # 文章日期部件 │ │ nav.ejs # 文章详情分页部件 │ │ tag.ejs # 文章标签部件 │ │ title.ejs # 文章标题部件 │ │ │ └─_widget # 侧边栏卡片组件 │ archive.ejs # 文章归档卡片 │ author.ejs # 个人信息卡片 │ category.ejs # 文章分类卡片 │ recent_posts.ejs # 最近发布卡片 │ shortcut_menu.ejs # 快捷分类菜单卡片 │ tag.ejs # 标签列表卡片 │ tag_cloud.ejs # 标签云卡片 │ │ about.ejs # 关于我模板 │ archive.ejs # 文章列表模板 │ category.ejs # 分类列表模板 │ index.ejs # 主页 │ layout.ejs # 布局模板 │ page.ejs # 单页模板 │ post.ejs # 文章详情模板 └─ tag.ejs # 标签页模板 需要注意的是一些默认的模板名称，hexo 会自动去寻找这些模板来生成对应的页面。模板文档 - Hexo 模板名 用途 回退 layout 布局 - index 首页 - post 文章 index page 分页 index archive 归档 index category 分类归档 archive tag 标签归档 archive 所以你的主题目录： 应包含一个 index 模板 如果要使用 layout 组件，必须要使用 &lt;%- body %&gt; 输出模板的内容。 Part2. 配置文件设置在开发主题的时候你会遇到一些属性可能全局会用到，比如说头部导航，页尾配置，侧边栏卡片显隐等，就可以配置 _config.yml 文件来实现全局变量 文档 Hexo的配置文件分为 站点配置文件 和 主题配置文件，分别位于 项目根目录 和 主题根目录 下。 一般来说，全局的一些配置项需要放到 站点配置文件 中，比如说：站点配置，静态页面生成规则，插件配置等，然后通过 config.xxx 来获取&amp;使用。和主题有关的配置则放到 主题配置文件 中，比如：侧边栏开关，社交账户信息，头部导航等控制主题内容的部分，通过 theme.xxx 来使用。 我的想法是尽量减少对于站点配置文件的控制，能放到主题配置文件中的就放到主题配置文件中。 🎉 尾声基本上关于主题开发的内容就那么多，整体来说只要你懂一些三剑客的基础很容易就可以自己开发出一个主题，只是有一些犄角旮旯需要你去查文档，有一些说明并不明显，需要耐心的从文档中检索出来。 如果需要发布到 Hexo 上，还需要通过 主题单元测试，确保每一项功能都能正常使用，发布步骤见文档 如果需要发布你的主题，那么我会在另一篇文章中来记录。我先挖一个坑，因为自己制作完主题之后还没有按照文档规范走完测试流程。 遇到的问题# 使用 is_current(path) 判断生成的 ‘active’ 类不会在对应分类添加，只会执行一次查看引入的部件 &lt;%- partial(&#39;partial/xxx&#39;,&#123; cache: &lt;Boolean&gt; &#125;) %&gt; 部分是否开启了缓存 👉 模版 | Hexo # orderby 有哪些可选参数? name 名称 length 文章数 random 随机排列 # 空白主题不支持 markdown 的 table 语法&#x2F;看不到表格因为没有设置 &lt;table&gt; 的样式，自己使用CSS写一个表格样式就好。 # 使用 hexo-prism-plugin 进行代码高亮处理，但是在列表页的预览内容中的代码块不会被处理其实会被处理，只是我在用 hexo-theme-unit-test 测试的时候有使用 代码块标签插件 的测试文章，类似这样： &#123;% codeblock lang:js mark:1,7-8,10 %&#125; const http = require(&#x27;http&#x27;); const hostname = &#x27;127.0.0.1&#x27;; const port = 1337; http.createServer((req, res) =&gt; &#123; res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/plain&#x27; &#125;); res.end(&#x27;Hello World\\n&#x27;); &#125;).listen(port, hostname, () =&gt; &#123; console.log(`Server running at http://$&#123;hostname&#125;:$&#123;port&#125;/`); &#125;); &#123;% endcodeblock %&#125; 需要开启 prismjs，默认是关闭的，在 _config.yml 中开启即可。 资源 Swig - A Node.js and Browser JavaScript Template Engine EJS – Embedded JavaScript templates Pug - Getting Started Haml hexojs&#x2F;site: The website for Hexo.","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://yogwang.site/tags/Hexo/"},{"name":"挖坑","slug":"挖坑","permalink":"https://yogwang.site/tags/%E6%8C%96%E5%9D%91/"}]},{"title":"原型链！ __proto__ 与 prototype","slug":"JS-proto-and-prototype","date":"2021-05-21T16:51:09.000Z","updated":"2026-01-05T05:39:58.476Z","comments":true,"path":"2021/JS-proto-and-prototype/","permalink":"https://yogwang.site/2021/JS-proto-and-prototype/","excerpt":"Every JavaScript object has a second JavaScript object (or null ,but this is rare) associated with it. This second object is known as a prototype, and the first object inherits properties from the prototype.每个 JavaScript 对象都会对应一个原型对象（除了 null），并从原型对象继承属性和方法。JavaScript 权威指南 一句话解释：对象 __proto__ 属性是JS内置的，它所对应值是原型对象的 prototype ；而 prototype 就是你自己写的原型属性、方法 加上 JS原型内置的属性、方法","text":"Every JavaScript object has a second JavaScript object (or null ,but this is rare) associated with it. This second object is known as a prototype, and the first object inherits properties from the prototype.每个 JavaScript 对象都会对应一个原型对象（除了 null），并从原型对象继承属性和方法。JavaScript 权威指南 一句话解释：对象 __proto__ 属性是JS内置的，它所对应值是原型对象的 prototype ；而 prototype 就是你自己写的原型属性、方法 加上 JS原型内置的属性、方法 var one = &#123;x: 1&#125;; var two = new Object(); one.__proto__ === Object.prototype // true Object.getPrototypeOf(one) === Object.prototype // true two.__proto__ === Object.prototype // true Object.getPrototypeOf(two) === Object.prototype // true one.toString === one.__proto__.toString // true two.toString === two.__proto__.toString // true two.toString === one.__proto__.toString // true 那现在的疑问就是 __proto__ 和 prototype 的使用 __proto__ 不是ES的标准，单纯是为了方便让用户可以直接获取，推荐通过 Object.getPrototypeOf() 来获取，并不推荐直接通过这方法来修改原型 prototype 是创建函数时，JS为这个函数自动添加的属性，通过手动配置 prototype 属性，或者指向现存的对象来继承该对象。 🎉 小结prototype 指向一块内存，这个内存里面有共用属性，__proto__ 指向同一块内存 prototype 和 __proto__ 的不同点在于： prototype 是构造函数的属性，而 __proto__ 是对象的属性 JavaScript 常被描述为一种 基于原型的语言 (prototype-based language) ——每个对象拥有一个 原型对象 ，对象以其原型为模板、从原型继承方法和属性。原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为 原型链 (prototype chain) ，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。 准确地说，这些属性和方法定义在 Object 的构造器函数(constructor functions)之上的 prototype 属性上，而非对象实例本身。 在传统的 OOP 中，首先定义“类”，此后创建对象实例时，类中定义的所有属性和方法都被复制到实例中。在 JavaScript 中并不如此复制 —— 而是在对象实例和它的构造器之间建立一个链接（它是 __proto__ 属性，是从构造函数的 prototype 属性派生的），之后通过上溯原型链，在构造器中找到这些属性和方法。 注意: 理解对象的原型（__proto__属性）与 构造函数的 prototype 属性之间的区别是很重要的。前者是每个实例上都有的属性，后者是构造函数的属性。 在JavaScript中，函数可以有属性。 每个函数都有一个特殊的属性叫作 prototype (原型)，通过给 prototype 添加属性和方法，来为以这个 函数 为 基础模型 的 实例对象 继承下来函数上所有的属性。 // 从函数里创建一个对象 function f() &#123; this.a = 1; this.b = 2; &#125; // 在f函数的原型上定义属性 f.prototype.b = 3; f.prototype.c = 4; // 通过new操作符来创建基于f()的对象实例 let o = new f(); // 输出一下 对象o console.log(o) /* log ƒ &#123; a:1, b:2 &#125; a: 1 b: 2 __proto__: b: 3 c: 4 constructor: ƒ f() arguments: null caller: null length: 0 name: &quot;f&quot; prototype: &#123;b: 3, c: 4, constructor: ƒ&#125; __proto__: ƒ () [[FunctionLocation]]: VM510:2 [[Scopes]]: Scopes[2] __proto__: Object */ // 更多熟悉调用demo console.log(o.a); // 1 // a是o的自身属性吗？是的，该属性的值为 1 console.log(o.b); // 2 // b是o的自身属性吗？是的，该属性的值为 2 // 原型上也有一个&#x27;b&#x27;属性，但是它不会被访问到。 // 这种情况被称为&quot;属性遮蔽 (property shadowing)&quot; console.log(o.c); // 4 // c是o的自身属性吗？不是，那看看它的原型上有没有 // c是o.[[Prototype]]的属性吗？是的，该属性的值为 4 console.log(o.d); // undefined // d 是 o 的自身属性吗？不是，那看看它的原型上有没有 // d 是 o.[[Prototype]] 的属性吗？不是，那看看它的原型上有没有 // o.[[Prototype]].[[Prototype]] 为 null，停止搜索 // 找不到 d 属性，返回 undefined // o.__proto__.__proto__.__proto__ =&gt; null // Object.getPrototypeOf(Object.getPrototypeOf(Object.getPrototypeOf(o))) =&gt; null 如果想知道 new 操作符做了那些事，可以查看这篇笔记 👉 JS中的 new 关键字做了什么？ 尾声- 使用不同的方法来创建对象和生成原型链？这个我就不多说了，直接看MDN上的示例就好 使用不同的方法来创建对象和生成原型链 - 继承与原型链 | MDN，知乎上也有，直接搜就好了。 - 简单的说，原型链 其实算是面向对象思想中的继承部分，以方便根据需求拆分功能，完成特定的工作职责 - ES6 提出了 类(Class) 这个概念让对象原型的写法更加清晰，更像面向对象编程的语法，并且同样有着 prototype 这个属性。 资源对象原型 - 学习 Web 开发 | MDN继承与原型链 - JavaScript | MDNObject.prototype.__proto__ - JavaScript | MDNObject.getPrototypeOf() - JavaScript | MDNJavascript Object Hierarchy JS 中 __proto__ 和 prototype 存在的意义是什么？ - 知乎傻傻分不清的__proto__与prototype - SegmentFault 思否从__proto__和prototype来深入理解JS对象和原型链 · Issue #9 · creeperyang&#x2F;blog","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"}]},{"title":"JS中的 new 关键字做了什么？","slug":"JS-what-dose-new-operators-do","date":"2021-05-21T10:48:10.000Z","updated":"2026-01-05T05:39:58.477Z","comments":true,"path":"2021/JS-what-dose-new-operators-do/","permalink":"https://yogwang.site/2021/JS-what-dose-new-operators-do/","excerpt":"new 运算符 创建 一个用户定义的 对象类型 的实例或 具有构造函数的内置对象 的实例。 完整的了解 new 运算符你可能还需要了解一下 面向对象思想 以及 原型链，可以简单查看这篇笔记 👉 原型链！ __proto__ 与 prototype 如果快速的了解 new 关键字按照MDN的文档描述来说就是： new关键字会创建一个空的简单JavaScript对象（即 &#123;&#125;）； 链接该对象（设置该对象的 constructor）到另一个对象 （绑定原型）； 将 步骤1 新创建的对象作为 this 的上下文 ； 如果该函数没有返回对象，则返回 this。 可以简单理解成 new 关键字帮我们处理了书写构造函数时一些固定的步骤","text":"new 运算符 创建 一个用户定义的 对象类型 的实例或 具有构造函数的内置对象 的实例。 完整的了解 new 运算符你可能还需要了解一下 面向对象思想 以及 原型链，可以简单查看这篇笔记 👉 原型链！ __proto__ 与 prototype 如果快速的了解 new 关键字按照MDN的文档描述来说就是： new关键字会创建一个空的简单JavaScript对象（即 &#123;&#125;）； 链接该对象（设置该对象的 constructor）到另一个对象 （绑定原型）； 将 步骤1 新创建的对象作为 this 的上下文 ； 如果该函数没有返回对象，则返回 this。 可以简单理解成 new 关键字帮我们处理了书写构造函数时一些固定的步骤 创建临时对象； 绑定原型； return 这个临时对象 整个遍写构造函数的过程中，可以省略上面的步骤，直接使用 this 就可以指向这个临时对象，为他创建属性，直接为 prototype 赋值属性和方法就可以对公共（对象原型）增加属性、方法。 未完成 尾声ES6 为 new 引入了一个 new.target 属性，可以用来确定构造函数是怎么调用的。 附new 运算符 - JavaScript | MDNObject.prototype.constructor - JavaScript | MDNJS 的 new 到底是干什么的？ - 知乎§ 6.new.target 属性 - Class 的基本语法 - ECMAScript 6入门","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"},{"name":"未完成","slug":"未完成","permalink":"https://yogwang.site/tags/%E6%9C%AA%E5%AE%8C%E6%88%90/"}]},{"title":"微信小程序学习日记 L05 获取用户资料","slug":"miniprogram-devDiary-05-authorize","date":"2021-05-20T08:04:22.000Z","updated":"2026-01-05T05:39:58.502Z","comments":true,"path":"2021/miniprogram-devDiary-05-authorize/","permalink":"https://yogwang.site/2021/miniprogram-devDiary-05-authorize/","excerpt":"在实际业务场景中，最常接触到的就是拉取微信登陆了，但单纯的一个点击按钮直接微信登录的需要获取多少微信权限呢？ 最少的需要使用到1个微信开放接口：wx.login，如果需要获取用户头像和昵称，需要调用 wx.getUserProfile 方法 (wx.getUserInfo 已调整【尾声#1】)，并且需要在绑定在按钮上 ，并会唤起授权提示；如果需要获取用户手机号信息，需要在按钮上绑定 getPhoneNumber 事件。 一般来说非敏感信息可以直接调用，含有敏感信息的接口需要绑定在按钮上，在用户自行操作之后才可以调用。","text":"在实际业务场景中，最常接触到的就是拉取微信登陆了，但单纯的一个点击按钮直接微信登录的需要获取多少微信权限呢？ 最少的需要使用到1个微信开放接口：wx.login，如果需要获取用户头像和昵称，需要调用 wx.getUserProfile 方法 (wx.getUserInfo 已调整【尾声#1】)，并且需要在绑定在按钮上 ，并会唤起授权提示；如果需要获取用户手机号信息，需要在按钮上绑定 getPhoneNumber 事件。 一般来说非敏感信息可以直接调用，含有敏感信息的接口需要绑定在按钮上，在用户自行操作之后才可以调用。 开放接口1、 微信登陆如果只是单纯需要获取用户的微信 openId 来关联用户账户，则可以直接调用 wx.login() 方法，把获取的 code(登录凭证) 传递给后端就可以，后端可以根据 code 请求微信的服务器端Api来换取 [ openid, unionid, session_key ] 一个简单的示例： // login.js Page(&#123; onLoad()&#123; // 可以绑定在页面中的某个按钮上，也可以页面载入后就直接请求 this.onWechatLogin() &#125; // 微信登陆操作 onWechatLogin () &#123; // 请求微信登陆api wx.login(&#123; success: (wxRes) =&gt; &#123; const data = &#123; code: wxRes.code &#125; // 请求后端登陆API，这个方法是我自己封装的请求函数， // 具体请看 小程序学习日记 L04 网络请求 postAction(&quot;/pub/weChat/login&quot;, data).then(res =&gt; &#123; // 服务器返回数据后的操作 &#125;) &#125; &#125;) &#125;, &#125;) 登陆接口文档 wx.login | 微信开放文档 小程序登陆流程 小程序登录 | 微信开放文档 服务器端文档 auth.code2Session | 微信开放文档 2、 获取用户资料在早些时候是调用微信的 wx.getUserInfo 接口，但是从我开始写小程序的时间，正好是 wx.getUserProfile() 更新替代的时候，所以我的获取用户资料的demo就直接使用 wx.getUserProfile() 接口。其实如果不需要保存用户头像和昵称，可以使用微信新提供的 &lt;open-data&gt; 组件直接在界面中展示 预览代码片段。 &lt;!-- 直接使用 open-data 组件展示用户头像和昵称 --&gt; &lt;open-data type=&quot;userAvatarUrl&quot;&gt;&lt;/open-data&gt; &lt;open-data type=&quot;userNickName&quot;&gt;&lt;/open-data&gt; 然后需要做头像固定宽高圆角之类样式的，给 &lt;open-data&gt; 添加 className 就可以了。不过这不在拉取授权的范畴内，所以只是举例，如果需要获取用户资料的需要以下方式来唤起授权 &lt;!-- page.wxml --&gt; &lt;view class=&quot;container&quot;&gt; &lt;!-- 需要在按钮上绑定获取用户信息的事件来触发 wx.getUserProfile --&gt; &lt;button bindtap=&quot;getUserProfile&quot; wx:if=&quot;&#123;&#123;!hasUserInfo&#125;&#125;&quot;&gt; 获取头像昵称 &lt;/button&gt; &lt;view wx:else&gt; &lt;image src=&quot;&#123;&#123; userInfo.avatarUrl &#125;&#125;&quot; mode=&quot;cover&quot;&gt;&lt;/image&gt; &lt;text&gt;&#123;&#123; userInfo.nickName &#125;&#125;&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; // page.js Page(&#123; data: &#123; userInfo: &#123;&#125;, hasUserInfo: false, &#125;, getUserProfile() &#123; // 要直接在按钮绑定的方法内调用 wx.getUserProfile // 不能在 callback 或者在 promise.then 中调用 wx.getUserProfile(&#123; desc: &#x27;用于完善会员资料&#x27;, success: (res) =&gt; &#123; this.setData(&#123; userInfo: res.userInfo, hasUserInfo: true &#125;) &#125; &#125;) &#125;, &#125;) 用户信息 | 微信开放文档 open-data | 微信开放文档 3、 获取用户手机号和以前的 wx.getUserInfo 获取微信用户个人信息一样，需要指定 open-type 的值为 getPhoneNumber，以及使用 bindgetphonenumber 绑定事件。在用户确认授权之后可以在 event 获取到加密后的 用户信息（encryptedData），以及加密向量（iv）等信息，最后就看需不需要回填到前台，如果不需要就直接在后端处理就可以了。 &lt;!-- page.wxml --&gt; &lt;button open-type=&quot;getPhoneNumber&quot; bindgetphonenumber=&quot;getPhoneNumber&quot;&gt;获取手机号&lt;/button&gt; // page.js Page(&#123; getPhoneNumber (e) &#123; // 检查服务器端 sessionKey 是否过期 wx.checkSession(&#123; success () &#123; // sessionKey 未过期 const &#123; iv, encryptedData &#125; = e.detail if(!iv) &#123; wx.showToast(&#123; title:&#x27;授权失败请重试&#x27; &#125;) return &#125; const data = &#123; iv:iv, // 加密算法的初始向量 encryptedData:encryptedData // 加密后的用户信息 &#125; // 请求服务端解密手机号 postAction(&quot;/user/weChat/getPhoneNumber&quot;, data).then(res=&gt;&#123; // 根据是否需要回填手机号做对应操作 &#125;) &#125;, fail () &#123; // sessionKey过期，重新做登录动作， // 让后端更新 sessionKey，并提示用户重新授权 &#125; &#125;) &#125; &#125;) 注意：在回调中调用 wx.login 登录，可能会刷新登录态。此时服务器使用 code 换取的 sessionKey 不是加密时使用的 sessionKey，导致解密失败。建议开发者提前进行 login；或者在回调中先使用 checkSession 进行登录态检查，避免 login 刷新登录态。 解密后的数据为： &#123; &quot;phoneNumber&quot;: &quot;13580006666&quot;, // 用户绑定的手机号（国外手机号会有国际区号） &quot;purePhoneNumber&quot;: &quot;13580006666&quot;, // 没有国际区号的手机号 &quot;countryCode&quot;: &quot;86&quot;, // 国际区号 &quot;watermark&quot;: // 数据水印 &#123; &quot;appid&quot;:&quot;APPID&quot;, // 归属小程序appid &quot;timestamp&quot;: TIMESTAMP // 数据获取的时间戳 &#125; &#125; 获取手机号 | 微信开放文档 wx.checkSession | 微信开放文档 服务端获取开放数据 | 微信开放文档 4、 调用微信支付支付 | 微信开放文档 5、 获取收货地址收货地址 | 微信开放文档 6、 获取微信运动微信运动 | 微信开放文档 7、 获取自定义权限wx.authorize | 微信开放文档授权 | 微信开放文档 ————– 未完成 —————🔊 尾声● 2021&#x2F;04&#x2F;15后（基础库2.10.4起） 微信调整了 wx.getUserInfo 接口现在已经只会返回匿名用户信息了，加密信息（encryptedData）中的 openID和unionID还可以获取，如果要获取用户个人信息，则需要使用 wx.getUserProfile 来代替，会唤起微信的授权窗口。调整说明 👉 小程序登录、用户信息相关接口调整说明 | 微信开放社区 资源 📚开放接口 | 微信开放文档服务端 | 微信开放文档","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"未完成","slug":"未完成","permalink":"https://yogwang.site/tags/%E6%9C%AA%E5%AE%8C%E6%88%90/"},{"name":"学习","slug":"学习","permalink":"https://yogwang.site/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"小程序","slug":"小程序","permalink":"https://yogwang.site/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"ES6 中的数组拓展方法 flat() & flatMap()","slug":"JS-flat-flatMap","date":"2021-05-17T06:14:01.000Z","updated":"2026-01-05T05:39:58.473Z","comments":true,"path":"2021/JS-flat-flatMap/","permalink":"https://yogwang.site/2021/JS-flat-flatMap/","excerpt":"之前有使用过 flat() 方法，但是一直不知道 flatMap() 方法，在使用 map() 方法组装集合的时候，在组装完成之后还要链式调用一下 flat()，如果可以知道 flatMap() 代码还能精简一点，也方便递归返回的数组内容。 本来是上个月发现的，但隔了一个月才有时间写，已经想不起来当时怎么发现的 flatMap() 这个方法了…就直接跳过前置场景，直接开始聊这两个扩展方法吧。","text":"之前有使用过 flat() 方法，但是一直不知道 flatMap() 方法，在使用 map() 方法组装集合的时候，在组装完成之后还要链式调用一下 flat()，如果可以知道 flatMap() 代码还能精简一点，也方便递归返回的数组内容。 本来是上个月发现的，但隔了一个月才有时间写，已经想不起来当时怎么发现的 flatMap() 这个方法了…就直接跳过前置场景，直接开始聊这两个扩展方法吧。 Array.prototype.flat([depth]) flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回，对原数据没有影响。 flat() 默认深度为 1，如果想要 “拉平” 多层的嵌套数组，可以将 flat() 方法的参数写成一个整数，表示想要拉平的层数。✨ 如果不管有多少层嵌套，都要转成一维数组，可以用 Infinity 关键字作为参数。✨ 如果原数组有空位，flat()方法会跳过空位(过滤掉空值) var arr1 = [1, 2, [3, 4]]; // 展开一层数组 arr1.flat(); // [1, 2, 3, 4] var arr2 = [1, 2, [3, 4, [5, 6]]]; arr2.flat(); // [1, 2, 3, 4, [5, 6]] // 展开两层数组 arr2.flat(2); // [1, 2, 3, 4, 5, 6] // 使用 Infinity，可展开任意深度的嵌套数组 var arr3 = [1, 2, [3, 4, [5, 6, [7, 8, [9, 10]]]]]; arr3.flat(Infinity); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] // flat() 方法会移除数组中的空项 var arr4 = [1, 2, , 4, 5]; arr4.flat(); // [1, 2, 4, 5] 很容易理解的一个方法，就是推平数组，其实成为自己想要的一维数组。不过可以接收一个 depth 参数，我是再写这篇笔记的时候才知道的，所以还是要多记笔记啊。 Array.prototype.flatMap(callback [, thisArg])) flatMap() 方法对原数组的每个成员执行一个函数（相当于执行 Array.prototype.map()），然后对返回值组成的数组执行 flat() 方法。该方法返回一个新数组，不改变原数组。 这个方法如果在知道 flat() 方法之后直接看，就还挺清楚作用是什么的，但是一看MDN上的说明，瞬间就被迷糊了….其实简单来说是先 map() 然后执行 flat() 的简化版（不能指定深度）。 ✨ flatMap() 只能展开一层数组 let arr = [&quot;it&#x27;s Sunny in&quot;, &quot;&quot;, &quot;California&quot;]; arr.map(x =&gt; x.split(&quot; &quot;)); // [[&quot;it&#x27;s&quot;,&quot;Sunny&quot;,&quot;in&quot;],[&quot;&quot;],[&quot;California&quot;]] arr.map(x =&gt; x.split(&quot; &quot;)).flat() // [&quot;it&#x27;s&quot;,&quot;Sunny&quot;,&quot;in&quot;, &quot;&quot;, &quot;California&quot;] arr.flatMap(x =&gt; x.split(&quot; &quot;)); // [&quot;it&#x27;s&quot;,&quot;Sunny&quot;,&quot;in&quot;, &quot;&quot;, &quot;California&quot;] 尾声使用 reduce() 与 concat() 来替代 flat() 方法就不复述了，直接去看MDN上的实现就好。 替代方案 - flat 替代方案 - flatMap 是不是发现了一个 Infinity 关键字？这个关键字可以在哪些地方使用？Infinity 是一个全局变量(只读)，大于任何值，你也可以取反 -Infinity 使用基本上只要可以传入一个正整数来 比较 或者 迭代 的都可以使用它 📚 资源Array.prototype.flat() - JavaScript | MDNArray.prototype.flatMap() - JavaScript | MDN§ 9.数组实例的 flat()，flatMap() - 数组的扩展 - ECMAScript 6入门Infinity - JavaScript | MDN","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"},{"name":"ECMAScript 6","slug":"ECMAScript-6","permalink":"https://yogwang.site/tags/ECMAScript-6/"}]},{"title":"VueJS 的过滤器 filter API","slug":"vue-api-filter","date":"2021-05-17T03:23:49.000Z","updated":"2026-01-05T05:39:58.521Z","comments":true,"path":"2021/vue-api-filter/","permalink":"https://yogwang.site/2021/vue-api-filter/","excerpt":"一直没有怎么用过 Vue 的 过滤器 API，都是直接用 AntD Pro 当中提供的数字千分格式化、时间格式化之类的，没有自己去声明过，主要是因为 Array.prototype.filter 的先入为主，一直把 vue.filter 理解成为了筛选，而不是过滤器。 其实，vue.filter 是借鉴了 Linux 当中的 Pipe 符号 (|) 来处理数据 ，然后借用了 filter 这个名字： 利用 Linux 所提供的管道符 “|” 将两个命令隔开，管道符左边命令的输出就会作为管道符右边命令的输入 其实我觉得如果直接用 pipe 来命名其实就更好理解了，但是也许是因为前端圈子接触到 pipe 的人并不多，使用 filter 这个熟悉的单词可能更加容易让大众接受。 使用起来确实很方便，用 | 符号分隔就行，会按照 从前往后的顺序 依次 传入过滤器，然后返回转换后的值。 等到后来再遇到适合的场景想起来使用 filter ，但又因为项目的历史原因没有去使用，因为自己都是局部使用 computed计算 和 方法调用返回 来处理（也是Vue3所推荐的替代过滤器的方式）","text":"一直没有怎么用过 Vue 的 过滤器 API，都是直接用 AntD Pro 当中提供的数字千分格式化、时间格式化之类的，没有自己去声明过，主要是因为 Array.prototype.filter 的先入为主，一直把 vue.filter 理解成为了筛选，而不是过滤器。 其实，vue.filter 是借鉴了 Linux 当中的 Pipe 符号 (|) 来处理数据 ，然后借用了 filter 这个名字： 利用 Linux 所提供的管道符 “|” 将两个命令隔开，管道符左边命令的输出就会作为管道符右边命令的输入 其实我觉得如果直接用 pipe 来命名其实就更好理解了，但是也许是因为前端圈子接触到 pipe 的人并不多，使用 filter 这个熟悉的单词可能更加容易让大众接受。 使用起来确实很方便，用 | 符号分隔就行，会按照 从前往后的顺序 依次 传入过滤器，然后返回转换后的值。 等到后来再遇到适合的场景想起来使用 filter ，但又因为项目的历史原因没有去使用，因为自己都是局部使用 computed计算 和 方法调用返回 来处理（也是Vue3所推荐的替代过滤器的方式） 初步使用：在组件中使用过滤器过滤器可以用在两个地方（可以直接的使用方式有 2 种） 在双花括号中 &#123;&#123; message | filterName &#125;&#125;; 在 v-bind 中 &lt;div v-bind:id=&quot;message | filterName&quot;&gt;&lt;/div&gt;。 那如果说我要使用多个过滤器呢？例如：&#123;&#123; message | filterA | filterB &#125;&#125; 会先传入 filterA 去处理，filterA 返回的结果继续传入给 filterB 最后展示的值就是 filterB 返回的结果。 🌰 DEMO: &lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;span&gt;&#123;&#123; price | NumberFormat | FilterDollarSign &#125;&#125;&lt;/span&gt; &lt;!-- 渲染结果是 $ 199,999,999 --&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default &#123; data() &#123; return &#123; price:199999999, &#125;; &#125;, filters:&#123; NumberFormat(value) &#123; if (!value) return &#x27;0&#x27; const intPartFormat = value.toString().replace(/(\\d)(?=(?:\\d&#123;3&#125;)+$)/g, &#x27;$1,&#x27;) return intPartFormat &#125;, FilterDollarSign(price)&#123; return `$ $&#123;price&#125;` &#125; &#125;, &#125;; &lt;/script&gt; ✨ 多参数 过滤器 的情况例如，需要传入 两个参数 的过滤器，刨开第一个默认传入的参数，键入第二个参数即可： &#123;&#123; price | NumberFormat(2) &#125;&#125; , 三个参数： &#123;&#123; price | NumberFormat(2, '$') &#125;&#125;，更多参数以此类推。 &lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;span&gt;&#123;&#123; price | NumberFormat(2, &#x27;$&#x27;) &#125;&#125;&lt;/span&gt; &lt;!-- 渲染结果是 $ 0.67 --&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default &#123; data() &#123; return &#123; price:0.6666, &#125;; &#125;, filters:&#123; NumberFormat(value, limit, sign) &#123; if (!value) return &#x27;0&#x27; const intPartFormat = value.toFixed(limit).toString() return `$&#123;sign&#125; $&#123;intPartFormat&#125;` &#125; &#125;, &#125;; &lt;/script&gt; 更进一步：使用全局过滤器在项目的不断完善中，会有出现一些重复使用的过滤器，如果每次都重新声明就很麻烦，就可以注册 全局过滤器 vue.filter 🌰 栗子： // main.js Vue.filter(&#x27;NumberFormat&#x27;, function (value) &#123; if (!value) &#123; return &#x27;0&#x27; &#125; const intPartFormat = value.toString().replace(/(\\d)(?=(?:\\d&#123;3&#125;)+$)/g, &#x27;$1,&#x27;) return intPartFormat &#125;) new Vue(&#123; // options &#125;).$mount(&#x27;#app&#x27;) 然后就可以在全局直接使用这个过滤器了，不需要单独再声明或者引入。 当然如果全部都直接在 main.js 当中书写很多过滤器就很容易让 main.js 内容过多，所以可以提取出来，例如 ant-design-vue-pro&#x2F;filter.js，然后再 import 进来就可以了 ant-design-vue-pro&#x2F;main.js ✨ 全局和局步同名冲突 当全局过滤器和局部过滤器重名时，会采用局部过滤器。 ✨ 以上说的都是在 &lt;template&gt; 当中使用过滤器，如果我想在 methods 当中使用呢?全局过滤器的话，可以直接使用文档中的 var myFilter = Vue.filter(&#39;my-filter&#39;) 来获取，然后就可以把 myFilter 当成一个函数使用了，如果时当前组件的过滤器的，可以使用 this.$options.filters[&#39;my-filter&#39;] 来获取，调用方式和上边一样。 🎐 尾声适合过滤器的场景一般是简单的字符串处理，例如上边提到的添加数字千分号、把 状态key 转换成 状态label 之类的。 过滤器中如何使用当前组件的 data 或者 methods 之类参看上条，如果需要使用 data、computed 和 methods 之类请使用 computed 替代 filter VueJS 3.x 当中的 filter 已删除 In 3.x, filters are removed and no longer supported. Instead, we recommend replacing them with method calls or computed properties.在 3.x 中，过滤器已删除，不再支持。相反地，我们建议用方法调用或计算属性替换它们。 🔗 资源Filters | Vue.js - v2.xFilters | Vue.js - v3.x","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"VueJS","slug":"VueJS","permalink":"https://yogwang.site/tags/VueJS/"}]},{"title":"微信小程序学习日记 L04 网络请求","slug":"miniprogram-devDiary-04-request","date":"2021-05-15T05:54:11.000Z","updated":"2026-01-05T05:39:58.502Z","comments":true,"path":"2021/miniprogram-devDiary-04-request/","permalink":"https://yogwang.site/2021/miniprogram-devDiary-04-request/","excerpt":"在小程序中发送网络请求，需要使用微信提供的API，提供了5种： 普通 HTTPS 请求（wx.request） 上传文件（wx.uploadFile） 下载文件（wx.downloadFile) WebSocket 通信（wx.connectSocket） UDP 通信（wx.createUDPSocket） 一般项目中使用频率最高的是 wx.request 和 wx.uploadFile 需要注意的是，小程序只可以跟指定的域名进行网络通信，需要事先设置通讯域名（服务器域名请在 「小程序后台-开发-开发设置-服务器域名」 中进行配置）。 可以查看 配置流程 了解一下具体注意项。","text":"在小程序中发送网络请求，需要使用微信提供的API，提供了5种： 普通 HTTPS 请求（wx.request） 上传文件（wx.uploadFile） 下载文件（wx.downloadFile) WebSocket 通信（wx.connectSocket） UDP 通信（wx.createUDPSocket） 一般项目中使用频率最高的是 wx.request 和 wx.uploadFile 需要注意的是，小程序只可以跟指定的域名进行网络通信，需要事先设置通讯域名（服务器域名请在 「小程序后台-开发-开发设置-服务器域名」 中进行配置）。 可以查看 配置流程 了解一下具体注意项。 #1 HTTPS 请求wx.request(options) 可以传入一个 options 对象，具体可以配置哪些参数可以查看 发起请求 - 参数 ，我就不一一例出来了。 简单的上一个登陆请求示例： wx.request(&#123; url: &#x27;https://example.weixin.qq.com/login&#x27;, // 接口地址 data: &#123; // 请求参数 uid: &#x27;admin&#x27;, pwd: &#x27;123456&#x27; &#125;, header: &#123; // 请求头 &#x27;content-type&#x27;: &#x27;application/json&#x27; // 默认json，为了举例我还是写上来了 &#125;, method:&#x27;POST&#x27;, // 请求类型 success (res) &#123; // 接口调用成功的回调函数 &#125;, fail (err) &#123; // 接口调用失败的回调函数 &#125; &#125;) 需要注意的是： 不支持以 Promise 风格 调用。Promise 风格 是基础库版本 2.10.2 起开始支持的新调用方式，旧版本只能使用 callback 的形式来处理 最终发送给服务器的数据是 String 类型，如果传入的 data 不是 String 类型，会被转换成 String ，可以查看 data 参数说明 不过一般我会自己把请求函数 Promisify，如下 // request.js export function request (&#123; url, method, data, contentType = &#123;&#125; &#125;) &#123; const &#123; requestUrl &#125; = getApp().globalData // 在 app.js 设置的全局变量 const apiUrl = requestUrl + url // 拼接完整请求地址 const token = wx.getStorageSync(&quot;token&quot;) const header = Object.assign(&#123; &quot;content-type&quot;: &quot;application/json&quot;, &quot;X-Access-Token&quot;: token &#125;, contentType) console.info(&quot;请求接口: &quot;, apiUrl); console.info(&quot;请求头部: &quot;, header) console.info(&quot;请求参数: &quot;, data) return new Promise((resolve, reject) =&gt; &#123; wx.request(&#123; url: apiUrl, data: data, method: method, header: header, success (res) &#123; console.info(`[$&#123;apiUrl&#125;]请求返回值:`); console.table(res.data) const &#123; success, result, message &#125; = res.data if(success) &#123; resolve(res.data) &#125; else &#123; reject(res.data) console.warn(&quot;ERROR_URL:&quot;, url) return onErr(res.data) // 异常处理 &#125; &#125;, fail (err) &#123; reject(err) Toast(&#123; title: &quot;服务器异常，请重试！&quot; &#125;) // 封装的wx.showToast() console.warn(&quot;----------请求异常-----------&quot;) console.warn(err) &#125; &#125;) &#125;) &#125; 然后再封装一下不同的请求方法，在使用的时候按需引入就好了 // manage.js import &#123; request &#125; from &#x27;./request&#x27; export const FORM_DATA = &#123;&quot;content-type&quot;: &quot;application/x-www-form-urlencoded;charset=UTF-8&quot;&#125; // post export function postAction (url, parameter, contentType = &#123;&#125;) &#123; return request(&#123; url: url, method: &#x27;POST&#x27;, data: parameter, contentType:contentType, &#125;) &#125; // http method= &#123;POST | PUT&#125; export function httpAction (url, parameter = &#123;&#125;, method, contentType = &#123;&#125;) &#123; return request(&#123; url: url, method: method, data: parameter, contentType:contentType, &#125;) &#125; // put export function putAction (url, parameter = &#123;&#125;, contentType = FORM_DATA) &#123; return request(&#123; url: url, method: &#x27;PUT&#x27;, data: parameter, contentType:contentType, &#125;) &#125; // get export function getAction (url, parameter = &#123;&#125;, contentType = &#123;&#125;) &#123; return request(&#123; url: url, method: &#x27;GET&#x27;, data: parameter, contentType:contentType, &#125;) &#125; // delete export function deleteAction (url, parameter = &#123;&#125;, contentType = &#123;&#125;) &#123; return request(&#123; url: url, method: &#x27;DELETE&#x27;, data: parameter, contentType:contentType, &#125;) &#125; 是不是有一股子 Ant Design Vue Pro 的味道 😂😂😂 #2 上传文件wx.uploadFile(options)，可以传入一个 options 对象，参数配置文档 注意：客户端发起一个 HTTPS POST 请求，其中 content-type 为 multipart/form-data。 示例代码： wx.chooseImage(&#123; success (res) &#123; const tempFilePaths = res.tempFilePaths // 获取的文件临时路径 wx.uploadFile(&#123; url: &#x27;https://example.weixin.qq.com/upload&#x27;, // 请求的网络接口 filePath: tempFilePaths[0], // 文件路径 name: &#x27;file&#x27;, // 文件key，服务端可以通过这个 key 获取文件二进制内容 formData: &#123; // 额外的 formData 可以不传 &#x27;user&#x27;: &#x27;test&#x27; &#125;, success (result)&#123; // 接口调用成功的回调函数 &#125;, fail (error)&#123; // 接口调用失败的回调函数 &#125; &#125;) &#125; &#125;) 同样也会封装成 Promise // request.js export function uploadFile (&#123; url, data &#125;) &#123; const &#123; requestUrl &#125; = getApp().globalData // 在 app.js 设置的全局变量 const apiUrl = requestUrl + url const token = wx.getStorageSync(&quot;token&quot;) const header = &#123; &quot;X-Access-Token&quot;: token &#125; console.info(&quot;请求接口: &quot;, apiUrl); console.info(&quot;请求头部: &quot;, header) console.info(&quot;文件地址: &quot;, data) return new Promise((resolve, reject) =&gt; &#123; wx.uploadFile(&#123; url: apiUrl, filePath: data.filePath, name: &#x27;file&#x27;, header: header, success: (res) =&gt; &#123; console.info(`[$&#123;apiUrl&#125;]请求返回值:`); console.table(res.data) const &#123; data, statusCode &#125; = res if (statusCode !== 200)&#123; Toast(&#123; title: &quot;上传失败&quot; &#125;) reject(res.data) return &#125; // 这里需要注意是否返回的是JSON格式的 data const d = JSON.parse(data) const &#123; success, result, message &#125; = data if (success) &#123; resolve(d) &#125; else &#123; reject(res.data) console.warn(&quot;ERROR_URL:&quot;, url) return onErr(d) // 异常处理 &#125; &#125;, fail (err) &#123; reject(err) Toast(&#123; title: &quot;服务器异常，请重试！&quot; &#125;) console.warn(&quot;-----------上传失败-----------&quot;); console.warn(err); &#125; &#125;) &#125;) &#125; #3 下载文件wx.downloadFile(options)，同样也可以传入一个 options 对象，配置文档 DownloadTask | 微信开放文档 发起一个 HTTPS GET 请求 返回文件的本地临时路径 (本地路径) 单次下载允许的最大文件为 200MB 注意：请在服务端响应的 header 中指定合理的 Content-Type 字段，以保证客户端正确处理文件类型。 示例代码 wx.downloadFile(&#123; url: &#x27;https://example.com/audio/123&#x27;, // 仅为示例，并非真实的资源 success (res) &#123; // 只要服务器有响应数据，就会把响应内容写入文件并进入 success 回调，业务需要自行判断是否下载到了想要的内容 if (res.statusCode === 200) &#123; wx.playVoice(&#123; filePath: res.tempFilePath &#125;) &#125; &#125; &#125;) 暂时还没有使用的场景，就暂时不描述了，WebSocket 也是还没有在小程序业务上使用过，就不细说了，简单的用文档中的示例 #4 WebSocket 通信首先需要使用 wx.connectSocket(options) 创建一个 WebSocket 连接。具体文档 SocketTask | 微信开放文档然后就和正常使用 WebSocket 一样了： 方法 wx.sendSocketMessage(Object object) 通过 WebSocket 连接发送数据。 wx.closeSocket(Object object) 关闭 WebSocket 连接 事件 全局事件 wx.onSocketOpen(callback) 监听 WebSocket 连接打开事件 wx.onSocketMessage(callback) 监听 WebSocket 接受到服务器的消息事件 wx.onSocketError(callback) 监听 WebSocket 错误事件 wx.onSocketClose(callback) 监听 WebSocket 连接关闭事件 当前Socket事件 通过 wx.connectSocket() 接口创建返回赋值给变量 SocketTask SocketTask.onSocketOpen(callback) 监听 WebSocket 连接打开事件 SocketTask.onSocketMessage(callback) 监听 WebSocket 接受到服务器的消息事件 SocketTask.onSocketError(callback) 监听 WebSocket 错误事件 SocketTask.onSocketClose(callback) 监听 WebSocket 连接关闭事件 #5 UDP 通信使用 wx.createUDPSocket() 创建一个 UDP Socket 实例，之后就可以和 WebSocket 通信类似的方式使用 UDPSocket API来通信了，具体文档 UDPSocket | 微信开放文档 方法 UDPSocket.bind(number port) 绑定一个可用端口号 UDPSocket.send() 向指定的 IP 和 port 发送消息 UDPSocket.connect(Object object) 预先连接到指定的 IP 和 port，需要配合 write 方法一起使用 UDPSocket.write() 用法与 send 方法相同，如果没有预先调用 connect 则与 send 无差异 UDPSocket.close() 关闭 UDP Socket 实例，相当于销毁 事件 UDPSocket.onClose(callback) 监听关闭事件 UDPSocket.offClose(callback) 取消监听关闭事件 UDPSocket.onError(callback) 监听错误事件 UDPSocket.offError(callback) 取消监听错误事件 UDPSocket.onListening(callback) 监听开始监听数据包消息的事件 UDPSocket.offListening(callback) 取消监听开始监听数据包消息的事件 UDPSocket.onMessage(callback) 监听收到消息的事件 UDPSocket.offMessage(callback) 取消监听收到消息的事件 错误码之类的直接看 文档 吧。这个API应该是和我无缘了，物联网和直播之类的场景我应该是很难遇到的。 其它📌 配置网络请求超时时间如果需要配置超时时间则需要去 app.json 中配置 networkTimeout，默认 60000 (单位：毫秒)，最大超时时间也是 60000。可以为4个网络请求单独配置超时时间，具体查看 👉 配置文档 // app.json &#123; // 其他配置项.... &quot;networkTimeout&quot;: &#123; &quot;request&quot;: 10000, // wx.request 的超时时间 &quot;uploadFile&quot;: 10000 // wx.uploadFile 的超时时间 &#125; &#125; 资源网络 | 微信开放文档RequestTask | 微信开放文档API Promise化 | 微信开放文档 WebSocket - Web API 接口参考 | MDN","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"挖坑","slug":"挖坑","permalink":"https://yogwang.site/tags/%E6%8C%96%E5%9D%91/"},{"name":"未完成","slug":"未完成","permalink":"https://yogwang.site/tags/%E6%9C%AA%E5%AE%8C%E6%88%90/"},{"name":"学习","slug":"学习","permalink":"https://yogwang.site/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"小程序","slug":"小程序","permalink":"https://yogwang.site/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"CSS 选择器权重和优先级","slug":"CSS-specificity-selectors-weight","date":"2021-05-14T03:03:15.000Z","updated":"2026-01-05T05:39:58.461Z","comments":true,"path":"2021/CSS-specificity-selectors-weight/","permalink":"https://yogwang.site/2021/CSS-specificity-selectors-weight/","excerpt":"群里突然又聊到了CSS样式的权重，这个话题每隔一段时间就会出现一次，但是每次都去搜索找选择器权重的文章分享有点太麻烦了，主要是配图，想要找到自己记忆里的那张图真的很麻烦😂，所以还是自己整理一篇，以后直接分享自己的笔记就好了。其实权重计算这个东西不麻烦，就是分 4 类: inlineStyle: 行内样式 #ID: ID选择器 .Class: 类,属性和伪类选择器 Element: 元素和伪类元素选择器 简单的权重比较 inline style &gt; ID &gt; Class &gt; Element &gt; * 这个应该不需要说了吧，主要是多个选择器混合使用时计算的问题。","text":"群里突然又聊到了CSS样式的权重，这个话题每隔一段时间就会出现一次，但是每次都去搜索找选择器权重的文章分享有点太麻烦了，主要是配图，想要找到自己记忆里的那张图真的很麻烦😂，所以还是自己整理一篇，以后直接分享自己的笔记就好了。其实权重计算这个东西不麻烦，就是分 4 类: inlineStyle: 行内样式 #ID: ID选择器 .Class: 类,属性和伪类选择器 Element: 元素和伪类元素选择器 简单的权重比较 inline style &gt; ID &gt; Class &gt; Element &gt; * 这个应该不需要说了吧，主要是多个选择器混合使用时计算的问题。 大部分人想到CSS权重应该会首先想到这个图 图片来源: 简明现代魔法 然后简单的按照这里的权重去计算出来结果去比较 例如： 但是！这样的计算会有一个问题，就是如果说某一项选择器超过了10个，那么是不是就会造成疑问，是否会晋级例如 // 1个ID选择器 #demo &#123; color:green &#125; // 11个class选择器 .demo1 .demo2 .demo3 .demo4 .demo5 .demo6 .demo7 .demo8 .demo9 .demo10 .demo11 &#123; color:red &#125; 按照上边的计算方式，得出的结果就是 100 ：110，但是实际并不会被11个类选择器所覆盖。 所以其实，是一个类似数组的形式，其计算结果为 [0, 1, 0, 0] 比上 [0, 0, 11, 0]， 这点可以从 W3C规范 上看到，其实是分为 [A, B, C, D] 四类，然后去一对一去比较，并不会被 进位 所影响。 ⭐ !important !important 是一个特殊的声明，W3C 将其与选择器权重计算区分开，但是很多文章中把他放置到 A 类之前作为 第0类 权重，确实在实际工作中观察到的效果也一致，只不过不能通过重复声明 !important 来达到提升权重的目的（Invalid property value） 但如果是继承下来的 !important 属性，则会被新的声明覆盖。 # 如果使用简写属性并且使用 !important 声明 Declaring a shorthand property (e.g., ‘background‘) to be “!important“ is equivalent to declaring all of its sub-properties to be “!important“. 将简写属性（例如’background‘）声明为 “!important“ 等同于将其所有子属性声明为 “!important“ 。 接下来看一个完整的例子 &lt;div class=&quot;demo-class1 demo-class2&quot;&gt;&lt;span&gt;测试文字ABC&lt;/span&gt;&lt;/div&gt; 的元素样式： .demo-class1 &#123; font: italic 12pt sans-serif !important; text-indent: 1em ! important; // 被覆盖 &#125; .demo-class2 &#123; font-weight: bold; // 未生效 font-size: 24pt; // 未生效 line-height: 1.2 !important; // 生效 text-indent: 1.5em !important; // 生效 &#125; .demo-class2 span &#123; font-style: normal // 生效 &#125; 尾声我所推荐的权重计算图 新版本中的选择器权重修改在 W3C 最新版的 选择器文档 中，行内样式已经从权重中移出了，权重变成了三类 [#ID, .Class, Element] 在阅读 W3C 规范中，发现有中有这样一句话 By default, rules in author style sheets have more weight than rules in user style sheets. Precedence is reversed, however, for “!important” rules. All user and author rules have more weight than rules in the UA’s default style sheet. 默认情况下，author style sheets(作者样式表) 中的规则比 user style sheets(用户样式表) 中的规则具有更大的权重。 但是，对于 “!important” 规则，优先级相反。 与 UA 的默认样式表中的规则相比，所有用户和作者规则的权重均更大。 其中的 Author Style sheets、User Style sheets 是我没有遇到过的名词，UA 当然是浏览器(用户代理)默认样式，从查阅到的结果来看： 作者样式表 (Author Style sheets)作为开发者的我们为项目所配置的样式表 用户样式表 (User Style sheets)浏览器为浏览站点的用户提供的一个修改当前站点样式的功能（一般都是浏览器插件实现）所生成的样式表 # 参考CSS2 - 6.4 The cascade - W3C RecommendationCSS2 - 6.4.2 !important rules - W3C RecommendationCSS2 - 6.4.3 Calculating a selector’s specificity - W3C RecommendationSelectors - 16. Calculating a selector’s specificity - W3C RecommendationDraft - 6.3. Important Declarations: the !important annotation - W3C Editor’s Draft CSS选择器的权重计算规则 - 简明现代魔法Day20：小事之 CSS 權重 (css specificity) - iT 邦幫忙Specifics on CSS Specificity | CSS-TricksUser style sheet vs Author style sheet | Treehouse Community","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://yogwang.site/tags/CSS/"}]},{"title":"微信小程序学习日记 L03 生命周期","slug":"miniprogram-devDiary-03-lifecycle","date":"2021-05-13T11:29:31.000Z","updated":"2026-01-05T05:39:58.502Z","comments":true,"path":"2021/miniprogram-devDiary-03-lifecycle/","permalink":"https://yogwang.site/2021/miniprogram-devDiary-03-lifecycle/","excerpt":"一开始按照 Vue 的思路下来，会认为生命周期很重要，需要完整的看一遍，但是其实整个小程序开发完之后，生命周期的概念其实并不是很重要，大概分成 小程序 的生命周期 和 页面/组件 的生命周期。这些生命周期函数中 主要就是使用 onShow 和 onLoad 两个，用来获取和设置初始参数，发起请求等等。其它的几个回调函数其实很少有用到，但是还是聊一聊吧。","text":"一开始按照 Vue 的思路下来，会认为生命周期很重要，需要完整的看一遍，但是其实整个小程序开发完之后，生命周期的概念其实并不是很重要，大概分成 小程序 的生命周期 和 页面/组件 的生命周期。这些生命周期函数中 主要就是使用 onShow 和 onLoad 两个，用来获取和设置初始参数，发起请求等等。其它的几个回调函数其实很少有用到，但是还是聊一聊吧。 📱 app.js 小程序的生命周期回调函数 App(Object object) | 微信开放文档1. onLaunch(options) 小程序初始化完成时触发 全局只触发一次 参数也可以使用 wx.getLaunchOptionsSync 获取 options参数和 wx.getLaunchOptionsSync 方法的回调参数一致 注意：部分版本在无 referrerInfo的时候会返回 undefined，建议使用 options.referrerInfo &amp;&amp; options.referrerInfo.appId 进行判断。 2. onShow(options) 小程序启动，或从后台进入前台显示时触发 可以使用 wx.onAppShow 绑定监听 options参数与 wx.onAppShow 方法的回调参数一致 3. onHide() 小程序从前台进入后台时触发 可以使用 wx.onAppHide 绑定监听 📄 页面中的生命周期回调函数 Page(Object object) | 微信开放文档1. onLoad(options) 页面加载时触发 一个页面在一个生命周期中只会调用一次 可以在 options 中获取打开当前页面路径中的参数。 2. onShow() 页面显示&#x2F;切入前台时触发 一般的接口请求我会在这边调用 3. onReady() 页面初次渲染完成时触发 代表页面已经准备妥当，可以和视图层进行交互。 一个页面只会调用一次 注意：对界面内容进行设置的 API 如 wx.setNavigationBarTitle，请在 onReady 之后进行。 4. onHide() 页面隐藏&#x2F;切入后台时触发 触发时机： 如 wx.navigateTo 或底部 tab 切换到其他页面，小程序切入后台等。 5. onUnload() 页面卸载时触发 触发时机：如 wx.redirectTo 或 wx.navigateBack 到其他页面时 示例代码： Page(&#123; data: &#123; text: &quot;This is page data.&quot; &#125;, onLoad: function(options) &#123; // Do some initialize when page load. &#125;, onShow: function() &#123; // Do something when page show. &#125;, onReady: function() &#123; // Do something when page ready. &#125;, onHide: function() &#123; // Do something when page hide. &#125;, onUnload: function() &#123; // Do something when page close. &#125;, onPullDownRefresh: function() &#123; // Do something when pull down. &#125;, onReachBottom: function() &#123; // Do something when page reach bottom. &#125;, onShareAppMessage: function () &#123; // return custom share data when user share. &#125;, onPageScroll: function() &#123; // Do something when page scroll &#125;, onResize: function() &#123; // Do something when page resize &#125;, // 自定义函数 onCustomMethod: function() &#123; this.setData(&#123; text: &#x27;Set some data for updating view.&#x27; &#125;, function() &#123; // this is setData callback &#125;) &#125;, &#125;) 📑 组件中的生命周期回调函数 组件生命周期 | 微信开放文档1. created() 在组件实例刚刚被创建时执行 组件实例刚刚被创建好时， created 生命周期被触发。 此时还不能调用 setData 2. attached() 在组件实例进入页面节点树时执行 在组件完全初始化完毕、进入页面节点树后， attached 生命周期被触发。 绝大多数初始化工作可以在这个时机进行 3. ready() 在组件在视图层布局完成后执行 同页面组件的 onShow 4. moved() 在组件实例被移动到节点树另一个位置时执行 没有一个很合适的场景，在小程序中也有人提问这个函数的执行时机，我写了一个片段可以查看 🔖代码片段 5. detached() 在组件实例被从页面节点树移除时执行 退出一个页面时，如果组件还在页面节点树中，则 detached 会被触发。 🧷 组件所在页面的生命周期： 还有一些特殊的生命周期，它们并非与组件有很强的关联，但有时组件需要获知，以便组件内部处理。这样的生命周期称为“组件所在页面的生命周期”，在 pageLifetimes 定义段中定义。 1. show() 组件所在的页面被展示时执行2. hide() 组件所在的页面被隐藏时执行3. resize(size) 组件所在的页面尺寸变化时执行 可以接收一个 size 参数 自小程序基础库版本 2.2.3 起，组件的的生命周期也可以在 lifetimes 字段内进行声明（这是推荐的方式，其优先级最高）。 在 behaviors 中也可以编写生命周期方法，同时不会与其他 behaviors 中的同名生命周期相互覆盖。但要注意，如果一个组件多次直接或间接引用同一个 behavior ，这个 behavior 中的生命周期函数在一个执行时机内只会执行一次。 🌰 组件生命周期完整示例Component(&#123; // 推荐组件生命周期函数定义方式 lifetimes: &#123; attached: function() &#123; // 在组件实例进入页面节点树时执行 &#125;, detached: function() &#123; // 在组件实例被从页面节点树移除时执行 &#125;, &#125;, // 以下是旧式的定义方式，可以保持对小于 2.2.3 版本基础库的兼容 attached: function() &#123; // 在组件实例进入页面节点树时执行 &#125;, detached: function() &#123; // 在组件实例被从页面节点树移除时执行 &#125;, // 组件所在页面的生命周期回调 pageLifetimes: &#123; show: function() &#123; // 页面被展示 &#125;, hide: function() &#123; // 页面被隐藏 &#125;, resize: function(size) &#123; // 页面尺寸变化 &#125; &#125; &#125;)尾声🎇 在组件中有提到 behavior 这个东西的一些疑问behavior 直译过来就是行为，有点不是很明确，只能看 behaviors | 微信开放文档 上的解释： behaviors 是用于组件间代码共享的特性，类似于一些编程语言中的 “mixins” 或 “traits”。 再继续往下翻文档的时候看到 使用方法 和 同名字段的覆盖和组合规则 就基本能确定了，就是 VueJS 中的 mixins API 但是如果在 behavior 中也使用了生命周期函数，和当前组件的生命周期函数的谁先执行呢？是否和Vue一样？可以查看官方提供的 🔖代码片段实际操作得出的结果：先执行 behavior 的生命周期函数，然后再是执行组件本身的生命周期函数文档也给出了规则： 对于同种生命周期函数，遵循如下规则： behavior 优先于组件执行； 子 behavior 优先于 父 behavior 执行； 靠前的 behavior 优先于 靠后的 behavior 执行； 最后本文所描述小程序最新版本 v2.17.0 (2021-04-28) 🙄 疑问获取场景值 可以在 app.js 的 onLaunch 和 onShow 中获取，并不能在页面中的 onLaunch 和 onShow 中获取，会返回 undefined，但可以使用 wx.getLaunchOptionsSync() 这个 API 来获取小程序启动时的参数。 文档App(Object object) | 微信开放文档Page(Object object) | 微信开放文档组件生命周期 | 微信开放文档behaviors | 微信开放文档场景值 | 微信开放文档","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://yogwang.site/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"小程序","slug":"小程序","permalink":"https://yogwang.site/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"微信小程序学习日记 L02 路由跳转","slug":"miniprogram-devDiary-02-router","date":"2021-05-09T07:25:19.000Z","updated":"2026-01-05T05:39:58.502Z","comments":true,"path":"2021/miniprogram-devDiary-02-router/","permalink":"https://yogwang.site/2021/miniprogram-devDiary-02-router/","excerpt":"以前一直都是写的 Vue，所以在刚接触小程序的时候会疑惑，小程序是否也有和 Vue 一样有路由表，但是看完开放文档之后发现没有路由表，就很疑惑。那小程序怎么去做页面跳转的呢？ 首先，虽然小程序没有路由表，但是在全局配置文件(app.json)中有 pages 信息用于指定小程序由哪些页面组成，每一项都对应一个页面的 路径（含文件名） 信息。文件名不需要写文件后缀，框架会自动去寻找对应位置的文件进行处理。","text":"以前一直都是写的 Vue，所以在刚接触小程序的时候会疑惑，小程序是否也有和 Vue 一样有路由表，但是看完开放文档之后发现没有路由表，就很疑惑。那小程序怎么去做页面跳转的呢？ 首先，虽然小程序没有路由表，但是在全局配置文件(app.json)中有 pages 信息用于指定小程序由哪些页面组成，每一项都对应一个页面的 路径（含文件名） 信息。文件名不需要写文件后缀，框架会自动去寻找对应位置的文件进行处理。 例如默认项目中: &#123; &quot;pages&quot;: [ &quot;pages/index/index&quot;, // 首页 &quot;pages/logs/logs&quot; // 日志页 ], &quot;entryPagePath&quot;: &quot;pages/index/index&quot; // 初始页面 &#125; 可以通过 entryPagePath 指定小程序的初始页面（首页），如果未配置则默认为 pages 数组的第一项。 📑 pages - 全局配置 | 微信开放文档 如果想要配置到底部的Tabs上，则需要在 tabBar 属性中配置例如： &#123; &quot;pages&quot;: [ &quot;pages/index/index&quot;, &quot;pages/logs/logs&quot; ], &quot;entryPagePath&quot;: &quot;pages/index/index&quot;, &quot;tabBar&quot;: &#123; &quot;color&quot;: &quot;#BBBBBD&quot;, // 文字默认颜色 &quot;selectedColor&quot;: &quot;#040104&quot;, // 文字选中时的颜色 &quot;list&quot;: [ // tab 的列表 &#123; &quot;pagePath&quot;: &quot;pages/index/index&quot;, // 页面路径，必须在 pages 中先定义 &quot;text&quot;: &quot;首页&quot;, // tab 上按钮文字 &quot;iconPath&quot;: &quot;assets/img/tabbar_home.png&quot;, // icon图片路径 &quot;selectedIconPath&quot;: &quot;assets/img/tabbar_home_active.png&quot; // tab选中时icon图片路径 &#125;, &#123; &quot;pagePath&quot;: &quot;pages/logs/logs&quot;, &quot;text&quot;: &quot;日志&quot;, &quot;iconPath&quot;: &quot;assets/img/tabbar_logo.png&quot;, &quot;selectedIconPath&quot;: &quot;assets/img/tabbar_logo_active.png&quot; &#125; ] &#125;, &#125; 注意：只能配置最少 2 个、最多 5 个 tab，tab 按数组的顺序排序，每个项都是一个对象 📑 tabBar - 全局配置 | 微信开放文档📑 自定义 tabBar | 微信开放文档 页面信息配置完了，怎么进行路由呢？小程序提供了 5 种路由操作API： #1. wx.switchTab(Opts) 跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面 #2. wx.navigateTo(Opts) 保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面。 对应 vue-router 当中的 $router.push() #3. wx.redirectTo(Opts) 关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面。 对应 vue-router 当中的 $router.replace() #4. wx.navigateBack(Opts) 关闭当前页面，返回上一页面或多级页面，如果大于现有页面数，则返回到首页。 对应 vue-router 当中的 $router.back()、$router.forward()、$router.go(-1) 或者 $router.go(-n) #5. wx.reLaunch(Opts) 关闭所有页面，打开到应用内的某个页面 可以理解成 location.reload() ，刷新小程序并且打开指定页面 注意：小程序中页面栈最多十层 最后是疑问部分：🎇 路由是否可以像 vue-router 一样省略 index不可以，需要全路径 🎇 如何路由传参需要跳转的应用内非 tabBar 的页面路径后可以用 query 的形式传递参数，如 path?key=value&amp;key2=value2。页面中也可以在 onLoad 事件中接受参数 Page(&#123; onLoad: function(option)&#123; console.log(option.query) &#125; &#125;) 具体查看文档 wx.navigateTo(Object object) | 微信开放文档 🎇 清空路由历史没有单独的清空跳转历史API，可以直接使用 wx.reLaunch() 来跳转到目标页面，并且同时关闭所有已经打开过的页面，就不能用 wx.navigateBack() 返回了，左上角的按钮也会变成 🏠 home 🎇 路由文档中的 EventChannel 是什么 如果一个页面由另一个页面通过 wx.navigateTo 打开，这两个页面间将建立一条数据通道 被打开的页面可以通过 this.getOpenerEventChannel() 方法来获得一个 EventChannel 对象； wx.navigateTo 的 success 回调中也包含一个 EventChannel 对象。 有点 Vue 中的父子组件通信 $emit 和 @on ，比如说来进行数据回传： 1.先打开页面A；2.然后选择具体信息（打开页面B）；3.选择完成确定；4.返回页面A（接收页面B回传的数据） 的步骤。 示例代码就不复制过来了，直接看 示例代码 内的 Demo 就好了，也可以查看 📌代码片段 EventChannel | 微信开放文档页面间通信 - Page(Object object) | 微信开放文档 本文所描述小程序最新版本 v2.17.0 (2021-04-28)","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://yogwang.site/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"小程序","slug":"小程序","permalink":"https://yogwang.site/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"微信小程序学习日记 L01 目录结构","slug":"miniprogram-devDiary-01-structure","date":"2021-05-06T14:21:47.000Z","updated":"2026-01-05T05:39:58.502Z","comments":true,"path":"2021/miniprogram-devDiary-01-structure/","permalink":"https://yogwang.site/2021/miniprogram-devDiary-01-structure/","excerpt":"小程序包含一个描述整体程序的 app 和多个描述各自页面的 page。刚刚接触到小程序，使用 微信开发者工具 新建完项目之后，会有一个这样的初始结构： ├─pages │ ├─index │ │ index.js │ │ index.json │ │ index.wxml │ │ index.wxss │ │ │ └─logs │ logs.js │ logs.json │ logs.wxml │ logs.wxss │ ├─utils │ util.js ├─ app.js ├─ app.json ├─ app.wxss ├─ project.config.json └─ sitemap.json","text":"小程序包含一个描述整体程序的 app 和多个描述各自页面的 page。刚刚接触到小程序，使用 微信开发者工具 新建完项目之后，会有一个这样的初始结构： ├─pages │ ├─index │ │ index.js │ │ index.json │ │ index.wxml │ │ index.wxss │ │ │ └─logs │ logs.js │ logs.json │ logs.wxml │ logs.wxss │ ├─utils │ util.js ├─ app.js ├─ app.json ├─ app.wxss ├─ project.config.json └─ sitemap.json 先看最外层的文件 [ app.js, app.json, app.wxss, project.config.json, sitemap.json ] app.js 小程序实例化，可配置小程序实例 设置生命周期回调和事件监听 配置小程序全局对象 globalData 全局可以通过 getApp() 方法获取小程序实例恶 app.json 小程序全局公共配置、默认配置项 &quot;pages&quot; 页面路由配置 &quot;window&quot; 全局默认页我面样式配置 配置文档 &quot;tabBar&quot; 底部 选项卡 配置就 &quot;usingComponents&quot; 全局自定义组件配置 使用自定义组件 其它他配置项可以查看 👉 全局配置 | 微信开放文档 app.wxss 小程序全局样式 小程序全局的样式配置，会被局部样式覆盖 具有 CSS 大部分特性 当前支持的选择器 👉 选择器 | 微信开放文档 拓展了一个尺寸单位 rpx 尺寸单位 | 微信开放文档 project.config.json 小程序项目配置文件 可以直接配置本地小程序项目属性，工具栏-设置-项目设置 中设置的配置项 每次提交项目时不会提交该文件 sitemap.json 配置小程序及其页面是否允许被微信搜索索引 rules 索引规则，具体可查看 sitemap 配置 | 微信开放文档 如果没有 sitemap.json ，默认所有页面都允许被索引 然后看 pages 目录 小程序的页面目录 pages/index 下是包括了4种文件的 [ js, wxml, json, wxss ], 和根目录一样，只是多了一个 wxml 文件，分别对应的是： js - 注册页面，配置页面的初始数据、生命周期回调、事件处理函数等 配置文档 wxml - 组件的结构，微信自己的一套类似 html 的标签语言，来构建出页面结构 WXML | 微信开放文档 &lt;view&gt; 对应 &lt;div&gt; 标签 &lt;text&gt; 对应 &lt;span&gt; 标签 &lt;template&gt; 对应 Vue 的 &lt;template&gt; 模板标签 &lt;image&gt; 对应 &lt;img&gt; 标签 其它更多标签可以查看 视图容器 | 微信开放文档 json - 当前页面配置，类似 app.json 会覆盖 app.json 的 window 中相同的配置项 具体配置查看 👉 配置文档 非必须项，可以被删除 wxss - 组件的样式 会覆盖 app.wxss 当中相同的选择器样式 非必须项，可以被删除 注意：为了方便开发者减少配置项，描述页面的四个文件必须具有相同的路径与文件名。 微信客户端会先根据 index.json 配置生成一个界面，顶部的颜色和文字都可以在这个 json 文件里边定义好。然后微信就会装载这个页面的 WXML 结构和 WXSS 样式，最后微信会装载 index.js utils 目录一般来说 utils 目录下是一些被抽离出来的公共代码，比如说你封装好的请求函数，和默认给你的时间格式化和数字格式化。通过 export 导出，在需要的文件中通过 import 引入。 但是不支持 绝对路径，需要使用 相对路径 来引入，这个比较麻烦需要自己注意。 最后在正常使用过程中，我们还会遇到 component - 自定义组件，它和 pages 页面组件类似，也是由 [ json, wxml, wxss, js ] 4个文件组成，但是稍有不同。 你可以单独新建一个顶级的 components 目录，例如：/components/userInfo/...，也可以放到不同 page 对应的目录下 /pages/home/components/userInfo/... 不同点：首先，.json 文件中需要声明 component 为 true &#123; &quot;component&quot;: true &#125; 然后是在 .js 文件中注册组件的不同， 需要使用 Component() 来注册组件，多了 properties 属性和 methods 属性。 具体配置就不多说了，直接参看文档 Component 构造器 | 微信开放文档 总结整体和 Vue 的遍写思路很像了， .js 文件对应的是 Vue 文件的 &lt;script&gt; 部分 .wxml 文件对应的是 Vue 文件的 &lt;template&gt; 部分 .wxss 文件时 Vue 文件中的 &lt;style&gt; 部分 .json 文件算是 Vue 实例初始化时的 options 本文所描述小程序最新版本 v2.17.0 (2021-04-28)","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://yogwang.site/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"小程序","slug":"小程序","permalink":"https://yogwang.site/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"微信小程序学习开发日记 L00","slug":"miniprogram-devDiary-00","date":"2021-04-01T03:22:28.000Z","updated":"2026-01-05T05:39:58.502Z","comments":true,"path":"2021/miniprogram-devDiary-00/","permalink":"https://yogwang.site/2021/miniprogram-devDiary-00/","excerpt":"发现我安装小程序开发者工具是18年的事情了，那个时候还没有开始学 vue，算是开始填早几年立的一个 📌Flag 吧。 当时是想给我们的烘焙工作室的公众号做一个配套的营销工具，所以在18年底有去了解，只不过后来只做了一个展示型网站 岁礼气球派对，后来又改版了好几次现在主营是派对布置，好了有点扯远了。 填坑的动力主要是业务驱动，因为现在正好有这个任务安排，在回顾2020也大概提到了。所以今天先开始概括一下没有开发过小程序的前端，对于小程序的一些疑问。","text":"发现我安装小程序开发者工具是18年的事情了，那个时候还没有开始学 vue，算是开始填早几年立的一个 📌Flag 吧。 当时是想给我们的烘焙工作室的公众号做一个配套的营销工具，所以在18年底有去了解，只不过后来只做了一个展示型网站 岁礼气球派对，后来又改版了好几次现在主营是派对布置，好了有点扯远了。 填坑的动力主要是业务驱动，因为现在正好有这个任务安排，在回顾2020也大概提到了。所以今天先开始概括一下没有开发过小程序的前端，对于小程序的一些疑问。 # Roadmap 学习路径会在学习和开发中不断调整，不同阶段会有不同的理解，以下只是现阶段我对于学习顺序先后的整理。 目录结构 👉 学习日记 L01 目录结构路由跳转 👉 学习日记 L02 路由跳转生命周期 👉 学习日记 L03 生命周期网络请求 👉 学习日记 L04 网络请求拉起授权 👉 学习日记 L05 拉起授权组件分割 # 疑问❓ 小程序开发到底是像 Vue 还是 React？❓ 小程序开发能否使用 npm 进行包管理？可以，npm 支持 | 微信开放文档 tips：在小程序中使用npm包前，需先构建 npm ❓ 尺寸单位 rpx 应该怎么去理解正常来说，在网页端我们基本都是使用 px&#x2F;em&#x2F;rem 这类的常规单位，然后按照不同的设备尺寸去适配，但是小程序有一个 rpx 单位，可以根据屏幕宽度进行自适应，怎么去理解呢？其实就是看设计稿，因为 rpx 默认屏幕宽为 750rpx ，所以如果UI给的设计稿为 750px 则 1rpx 趋近于 0.5px 或者 1pt 因为大部分设备 DPR = 2，如果设计稿是 375px 宽度的则 1：1 转换就可。一句话形容就是按照设计稿的宽度除以 750 再乘以 2 来计算。 ❓ 小程序是否支持CSS预处理器不支持，但是你可以自己处理成 .wxss，具体可以查看这篇文章： 📍在小程序中使用CSS预处理器 ❓ Component 如何使用 properties 中的 observer很简单就是在 properties 声明对外属性的时候增加一个 observer ，然后就和 VueJs 当中的 watch 一样使用了。 Component(&#123; properties: &#123; attr: &#123; type: String, value: &#x27;&#x27;, observer: function(newVal, oldVal) &#123; // 属性值变化时执行 &#125; &#125;, &#125; &#125;) 然后 自定义组件 下也有一个 observers 参数的，可以监听 properties 和 data 的变化。具体查看 数据监听器 | 微信开放文档 ❓ bindtap 绑定的函数怎么传入自定义参数使用 dataset，例如：&lt;view id=&quot;tapTest&quot; data-hi=&quot;Weixin&quot; bindtap=&quot;&#123;&#123;tapName&#125;&#125;&quot;&gt; Click me! &lt;/view&gt;，具体可以看 事件 | 微信开放文档。是不是有点蠢…. ❓ 事件如何绑定在按键上使用 bindtap 等绑定事件 事件的使用方式 ❓ 是否有组件 slot有，组件提供一个 &lt;slot&gt; 节点，具体文档 组件模板和样式 | 微信开放文档 ❓ 组件间通信方法&#x2F;事件类似 Vue 中的 $emit 方法， this.triggerEvent(&quot;myEventName&quot;, myEventDetail, myEventOption)，文档 组件间通信与事件 | 微信开放文档 ❓ 双向绑定的 properties 属性变更父级没有同步改变绑定 properties 的时候不要使用驼峰写法，请使用短横线命名(-分割) ❓ 双向绑定的变量在键盘唤起时不会更新长度改变在安卓出现这个问题，但是iOS没有复现问题，在视图层直接使用 content.length，在唤起键盘时键入文字，不会实时改变 length 的数字，只有在收起键盘时才会更新。解决办法: 不使用双向绑定，使用 bindinput 去监听改变手动去 setData 就可以了。 ❓ 小程序iOS端不支持 Promise.finally()Vue 项目中很多时候我都会写 Promise.finally() 来把一些成功失败都会执行的操作放在内部，但是小程序对于 Promise 的支持是不完全的，所以没办法使用 Promise.finally() 更新 [2021-04-06] - 小程序 v2.16.1 起开始支持 Promise.finally()，但是看开发者社区反馈 iOS 下会报错。 更新 [2021-11-25] - 现在iOS使用 Promise.finally() 已经不会报错了（基础库 v2.21.0），具体是哪一个版本修复的就不清楚了 😂 ❓ 小程序开发工具的调试模式能不能热更新&#x2F;局部刷新，每次重新编译好麻烦不能，(当前版本v2.16.0)，现在每次改动都会重新编译一次，文件越多编译越慢，如果一直改动比较频繁的话的话，可以在开发者工具顶部的编译模式中添加编译模式选择指定页面以及参数信息，期待以后会支持局步热更新吧…. ❓ 小程序 input 组件设置 letter-spacing 无效暂时没办法，想着用间隔来实现验证码方块之类的效果，可是不行，官方虽然说可以，但实现不了，暂时增加了输入框宽度，然后 transform 偏移光标部分到可视区域外，然后使用多 view 标签 + CSS样式模拟激活光标和文字间距 ❓ 图片内容自适应容器&lt;image mode=&quot;aspectFit&quot;&gt;&lt;/image&gt;，根据 mode 值来达到目标: scaleToFill 对应 background-size:100% 100% aspectFit 对应 background-size:cotain aspectFill 对应 background-size:cover 更多 image | 微信开放文档 ❓ 复制到剪切板wx.setClipboardData(Object object) 具体文档 wx.setClipboardData(Object object) | 微信开放文档，以及接口滥用示例 5.15.4 滥用操作剪切板接口 - 原则及相关说明 | 微信开放文档 ❓ 自定义组件无法应用 app.wxss 中的样式 除继承样式外， app.wxss 中的样式、组件所在页面的的样式对自定义组件无效（除非更改组件样式隔离选项）。修改一下组件的 addGlobalClass 选项就可以了。具体文档 Component(&#123; options: &#123; addGlobalClass: true, &#125; &#125;) ❓ 每次运行都会出现“AppRoute的监听器可能导致内存泄漏”的警告 每次运行都会出现该提示： [Event] 21 listeners of event AppRoute have been added, possibly causing memory leak. 在 【项目】 - 【项目设置】 的 【本地设置】 中关闭 【自动运行体检评分】 就可以了，再点击编译这个警告提示就不会出现了 附：微信开放文档 · 小程序微信开发者代码管理","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"挖坑","slug":"挖坑","permalink":"https://yogwang.site/tags/%E6%8C%96%E5%9D%91/"},{"name":"未完成","slug":"未完成","permalink":"https://yogwang.site/tags/%E6%9C%AA%E5%AE%8C%E6%88%90/"},{"name":"学习","slug":"学习","permalink":"https://yogwang.site/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"小程序","slug":"小程序","permalink":"https://yogwang.site/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"JavaScript 中的位运算符","slug":"JS-operators","date":"2021-03-23T01:43:40.000Z","updated":"2026-01-05T05:39:58.475Z","comments":true,"path":"2021/JS-operators/","permalink":"https://yogwang.site/2021/JS-operators/","excerpt":"在思否上遇到一个问位运算符的问题 字符串的位运算，是怎么执行的，我也挺好奇的，就是为啥字符串进行位运算的时候返回的结果是 0，索性在解答这个问题的同时把位运算符都整理一遍。 那么先来整理一下位运算符，最后再说明为什么字符串的处理结果为 0","text":"在思否上遇到一个问位运算符的问题 字符串的位运算，是怎么执行的，我也挺好奇的，就是为啥字符串进行位运算的时候返回的结果是 0，索性在解答这个问题的同时把位运算符都整理一遍。 那么先来整理一下位运算符，最后再说明为什么字符串的处理结果为 0 位运算符按位与 AND &amp; a &amp; b 在 a, b 的位表示中，每一个对应的位都为 1 则返回 1 ， 否则返回 0。 10 &amp; 5 // 1010 &amp; 0101 =&gt; 0000 // logs 0 按位或 OR | a | b 在 a, b 的位表示中，每一个对应的位，只要有一个为 1 则返回 1 ， 否则返回 0。 10 | 5 // 1010 | 0101 =&gt; 1111 // logs 15 按位异或 XOR ^ a ^ b 在 a, b 的位表示中，每一个对应的位，两个不相同则返回 1，相同则返回 0。 15 ^ 5 // 1111 ^ 0101 =&gt; 1010 // logs 10 按位非 NOT ~ ~ a 反转被操作数的位。 这里就不能像上边这样简写了，需要完整书写32位，再反转。 ~ 1 // ~ 00000000000000000000000000000001 =&gt; 11111111111111111111111111111110 // logs -2 就是把运算数转换为 32 位的二进制整数，然后逐位进行取反操作，最后返回十进制浮点数 左移 shift &lt;&lt; a &lt;&lt; b 将 a 的二进制串向左移动 b 位,右边移入 0。 5 &lt;&lt; 2 // 0101 &lt;&lt; 2 =&gt; 010100 // logs 20 简单来说就是整个二进制串向左移动，如果超出就被丢弃，然后末尾补充 0，举个负数例子可能会清晰很多 -113 &lt;&lt; 4 // 11111111111111111111111110001111 &lt;&lt; 4 =&gt; 11111111111111111111100011110000 // logs -1808 算术右移 &gt;&gt; a &gt;&gt; b 把 a 的二进制表示向右移动 b 位，丢弃被移出的所有位。译注:算术右移左边空出的位是根据最高位是 0 和 1 来进行填充的 10 &gt;&gt; 2 // 1010 &gt;&gt; 2 =&gt; 10 // logs 2 和左移一样的处理思路，只不过方向反过来，并且按照首位来填充，如果是1则填充1，0则填充0 -2 &gt;&gt; 4 // 11111111111111111111111111111110 &gt;&gt; 4 =&gt; 11111111111111111111111111111111 // logs -1 2147483647 &gt;&gt; 4 // 01111111111111111111111111111111 &gt;&gt; 4 =&gt; 00000111111111111111111111111111 // logs 134217727 无符号右移 &gt;&gt;&gt; a &gt;&gt;&gt; b 把 a 的二进制表示向右移动 b 位，丢弃被移出的所有位，并把左边空出的位都填充为 0。 这个挺好理解的，比算术右移方便记，只需要填0就好了。 -2 &gt;&gt;&gt; 4 // 11111111111111111111111111111110 &gt;&gt; 4 =&gt; 00001111111111111111111111111111 // logs 268435455 100 &gt;&gt;&gt; 4 // 1100100 &gt;&gt; 4 =&gt; 0000100 // logs 6 回到最初的问题为什么字符串进行位运算的时候返回的结果是 0位操作符在移位前做了两种转换，第一步，将不是 number 类型的数据转换为 number，第二步，将 number 转换为无符号的 32bit 数据，也就是 Uint32 类型。 字符串转换为 number 会失败，所以返回 0，最终操作的时候其实是在操作 0 附表达式与运算符 - JavaScript | MDNJS中表达式 &gt;&gt;&gt; 0 浅析 - SegmentFaultWhat is the JavaScript &gt;&gt;&gt; operator and how do you use it? - Stack Overflow","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"}]},{"title":"在小程序中使用CSS预处理器","slug":"use-stylus-with-gulp-in-miniprogram","date":"2021-03-18T03:09:04.000Z","updated":"2026-01-05T05:39:58.518Z","comments":true,"path":"2021/use-stylus-with-gulp-in-miniprogram/","permalink":"https://yogwang.site/2021/use-stylus-with-gulp-in-miniprogram/","excerpt":"该来的一天还是来了，两年前立的Flag还是到了，现在在跟进项目配套的小程序开发，但对于写惯了 Stylus 的我，真的是太煎熬了，每次都忘记写冒号和分号…所以就想着翻翻开发文档看 .wxss 支持不支持CSS预处理器的写法，比如 SCSS。明显这是不可能的，官方也没有计划支持，所以还是得自己动手。 大概看了一下大家的解决方案，和我想的一样，使用 Gulp 来自动化构建成 .wxss 文件。","text":"该来的一天还是来了，两年前立的Flag还是到了，现在在跟进项目配套的小程序开发，但对于写惯了 Stylus 的我，真的是太煎熬了，每次都忘记写冒号和分号…所以就想着翻翻开发文档看 .wxss 支持不支持CSS预处理器的写法，比如 SCSS。明显这是不可能的，官方也没有计划支持，所以还是得自己动手。 大概看了一下大家的解决方案，和我想的一样，使用 Gulp 来自动化构建成 .wxss 文件。一、抄脚本首先呢，就是安装依赖，这次需要的依赖项有3个：gulp 、 gulp-rename 和 gulp-stylus（也可以是 sass 或 less） npm init -y npm i gulp gulp-rename gulp-stylus -D 然后创建 Gulp 脚本 最初我直接复制的肉大的脚本改了下，但是遇到了报错信息 TypeError: gulp.src(...).pipe(...).pipe is not a function，Google 后是说，Gulp4 更新后，API调整过了，旧的写法不可以用了。 所以我先选择降低了 Gulp 版本到 v3.9.1，降低版本后继续执行，遇到另一个报错信息 ReferenceError: primordials is not defined，好像是 Node 版本太高了，切换到 11.15.0 可以运行了，但是 侦听文件改变 的部分还有问题，运行之后执行了两次，后边再修改就没有编译了，所以还是用 Gulp4 自己重新调整吧。 二、Gulp4 重写const gulp = require(&#x27;gulp&#x27;); const stylus = require(&#x27;gulp-stylus&#x27;); const rename = require(&#x27;gulp-rename&#x27;); // 样式文件地址，我设置了全部，排除了node_modules，你也可以自己选择指定目录 const stylusFiles = [ &quot;./**/*.styl&quot;, &quot;!./node_modules/**/*.styl&quot;, ] // 编译stylus并且重命名为.wxss，生成在原目录下 const styl2wxss = () =&gt; &#123; return gulp .src(stylusFiles) .pipe(stylus(&#123; prefixer: false&#125;)) .pipe(rename(&#123; extname: &#x27;.wxss&#x27; &#125;)) .pipe(gulp.dest(&#x27;./&#x27;)); &#125;; // 编译任务 gulp.task(styl2wxss); // 监听任务 gulp.task(&#x27;watch&#x27;, () =&gt; &#123; gulp.watch(stylusFiles, styl2wxss); &#125;); // 如果你有多个任务比如同时使用pug与stylus，可以像这样放入series内，会自动依次执行 gulp.task(&#x27;dev&#x27;, gulp.series(&#x27;styl2wxss&#x27;, &#x27;watch&#x27;)); 然后把执行脚本加入到 package.json 中 &quot;scripts&quot;: &#123; &quot;watch&quot;: &quot;gulp watch&quot; &quot;dev&quot;: &quot;gulp dev&quot; &#125; 执行 npm run watch 或者 npm run dev 就可以了。 到这里位置一切都正常，但是我编译完成之后，小程序编译报错了，因为不能加私有兼容前缀，所以还得处理一下，看看 stylus 的配置文档。 2 hours later….翻了好久文档也没找到解决办法，不过 stylus 提供了一个 vendors 属性，具体看 文档链接把 vendors = official 加到文件头部就可以了，但是总觉得怪怪的不舒服，官方好像也没有想处理这个问题的念头？先不管了，之后看有没有遇到其它解决方案吧。 三、使用VSCode扩展VSCode的扩吧展商店里已经有大佬上传了 Stylus/Sass/Less 转换成 wxss 的插件了，有直接安装就可以用的，而且我上边提到的编译后出现兼容前缀的问题插件转换后没有遇到，还不知道他们是如何解决这个问题的，等空了看看他们的源码怎么写的吧。 扩展# 如何让图片 url 在编译时自动补全CDN路径？ 本地资源图片无法通过 WXSS 获取，可以使用网络图片，或者 base64，或者使用&lt;image/&gt;标签 现阶段的小程序是不允许在 wxss 中使用本地资源了，不然会报错。如果用图片CDN，每次都输入全网络地址又太麻烦了，所以就想着有没有什么好一些的解决方式。 解决方案1：使用 stylus 全局变量。例如我的全局变量文件位于 /assets/stylus/variables.styl。那么修改一下脚本文件就可： const styl2wxss = () =&gt; &#123; return gulp .src(stylusFiles) .pipe(stylus(&#123; prefixer: false, import: path.join(__dirname,&#x27;./assets/stylus/variables.styl&#x27;), &#125;)) .pipe(rename(&#123; extname: &#x27;.wxss&#x27; &#125;)) .pipe(gulp.dest(&#x27;./&#x27;)) &#125;; 就这可以这样书写了 // 例如变量名为 $httpUrl .className background url($httpUrl/img/bg_img.png) center/contain no-repeat // 编译为 // background: url(&quot;http://www.domain.com/assets/img/bg_img.png&quot;) center/contain no-repeat; 解决方案2：stylus 编译成 css 自动处理补全 CDN 地址虽然使用全局变量可以用，但是也不优雅，想着可以在 stylus 编译成 css 的时候同步处理补全 CDN 路径，在书写的时候只需要键入 url(/img/xxx.jpg) 就会得到对应的 CDN 地址 url(https://www.baidu.com/assets/img/xxx.jpg) 了。但是找了一圈还没找到解决，思路有了得等有时间了尝试一下，先挖个坑。 附使用 Pug 和 Stylus 开发小程序的 watch 脚本gulp.jsExpressive, dynamic, robust CSS — expressive, robust, feature-rich CSS preprocessor node.js - How to fix ReferenceError: primordials is not defined in node - Stack OverflowVendor prefixed properties WITHIN vendor prefixed @keyframes · Issue #882 · stylus&#x2F;stylusBug in vendored keyframes · Issue #1135 · stylus&#x2F;stylus","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"挖坑","slug":"挖坑","permalink":"https://yogwang.site/tags/%E6%8C%96%E5%9D%91/"},{"name":"小程序","slug":"小程序","permalink":"https://yogwang.site/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"Gulp","slug":"Gulp","permalink":"https://yogwang.site/tags/Gulp/"}]},{"title":"程序员社群 成长&生活分享 2021/03/18","slug":"jirengu-share-my-life-88th","date":"2021-03-17T08:54:37.000Z","updated":"2026-01-05T05:39:58.502Z","comments":true,"path":"2021/jirengu-share-my-life-88th/","permalink":"https://yogwang.site/2021/jirengu-share-my-life-88th/","excerpt":"各位程序猿(媛)晚上好，今天轮到我来分享，先来自我介绍16年毕业计算机通信，后来专升本（计算机科学），这教育经历算是很差了，从事前端大概有三年(我也不是很确定…)，中间有留校工作了1年多，后来辗转成都和重庆，19年回的浙江。 好自我介绍结束，开始正题： 💻 怎么入的前端坑？之前一直学的计算机通信嘛，大概是13&#x2F;14年有一届青少年科技创新大赛被老师拉进团队开始接触网站制作，那段时间接触的是PHP和ASP。快实习的时候一起比赛的学长找我去他们公司做，算是正式进入到前端领域（是一个外包公司）。当时也没有认识到 外包 和 自研 的区别，工作也简单就是做一个 页面仔 还原设计稿的，一开始一个月熟悉项目开发流程，后边就开始独立自己切，每天都一直努力还原设计稿，这段时间积累HTML、CSS的知识确实是最快的时候，我到现在都没有怎么回顾过了，基本看到设计稿大概就知道应该是怎么样的一个HTML结构，CSS应该怎么去写，有哪些部分可以复用，到实习结束大概已经切了大概有一百个网站（我们实习期很长有一年）","text":"各位程序猿(媛)晚上好，今天轮到我来分享，先来自我介绍16年毕业计算机通信，后来专升本（计算机科学），这教育经历算是很差了，从事前端大概有三年(我也不是很确定…)，中间有留校工作了1年多，后来辗转成都和重庆，19年回的浙江。 好自我介绍结束，开始正题： 💻 怎么入的前端坑？之前一直学的计算机通信嘛，大概是13&#x2F;14年有一届青少年科技创新大赛被老师拉进团队开始接触网站制作，那段时间接触的是PHP和ASP。快实习的时候一起比赛的学长找我去他们公司做，算是正式进入到前端领域（是一个外包公司）。当时也没有认识到 外包 和 自研 的区别，工作也简单就是做一个 页面仔 还原设计稿的，一开始一个月熟悉项目开发流程，后边就开始独立自己切，每天都一直努力还原设计稿，这段时间积累HTML、CSS的知识确实是最快的时候，我到现在都没有怎么回顾过了，基本看到设计稿大概就知道应该是怎么样的一个HTML结构，CSS应该怎么去写，有哪些部分可以复用，到实习结束大概已经切了大概有一百个网站（我们实习期很长有一年） 那个时候就喜欢研究CSS，每天到公司之后都会看一会群里别人分享的优质网站，就觉得视觉效果很好，也会看一些特效分享什么的，小城市那个时候也没有那么内卷的氛围，但是到了JS部分是真的弱，只会jQuery，原生JS基本不会，document.getElementsByClassName() 这种的我当时肯定拼不出来，我只会 $(&quot;.xxx&quot;)。现在如果只研究CSS的话，就算你是第二个张鑫旭你也进不了大厂了。 📖 关于学习老生常谈的问题，前端的坑还是很大而且很杂什么都有，如果不是自己喜欢，需要业务推动的话，可能你很快就会落后于时代，就像当初实习的我一样，jQuery + Bootstrap 一把梭用到死。我实习是在15年那个时候 React/Vue 项目已经大规模出现了，当时我一直感叹那些项目怎么那么流畅也没有页面跳转的白屏，只是知道全部通过 Ajax 请求，但是不知道如何去实现，思维模式还是停留在MVC框架上。学校内的专业课知识更不用提了，落后于生产最少一个时代，基本上没有用武之地，只是给了可以读代码的机会，能不能看明白工作的业务代码都是问题。 每天 固定时间逛一逛社区 V2ex，思否，CNode, CSS-Tricks，能力范围内解决一些问题，一下子大脑宕机的时候也可以去逛逛放空一下。 学习新技术，大多数时候都是需要自己来找资料，我觉得比较好用的方式是 记公开的笔记，能让其他人看见，既能帮助自己，也能帮助别人。 你需要重新用文字描述一遍，学习的过程，重新归类整理脑中的记忆； 怕内容写错出糗，你会在记录的时候翻阅大量的相关资料来验证你的想法； 在别人会指出你理解错误的地方，这些部分自己可能不会察觉到； 每一次有人评论了，你就又会回过头来看到当初的笔记，重新回想起来部分内容，加深记忆。 也把参考的链接放在文章底部，以后如果回顾如果发现有问题也可以快速找到。 博客的话，我现在是用的 Hexo，部署在Github Page上边，也做了国内镜像方便同学们访问，有需求的话，可以了解一下阿里云的OSS静态托管，如果流量不大 ￥18 可以用两年，域名也不贵，一百块钱够折腾很久了。 还有就是 多加一些活跃的技术群 ，能听到很多以前没有了解过的东西。 💼 最后聊一聊找工作首先你要有一个目标，确定你想要找什么样子的工作，前端也分很多种，不同类型的岗位可能技术栈你都没听说过。如果之前一直都是日常业务路线的，接触到数据可视化的时候可能会不知道如何下口。 校招的部分 我就不多说了，我毕业的那段时间就有校招，不过都是实业类型的，互联网企业少得可怜，聊不出来什么，具体可以看方方老师讲 进入阿里巴巴需要什么水平 这期视频。 社招部分，首先你要做好简历的内容管理和排版，HR看一份简历不会超过1分钟，简历的作用就是在这一分钟内让HR的眼睛停下来，所以需要针对不同的公司来展示你的技术栈和项目经历。 海投先不说会不会被系统屏蔽，首先你的内容就不可能打到招聘方的痛点上。除非他们不在乎简历内容只看是否对口，具体怎么展示方方老师也在每期的模拟面试里都有说。这里 墙裂推荐 模拟面试实录，面试他们的时候你也要自己回答，如果卡壳了，就记下来卡住的地方，拓展开来写成笔记。 还有一个我之前看 令人心动的Offer 时刷到的一个Up主 超级简历WonderCV，平时也出一些简历评价和面试评价，只需要记住并且避开这些点就可。 再就是你之前加的社群的作用就体现了 找内推！！ 首先你会比别人多出来很多优质岗位的信息，其次你的简历一定会被HR看到，并且你如果你一直活跃再社群中，你的印象分会有一定的加成。 最后我的观点就是 找对重点多准备，不要裸辞，耐心多等等。 以上就是我今天的分享，祝各位 需求永远不变、再无BUG、永不脱发 😉","categories":[{"name":"代码之外","slug":"代码之外","permalink":"https://yogwang.site/categories/%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96/"}],"tags":[{"name":"社群分享","slug":"社群分享","permalink":"https://yogwang.site/tags/%E7%A4%BE%E7%BE%A4%E5%88%86%E4%BA%AB/"}]},{"title":"回顾史无前例的 2020 年","slug":"summary-at-the-end-of-2020","date":"2021-03-13T12:36:48.000Z","updated":"2026-01-05T05:39:58.514Z","comments":true,"path":"2021/summary-at-the-end-of-2020/","permalink":"https://yogwang.site/2021/summary-at-the-end-of-2020/","excerpt":"不知不觉庚子年已经过完了，都不知道怎么就过完了看似艰难的一年，甚至觉得中间缺失另一部分的时间，还有很多想做的事情还没来得及做，可能年纪大了吧，真像别人说的，现在的一年只占用了 1&#x2F;27 份的记忆空间，所以回忆起来觉得时间过得特别快，以后也只会越来越快。说实话去年没有什么好回顾的，所以一直拖到正月都过完了都不想动手写，很多事情都不顺心，也出现了很多计划之外的事情。不管是工作还是生活上，特别是感情上，导致全年大部分的时间情绪都不高涨，先回顾一下去年吧。","text":"不知不觉庚子年已经过完了，都不知道怎么就过完了看似艰难的一年，甚至觉得中间缺失另一部分的时间，还有很多想做的事情还没来得及做，可能年纪大了吧，真像别人说的，现在的一年只占用了 1&#x2F;27 份的记忆空间，所以回忆起来觉得时间过得特别快，以后也只会越来越快。说实话去年没有什么好回顾的，所以一直拖到正月都过完了都不想动手写，很多事情都不顺心，也出现了很多计划之外的事情。不管是工作还是生活上，特别是感情上，导致全年大部分的时间情绪都不高涨，先回顾一下去年吧。 🎐 去年的小目标 学习 TypeScript 年初实在有点不知道该干嘛，就开坑学了一段时间，感觉现在除了强类型之外，剩余的价值已经没有以前高了，也没有在项目里应用上TS 学习 ReactJS 五月份大概学习了一下，只是算了解了怎么去用，写了个一个Demo就没有再动过了。 学习 VueJS 3.0 看了几次尤大演讲和先行分享会，大概知道怎么一回事情，但是没有展开学习，也没有上手写过Demo 阅读 《Code Complete》 换了一本书《设计模式：可复用面向对象软件的基础》，大概读了 30% 有点读不下去了。 阅读 《Clean Code》 已经买了，还没有开始看 了解并使用单元测试 没有去了解 了解 Svelte 没有去了解 了解 React Native 或 Flutter 没有去了解 算是 🚩 Flag 立了太多了，一个都没有完成，特别是后边补充部分，年初有了想法，但是后续就没有那个劲了，书是下单买回家了，但是只开封了一本，另外一本连塑封都没拆就躺了半年多。可能也因为生活上不顺心的事情比较多，加上敏捷开发基本一两周就是一个小版本迭代，每周都是 30小时 左右的有效 Coding 时间，每天在公司忙完等回到家就只想着瘫着休息。 中间要不是偶尔看一下方方老师的直播，真的可能连笔记都不想写了，每次也都是需要立马拿出电脑开始写，只要过了一两天也就不想再动手写了，我数了下还有10多个草稿等着我完成，都是一些小话题，自己在思考的时候卡住的部分，想加深一下印象。还算好，博客算是没有断更… 关于工作上 💼上边提到了敏捷开发，去年一整年一直在忙公司自研的项目，坑开得很大，而且Web前端部分初期就只有我一个人，所以整个 0.x 版本，一直都是一边设计系统一边实现功能，也不断有老需求被砍，新需求进来。反反复复折腾了挺久，最近应该快要上线了。开发中的踩坑部分我也在 Jeecg-boot 开发挖坑日记 大概提到了，本来还想着可以在项目内加上单元测试什么的，一直没有机会，最近稍微空闲了点但整个人心情都怎么好就一直搁置着。中间穿插了公司产品配套的H5应用开发，这些东西小应用基本没有什么含金量都是重复工作，增加熟练度罢了，可以聊的东西没有什么。 总体来说20年，没有19年对我来说有那么大的提升，业务上技术栈已经开始重复了，WebGL 我算是被劝退了，需要的横向知识面太广了，瞬间感觉到无尽的学习压力，而且当前公司的业务可以说是完全用不到，如果自学的话，真的进行不下去了。 你说关于今年我是怎么打算啊？可能先 调整心态 吧，这段时间三观打击的比较厉害，总是伴随的颓的心态，干什么都很难提起兴趣，等小腿好一点，就可以 恢复夜跑 了，去年一直没有锻炼，确实感觉到身体不如从前了，快跑一公里心率居高不下很久。 不出意外 小程序开发 是在日程上了，然后把近期开的一些坑填一填。 再有的话，能想到的就是刷 LeetCode 吧，去年有过跳槽的念头，如果要落实，应该会刷一下算法题，公司的项目后续就是维护了，找到人手接班就好了。 最后就是把外包项目结束掉，再往后的话，边走边考虑吧，如果年中能恢复过来的话，再展望一下。 末尾总结 整个人潦草的在工作和生活中没有计划的过完了一年，一直处于情绪低谷，舍断离、刷新自己失败。 这次庚子年对于很多人来说都是很差的一年，我甚至都很难提起回顾2020年的念头，毕竟谁都想生活得一帆风顺。 以上，Peace!","categories":[{"name":"代码之外","slug":"代码之外","permalink":"https://yogwang.site/categories/%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96/"}],"tags":[{"name":"总结","slug":"总结","permalink":"https://yogwang.site/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"关于情感勒索与关系依存自尊者","slug":"about-emotional-blackmail","date":"2021-02-23T09:33:57.000Z","updated":"2026-01-05T05:39:58.479Z","comments":true,"path":"2021/about-emotional-blackmail/","permalink":"https://yogwang.site/2021/about-emotional-blackmail/","excerpt":"最近和女友闹得很僵，情绪很低落，没有什么动力填坑，更别提开新坑了，光把 设计模式学习 补完就折腾的够呛，而且有一些定义很模糊容易混淆，经常就为了区分两个很类似的模式停滞几个小时。 周二的时候知乎推送了一个问题 在恋爱中，女孩子真的会遇到一个满眼都是自己的男孩子吗?, 第一次接触到一个名词 关系依存自尊，确实一直以来都把感情看得很重要，并且已经深刻影响到自己生活的方方面面。 KnowYourself 的回答真的让我一下子明白过来，原来在不经意中我已经情感勒索了很久并不自知，也理解了她口中的压力并不是我以前所想的那样……","text":"最近和女友闹得很僵，情绪很低落，没有什么动力填坑，更别提开新坑了，光把 设计模式学习 补完就折腾的够呛，而且有一些定义很模糊容易混淆，经常就为了区分两个很类似的模式停滞几个小时。 周二的时候知乎推送了一个问题 在恋爱中，女孩子真的会遇到一个满眼都是自己的男孩子吗?, 第一次接触到一个名词 关系依存自尊，确实一直以来都把感情看得很重要，并且已经深刻影响到自己生活的方方面面。 KnowYourself 的回答真的让我一下子明白过来，原来在不经意中我已经情感勒索了很久并不自知，也理解了她口中的压力并不是我以前所想的那样…… 在了解一下回答中所描述的 关系依存自尊型 和 情绪勒索 之后，下单了两本关于情感勒索的书，准备这几天把它们看完，之后再来把文章写完吧，今天就这样。 未完成… 附在恋爱中，女孩子真的会遇到一个满眼都是自己的男孩子吗？- 知乎情绪勒索 - Wikipedia情感勒索 - Susan Forward讀《情緒勒索》你為什麼拿自己的人生滿足別人？","categories":[{"name":"代码之外","slug":"代码之外","permalink":"https://yogwang.site/categories/%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96/"}],"tags":[{"name":"未完成","slug":"未完成","permalink":"https://yogwang.site/tags/%E6%9C%AA%E5%AE%8C%E6%88%90/"},{"name":"情感","slug":"情感","permalink":"https://yogwang.site/tags/%E6%83%85%E6%84%9F/"}]},{"title":"「 设计模式学习 」 L00 开坑贴 & 设计模式概览","slug":"design-pattern-learning-L00","date":"2020-11-24T16:10:59.000Z","updated":"2026-01-05T05:39:58.483Z","comments":true,"path":"2020/design-pattern-learning-L00/","permalink":"https://yogwang.site/2020/design-pattern-learning-L00/","excerpt":"设计模式是我在2018年在成都工作的时候听 肉山老师 的直播JavaScript 设计模式 导言的时候就想学习的一个东西，但是一直拖拖拖，虽然后来买了肉老师的 Chat 从 jQuery 里学习设计模式，但是看了一头雾水，后来同样买了肉老师推荐的书《设计模式：可复用面向对象软件的基础》，也是在家里吃灰了半年多。一直想把整个设计模式都了解一下，不用吃透大概明了就可以，但是每次都提不起开坑的念头，如果再写成学习笔记的话，学习周期会大大拉长。 这次在项目的不断迭代中，我遇到了一个问题，就是 项目中的类型和状态管理，所以就想着是否有一个合适的设计模式来解决问题，所以就被逼迫着捡起来了……","text":"设计模式是我在2018年在成都工作的时候听 肉山老师 的直播JavaScript 设计模式 导言的时候就想学习的一个东西，但是一直拖拖拖，虽然后来买了肉老师的 Chat 从 jQuery 里学习设计模式，但是看了一头雾水，后来同样买了肉老师推荐的书《设计模式：可复用面向对象软件的基础》，也是在家里吃灰了半年多。一直想把整个设计模式都了解一下，不用吃透大概明了就可以，但是每次都提不起开坑的念头，如果再写成学习笔记的话，学习周期会大大拉长。 这次在项目的不断迭代中，我遇到了一个问题，就是 项目中的类型和状态管理，所以就想着是否有一个合适的设计模式来解决问题，所以就被逼迫着捡起来了…… 肉老师谈论如何学习设计模式的方法，和我的学习想法是类似的，不管是学习设计模式还是学习一个框架&#x2F;库，先了解一个大概心里有一个底，然后在实际遇到问题的时候再去找文档来炒冷饭，我觉得这样会更清晰一些，但是他不推荐了解的那么多设计模式，只需要过一遍，等遇到了差不多的场景再去具体看适合哪一个。 《设计模式：可复用面向对象软件的基础》这本书是 1995 出版的，可能会有一些问题，或者有一些新的设计模式出现，但都不是问题，咱先把这本书内的 23 个设计模式了解，之后再看情况去了解新的内容。 所以这篇文章应该会陆陆续续的更新一些新内容，好了，在这篇标号 00 的笔记中我就以前端开发者的视角按照设计模式名称+概括+简单示例，来大概描述一下每种设计模式，如果有遇到可用场景时再深入的去记录。 这本书内把设计模式分成 三种类型（ 创建型、结构形、行为型） 和 二十三个模式 创建型 1. 工厂方法 Factory Method 定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂模式使一个类的实例化延迟到其子类。 工厂模式在实际应用中有很多，比如前端er最了解的 jQuery 中的 $() 方法查看文档，传入一个类名或者ID或者其它的值，返回回来一个DOM实例。中间的一些过程就不需要关注了，直接使用 $() 方法就会必定返回一个DOM实例。讲人话，就是传入一些值，返回一个符合预期的结果。 2. 抽象工厂 Abstract Factory 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 抽象工厂模式是一个比较复杂的创建型模式，如果用最简单的话来说，可以描述成基于一组工厂方法，传入数据之后返回一个复杂对象，中间的步骤不需要关注。有点类似于Vue中的高阶组件中包含了很多子组件和一些其它元素最后展现出一个渲染结果。用廖雪峰老师的例子来举例就很容易让人明白 我们希望为用户提供一个Markdown文本转换为HTML和Word的服务 - 抽象工厂，虽然示例是Java，但是不影响理解。 3. 生成器 Builder 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 生成器模式，有些地方也叫建造者模式，用简单的话来概括就是传入一个或者一组数据，最后拼接返回一个结果，用Vue来举例的话就有点像 Reander 函数。乍一看可能和抽象工厂很像，对确实很像，他们都是基于工厂模式的扩展，主要的区别就是抽象工厂模式对于中间的数据没有要求，而生成器重点关注如何分步生成复杂对象。 争议 这边的具体区别我还没有彻底弄明白确实需要整理之后来区别一下。具体得等这篇文章最后了。 4. 原型模式 Prototype 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 这个在Javascript中并不需要多理解，因为Js中每个数据类型都是对象，都拥有一个 prototype 属性，当然你也可以自己用代码来实现自己得原型模式其实显得很奇怪。大概可以用构造函数的视角来理解，只不过构造函数生成的实例对象的属性都是独立的，所以引入了 prototype 属性，来做到数据共享(修改其中一个，影响到其它所有)。同样JS有提供一个原生的实现 Object.create() 5. 单例模式 Singleton 保证一个类仅有一个实例，并提供一个访问它的全局访问点 类似于 window 对象，全局确保只有一个我们可以使用的 window 实例。具体业务使用场景中，Vuex 也是单例模式，全局只会有一个Store实例来供用户去读取和修改。 我在查阅资料的时候稍微看到了还有人提到 惰性单例模式，这个之后再去了解 结构形 1. 适配器 Adapter 将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 适配器模式的话，我们可以这样来理解，很多时候我们不确定客户端浏览器是否支持我们所使用的API，这个时候就会写兼容，大概来写一个伪代码段来举例 var getByClass = function (className) &#123; if(document.querySelector) &#123; return document.querySelector(className); &#125; else &#123; return document.getElementsByClassName(className) &#125; &#125;; 就是那么简单，虽然有点强行解释，但这个就是适配器…. 2. 桥接 Bridge 将抽象部分与它的实现部分分离，使它们都可以独立地变化 这个我本来想用 UI 库中的 Notification 组件来举例的，因为只需要调用 notification[type].open(&#123;config&#125;) 函数传入几个参数就可以展现出不同的消息通知栏了， 但是隔了一天之后发现拿这个例子来讲好像不是很的能解释抽象和实现的分离，所以我用系统中的画图附件来举例会好理解很多。 在画版中会有很多不同的 工具，比如说画笔，图形和文字等，同样他们都有颜色、大小这些个 属性，我们在使用的时候只需要选择 工具 ，然后选择 属性 就可以绘制出我们所需要的结果了。 我们可以 单独 的去 变化组合 工具、属性，并不会出现红色画笔和黑色画笔这种 带有属性的工具（没有强耦合），如果后期扩展了新得工具只要单独增加新工具的业务逻辑就行，不需要去关注它的大小和颜色这些属性，同样增加新属性的时候也同理。 3. 组合 Composite 将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。 组合模式简单来说具有统一接口的一组树形结构。父级和子级拥有相同的接口，比如系统的文件管理，每个文件夹都可以包含具体文件和文件夹，并且每个文件&#x2F;文件夹都有类似的功能，比如说创建&#x2F;删除&#x2F;重命名。在执行删除功能的时候开始递归执行子级的删除操作，每个子级都被删除后执行父级的删除操作。 4. 装饰 Decorator 动态地给一个对象添加一些额外的职责。就增加功能来说，相比生成子类更为灵活。 一般来说我们都会直接想到使用类的继承，然后在子类上附加新的功能，但是继承为类引入静态特征，并且随着扩展功能的增多，子类就会爆炸式增长。所以我们不想增加很多子类的情况下扩展类，就会用到装饰器模式。 看到一个很形象的比喻，现在UI库中的表单组件的表单验证，在不同的表单组件上使用不同的校验规则，而且并不影响组件本身，只是在提交之前额外调用了传入的校验函数。 5. 外观 Facade 为子系统中的一组接口提供一个一致的界面。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 简单概括就是，在日常工作中会编辑出来很多子功能，这些子功能只有你清楚，如果你想给同事使用，就可以l考虑外观模式，整合起来并且开放一个相对统一的调用接口。 6. 享元 Flyweight 运用共享技术有效地支持大量细粒度的对象。 享元模式的话，我描述一个场景来帮助理解，比如说现在有一个气球里边装了几千个小球，这些小球材质大小一致，并且有三种颜色，如果我们为每一个气球都船舰一个对象，就会浪费大量的内存，这个时候我们就可以把相同的材质和大小和颜色提取出来，通过外部引用或者继承的方式来共享这些属性。 7. 代理 Proxy 为其他对象提供一种代理以控制对这个对象的访问。 这个的话，学习过Vue的前端就很清晰了，Vue对一些数据的操作进行了代理，去检查是否需要更新视图。ES6中也新增了 Proxy 这个API，并且Vue3中使用 Proxy 代替了 defineProperty。 行为型 1. 职责链 Chain of Responsibility 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。 简短的来说就是分工合作，比如说工厂的流水线，每一个工作站都有自己的工作，完成自己的工作（加工&#x2F;质检）之后通过传输带到下一个工作站进行处理，最后出厂一个成品的手机。 2. 命令 Command 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。 设计思想是把命令拆分开来，创建和执行分离，使得调用者无需关心具体的执行过程，大概是，每天中午点餐的时候只要和老板娘喊一嗓子炒年糕，一会老板就会端出来一盆炒年糕。 3. 解释器 Interpreter 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。 快速的话可以理解成 正则，把一系列复杂的规则判断用简单的语句实现。 4. 迭代器 Iterator 提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。 这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。可以用对象的 Object.entries() 方法来理解。每一个对象都有它自己的迭代方法，你不需要知道它具体有哪些属性，它可以按照顺序去输出对象的内部元素。 5. 中介者 Mediator 用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 MVC 框架中的 C（控制器），它就是用来控制 M（模型）和 V（视图）的中介者。 6. 备忘录 Memento 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。 一般来描述这个模式都是举例文本编辑器的撤销功能，并且可以一直退回到空白文本的状态，其它的类似还有，浏览器的后退前进，数据库的事务回滚等等。保持对象的状态，并且可以在调用组件生命周期内持久保存这些快照。 7. 观察者 Observer 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。 这个直接用Vue来举例吧，data 内 声明 的变量被修改时，会自动通知UI更新。最直接可以看到的就是每一个在data内声明的变量都会有一个 __ob__ 对象。观察者模式和中介者模式其实非常的相似，只不过这里的 “中介者&#x2F;订阅者” 就是观察者 8. 状态 State 允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。 可以描述一个应用场景，在一个后台管理系统中，一定会有审核相关的部分，每一条不同状态的记录都会对应不同的操作，这边就会适合状态模式的应用。 9. 策略 Strategy 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。 也描述一个应用场景吧，比如你现在老板给你一个任务，让你做一个根据职位、绩效、考勤和工资自动计算奖金的程序，不同的职务有不同的标准，不同的绩效等级也会影响奖金系数。一开始你可以使用 if...else，去判断不同的场景，随着需求变化，代码不断调整，越来越臃肿。代码几乎不能维护，因为你根本不知道这里的一处改动会对后面造成什么样的影响。这时候可以使用策略模式来更具不同的条件执行不同的业务逻辑。 10. 模板方法 Template Method 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 在面向对象程序设计过程中，程序员常常会遇到这种情况：设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但某些步骤的具体实现还未知，或者说某些步骤的实现与具体的环境相关。 这个很容易解释，我们所熟悉的 Ajax 函数就是，基本流程都确定，只需要接受 URL 地址 和 Settings 对象 就可以，再把需要执行的操作放在回调函数里。它封装了不变部分，扩展可变部分。在父类中提取了公共的部分代码，便于代码复用，而把可变部分算法由子类继承实现，便于子类继续扩展。 11. 访问者 Visitor 表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 核心思想是为了访问比较复杂的数据结构，不去改变数据结构，而是把对数据的操作抽象出来，在“访问”的过程中以回调形式在访问者中处理操作逻辑。 这个还没有想到合适的场景，大概就是说 有一个稳定的数据结构，但是需要实现的功能并不确定，针对不同的访问者有不同的行为职责。感觉有点类似命令模式，命令模式Plus？ 不断了解各种设计模式的的时候，发现其实不同的设计模式之间可能并没有很明确的界限，并且这些传统的设计模式在前端工作中很多都使用不上，应该可以简略成几个模式即可，不需要每一个都了解，反而可能影响自己的认知。 附《设计模式：可复用面向对象软件的基础》《深入设计模式》一本关于设计模式及其背后原则的电子书籍JavaScript设计模式与开发实践 - 曾探设计模式 | 菜鸟教程设计模式 - 廖雪峰从 jQuery 里学习设计模式 - MeathillJavascript继承机制的设计思想 - 阮一峰JavaScript中的设计模式","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"挖坑","slug":"挖坑","permalink":"https://yogwang.site/tags/%E6%8C%96%E5%9D%91/"},{"name":"设计模式","slug":"设计模式","permalink":"https://yogwang.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"学习","slug":"学习","permalink":"https://yogwang.site/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"项目中的类型和状态管理","slug":"JS-type-and-status-management-dictionary","date":"2020-11-24T15:47:32.000Z","updated":"2026-01-05T05:39:58.477Z","comments":true,"path":"2020/JS-type-and-status-management-dictionary/","permalink":"https://yogwang.site/2020/JS-type-and-status-management-dictionary/","excerpt":"这段时间项目迭代比较快，所以很多时候对于记录的状态和类型判断我都是使用的 魔术字符串 的形式，但是这样就与代码形成了 “强耦合”， 不利于后期的维护。 例如这样的代码结构： &lt;!-- 用vue template来举例 --&gt; &lt;template&gt; &lt;table&gt; &lt;!-- 其它结构 --&gt; &lt;td&gt; &lt;!-- 直接使用状态值判断 --&gt; &lt;a @click=&#x27;xxx&#x27; v-if=&#x27;record.status === 0&#x27;&gt;操作A&lt;/a&gt; &lt;!-- 使用数组下标判断 --&gt; &lt;a @click=&#x27;xxx&#x27; v-eles-if=&#x27;record.status === status[1].key&#x27;&gt;操作B&lt;/a&gt; &lt;a @click=&#x27;xxx&#x27; v-else&#x27;&gt;其他操作&lt;/a&gt; &lt;/td&gt; &lt;!-- 其它结构 --&gt; &lt;/table&gt; &lt;/template&gt; 特别是最近一整个分类的类型和状态的都变更了，所以在业务逻辑内的魔术字符串也需要一个一个文件去同步修改，大部分的都被替换了，但还有一些零碎的地方没有被修改到，导致不断有 BUG 被提上来，这就很头疼了。 所以我就想者怎么把业务逻辑内的魔术字符串使用一种方式替换掉，最开始我想法是把状态集中起来进行管理","text":"这段时间项目迭代比较快，所以很多时候对于记录的状态和类型判断我都是使用的 魔术字符串 的形式，但是这样就与代码形成了 “强耦合”， 不利于后期的维护。 例如这样的代码结构： &lt;!-- 用vue template来举例 --&gt; &lt;template&gt; &lt;table&gt; &lt;!-- 其它结构 --&gt; &lt;td&gt; &lt;!-- 直接使用状态值判断 --&gt; &lt;a @click=&#x27;xxx&#x27; v-if=&#x27;record.status === 0&#x27;&gt;操作A&lt;/a&gt; &lt;!-- 使用数组下标判断 --&gt; &lt;a @click=&#x27;xxx&#x27; v-eles-if=&#x27;record.status === status[1].key&#x27;&gt;操作B&lt;/a&gt; &lt;a @click=&#x27;xxx&#x27; v-else&#x27;&gt;其他操作&lt;/a&gt; &lt;/td&gt; &lt;!-- 其它结构 --&gt; &lt;/table&gt; &lt;/template&gt; 特别是最近一整个分类的类型和状态的都变更了，所以在业务逻辑内的魔术字符串也需要一个一个文件去同步修改，大部分的都被替换了，但还有一些零碎的地方没有被修改到，导致不断有 BUG 被提上来，这就很头疼了。 所以我就想者怎么把业务逻辑内的魔术字符串使用一种方式替换掉，最开始我想法是把状态集中起来进行管理 阶段一：使用数组来管理 方式 ①在数组中枚举所有状态，然后调用数组下标的方式去使用。例如这个示例： // order.js const statusLabels = [&#x27;已创建&#x27;, &#x27;申请中&#x27;, &#x27;通过审核&#x27;, &#x27;....&#x27;] 就可以这样使用 statusLabels[index] 来转换 key 值为 label ，但是这样很明显会有一些问题，比如说： 这个 key 值不能是负数，虽然可以通过下面的方式来处理，但是有点蠢….如果最小的 key 值 为 -2 时，把对应的 状态名 放到数组首位，通过这样转换 status[index + 2]； 依旧强耦合，在组件的条件判断中还是会使用 key 值，例如：&lt;a @click=&#39;xxx&#39; v-if=&#39;record.status === 0&#39;&gt;编辑&lt;/a&gt;,如果将来 增加&#x2F;删除 状态的时候会还是需要一个一个文件修改。 只能处理 key - label 的转换，并不能增加其他属性 当然如果单纯只是转换 key 和 label 可以这样使用，这个是项目一开始所使用的方式，后来陆续修改成了 方式 ② 的形式。 阶段二：数组管理 方式 ②这个阶段因为很多组件复用了订单状态表，并且增加了很多属性，比如说图标等。 // order.js const status = [ &#123; label:&#x27;已创建&#x27;, key:0, icon: &#x27;exclamation-circle&#x27;, &#125;, &#123; label:&#x27;申请中&#x27;, key:1, icon: &#x27;clock-circle&#x27;, &#125;, &#123; label:&#x27;通过审核&#x27;, key:2, icon: &#x27;check-circle&#x27;, &#125;, // ..... ] 转换 key 值为 label 就可以这样使用 status.find(r =&gt; r.key===record.status)，然后通过 .属性名 的方式来使用需要的属性，但是这样也会有一些问题，比如说： 条件判断中语义不明，会出现这样的代码，&lt;a @click=&#39;xxx&#39; v-if=&#39;record.status === status[1].key&#39;&gt;编辑&lt;/a&gt;，除了我之外其他人并不知道 status[1] 是什么意思； 如果将来 增加&#x2F;删除 状态的时候会还是需要去同步修改使用下标的组件，不然可能下标错位，当然可以直接追加在最后，但是我有代码洁癖的所以就没办法了。 这个阶段就是我写这篇笔记时的管理，因为项目的 v1.2.x 版本 状态码整体调整了一次，后续状态码一直有小范围的改动，所以出现了需要大面积替换魔术字符串的情况。 那么我就在考虑如何在状态管理的文件中 枚举一次 所有状态，来处理转换状态标签和操作的判断条件，如果后续如果状态码有改动也方便维护的处理方式，就有之后两个阶段的处理方式 阶段三：使用对象来管理这个阶段有考虑过使用 Map 数据结构 因为可以遍历，但是在取值的时候会比较麻烦，并不能直接使用 链式（变量属性）来使用。 所以使用对象来管理，并且使用 Object.values 来返回所有状态数组，例如以下示例： // order.js const status = &#123; created:&#123; label:&#x27;已创建&#x27;, key:0 &#125;, pending:&#123; label:&#x27;申请中&#x27;, key:1 &#125;, approved:&#123; label:&#x27;通过审核&#x27;, key:12 &#125;, // ..... &#125; const statusList = Object.values(status) // 转换 const getOrderStatus = function(key)&#123; const f = statusList.find(item =&gt; item.key === key) return f || status.created &#125; 这个时候可以通过 getOrderStatus 函数来处理 key-label 的转换，并且可以使用 链式（变量属性）的方式去处理判断条件。 &lt;a @click=&#x27;xxx&#x27; v-if=&#x27;record.status === status.created.key&#x27;&gt;编辑&lt;/a&gt; 那这样就可以很方便的来 转换状态 和 在判断条件中使用，并且不用担心语义化的问题。 但是这边又出现了一个问题，比如说： 在用户下的客户类别中的付费用户，如果单纯使用一个 user.js 来管理，并且使用 user.customer.member.key 去判断是否展示操作内容，但是这样的话，在管理端的用户列表中，去替换用户类型的 key 为 label 就比较麻烦，因为层级会比较深，Object.values 只会返回一层，如果一个一个拿出来手动放到一个数组里边有会显得很呆。 所以！ 阶段四：对集中管理文件中的对象拆分因为如果同一个列别中有多级分类的话，就类似上边的例子，user.customer.member 这种用户类别。所以这个时候就把 user.js 拆分成多个文件，然后再 import 进来，这样既可以在状态判断和label转换的时候引入需要的文件就可以了。 示例： // customer.js const customer = &#123; normal:&#123; /*...*/ &#125;, member:&#123; /*...*/ &#125;, // ... &#125; const customerTypes = Object.values(customer) const getCustomerType = function (key) &#123; const record = customerTypes.find(record =&gt; record.key === key) return record || &#123; label: &#x27;未指定&#x27;, key: 0 &#125; &#125; export &#123; customer, customerTypes, getCustomerType &#125; // agent.js const agent = &#123; province:&#123; /*...*/ &#125;, area:&#123; /*...*/ &#125;, // ... &#125; const agentTypes = Object.values(agent) const getAgentType = function (key) &#123; const record = agentTypes.find(record =&gt; record.key === key) return record || &#123; label: &#x27;未指定&#x27;, key: 0 &#125; &#125; export &#123; agent, agentTypes, getAgentType &#125; // user.js import &#123; customer, customerTypes &#125; from &quot;./customer.js&quot; import &#123; agent, agentTypes &#125; from &quot;./agent.js&quot; const user = &#123; customer:customer, agent:agent, // 一些单独的其它类型 xxxx:&#123; /*...*/ &#125;, xxxx:&#123; /*...*/ &#125; // ... &#125; const allUserTypeList = [ ...customerTypes, ...agentTypes, users.xxxx, users.xxxx, ] // 获取账户角色类型 const getAccountType = function (type, key = &#x27;key&#x27;) &#123; const finder = allUserTypeList.find(item =&gt; item[key] === type) return finder || &#123; label: &#x27;未指定&#x27;, key: 0 &#125;, &#125; 确定是用户类型的时候，只需要 import 对应的 角色.js 的就可以，如果不确定类型的时候就可以使用 user.js 来使用 user.xxx.xxx 来使用对应的角色类型数据，或者用 getAccountType 来获取类型。 现在我是用这种方式来管理状态的，但是我觉得还是有一些问题，准备看一下前人是否已经总结出来这种模式，所以准备把之前买来的设计模式大概翻看一下，看看有没有可用的，也算把自己的基础能力完善起来。 尾声我在 Segmentfault 上的问题帖：项目中前端部分关于订单状态管理的一些疑问，如果有更好的想法，可以直接评论，或者 📧 Mail给我","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"挖坑","slug":"挖坑","permalink":"https://yogwang.site/tags/%E6%8C%96%E5%9D%91/"},{"name":"设计模式","slug":"设计模式","permalink":"https://yogwang.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Symbol() 是个什么东西?","slug":"JS-ES6-Symbol","date":"2020-11-21T15:44:47.000Z","updated":"2026-01-05T05:39:58.472Z","comments":true,"path":"2020/JS-ES6-Symbol/","permalink":"https://yogwang.site/2020/JS-ES6-Symbol/","excerpt":"最近在一些 Demo 中经常会看到 Symbol() 这个东西，例如: var race = &#123; protoss: Symbol(), terran: Symbol(), zerg: Symbol() &#125; 就只能记得大概了，就是赋值一个独特的值，但是这个值具体是什么我想不起来了。所以还是记个笔记加深下印象，省的看了又忘。 ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型","text":"最近在一些 Demo 中经常会看到 Symbol() 这个东西，例如: var race = &#123; protoss: Symbol(), terran: Symbol(), zerg: Symbol() &#125; 就只能记得大概了，就是赋值一个独特的值，但是这个值具体是什么我想不起来了。所以还是记个笔记加深下印象，省的看了又忘。 ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型 如果只看 阮一峰的 ECMAScript 6入门 和 MDN 上的说明，可能会有点迷糊，但是大概知道只要是 Symbol类型 是都是独一无二的，保证不会与其他属性名产生冲突。例如： var s1 = Symbol(1) // Symbol(1) var s2 = Symbol(1) // Symbol(1) s1 === s2 // false s1 == s2 // false 所以，就出现了文章一开始的那个例子，出自方应杭老师的的每日一题（在文章最后有附链接）大概的需求场景，就是需要通过传入不同的 String 来执行不同的操作，接下来我就大概引用该文章内的例子来说明 例如：在玩SC2的时候，我们需要在开始时选择种族，选择完成之后在游戏加载时就会执行对应的创建角色操作。 var race = &#123; protoss: &#x27;protoss&#x27;, // 神族 terran: &#x27;terran&#x27;, // 人族 zerg: &#x27;zerg&#x27; // 虫族 &#125; function createRole(type)&#123; if(type === race.protoss)&#123; 创建神族角色 &#125; else if(type === race.terran)&#123; 创建人族角色 &#125; else if(type === race.zerg)&#123; 创建虫族角色 &#125; &#125; 用户选择种族后，就需要调用 createRole 来创建角色： // 传入字符串 createRole(&#x27;zerg&#x27;) // 或者传入变量 createRole(race.zerg) 但是在传入 type 值的时候，如果直接用字符串，就不是一个好的方式（不利于将来的修改和维护），所以需要传入例如 race.zerg 这样的变量属性。那么如果这样操作的话，其实这些对象属性（race.protoss,race.terran,race.zerg）对应的值并不重要，因为传入的肯定是同一个值。所以以下声明和前一个例子中声明可以完成同一个作用。 var race = &#123; protoss: &#x27;askdjaslkfjas;lfkjas;flkj&#x27;, // 神族 terran: &#x27;;lkfalksjfl;askjfsfal;skfj&#x27;, // 人族 zerg: &#x27;qwieqwoirqwoiruoiwqoisrqwroiu&#x27; // 虫族 &#125; 也就是说， race.zerg 的值是多少并不重要，只要它的值跟 race.protoss 和 race.terran 的值不一样就行，Symbol 的用途就是如此。 凡是数据类型属于 Symbol 类型，就都是独一无二的 所以可以用以下代码来声明，并且保证不会出现冲突的属性值： var race = &#123; protoss: Symbol(), terran: Symbol(), zerg: Symbol() &#125; // 抑或填入描述 var race = &#123; protoss: Symbol(&#x27;protoss&#x27;), terran: Symbol(&#x27;terran&#x27;), zerg: Symbol(&#x27;zerg&#x27;) &#125; 至此我觉得 Symbol 数据类型已经解释清楚了，如果还是不明白，请重新回到头部阅读一遍。 Symbol 拥有的一些特性一、Symbol 作为属性名进行遍历时： Symbol 作为属性名，遍历对象的时候，该属性不会出现在 for...in、for...of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 返回。 Symbol 也不是私有属性。 可以通过 Object.getOwnPropertySymbols() 方法来获取指定对象的所有 Symbol 属性名（方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值） const obj = &#123;&#125;; let a = Symbol(&#x27;a&#x27;); let b = Symbol(&#x27;b&#x27;); obj[a] = &#x27;Hello&#x27;; obj[b] = &#x27;World&#x27;; Object.getOwnPropertySymbols(obj); // [Symbol(a), Symbol(b)] 当然也可以使用 ES6 的新 API Reflect.ownKeys() 来获取所有类型的键名，包括 常规键名 和 Symbol 键名。 二、Symbol.for() 方法 Symbol.for()方法可以接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。 如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。 let s1 = Symbol.for(&#x27;foo&#x27;); let s2 = Symbol.for(&#x27;foo&#x27;); s1 === s2 // true Symbol.for(&quot;bar&quot;) === Symbol.for(&quot;bar&quot;) // true Symbol.for() 与 Symbol() 都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。 三、Symbol.keyFor() 方法 Symbol.keyFor() 方法返回一个已登记的 Symbol 类型值的 key。 let s1 = Symbol.for(&quot;foo&quot;); Symbol.keyFor(s1) // &quot;foo&quot; let s2 = Symbol(&quot;foo&quot;); Symbol.keyFor(s2) // undefined 四、内置的 Symbol 属性除了定义自己使用的 Symbol 值以外，ES6 还提供了 11 个内置的 Symbol 值，指向语言内部使用的方法。 Symbol.hasInstance Symbol.isConcatSpreadable Symbol.species Symbol.match Symbol.replace Symbol.search Symbol.split Symbol.iterator Symbol.toPrimitive Symbol.toStringTag Symbol.unscopables 这11个属性具体的说明看阮一峰老师的 ECMAScript 6入门 就可以了，里边有单独的小Demo可以阅读，我就不单独说明了，因为如果全部说明的话，内容就太多了，并且和书的内容高度重复了。 附「每日一题」JS 中的 Symbol 是什么？ | 方应杭Symbol - ECMAScript 6入门 | 阮一峰Symbol - JavaScript | MDNSymbol.prototype.description - JavaScript | MDNReflect - ECMAScript 6入门 | 阮一峰Reflect.ownKeys() - JavaScript | MDN","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"},{"name":"ECMAScript 6","slug":"ECMAScript-6","permalink":"https://yogwang.site/tags/ECMAScript-6/"}]},{"title":"📟 树莓派 4B(2GB RAM) 开箱记录","slug":"raspberrypi-01-setup","date":"2020-11-16T12:56:29.000Z","updated":"2026-01-05T05:39:58.512Z","comments":true,"path":"2020/raspberrypi-01-setup/","permalink":"https://yogwang.site/2020/raspberrypi-01-setup/","excerpt":"自从我爸妈他们屋子重新装修好了之后，我爸就嚷嚷着要把他的旧电脑搬上楼装起来，但是家里没有多少地方能摆电脑桌了(怕他又和以前一样在书房看着小说抽一整天的烟)。所以趁着双十一，就入手了一个树莓派 4 Model B，准备给他放客厅连到电视上，通过家里人时不时打断他投入看小说的状态。 今天到货了，开始折腾一下….","text":"自从我爸妈他们屋子重新装修好了之后，我爸就嚷嚷着要把他的旧电脑搬上楼装起来，但是家里没有多少地方能摆电脑桌了(怕他又和以前一样在书房看着小说抽一整天的烟)。所以趁着双十一，就入手了一个树莓派 4 Model B，准备给他放客厅连到电视上，通过家里人时不时打断他投入看小说的状态。 今天到货了，开始折腾一下…. 📦 喜闻乐见的开箱环节 我买的是官方的国内代理，其实就是淘宝店，然后买的 【 官方配件基础套餐 】，里边有一个板子然后一些配件(电源，散热贴片，外壳，TF卡(16G)，读卡器) 💾 安装镜像安装镜像没什么好说的，使用官方文档上的软件，格式化SD卡以及写入系统镜像即可。 意外情况：如果一直卡在 Writing..0% 的界面的话，直接到官网手动下载需要的镜像，然后在 CHOOSE OS 中选择 Use custom 选项，然后找到下载的镜像文件再写入就可以了。 安装完成之后在 Boot 分区下创建 ssh 文件(开启SSH)和 wpa_supplicant.conf 文件(自动连接WiFi)，然后把TF卡插回树莓派，接入电源后使用 SSH 链接就可以连接到树莓派了，默认用户名（pi）和密码（raspberry）。 如果要使用桌面的话，如果使用 VNC Viewer 来访问的话，直接查看官方的文档即可。 我的话，直接就通过 Win10 自带的远程连接的话，就不能按照文档照搬了， sudo apt-get install xrdp tightvncserver 安装完成后键入 sudo /etc/init.d/xrdp start 启动 xrdp，这个时候就已经可直接使用远程连接访问树莓派了。但是浏览网页明显感觉到卡顿，不知道是不是远程链接的问题。 2020年11月17日更新，使用 Ubuntu Server 安装 Desktop 之后就没有感觉很卡了。 💥遇问题1、没有外接显示器，直接使用SSH连接的时候遇到 Connection refused因为中午在办公室开箱的，所以在午休的时候捣鼓，写入系统之后发现怎么都连接不上，以为是没有镜像没有写入好，所以又重新格式化又写了一遍，之后发现还是连不上，就Google了一下，发现是SSH没有开启的问题。 As of the November 2016 release, Raspberry Pi OS has the SSH server disabled by default. 但是我手头上没有可以用的显示器，就想着怎么不用显示器来开启SSH，官方提供了几个方案（连接在文档最后）： 连接显示器后进入 Preferences 菜单进行操作。 连接显示器后使用命令行开启。 通过 headless 可以直接在 boot 分区下创建 ssh 文件(小写)，在系统启动时自启动 SSH。 方案1 和 方案2 直接放弃，要有这个条件我还纠结啥….所以只能在 方案3 上尝试一下。 由于后来我又尝试安装了 Ubuntu Desktop 20.10 所以可能有些不一样，各种创建文件的方式我都尝试了，但是都没有成功，好像是说 Ubuntu Desktop 默认没有 SSH 服务，需要手动安装启动。只能尝试通过先安装 Ubuntu Server版，再安装 ubuntu-desktop 的方式看看能不能行得通。 2020年11月17日更新，确实 Ubuntu Server 版本写入TF卡后直接连网线就可以使用SSH连接了。换源什么的应该都不用说了吧？ 2、Ubuntu Desktop 中使用Firefox看B站提示缺少Flash刚刚安装完 Ubuntu Desktop 包，想试试看视频卡不卡，然后进入B站提示我缺少Flash，因为Ubuntu中不包含 Ubuntu Restricted Extras 软件包，使用 sudo apt-get install ubuntu-restricted-extras 安装就可以了。（画外音：同意协议记得用键盘操作，鼠标点击是没有用的） 附SD Memory Card Formatter - SD AssociationOperating system images – Raspberry PiSSH (Secure Shell) - Raspberry Pi Documentation","categories":[{"name":"代码之外","slug":"代码之外","permalink":"https://yogwang.site/categories/%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96/"}],"tags":[{"name":"RaspberryPi","slug":"RaspberryPi","permalink":"https://yogwang.site/tags/RaspberryPi/"}]},{"title":"聊一下自己 VueJS 项目的编码习惯和风格","slug":"vue-coding-style-and-lint","date":"2020-11-11T04:01:49.000Z","updated":"2026-01-05T05:39:58.521Z","comments":true,"path":"2020/vue-coding-style-and-lint/","permalink":"https://yogwang.site/2020/vue-coding-style-and-lint/","excerpt":"最近在考虑把遍码习惯整理一下，一个良好的遍码习惯可以有效减少一个项目的维护成本，因为不可能在整个项目的生命周期中，均由最初的开发人员来维护，或者所有的代码都是由你一个人写出来的，改善代码的可读性，可以让开发人员尽快理解历史的业务代码。 之前也有研究过 ESlint的格式化风格 选择一款适合自己的来规范自己，但是了解的越多，越觉得还是需要团队互相讨论来找一个大家能都接受的妥协结果，所以最后还是选择了 Prettier ，因为我觉得其它两种风格相对来说太严苛了，很多项目都是自己开发并没有多人合作开发的情况出现，所以使用 Prettier 相对来说所自由一些…","text":"最近在考虑把遍码习惯整理一下，一个良好的遍码习惯可以有效减少一个项目的维护成本，因为不可能在整个项目的生命周期中，均由最初的开发人员来维护，或者所有的代码都是由你一个人写出来的，改善代码的可读性，可以让开发人员尽快理解历史的业务代码。 之前也有研究过 ESlint的格式化风格 选择一款适合自己的来规范自己，但是了解的越多，越觉得还是需要团队互相讨论来找一个大家能都接受的妥协结果，所以最后还是选择了 Prettier ，因为我觉得其它两种风格相对来说太严苛了，很多项目都是自己开发并没有多人合作开发的情况出现，所以使用 Prettier 相对来说所自由一些… 先来讲代码的格式与注释代码的格式和注释虽起不到逻辑作用，但是可以是团队合作效率更高，代码更易于维护。特别是在其他人接手自己项目的时候，能让他很快了解自己的想法。 我这边一直在使用的类似 AirBnb 的 Lint 风格，但只是其中的一些命名、缩进和换行的风格，我并没有严格按照他们的风格来，例如： 用命名函数表达式而不是函数声明 func-style 函数表达式： const func = function () &#123;&#125; 函数声明： function func() &#123;&#125; 虽然有他们的道理，但是我并不是很喜欢，当然会根据不同团队做出改变。所以保持业务代码的可读性就好，我没有按部就班的使用，项目也只是启用了 Prettier 的默认设置。 概念隔离：不同的的概念&#x2F;逻辑代码使用空行隔离 代码注释代码注释我这边还没有很明确到很精细的规范，很自由。只是要求了在 文件头、函数声明时 以及 函数内一些关键的部分 进行补充说明，因为有时候只是代码的语义化并不能很好的说明情况。虽然自己也经常会忘记在一些复杂场景下补充注释，但是事后记得补全就好。 哦，对了，记得增加提示信息，防止出现踩坑事件，例如使用 TODO 等标记未来得及完成的部分，并且安装 TODO Tree 插件确保自己不会遗忘填坑。 冗余代码尽量避免重复代码，我对于冗余代码的意见是很大的，需要代码简洁明了清晰易读，特别是明显可以抽离出来复用的业务逻辑。如果重复出现多次的话，我一定会分离出去，特别是一些复杂场景下的大段代码中，尽量 保持一个函数职责单一 对于代码的提炼在考虑到项目的后续发展和可能会出现的扩展之后，在一定版本迭代中不会出现功能拓展的业务代码进行提炼和优化，这就需要你对于项目整体要有一定程度的了解。 对可能在可遇见的时间范围内会出现变动的的业务代码精心适量的优化，并且保持扩展的便利性，确保不会出现死结。 同时保持代码短小精炼并且易维护、易拓展是很困难的，优先保证易维护和易拓展。 效率有时候为了实现尽快实现功能，会出现急功近利的情况，牺牲代码的可读性以及结构。如果很赶时间，尽量在Coding之前，整理好需求，在设计完代码流程和结构之后把注释写在功能头部。方便结束之后整理优化，就算自己忘记整理了，也不至于接手的下一任直接重写，记得代码面向读代码的人来写。 最后是 Vue 官方的风格规范:Vue 有一套官方的风格指南，里边有一些指导和参考，总共分为四类： 优先级 A：必要的 优先级 B：强烈推荐 优先级 C：推荐 优先级 D：谨慎使用 优先级 A 的就不需要说了吧，必要的这块内容，应该在学习 Vue 的时候就已经从官方给出的 Demo 感受到了，比如 组件名为多个单词，以及 组件的 data 必须是一个函数。虽然有一些规范在 Vue3 中已经被修改了，但是在 Vue2 中还是适用的。 优先级 B 这一类的内容是为了增加代码可读性的，所以尽最大可能的保证使用以及一贯性，基本都是一些命名和书写规范，刻意保持一段时间就习惯了。 优先级 C 这块内容是比较自由的，官方也设定为推荐级别，其中提到的 组件&#x2F;实例的选项的顺序，我觉得重要性还是很高的，在Cooding时保持和官方文档一样的排列顺序。 最近我就出现了同事把 created 代码放到组件最后，我在增加功能的时候在头部也增加了 created ，发现自己的 created 钩子没有执行。当然这个锅其实有一部分是编辑器的，我这边没有对重复声明的对象属性进行错误高亮。 优先级 D 中的内容是警告内容，这块内容在良好的编码习惯下一般是不会出现的。 当然如果你觉得官方的Lint的风格很好，那么你可以使用他们提供的 eslint-plugin-vue 这个依赖项，来规范和格式化代码。 最后的最后我对之前 Vue 官方指导没有提到的一些地方进行补充： 每一个组件都要有 name 属性。2.你需要了解 mixins 和 extends。 使用 computed 来计算一些属性，比如路由信息 $route中的一些传递参数，或者在代码中出现频率很高的深层属性。 在生命周期钩子中，保证不出现业务代码，如果一块内容超过6行那就单独拿出来写成函数放到 methods 中，尽量减少生命周期钩子中的代码量。 业务代码都在 methods 中，或者取成 功能名称.js文件。 在路由中使用 params 来传递参数，记得在路由配置中绑定动态路径参数，不然会丢失 保持Lint开启。 使用环境变量。 附风格指南 — Vue.jsvue&#x2F;order-in-components | eslint-plugin-vue Introduction | eslint-plugin-vue","categories":[],"tags":[{"name":"VueJS","slug":"VueJS","permalink":"https://yogwang.site/tags/VueJS/"},{"name":"Coding","slug":"Coding","permalink":"https://yogwang.site/tags/Coding/"}]},{"title":"ES6 中的 新数据结构 Set & Map","slug":"JS-ES6-MAP","date":"2020-11-07T05:22:28.000Z","updated":"2026-01-05T05:39:58.472Z","comments":true,"path":"2020/JS-ES6-MAP/","permalink":"https://yogwang.site/2020/JS-ES6-MAP/","excerpt":"今天在一个需求里边遇到一个使用 MAP 数据结构的场景，就去解了一下 ES6 的新数据结构 ECMAScript 6 内提供了 4种 新结构 Set, WeakSet, Map, WeakMap，虽然已经是5年前的知识了，但是对于我来说还是新🤣 本来想先聊 Map 的，但是仔细看了阮一峰老师的文章之后发现，确实是要从 Set 开始讲","text":"今天在一个需求里边遇到一个使用 MAP 数据结构的场景，就去解了一下 ES6 的新数据结构 ECMAScript 6 内提供了 4种 新结构 Set, WeakSet, Map, WeakMap，虽然已经是5年前的知识了，但是对于我来说还是新🤣 本来想先聊 Map 的，但是仔细看了阮一峰老师的文章之后发现，确实是要从 Set 开始讲 1 | Set 数据结构 类似于数组，但是成员的值都是唯一的，没有重复的值。 本身是一个构造函数，用来生成 Set 数据结构。 拥有两个属性： Set.prototype.constructor：构造函数，默认就是 Set 函数。 Set.prototype.size：返回 Set 实例的成员总数。 四个操作方法和四个遍历方法： 操作方法 Set.prototype.add(value)：添加某个值，返回 Set 结构本身。 Set.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 Set.prototype.has(value)：返回一个布尔值，表示该值是否为Set的成员。 Set.prototype.clear()：清除所有成员，没有返回值。 遍历方法 Set.prototype.keys()：返回 键名 的遍历器 Set.prototype.values()：返回 键值 的遍历器 Set.prototype.entries()：返回 键值对 的遍历器 Set.prototype.forEach()：使用回调函数遍历每个成员 先说 Set 数据结构的创建，因为 Set 本身是一个构造函数，所以可以使用 new 命令来创建，然后通过 add() 来添加成员。 当然也可以通过传入一个数组来进行初始化，或者具有 iterable 接口的其他数据结构。 // 直接创建一个Set结构 const s = new Set(); s.add(1); // Set(1) &#123;1&#125; // 传入数组的形式创建Set结构 const s2 = new Set([1, 2, 3, 4]) // Set(4) &#123;1, 2, 3, 4&#125; 既然 Set 函数支持传入数组来进行初始化，并且成员的值都是唯一的，没有重复的值，所以可以使用 Set 来实现一个简短的数组去重方法： // 简单数组去重 const sourceArray = [1, 2, 3, 4, 5, 5, 5, 6, 7, 6, 8] const newArray = Array.from((new Set(sourceArray))) console.log(newArray) // (8) [1, 2, 3, 4, 5, 6, 7, 8] 另外向 Set 添加成员的时候需要注意几个点: 添加成员的时候，不会发生类型转换 两个 对象 总是不相等的，但是两个 NaN 会被认为是相等的 插入顺序就是遍历顺序，所以能保证按照添加顺序调用（不能直接改变结构） 内部使用的算法叫做 “Same-value-zero equality”，类似于精确相等运算符（&#x3D;&#x3D;&#x3D;） 乍一看可能不明白，我举几个例子🌰 // 插入数字和字符串 let set = new Set() set.add(1) set.add(&#x27;1&#x27;) // Set(2) &#123;1, &quot;1&quot;&#125; // 插入对象 let set = new Set() let a1 = &#123;&#125; let a2 = &#123;&#125; set.add(a1) set.add(a2) set.size // 2 // Set(2) &#123;&#123;…&#125;, &#123;…&#125;&#125; // 插入 NaN let set = new Set() let a1 = NaN let a2 = NaN set.add(a1) set.add(a2) set.size // 1 // Set(1) &#123;NaN&#125; // 顺序保持 let set = new Set() set.add(1) set.add(2) set.add(6) set.add(4) set.add(5) // Set(5) &#123;1, 2, 6, 4, 5&#125; 接着就是 Set 的遍历方法了， 第一类： keys()，values()，entries() 返回的都是遍历器对象（Iterator 对象 - SetIterator） Set 的遍历顺序就是插入顺序 Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的 values 方法。 由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以 keys 方法和 values 方法的行为完全一致。 第二类： forEach() const set = new Set([&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;]); // 返回键名 for (let item of set.keys()) &#123; console.log(item); &#125; // red // green // blue // 返回键值 for (let item of set.values()) &#123; console.log(item); &#125; // red // green // blue // 返回键值对 for (let item of set.entries()) &#123; console.log(item); &#125; // (2)[&quot;red&quot;, &quot;red&quot;] // (2)[&quot;green&quot;, &quot;green&quot;] // (2)[&quot;blue&quot;, &quot;blue&quot;] // 直接遍历 for (let x of set) &#123; console.log(x); &#125; // red // green // blue set.forEach((value, key) =&gt; console.log(key + &#x27; : &#x27; + value)) // red : red // green : green // blue : blue 2 | Map 数据结构 JavaScript 的对象（Object），本质上是 键值对 的集合（Hash 结构），但是传统上只能用 字符串 当作键。这给它的使用带来了很大的限制。为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是 键值对 的集合，但是 “键” 的范围 不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了 “字符串 — 值” 的对应，Map 结构提供了 “值 — 值” 的对应，是一种更完善的 Hash 结构实现。如果你需要 “键值对” 的数据结构，Map 比 Object 更合适。 来一段对比的例子： const data = &#123;&#125;; const key = &#123; key: 1 &#125;; data[key] = &#x27;Value&#x27;; console.log(data) // &#123; &#x27;[object Object]&#x27;: &#x27;Value&#x27; &#125; console.log(data[key]) // Value const key2 = &#123; key: 2 &#125;; data[key2] = &#x27;Key2 Value&#x27;; console.log(data[key]) // Key2 Value console.log(data[key2]) // Key2 Value console.log(data) // &#123; &#x27;[object Object]&#x27;: &#x27;Key2 Value&#x27; &#125; 上面代码原意是将一个 对象key 作为 对象data 的键，但是由于对象只接受字符串作为键名，所以key被自动转为字符串 [object Object]。虽然也能用 data[key] 来调用，但实质是把 key 自动转换成了字符串 [object Object] 来调用，所以当有设置多个对象作为键的时候就会覆盖原先的属性。 下边的代码使用 Map 结构的set方法，将上面的代码进行复原： const data = new Map(); const key = &#123; key: 1 &#125;; m.set(key, &#x27;Value&#x27;) console.log(m.get(key)） // &quot;Value&quot; const key2 = &#123; key: 2 &#125;; m.set(key2, &#x27;Key2 Value&#x27;) console.log(m.get(key2)) // &quot;Key2 Value&quot; console.log(data) // Map &#123; &#123; key: 1 &#125; =&gt; &#x27;Value&#x27;, &#123; key: 2 &#125; =&gt; &#x27;Key2 Value&#x27; &#125; 可以看到 Map 数据结构 可以完美实现原意，使用对象作为 键，其它就和对象的结构基本类似。 Map 结构的实例和 Set 结构一样的属性和相似的操作方法 拥有两个属性： Map.prototype.constructor：构造函数，返回一个函数，它创建了实例的原型。默认是 Map 函数。 Map.prototype.size：返回 Map对象的键&#x2F;值对的数量。 五个操作方法和四个遍历方法： 操作方法 Map.prototype.set(value)：设置 Map 对象中键的值。返回该 Map 对象。 Map.prototype.get(value)：返回键对应的值，如果不存在，则返回 undefined。 Map.prototype.has(value)：返回一个布尔值，表示 Map 实例是否包含键对应的值。 Map.prototype.delete(value)：删除某个元素，返回一个布尔值，表示删除是否成功。 Map.prototype.clear()：移除 Map 对象的所有键&#x2F;值对，没有返回值。 遍历方法 Map.prototype.keys()：返回 键名 的遍历器 Map.prototype.values()：返回 键值 的遍历器 Map.prototype.entries()：返回 键值对 的遍历器 Map.prototype.forEach()：使用回调函数遍历每个成员 和 Set 一样，Map 也可以接收传入数组来进行初始化，但是数组内需要是键值对的形式，例如： // 数组 转为 Map const data = [ [1, &#x27;one&#x27;], [2, &#x27;two&#x27;], [3, &#x27;three&#x27;], ] const map = new Map(data); console.log(map) // Map(3) &#123;1 =&gt; &quot;one&quot;, 2 =&gt; &quot;two&quot;, 3 =&gt; &quot;three&quot;&#125; 对象不是一个可迭代的结构，可以通过 Object.entries() 转换成可迭代结构 // 对象转为 Map let obj = &#123;&quot;a&quot;:1, &quot;b&quot;:2&#125;; let map = new Map(Object.entries(obj)); console.log(map) // Map(2) &#123;&quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 2&#125; Map 也可以转换回其它数据结构 // Map 转为数组 const myMap = new Map() .set(true, 7) .set(&#123;foo: 3&#125;, [&#x27;abc&#x27;]); [...myMap] // 使用 扩展运算符 最简便 // [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ &#x27;abc&#x27; ] ] ] 如果所有 Map 的键都是字符串，它可以无损地转为对象。 如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名（如本节最开始的Demo所示） // Map 转为对象 function strMapToObj(strMap) &#123; let obj = Object.create(null); for (let [k,v] of strMap) &#123; obj[k] = v; &#125; return obj; &#125; const myMap = new Map() .set(&#x27;yes&#x27;, true) .set(&#x27;no&#x27;, false); strMapToObj(myMap) // &#123; yes: true, no: false &#125; Map 转为 JSONMap 转为 JSON 要区分两种情况。一种情况是，Map 的键名 都是字符串，这时可以选择转为 对象 JSON。 function strMapToJson(strMap) &#123; return JSON.stringify(strMapToObj(strMap)); &#125; let myMap = new Map().set(&#x27;yes&#x27;, true).set(&#x27;no&#x27;, false); strMapToJson(myMap) // &#x27;&#123;&quot;yes&quot;:true,&quot;no&quot;:false&#125;&#x27; 另一种情况是，Map 的键名 有非字符串，这时可以选择转为 数组 JSON。 function mapToArrayJson(map) &#123; return JSON.stringify([...map]); &#125; let myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, [&#x27;abc&#x27;]); mapToArrayJson(myMap) // &#x27;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&#x27; JSON 转为 Map这段我直接引用阮一峰老师的文字吧 正常情况下，所有键名都是字符串。function jsonToStrMap(jsonStr) &#123; return objToStrMap(JSON.parse(jsonStr)); &#125; jsonToStrMap(&#x27;&#123;&quot;yes&quot;: true, &quot;no&quot;: false&#125;&#x27;) // Map &#123;&#x27;yes&#x27; =&gt; true, &#x27;no&#x27; =&gt; false&#125;但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。function jsonToMap(jsonStr) &#123; return new Map(JSON.parse(jsonStr)); &#125; jsonToMap(&#x27;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&#x27;) // Map &#123;true =&gt; 7, Object &#123;foo: 3&#125; =&gt; [&#x27;abc&#x27;]&#125;3 | WeakSet 数据结构 WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。 WeakSet 的成员只能是 对象，而 不能是其他类型的值。 WeakSet 中的对象都是 弱引用（即垃圾回收机制不考虑 WeakSet 对该对象的引用） WeakSet 不能遍历，是因为成员都是弱引用 那直接看说明，很直接明了，第一个区别也很直接，主要就是第二个区别，什么是 垃圾回收机制不考虑 WeakSet 对该对象的引用 垃圾回收机制依赖引用计数，如果一个值的引用次数不为 0，垃圾回收机制就不会释放这块内存。结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。 而 WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。 因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些 对象 在 外部消失，它在 WeakSet 里面的引用就会自动消失。 由于上面这个特点，WeakSet 的成员是不适合引用的，因为它会随时消失。另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 WeakSet 不可遍历。 总而言之，言而总之，就是一个只能存储 Object 和 Array 的集合，而且内存泄漏得问题现在应该已经解决了吧…. WeakSet 结构有以下三个方法： WeakSet.prototype.add(value)：向 WeakSet 实例添加一个新成员。 WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。 WeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员，返回一个布尔值。 我能想到的场景就是判断是否某个对象是否还存在与场景中，🤦‍♂️其它的应用场景我真的想不到了…. 好了，大概看几个演示Demo吧 const ws = new WeakSet(); const obj = &#123;&#125; const arr = [] const arr2 = arr const arr3 = arr ws.add(obj) // WeakSet &#123;&#123;…&#125;&#125; ws.add(arr) // WeakSet &#123;Array(0), &#123;…&#125;&#125; ws.add(1) // Uncaught TypeError: Invalid value used in weak set ws.add(NaN) // Uncaught TypeError: Invalid value used in weak set ws.add(arr2) // WeakSet &#123;Array(0), &#123;…&#125;&#125; ws.has(obj) // true ws.has(arr) // true ws.has(arr2) // true ws.has(arr3) // true ws.has(&#123;&#125;) // false ws.has([]) // false ws.delete(arr) // true ws.has(arr) // false ws.has(arr2) // false 4 | WeakMap 数据结构 WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。 同时也和 WeakSet 一样，只接受 对象 作为键名（ null 除外），不接受其他类型的值作为键名。并且同样是弱引用，WeakMap 的键名所指向的对象，不计入垃圾回收机制。 实例方法 WeakMap 比 WeakSet 多了一个可用 get()： 返回 key 关联对象, 或者 undefined (没有 key 关联对象时)。 结尾再阮一峰老师的文章最后有一段，但是我实际操作的时候触发垃圾回收，所以 Weak* 的弱引用暂时没有 Demo 。 Chrome 浏览器的 Dev Tools 的 Memory 面板，有一个垃圾桶的按钮，可以强制垃圾回收（garbage collect）。这个按钮也能用来观察 WeakMap 里面的引用是否消失。 其它问题1、Vue 的不能监听到 Map 和 Set 的数据改变: Vue 的响应式系统不支持 Map 和 Set，也就是说，当 Map 与 Set 里面的元素变化时Vue追踪不到这些变化，因此无法做出响应。 2、为啥把对象设置为Null了，WeakSet/WeakMap 内的成员不会消失我在写笔记的时候一直想写一个 WeakSet 的弱引用 Demo，但是一直没有成功，就算把变量设置为 null 了，还能可以能从 WeakSet 里边看到，例如以下代码： let a = &#123; name: &#x27;a&#x27; &#125; const ws = new WeakSet(); ws.add(a) // WeakSet &#123;&#123;…&#125;&#125; a = null // null console.log(ws) // WeakSet &#123;&#123;…&#125;&#125; // - [[Entries]] // - 0: // - value: &#123;name: &quot;a&quot;&#125; // __proto__: WeakSet 一个人坐在沙发上纠结了好久，然后还是去群里问了下，得到了一下回复….我是真的没想到🤣 MeatHill：虽然 weak* 允许被回收，但是大多数情况下，在内存压力不大的时候它不会被回收，所以一般建议默认它不会被回收。尤其不要在 set 之后立刻看，几乎一定不会被回收。GC (垃圾回收机制)的成本不低，不是时时运转的。 Emmmm….. 我裂开🙃 3、WeakMap.prototype.clear() 当前版本或者起草中没有这个方法，这个方法在版本 28（2014 年 10 月 14） 之前是 ECMAScript 6 起草规范的一部分，但是在起草之后的版本中被移除了。它不在是最终标准的一部分了 。 附 Set 和 Map 数据结构 - 阮一峰 迭代器 Symbol.iterator - JavaScript | MDN Iterator 和 for…of 循环 - 阮一峰 Set - JavaScript | MDN Map - JavaScript | MDN WeakSet - JavaScript | MDN WeakMap - JavaScript | MDN 解决内存问题 | Chrome DevTools | Google Developers","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"},{"name":"ECMAScript 6","slug":"ECMAScript-6","permalink":"https://yogwang.site/tags/ECMAScript-6/"}]},{"title":"VueJS中 v-bind 的一些修饰符","slug":"vue-v-bind-props-camel-sync","date":"2020-11-05T13:59:52.000Z","updated":"2026-01-05T05:39:58.523Z","comments":true,"path":"2020/vue-v-bind-props-camel-sync/","permalink":"https://yogwang.site/2020/vue-v-bind-props-camel-sync/","excerpt":"今天洗澡的时候在听 饥人谷的模拟面试 (五) 的时候，一直觉得这次面试的学生有点差，如果是我来面话可能已经让他回家了，但是 方方老师 很有耐心，在中间问道 .sync 的时候我 ???? 完全没有印象了。 正好已经有2个月没有更新了，所以复习一下 v-bind 的三个修饰符 [ .prop, .camel, .sync ]","text":"今天洗澡的时候在听 饥人谷的模拟面试 (五) 的时候，一直觉得这次面试的学生有点差，如果是我来面话可能已经让他回家了，但是 方方老师 很有耐心，在中间问道 .sync 的时候我 ???? 完全没有印象了。 正好已经有2个月没有更新了，所以复习一下 v-bind 的三个修饰符 [ .prop, .camel, .sync ] 首先就是 .sync .sync (2.3.0+) 语法糖，会扩展成一个更新父组件绑定值的 v-on 侦听器。 直接看文档里边的这段话，可能会有点懵，但是可以大概猜到是更新单向流数据相关的。 然后看文档里边的 Demo 👇 &lt;!-- 向子组件传入 title, 并且接收update事件更新title --&gt; &lt;text-document v-bind:title=&quot;doc.title&quot; v-on:update=&quot;doc.title = $event&quot; /&gt; 然后通过子组件的 this.$emit(&#39;update:title&#39;, newTitle) 触发 update:title 事件, 不过正常时候的业务代码我不会这样写，会习惯使用以下的代码（不过没差啦，意思都一样） &lt;text-document :title=&quot;doc.title&quot; @update=&quot;title =&gt; doc.title = title&quot; /&gt; 然后通过子组件的 this.$emit(&#39;update&#39;, newTitle) 触发更新 虽然精简了一点，但是还是很冗余，所以轮到 .sync 这个语法糖出场，可以更加精简父组件的代码： &lt;text-document :title.sync=&quot;doc.title&quot; /&gt; 可以看到就是省略了接受子组件的 update 事件，像 v-model 这个语法糖一样双向绑定了数据。 需要注意一点的是，使用 .sync 这个语法糖，需要子组件内的 $emit 触发的事件以 update:myPropName 的形式来命名 所以我自己的遍码习惯就触发不了，需要修改子组件的 $emit 和文档中的一样使用 this.$emit(&#39;update:title&#39;, newTitle) 来触发更新 也可以将这个 .sync 修饰符和 v-bind 配合使用，用于修改传入的同一个对象中的多个属性 &lt;text-document v-bind.sync=&quot;doc&quot;&gt;&lt;/text-document&gt; 这样会把 doc 对象中的每一个 property (如 title ) 都作为一个独立的 prop 传进去，然后各自添加用于更新的 v-on 监听器。 二： .prop .prop - 作为一个 DOM property 绑定而不是作为 attribute 绑定 (差别在哪里？)。 这个的主要就是你需要先理解 DOM property 和 attribute 的 区别（ DOM属性 和 属性 挖个坑找时间聊聊），然后就很容易知道这个修饰符的作用了。 大概就是 v-bind 默认绑定到 DOM 节点的 attribute 上，使用 .prop 修饰符后，会绑定到 property 上 最后一个 .camel .camel - (2.1.0+) 将 kebab-case attribute 名转换为 camelCase。(从 2.1.0 开始支持) 因为 HTML代码是不区分大小写的，但是有一些标签需要使用驼峰来申明属性，例如文档中的 svg 标签的 viewBox 属性，如果渲染成 viewbox 则会找不到值。 这个真的很少用到，文档还特别说明了 vue-loader 渲染的不会有这个问题： 在使用字符串模板或通过 vue-loader&#x2F;vueify 编译时，无需使用 .camel。 在Vue 3.0中的 .sync 今天写Vue遍码风格的时候发现了一个3.0的新规范，就是不推荐使用 v-bind-sync 这一个选项，里边提到了在 3.0 中已经解决了在组件上 v-model 只允许使用一个的问题，所以不推荐继续使用 .sync 了，大概看一下就好，链接添加在了附录内，所以这又是一篇迟到的文章，2333333。 附 DOM property 和 attribute 的区别详解 vue 2.x 的 v-bind 指令的 .prop 事件修饰符详解 v-model | Vue.js 迁移指南","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"挖坑","slug":"挖坑","permalink":"https://yogwang.site/tags/%E6%8C%96%E5%9D%91/"},{"name":"VueJS","slug":"VueJS","permalink":"https://yogwang.site/tags/VueJS/"}]},{"title":"Vue 使用 ref 注册组件的特性","slug":"vue-api-ref","date":"2020-11-02T09:14:09.000Z","updated":"2026-01-05T05:39:58.521Z","comments":true,"path":"2020/vue-api-ref/","permalink":"https://yogwang.site/2020/vue-api-ref/","excerpt":"一直以来，我对于 VueJS 中对于使用 ref 注册的组件，在使用 $refs 调用时，为什么有时候是一个 DOM元素&#x2F;组件实例，是时候会是一个实例数组。 所以在很长一段时间内我觉得 ref 注册的的组件在使用 $refs 调用时有很大的不确定性，虽然我的弹窗组件一直都是用的 $refs.modal.open() 来打开的。 直到前一段时间，我在一个场景下想在 v-for 循环渲染的组件下 slot 模板中想使用 ref 注册成一个实例集合来调用时，发现怎么样重写返回的都只是一个组件实例，而不是一个组件实例集合。 所以有了这样一篇笔记。","text":"一直以来，我对于 VueJS 中对于使用 ref 注册的组件，在使用 $refs 调用时，为什么有时候是一个 DOM元素&#x2F;组件实例，是时候会是一个实例数组。 所以在很长一段时间内我觉得 ref 注册的的组件在使用 $refs 调用时有很大的不确定性，虽然我的弹窗组件一直都是用的 $refs.modal.open() 来打开的。 直到前一段时间，我在一个场景下想在 v-for 循环渲染的组件下 slot 模板中想使用 ref 注册成一个实例集合来调用时，发现怎么样重写返回的都只是一个组件实例，而不是一个组件实例集合。 所以有了这样一篇笔记。 注册 | ref 用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。 如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素； 如果用在子组件上，引用就指向组件实例： 关于 ref 注册时间的重要说明：因为 ref 本身是作为 渲染结果 被创建的，在初始渲染的时候你不能访问它们 - 它们还不存在！$refs 也 不是响应式 的，因此你不应该试图用它在模板中做数据绑定。 所以不要在 mounted() 之前的生命周期钩子里边直接使用 $refs 来获取元素，或者在没有渲染组件的情况下调用元素内的属性或方法，如果一定要的话，记得放在 $nextTick() 里。 使用 | $refs 一个对象，持有注册过 ref attribute 的所有 DOM 元素和组件实例。 只读 允许父级组件通过 $refs 来访问子组件实例内部元素的访问，比如来访问子组件实例内的 data 和 methods 当 ref 和 v-for 一起使用的时候，将得到一个 DOM 节点数组 或 包含了对应数据源 的组件实例的。 1、什么时候只返回一个组件&#x2F;DOM实例一般来说，直接在一个没有使用 v-for 循环的元素上使用 ref 注册的元素，在使用 this.$refs.xxx 获取时，返回的只会是一个组件实例。 2、什么时候返回一个实例集合按照文档上边来看，在使用 v-for 循环的元素上使用 ref 注册的元素，在使用 this.$refs.xxx 获取时，会返回一个实例集合。 有没有其他办法？比如我不是使用 v-for 循环出来的实例，但是我想注册在同一个 ref 下。 暂时没有办法。 附：ref — Vue.jsvm.$refs — Vue.js访问子组件实例或子元素 — Vue.jsDocument.querySelectorAll - MDNquerySelectorAll 方法相比 getElementsBy 系列方法有什么区别？- 知乎 如何评价 Vue 的 ref 语法糖提案？尤雨溪的回答 - 知乎","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"VueJS","slug":"VueJS","permalink":"https://yogwang.site/tags/VueJS/"}]},{"title":"JavaScript 中的 this 指向问题","slug":"JS-about-this","date":"2020-10-26T04:01:21.000Z","updated":"2026-01-05T05:39:58.472Z","comments":true,"path":"2020/JS-about-this/","permalink":"https://yogwang.site/2020/JS-about-this/","excerpt":"今天在群里看到大家在讨论一个问题，就是 this 的指向，并且牵扯到了 let，const 的变量提升，比如说在全局顶部声明的 let 变量能否挂载到 window 下之类的。还是老流程，先讨论第一个问题，然后再开始牵扯到后续的展开。 this 指向大概分为两种，普通函数内的 this 和 箭头函数内的 this，箭头函数内的 this 其实挺好理解的，主要是因为各种 call()、apply()、bind() 和 new 影响下的 this 指向问题。","text":"今天在群里看到大家在讨论一个问题，就是 this 的指向，并且牵扯到了 let，const 的变量提升，比如说在全局顶部声明的 let 变量能否挂载到 window 下之类的。还是老流程，先讨论第一个问题，然后再开始牵扯到后续的展开。 this 指向大概分为两种，普通函数内的 this 和 箭头函数内的 this，箭头函数内的 this 其实挺好理解的，主要是因为各种 call()、apply()、bind() 和 new 影响下的 this 指向问题。 先来最简单的demo来说明 this 的最终指向的是那个调用它的对象 function t1()&#123; console.log(this); &#125; t1() // logs Window // 其实等同于 window.t1() var t2 = &#123; name:&#x27;t2&#x27;, fn:function()&#123; console.log(this); &#125; &#125; t2.fn(); // logs &#123;name: &quot;t2&quot;, fn: ƒ&#125; var t3 = &#123; a:1, b:&#123; fn:function()&#123; console.log(this.a) &#125; &#125; &#125; t3.b.fn() // logs undefined // t3.b中并没有属性a 这样就很好理解了，就是从谁的身上点出来的方法，这个 this 就是在指向谁的。如果没有默认就是 window（严格模式下稍有不同是 undefined），例如 t1() # 构造函数中的 this# Call, Apply, Bind 影响下的 this# Class 下的 this 未完成突然发现之前还有一个坑没有填，我先去把旧坑填完。 附函数的扩展 - ECMAScript 6入门彻底理解js中this的指向，不必硬背 - 追梦子那些年我们一起过的JS闭包，作用域，this，让我们一起划上完美的句号 - 追梦子如何理解 Call, Apply, Bind?","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"},{"name":"未完成","slug":"未完成","permalink":"https://yogwang.site/tags/%E6%9C%AA%E5%AE%8C%E6%88%90/"}]},{"title":"JS 中的各种 for 循环","slug":"JS-for","date":"2020-07-23T16:03:04.000Z","updated":"2026-01-05T05:39:58.473Z","comments":true,"path":"2020/JS-for/","permalink":"https://yogwang.site/2020/JS-for/","excerpt":"真是一坑未填又开一坑….现在阶段，for循环有4种，我们先把所有的 for 循环列出，一个一个的聊。 从MDN上边，找到了 四种 for 循环，分别是：for、for...in、for...of 和 for await...of","text":"真是一坑未填又开一坑….现在阶段，for循环有4种，我们先把所有的 for 循环列出，一个一个的聊。 从MDN上边，找到了 四种 for 循环，分别是：for、for...in、for...of 和 for await...of 1. for 原始 for 循环语句经典的 for 循环，所有新手一开始都会写的 demo 基本都会用到的 for 循环吧，我就不多讲了，上一个学生时代（伪）的*号金字塔吧。 const max = 5 for (let n = 1; n &lt; max; n++) &#123; let str = &#x27;&#x27; for (let i = 1; i &lt; max - n; i++) &#123; str += &#x27; &#x27; &#125; for (let j = 1; j &lt; 2 * n; j++) &#123; str += &#x27;*&#x27; &#125; console.log(str); &#125; // * // *** // ***** // ******* 2. for...in 为遍历对象属性而构建的 for 循环 for...in 语句以任意顺序遍历一个对象的除Symbol以外的可枚举属性。啥？你问我 Symbol 是啥？看这里 上 demo 配合着来看，先是对象 const obj = &#123; a: 1, b: 2, c: 3 &#125;; for (let prop in obj) &#123; console.log(prop); &#125; // a // b // c 再看一下用它来遍历数组 const arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]; for (let prop in arr) &#123; console.log(prop); &#125; // 0 // 1 // 2 可以看到，它遍历对象的属性名，MDN最后有一句： “它最常用的地方应该是用于调试，可以更方便的去检查对象属性（通过输出到控制台或其他方式）” ？？？？？ ，可我实一般调试时都是直接把整个对象都打印出来啊 所以 for...in 是为遍历对象属性而构建的 for 循环，虽然数组可以用，但是并没有Dio用….并且它会枚举所有属性，包含了被迭代的对象的原型，实际工作开发，这些对象很可能是不需要出现的属性，比如VueJS的 __ob_。 虽然可以配合使用 hasOwnProperty() 来处理，但是太蛮烦了，最好用的场景可能就是这个同时输出键名和键值的场景 const triangle = &#123;a: 1, b: 2, c: 3&#125;; function ColoredTriangle() &#123; this.color = &#x27;red&#x27;; &#125; ColoredTriangle.prototype = triangle; const obj = new ColoredTriangle(); for (let prop in obj) &#123; if (obj.hasOwnProperty(prop)) &#123; console.log(`obj.$&#123;prop&#125; = $&#123;obj[prop]&#125;`); &#125; &#125; // obj.color = red 3. for...of 遍历可迭代对象的可枚举属性for...of 可迭代的对象就多了（包括 Array，Map，Set，String，TypedArray，arguments 对象，DOM 集合等等，但是 不包括Object 哦），在这些 可迭代 对象上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句，具体可以看MDN的文档。for…of - MDN 它与 for...in 的区别是什么？ 主要区别在于它们的迭代方式： for...in 语句以任意顺序迭代对象的可枚举属性。 for...of 语句遍历可迭代对象定义要迭代的数据。 配合着demo来看吧。 // 为对象和数组原型增加方法 Object.prototype.objCustom = function() &#123;&#125;; Array.prototype.arrCustom = function() &#123;&#125;; // 声明数组并赋值 let iterable = [3, 5, 7]; iterable.foo = &#x27;hello&#x27;; // for...in 遍历输出属性名 for (let i in iterable) &#123; console.log(i); // 0, 1, 2, &quot;foo&quot;, &quot;arrCustom&quot;, &quot;objCustom&quot; &#125; // for...in 判断是否拥有属性并输出属性名 for (let i in iterable) &#123; if (iterable.hasOwnProperty(i)) &#123; console.log(i); // 0, 1, 2, &quot;foo&quot; &#125; &#125; // arrCustom和objCustom不会被输出，因为它们是继承的，并非自身的属性 // for..of 输出可迭代数据 for (let i of iterable) &#123; console.log(i); // 3, 5, 7 // 仅仅输出可迭代对象数组定义的元素值 &#125; 每个对象将继承 objCustom 属性，并且作为 Array 的每个对象将继承 arrCustom 属性，因为将这些属性添加到 Object.prototype 和 Array.prototype。由于继承和原型链，对象 iterable 继承属性 objCustom 和 arrCustom。所以 for...in 会遍历出所有属性名，包括数组元素的下标和继承下来的属性，而 for...of 只遍历了可迭代的数组元素值。 4. for await...ofES9的内容？？？我先看看文档： for await...of 语句创建一个循环，该循环遍历异步可迭代对象以及同步可迭代对象，包括: 内置的 String, Array，类似数组对象 (例如 arguments 或 NodeList)，TypedArray, Map, Set 和用户定义的异步&#x2F;同步迭代器。它使用对象的每个不同属性的值调用要执行的语句来调用自定义迭代钩子。 然后 类似于 await 运算符一样，该语句只能在一个 async function 内部使用。 简单的用 generator 举一个例子： async function* asyncGenerator () &#123; var i = 0; while (i &lt; 3) &#123; yield i++; &#125; &#125; (async function () &#123; for await (num of asyncGenerator()) &#123; console.log(num); &#125; &#125;)() 但是没有想到有食用的业务场景，可能循环的异步调用？类似依次调用函数读取文件列表进行处理？？？等以后遇到了合适场景再展开了解吧。 以上 附 for - MDN for…in - MDN for…of - MDN for await…of - MDN 看，for..in和for..of在那里吵架！","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"},{"name":"挖坑","slug":"挖坑","permalink":"https://yogwang.site/tags/%E6%8C%96%E5%9D%91/"}]},{"title":"Js数组中的 find/findIndex/some 以及 every","slug":"JS-array-find-some-every","date":"2020-07-22T07:37:33.000Z","updated":"2026-01-05T05:39:58.472Z","comments":true,"path":"2020/JS-array-find-some-every/","permalink":"https://yogwang.site/2020/JS-array-find-some-every/","excerpt":"今天写 Demo 的时候突然在想 find() 与 some() 的区别是什么？ 都是为了找到数组中的内容啊？他们的区别在哪里呢 其实我在打这行字的时候就突然想起来区别是什么了😂，所以我把标题改了 相对于 some() 方法， 我知道 find() 方法会更加早一些，不知道为何，🤔明明 find() 方法才是更加新的特性( 也许因为子龙提到的因为jQuery？) 所以今天我们来聊一聊 find&#x2F;findIndex&#x2F;some 以及 every 这4个使用起来感觉差不多的方法。","text":"今天写 Demo 的时候突然在想 find() 与 some() 的区别是什么？ 都是为了找到数组中的内容啊？他们的区别在哪里呢 其实我在打这行字的时候就突然想起来区别是什么了😂，所以我把标题改了 相对于 some() 方法， 我知道 find() 方法会更加早一些，不知道为何，🤔明明 find() 方法才是更加新的特性( 也许因为子龙提到的因为jQuery？) 所以今天我们来聊一聊 find&#x2F;findIndex&#x2F;some 以及 every 这4个使用起来感觉差不多的方法。先来说 find() 方法： find 方法会寻找数组中满足条件的第一个元素的值(返回的是整个元素的内容，并不是元素的引用)，如果没有则返回 undefined。 接着是 some() 方法： some 方法会判断数组中是否存在满足条件的元素，如果有则返回 true, 如果没有则返回 false。 这两个方法都会在遇到第一个满足条件的元素时返回并退出方法。 我个人之前一直使用 find 方法来寻找数组中是否有满足条件的元素，很多时候只是判断是否存在，并没有使用返回的元素值。也许 find 更加语义话点吧，后来知道了 findIndex 之后开始使用 findIndex。直到有天群里在谈论 filter 时，有人提了一嘴 some() 我才知道这个 ECMA 5.1 的方法 匹配全体 every() 方法 every 方法判断一个数组内的所有元素是否都满足指定条件，返回一个布尔值。 这个方法和 some 方法类似，用到的场景并不多，它会匹配全体，全体都通过时才会返回 true，如果过程中遇到一个元素没有通过条件，则将会立即退出并返回 false 最后是 findIndex() 方法 findIndex 方法返回数组中满足条件的第一个元素的下标，如果没有满足条件的元素则返回 -1。 这个简直就是 find 方法的简化版，只是返回值从匹配的元素换成元素下标，我就不说了。。 所以 在用于判断是否存在指定条件的元素时，使用 some(); 如果需要全体元素都需要满足指定条件时使用 every(); 需要寻找满足指定条件并返回元素值时使用 find(); 需要寻找满足指定条件的元素下标的时使用 findIndex(). 当然，如果你的数组子元素不是对象或者数组时可以使用 includes 和 indexOf 来判断是否存在那个元素和查找这个元素的下标，具体可以看下方附录连接。 附： Array.prototype.every() - MDN Array.prototype.find() - MDN Array.prototype.findIndex() - MDN Array.prototype.some() - MDN 数组实例的 find() 和 findIndex() - ECMAScript 6 入门 Array.prototype.indexOf() - MDN Array.prototype.includes() - MDN","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"}]},{"title":"ES6 中 Array 的 fill() 方法","slug":"JS-array-fill","date":"2020-07-20T01:05:15.000Z","updated":"2026-01-05T05:39:58.472Z","comments":true,"path":"2020/JS-array-fill/","permalink":"https://yogwang.site/2020/JS-array-fill/","excerpt":"fill 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。 最近遇到的一个坑，其实也不算是坑，只是自己没有了解清楚就在用了。 以前在业务中声明数组变量时我都是使用的 var arr = [] 来声明，这次兴起用了一次 var arr = new Array(8).fill([]) 声明并且填充内容时居然翻车了….","text":"fill 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。 最近遇到的一个坑，其实也不算是坑，只是自己没有了解清楚就在用了。 以前在业务中声明数组变量时我都是使用的 var arr = [] 来声明，这次兴起用了一次 var arr = new Array(8).fill([]) 声明并且填充内容时居然翻车了…. 先来看下使用方法 arr.fill(value[, start[, end]]) fill 方法接受三个参数 value, start 以及 end，并且返回一个修改后的数组; valut 用来填充数组元素的值, 如果不写则填充 undefined start 和 end 参数是可选的, 分别是 起始索引 和 终止索引 ，默认值分别为 0 和 this 对象的 length 属性值。 fill 方法是个可变方法, 它会改变调用它的 this 对象本身, 然后返回它, 而并不是返回一个副本 🌰🌰🌰 时间[1, 2, 3].fill(4); // [4, 4, 4] [1, 2, 3].fill(4, 1); // [1, 4, 4] [1, 2, 3].fill(4, 1, 2); // [1, 4, 3] [1, 2, 3].fill(4, 1, 1); // [1, 2, 3] [1, 2, 3].fill(4, 3); // [1, 2, 3] [1, 2, 3].fill(4, NaN, NaN); // [1, 2, 3] [1, 2, 3].fill(4, -1); // [1, 2, 4] [1, 2, 3].fill(4, -2, -1); // [1, 4, 3] [1, 2, 3].fill(4, -1, -2); // [1, 2, 3] Array(3).fill(4); // [4, 4, 4] // 还有一个MDN上的奇怪操作 [].fill.call(&#123; length: 3 &#125;, 4); // &#123;0: 4, 1: 4, 2: 4, length: 3&#125; 接下来就要提到我遇到坑了，当使用fill方法填充一个对象时，比如说: var arr = new Array(8).fill(&#123; a: 1 &#125;) // [&#123;a: 1&#125;, &#123;a: 1&#125;, &#123;a: 1&#125;, &#123;a: 1&#125;, &#123;a: 1&#125;, &#123;a: 1&#125;, &#123;a: 1&#125;, &#123;a: 1&#125;] 然后我们修改其中任意子项的属性 a，然后输出他们 arr[0].a = 2 console.log(arr) // [&#123;a: 2&#125;, &#123;a: 2&#125;, &#123;a: 2&#125;, &#123;a: 2&#125;, &#123;a: 2&#125;, &#123;a: 2&#125;, &#123;a: 2&#125;, &#123;a: 2&#125;] 可以看到他们全体都被修改了，对的，当一个对象（数组也一样）被传递给 fill 方法的时候, 填充数组的是这个对象的引用。 所以这次我自己 Debug 了3个小时都没发现的 问题 就是因为这！！ 附： Array.prototype.fill() - MDN","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"},{"name":"ECMAScript 6","slug":"ECMAScript-6","permalink":"https://yogwang.site/tags/ECMAScript-6/"}]},{"title":"NVM for Windows 的安装和使用","slug":"NVW4W-install-use","date":"2020-07-15T08:40:22.000Z","updated":"2026-01-05T05:39:58.477Z","comments":true,"path":"2020/NVW4W-install-use/","permalink":"https://yogwang.site/2020/NVW4W-install-use/","excerpt":"今天后端同学那边遇到了一个问题，那边跑一个react项目，npm install 直接报错，但是在我这边并没有报异常，后来发现他的 NPM 版本为 3.10.10， 我猜测是 NPM 版本太低的缘故，就顺便看了下 Node 的版本，版本是 v6.10.0, 所以直接给他更新了 NodeJS，正当我以为问题解决了的时候，后端同学又和我说，现在的项目可以跑起来了，但是之前的项目他跑不起来了。 emmmm…..我又过去看了下报错信息，这会问题是 Node 给我更新掉了，版本太高项目跑不起来了….所以，有了这篇关于 Node Version Manager (NVM) for Windows 的文章","text":"今天后端同学那边遇到了一个问题，那边跑一个react项目，npm install 直接报错，但是在我这边并没有报异常，后来发现他的 NPM 版本为 3.10.10， 我猜测是 NPM 版本太低的缘故，就顺便看了下 Node 的版本，版本是 v6.10.0, 所以直接给他更新了 NodeJS，正当我以为问题解决了的时候，后端同学又和我说，现在的项目可以跑起来了，但是之前的项目他跑不起来了。 emmmm…..我又过去看了下报错信息，这会问题是 Node 给我更新掉了，版本太高项目跑不起来了….所以，有了这篇关于 Node Version Manager (NVM) for Windows 的文章 安装NVM 安装很简单，直接去Github上边找 nvm-windows 的 releases，直接下载最新那版的zip就可以了。有免安装和安装版可以选择(我选择了安装版)。 安装过程中选择一下 NVM 安装目录以及之后 NodeJS 的管理目录。 之前有安装 NodeJS 记得指定到之前安装的目录下，就可以使用 NVM 管理之前安装的Node版本了。如果是NodeJS使用的是绿色版的话，之后可能需要使用NVM 重新下载安装。 然后就等待安装完成就可以了。完成之后在终端输入 nvm 检查版本确认是否安装成功(当前版本1.1.7) 常用命令 查看 NVM 下已经安装的 Node 版本号显示当前已安装 Node 版本列表，缩写为 ls， 当前使用的版本会在前标识 * ，在末尾加上 available 显示可供下载的所有版本列表 PS C:\\Users\\yog\\Desktop&gt; nvm list // 简写为 nvm ls 14.5.0 * 12.12.0 (Currently using 64-bit executable) 切换到指定的 Node 版本 nvm use [version] [arch] 一般先使用 nvm ls 输出已经安装的版本，然后再根据可选项切换版本。 PS C:\\Users\\yog\\Desktop&gt; nvm use 12.12.0 // 具体版本号 Now using node v12.12.0 (64-bit) 设置 [arch] 可指定 32&#x2F;64位结构。 如果不填版本号只填写 32( nvm use 32 )将继续使用当前Node版本，只切换到32位模式。 安装指定版本的Node nvm install &lt;version&gt; [arch] &lt;version&gt; 可以是 具体版本号 也可以是 latest 来安装最新的 稳定 版本，[arch] 指定安装 32位 还是 64位 版本（默认为系统结构）， 设置为 all 以同时安装32和64位版本。 PS C:\\Users\\yog\\Desktop&gt; nvm install 6.10.0 Downloading node.js version 6.10.0 (64-bit)... Complete Downloading npm version 3.10.10... Complete Installing npm v3.10.10... Installation complete. If you want to use this version, type nvm use 6.10.0 也可以在末尾添加 --insecure 可以绕过远程下载服务器的SSL验证。 卸载指定Node版本 nvm uninstall &lt;version&gt; PS C:\\Users\\yog\\Desktop&gt; nvm uninstall 6.10.0 Uninstalling node v6.10.0... done 查看所有可安装的Node版本 PS C:\\Users\\yog\\Desktop&gt; nvm ls available | CURRENT | LTS | OLD STABLE | OLD UNSTABLE | |--------------|--------------|--------------|--------------| | 14.7.0 | 12.18.3 | 0.12.18 | 0.11.16 | | 14.6.0 | 12.18.2 | 0.12.17 | 0.11.15 | | 14.5.0 | 12.18.1 | 0.12.16 | 0.11.14 | | 14.4.0 | 12.18.0 | 0.12.15 | 0.11.13 | | 14.3.0 | 12.17.0 | 0.12.14 | 0.11.12 | | 14.2.0 | 12.16.3 | 0.12.13 | 0.11.11 | | 14.1.0 | 12.16.2 | 0.12.12 | 0.11.10 | | 14.0.0 | 12.16.1 | 0.12.11 | 0.11.9 | | 13.14.0 | 12.16.0 | 0.12.10 | 0.11.8 | | 13.13.0 | 12.15.0 | 0.12.9 | 0.11.7 | | 13.12.0 | 12.14.1 | 0.12.8 | 0.11.6 | | 13.11.0 | 12.14.0 | 0.12.7 | 0.11.5 | | 13.10.1 | 12.13.1 | 0.12.6 | 0.11.4 | | 13.10.0 | 12.13.0 | 0.12.5 | 0.11.3 | | 13.9.0 | 10.22.0 | 0.12.4 | 0.11.2 | | 13.8.0 | 10.21.0 | 0.12.3 | 0.11.1 | | 13.7.0 | 10.20.1 | 0.12.2 | 0.11.0 | | 13.6.0 | 10.20.0 | 0.12.1 | 0.9.12 | | 13.5.0 | 10.19.0 | 0.12.0 | 0.9.11 | | 13.4.0 | 10.18.1 | 0.10.48 | 0.9.10 | This is a partial list. For a complete list, visit https://nodejs.org/download/release 其它命令 nvm arch 查看 Node 当前运行32位还是64位模式。 nvm on 开启 NVM 版本管理. nvm off 关闭 NVM 版本管理. nvm proxy [url] 设置用于下载的代理。将 [url] 留空查看当前设置的代理，将 [url] 设置为 “none” 来删除代理。 nvm node_mirror [url] 设置节点镜像。默认为 https://nodejs.org/dist/，将 [url] 留空 以使用 默认url nvm npm_mirror [url] 设置 NPM 镜像。默认为 https://github.com/npm/cli/archive/，将 [url] 留空 保留为 默认url。 nvm root [path] 设置 NVM 不同版本的 Node.js 的存储目录，如果 [path] 留空，将显示当前设置的存储目录。 nvm version 显示当前 NVM 运行版本。 缩写 v。 遇到问题# 安装完成之后使用 nvm ls 没有看到之前已经安装的NodeJS版本我在使用的过程中没有遇到这个问题，但是同事在安装之后遇到了，这个问题。有可能是因为安装时指定的Node目录错误了，可以卸载之前安装的 NodeJS，然后使用 nvm install &lt;version&gt; 重新安装对应版本的 NodeJS # 切换版本之后全局依赖丢失今天小伙伴问题，切换了新版本之后他以前安装的全局依赖都没了，又要重新安装，然后切换到老版本之后和新安装的全局依赖版本还不一样，问我怎么解决的。 这个问题，是因为切换了版本之后其实是切换软链接路径，然后你又重新配置过依赖项安装位置了，比如指向到了NodsJs目录下，所以现在指向到的是新的NodeJs下的目录，肯定目录下就没有老的全局依赖了。所以重新切换到外部就好了，比如说我是在 NVM 目录下新建一个 dependencies 文件夹，然后重新 npm set prefix 到这个目录就好了，和以前切换npm安装路径一样，记得也同时修改一下缓存位置。对了，最后记得修改系统的环境变量，把新的全局依赖路径添加到系统变量的 path 中，只不过我是单独配置了一个 prefix 项，所以就不展示了。 # 使用 nvm use x.y.z 遇到报错 exit status 1: Access is denied. 的情况。 Permissions (Exit 1, Exit 5, Access Denied, Exit 145)If you do not run the nvm.exe file with appropriate permissions, you may receive an exit 1, exit 5, or Access Denied error. These come straight from Windows, indicating the user account does not have permissions to do what you’re trying to do.The most common permission issue has to do with creating symlinks. NVM4W uses symlinks (mklink is used in nvm use) to redirect the Node installation path to the appropriate installation. Windows requires elevated administrative privileges to create symlinks, but developer mode eases these restrictions.It’s best to enable developer mode on Windows 10, which will grant your user account slightly elevated permissions. See how to Enable Your Device for Development 因为 NVM 切换版本实质上是在创建 symlinks，而创建 symlinks 需要系统管理员权限，所以会被拒绝。可以通过以下三种方式规避： 开启开发人员模式： [Windows设置] - [更新和安全] - [开发者选项] - [开启开发人员模式]； 使用管理员权限打开终端； 降低 NVM 版本到 v1.1.17 来绕过这个问题； （操作来源：Access is denied · Issue #700 · coreybutler&#x2F;nvm-windows) 不过第三种方式这个我没测试，你们可以尝试一下，我猜测是不行的，因为会弹 UAC 确认，主要是用公司配发的电脑尝试的话太麻烦了（懒，也怕麻烦 IT Admin）。如果有人尝试了的话，希望可以 反馈结果 给我，那将十分感谢！🙇‍ * 如果你是使用的公司配发的电脑 （corporate-owned computer），并且无法获取到系统管理员权限，可以尝试切换到 NVS 来管理 NodeJS 版本，以此来规避权限问题。 具体可以查看我的这篇文章 切换到NVS(NodeVersionSwitcher)来管理NodeJS版本 了解切换到 NVS 的迁移成本。 附 nvm-windows - Github nvm use exit status 1: Access is denied - Stack Overflow Common Issues · coreybutler&#x2F;nvm-windows Wiki","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://yogwang.site/tags/Node-js/"},{"name":"NVM","slug":"NVM","permalink":"https://yogwang.site/tags/NVM/"}]},{"title":"简单实现滑动滑块完成验证","slug":"JS-slider-captcha","date":"2020-07-08T01:40:50.000Z","updated":"2026-01-05T05:39:58.476Z","comments":true,"path":"2020/JS-slider-captcha/","permalink":"https://yogwang.site/2020/JS-slider-captcha/","excerpt":"偶尔会遇到PM提的需求，要加入滑动验证，但是不想使用付费的第三方验证，想就在前端实现滑块验证即可(zuò zuò yàng zi)，这一段时间遇到两次要求加滑动验证了，就整理一下构思和部分伪代码逻辑。 本例只是一个面子工程，不会牵扯到复杂的人机验证部分，所以如果需要考虑人机校验，还是推荐你选择靠谱的第三方行为验证，不要自己瞎折腾。","text":"偶尔会遇到PM提的需求，要加入滑动验证，但是不想使用付费的第三方验证，想就在前端实现滑块验证即可(zuò zuò yàng zi)，这一段时间遇到两次要求加滑动验证了，就整理一下构思和部分伪代码逻辑。 本例只是一个面子工程，不会牵扯到复杂的人机验证部分，所以如果需要考虑人机校验，还是推荐你选择靠谱的第三方行为验证，不要自己瞎折腾。 主要使用的是 mousedown, mouseup 和 mousemove 这三个事件的事件绑定。如果考虑移动端需要使用 touchstart,touchend 和 touchmove 这三个事件，需要根据设备选择绑定的事件。目前的项目只考虑桌面设备所以直接就省去判断设备这个步骤。 先简单预览一下： 布局及样式好，首先拆分元素，整体可以拆分为两个部分：1. 滑动验证的容器 和 2. 滑块两个部分 容器部分可以继续拆分为 i. 外部容器 和 ii. 内部的文字 两块。 所以布局方面可以这样来写 &lt;div class=&quot;slider-captcha&quot;&gt; &lt;div class=&quot;slider&quot;&gt; &lt;i class=&quot;double-right&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;msg&quot;&gt;请按住滑块拖动到最右边，获取验证码&lt;/div&gt; &lt;/div&gt; 先简单实现样式 .slider-captcha&#123; width: 400px; height: 50px; border: 1px solid #ECEBED; border-radius: 5px; position: relative; &#125; .slider&#123; width: 60px; height: @height; line-height: @height; text-align: center; font-size: 20px; color: white; background: #55CEA7; border-radius: 5px; position: absolute; left: 0; /* 因为滑块是第一个子元素所以 top 可以省略不写 */ z-index: 2; cursor: pointer; box-sizing: border-box; &#125; .msg&#123; height: @height; line-height: @height; text-align: center; font-size: 13px; color: #A1ACC6; pointer-events: none; user-select: none; box-sizing: border-box; &#125; 完成预览： 接下来我会使用到 VueJS，希望你有使用 Vue。如果你没有使用过 Vue，直接看 methods 里边的函数也可以 先把 HTML 模板改成 Vue 模板 &lt;template&gt; &lt;div class=&quot;slider-captcha&quot; ref=&quot;container&quot;&gt; &lt;div :class=&quot;[&#x27;slider&#x27;, success&amp;&amp;&#x27;success&#x27;]&quot; ref=&quot;slider&quot; :style=&quot;&#123;left: `$&#123;vX&#125;px`&#125;&quot;&gt; &lt;a-icon type=&quot;double-right&quot; v-if=&quot;!success&quot; /&gt; &lt;/div&gt; &lt;div :class=&quot;[&#x27;msg&#x27;, success&amp;&amp;&#x27;success&#x27;]&quot;&gt; &#123;&#123; msg &#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default &#123; name: &#x27;slider-captcha&#x27;, data() &#123; return &#123; vX: 0, maxX: 0, msg:&#x27;请按住滑块拖动到最右边，获取验证码&#x27;, success: false, moveing: false &#125; &#125; &#125; &lt;/script&gt; &lt;style lang=&quot;stylus&quot; scoped&gt; $green = #55CEA7 .slider-captcha width 100% height 50px border 1px solid #ECEBED border-radius 5px position relative .msg height 100% color #A1ACC6 display flex justify-content center align-items center transition color 1s ease pointer-events none user-select none box-sizing border-box &amp;.success color white background $green .slider width 60px height 100% font-size 20px color white text-align center background $green border-radius 5px display flex position absolute left 0 z-index 2 cursor pointer transition background 1s ease box-sizing border-box &amp;.success display none &lt;/style&gt; 简单滑动逻辑这个时候就要用到 mousedown 和 mousemove 两个事件的绑定， 最后才用到 mouseup 事件。 有点忙， 看啥时候有空再补完，还需要调整一下排版","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"},{"name":"挖坑","slug":"挖坑","permalink":"https://yogwang.site/tags/%E6%8C%96%E5%9D%91/"}]},{"title":"Caddy单域名部署Vue与Laravel项目","slug":"caddy-single-domain-vue-laravel-deployment","date":"2020-06-23T06:16:12.000Z","updated":"2026-01-05T05:39:58.481Z","comments":true,"path":"2020/caddy-single-domain-vue-laravel-deployment/","permalink":"https://yogwang.site/2020/caddy-single-domain-vue-laravel-deployment/","excerpt":"之前是想写一篇 Nginx 关于配置前后端项目公用一个域名笔记的，可是后来客户提供的是已经是由其它项目的服务器，他们是使用的 Caddy 作为 web 服务器，所以也就变成了这篇文章。 我对于服务器环境配置可以说是一无所知，勉勉强强完成这次的项目部署，各位将就看看…😖","text":"之前是想写一篇 Nginx 关于配置前后端项目公用一个域名笔记的，可是后来客户提供的是已经是由其它项目的服务器，他们是使用的 Caddy 作为 web 服务器，所以也就变成了这篇文章。 我对于服务器环境配置可以说是一无所知，勉勉强强完成这次的项目部署，各位将就看看…😖 使用两个二级域名一个顶级域名可以创建很多个二级域名，所以使用两个二级域名就很容易配置了，直接创建两个服务就可以，但是会跨域，因为是不同二级域名，后端单独做一下跨域允许就可以了。 # Vue https://www.example.com &#123; root /var/www/vue log /var/log/caddy/fe.log errors /var/log/caddy/fe.errors.log gzip rewrite &#123; to &#123;path&#125; / &#125; &#125; # Laravel https://api.example.com &#123; root /var/www/laravel/public log /var/log/caddy/bk.log errors /var/log/caddy/bk.errors.log gzip # PHP-FPM Configuration for Caddy fastcgi / /run/php/php7.2-fpm.sock php &#123; ext .php split .php index index.php &#125; rewrite &#123; to &#123;path&#125; &#123;path&#125;/ /index.php?&#123;query&#125; &#125; &#125; 使用同一个域名方法一：使用同一域名然后不同路径作为站点地址：我使用 https://www.example.com/ 作为 Vue 项目的地址；https://www.example.com/api 作为 laravel 项目的站点地址。配置如下 # Vue https://www.example.com &#123; root /var/www/vue log /var/log/caddy/fe.log errors /var/log/caddy/fe.errors.log gzip rewrite &#123; to &#123;path&#125; / &#125; &#125; # Laravel https://www.example.com/v/ &#123; root /var/www/laravel/public log /var/log/caddy/bk.log errors /var/log/caddy/bk.errors.log gzip # PHP-FPM Configuration for Caddy fastcgi / /run/php/php7.2-fpm.sock php &#123; ext .php split .php index index.php &#125; rewrite &#123; to &#123;path&#125; &#123;path&#125;/ /index.php?&#123;query&#125; &#125; &#125; 这个时候访问的地址，后台可以接收到，但是在路由表中找不到对应信息，因为 laravel 部分把 /api 作为路由前缀，修改一下就可以了，例如 https://www.example.com/v ，前端请求的时候使用 /v/api 这个地址 方法二：使用一个域名作为 Vue 项目站点地址，api接口使用重定向这个方法我还没有在Caddy尝试，Nginx倒是知道，等以后尝试看看 遇到问题 配置完之后访问 laravel 提示 [ file not found ]一般来说遇到这个问题的同时，可以在日志文件中查看到 Primary script unknown 的异常，这个问题是由于配置的目录没有写入权限，如果已经配置了写入权限，请确保在 同一用户&#x2F;组 下运行 Caddy 和php-fpm 如果 Vue 项目需要启用 History 路由模式怎么配置Caddy ?当使用 history 模式时，URL 就像正常的 url，例如 http://yoursite.com/user/id，不过这种模式还需要后台配置支持。因为应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问 http://oursite.com/user/id 就会返回 404，所以需要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面 rewrite &#123; regexp .* to &#123;path&#125; / &#125; 附 Caddy_v1 官方文档 Caddy 中文文档 Primary script unknown - Caddy FORUM HTML5 History 模式 - Vue Router","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"挖坑","slug":"挖坑","permalink":"https://yogwang.site/tags/%E6%8C%96%E5%9D%91/"},{"name":"Caddy","slug":"Caddy","permalink":"https://yogwang.site/tags/Caddy/"}]},{"title":"记录单独配置内网路由和外网路由的办法","slug":"intranet-and-extranet-routes","date":"2020-06-22T03:04:47.000Z","updated":"2026-01-05T05:39:58.494Z","comments":true,"path":"2020/intranet-and-extranet-routes/","permalink":"https://yogwang.site/2020/intranet-and-extranet-routes/","excerpt":"由于公司刚刚搬迁，本地服务器还没有连上网络，所以并不能在外网访问到公司的服务器，只能使用局域网访问到。所以想连接手机热点来连外网，并且通过插网线来访问内网，想实现同时访问外网和内网的效果。 单独连热点或者单独连内网都是可以的，但是同时就不行了，会默认使用本地连接也就是插的网线来访问网络，所以只能从一下选择其中一个： 可以访问外网，但是不能访问内部服务器； 不可以访问内网，但可以使用内网服务器。 然而每次都要切换网络来完成需求，我觉得有点蠢，肯定有更加优雅的方式来实现的需求。 所以就记一下这个办法。","text":"由于公司刚刚搬迁，本地服务器还没有连上网络，所以并不能在外网访问到公司的服务器，只能使用局域网访问到。所以想连接手机热点来连外网，并且通过插网线来访问内网，想实现同时访问外网和内网的效果。 单独连热点或者单独连内网都是可以的，但是同时就不行了，会默认使用本地连接也就是插的网线来访问网络，所以只能从一下选择其中一个： 可以访问外网，但是不能访问内部服务器； 不可以访问内网，但可以使用内网服务器。 然而每次都要切换网络来完成需求，我觉得有点蠢，肯定有更加优雅的方式来实现的需求。 所以就记一下这个办法。 我们 使用管理员权限 打开终端 CMD。在终端中输入 route print 我们获得以下信息： 可以看到路由表中有两个 0.0.0.0 的路由信息 并且跃点数也是一样的都是 35，这样会路由冲突，只能使用其中一个。 我们重新配置一下路由信息就可以了，这个时候我们把两个冲突的路由信息复制出来，如果你不嫌麻烦的话上下翻也可以，重新打开一个新的终端也行。 先把两个 0.0.0.0 路由删掉route delete 0.0.0.0 添加外网路由信息这里就需要用到之前复制出来的路由信息了，不过只要网关信息 route add 0.0.0.0 mask 0.0.0.0 192.168.200.1 添加内网路由信息这里也需要用到之前复制出来的路由信息，网关 以及 网络掩码（网络掩码这部分一般都是 255.255.255.0 如果不确定的话联系一下网管就可以了） route add 192.168.1.0 mask 255.255.255.0 192.168.1.1 重新查看路由信息，看到新的路由配置已经被加上了 不过中间我看到 192.168.1.0 出现了两次，并且配置信息是一样的，是不是我这边本来就有这个路由信息的，所以我又把后来添加的信息去掉了。 各位添加的时候注意检查一下原来的路由表里边是否已经有内网的路由信息了。 因为是临时网络没有通，所以我就不加永久路由，每天手动调整一下路由就行，如果你这边是固定的内网有网络限制的话，可以在 route 之后添加 -p 就可以实现永久路由了。 route -p add 192.168.1.0 mask 255.255.255.0 192.168.1.1 以上","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[]},{"title":"谈一谈 JavaScript 中的闭包","slug":"JS-closures","date":"2020-06-15T09:56:21.000Z","updated":"2026-01-05T05:39:58.473Z","comments":true,"path":"2020/JS-closures/","permalink":"https://yogwang.site/2020/JS-closures/","excerpt":"函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起构成闭包（closure）。也就是说，闭包可以让你从内部函数访问外部函数作用域。在 JavaScript 中，每当函数被创建，就会在函数生成时生成闭包。 先拿 MDN 上的一个简单的 🌰 来说： function init() &#123; var name = &quot;Mozilla&quot;; // name 是一个被 init 创建的局部变量 function displayName() &#123; // displayName() 是内部函数，一个闭包 alert(name); // 使用了父函数中声明的变量 &#125; displayName(); &#125; init(); init() 创建了一个局部变量 name 和一个名为 displayName() 的函数。displayName() 是定义在 init() 里的内部函数（仅在 init() 函数体内可用），它没有自己的局部变量，然而它可以访问到外部函数的变量，所以 displayName() 可以使用父函数 init() 中声明的变量 name 。","text":"函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起构成闭包（closure）。也就是说，闭包可以让你从内部函数访问外部函数作用域。在 JavaScript 中，每当函数被创建，就会在函数生成时生成闭包。 先拿 MDN 上的一个简单的 🌰 来说： function init() &#123; var name = &quot;Mozilla&quot;; // name 是一个被 init 创建的局部变量 function displayName() &#123; // displayName() 是内部函数，一个闭包 alert(name); // 使用了父函数中声明的变量 &#125; displayName(); &#125; init(); init() 创建了一个局部变量 name 和一个名为 displayName() 的函数。displayName() 是定义在 init() 里的内部函数（仅在 init() 函数体内可用），它没有自己的局部变量，然而它可以访问到外部函数的变量，所以 displayName() 可以使用父函数 init() 中声明的变量 name 。 这个就是最简单的一个闭包实现。 不过要了解闭包，就得先了解 JavaScript 变量的作用域，变量的作用域分为 全局变量 和 局部变量例如全局变量 var a=&#x27;test&#x27; function fn()&#123; console.log(a) &#125; fn() // test 全局变量可以在函数内使用，函数内部的变量就不可以在函数外部被调用了 function fn()&#123; var a = &#x27;test&#x27; &#125; console.log(a) // Uncaught ReferenceError: a is not defined 在函数内部可以使用在外部函数内声明的变量，例如文章开头提到的例子，并且每次函数被执行是在内存里都会开辟一个新的区块，所以每次一执行的函数并不是指向同一个内存地址。 但是有些时候我们需要在函数外部调用这个函数内的局部变量。 这就是Javascript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。 既然内部函数可以读取 外部函数 中的 局部变量，那么只要 内部函数 作为 返回值，我们不就可以在函数外部读取它的 内部变量 了吗！ 的确，大都数情况我们都是在 函数内部定义一个函数，并且把这个内部函数 return 出来，从而来达到目的。 🌰 例如这个例子 function makeAdder(x) &#123; return function(y) &#123; return x + y; &#125;; &#125; var add5 = makeAdder(5); var add10 = makeAdder(10); console.log(add5(2)); // 7 console.log(add10(2)); // 12 上方的例子就可以看到在把 内部函数 赋值给 外部变量 之后，可以继续在之前的运行结果之上进行加运算。 当然也可以修改被调用的外部函数变量，例如这个累加的例子：function makeAdder(x) &#123; var x = x return function(y) &#123; x += y return x; &#125;; &#125; var add5 = makeAdder(5); var add10 = makeAdder(10); console.log(add5(5)); // 10 console.log(add5(10)); // 20 console.log(add10(5)); // 15 console.log(add10(10)); // 25一句话形容闭包 由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。 所以，在本质上，闭包就是将 函数内部 和 函数外部 连接起来的一座桥梁。 闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。 ES6 普及之后真的很少有使用到闭包了，const 和 let 的出现方便了太多了。#### 最后给你们看一个 阮一峰 老师文章里边的例子，乍一看 nAdd() 我懵了半分钟。function f1()&#123; var n=999; nAdd=function()&#123;n+=1&#125; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 nAdd(); result(); // 1000遇到的疑问 闭包是否一定要被外部变量保存（保持被引用） 并不是只有被外部变量引用的子函数叫做闭包，没有内存地址没有被保持引用的函数也可以是闭包； 因此可以把闭包简单理解成”定义在一个函数内部的函数”。 引发问题：变量提升，到底会被提升到哪里？ 以前一直以为 变量提升 会把使用 var 声明的变量提升到全局环境下。但是这次再写demo的时候发现原来是提升当前函数的顶部，并不是到全局下的。 function a()&#123; function b()&#123; console.log(str) &#125; var str=&#x27;test text&#x27; &#125; 在 变量提升 下可以这样理解 function a()&#123; var str function b()&#123; console.log(str) &#125; str=&#x27;test text&#x27; &#125; 附 闭包 - MDN 学习闭包 - 阮一峰 关于let声明的变量在window里无法获取到的问题","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"}]},{"title":"DigitalOcean向已经创建的Droplets实例添加SSH_key","slug":"digitalocean-created-droplets-add-ssh-key","date":"2020-06-13T17:23:22.000Z","updated":"2026-01-05T05:39:58.483Z","comments":true,"path":"2020/digitalocean-created-droplets-add-ssh-key/","permalink":"https://yogwang.site/2020/digitalocean-created-droplets-add-ssh-key/","excerpt":"几近一周没有好好写过代码了，就准备远程配置一下客户服务器的环境。 这次客户邀请我加入了他们 DigitalOcean 的 Team 中，但是他们不想提供 Droplet 实例 Root 密码， 看了一下控制台大概找到了一个添加 SSH_Key 登陆的地方，所以使用了 PuTTYGen 创建了一对 Key，但是添加之后使用 SSH 连接时提示我: 远程服务器拒绝此密钥，让我重新输入Root账户的密码。 大概找了一下国内的相关问题并没有找到解决的方法，Google 出来也差不多，基本都是添加 Key 之后，需要创建新的实例才可以使用新添加的 Key。那我需要对 已经创建了的 Droplet 实例 添加 Key 怎么办呢？ 相信大家在搜索该问题时已经添加好了自己的 SSH Key，具体添加创建 key 的过程我就不详述了，大家在官方 文档 中查找即可。","text":"几近一周没有好好写过代码了，就准备远程配置一下客户服务器的环境。 这次客户邀请我加入了他们 DigitalOcean 的 Team 中，但是他们不想提供 Droplet 实例 Root 密码， 看了一下控制台大概找到了一个添加 SSH_Key 登陆的地方，所以使用了 PuTTYGen 创建了一对 Key，但是添加之后使用 SSH 连接时提示我: 远程服务器拒绝此密钥，让我重新输入Root账户的密码。 大概找了一下国内的相关问题并没有找到解决的方法，Google 出来也差不多，基本都是添加 Key 之后，需要创建新的实例才可以使用新添加的 Key。那我需要对 已经创建了的 Droplet 实例 添加 Key 怎么办呢？ 相信大家在搜索该问题时已经添加好了自己的 SSH Key，具体添加创建 key 的过程我就不详述了，大家在官方 文档 中查找即可。 也可以在文末 附 中直接点击链接查看详细文档。 那么我就直接开始描述我是如何对已经创建的实例使用新增加的 Key。方法应该并不只有这一种，如果有其它更好的方式可以留言给我。 1.打开网页终端这步应该不用说了吧，打开终端之后切换到 ~/.ssh 目录下，查看一下目录下文件 root@test:/# cd ~/.ssh root@test:~/.ssh# ls authorized_keys id_rsa id_rsa.pub know_hosts 可以看到有一个名为 authorized_keys 的文件，这个我不知道是不是本来就有，我这边因为客户已经关联过一个 key 了所以是有这个文件。然后你使用 vi 或者 nano 打开这个 authorized_keys 文件。 2. 添加你的公钥到文件中我希望你没有把之前创建Key的公钥给丢了，不过找不到了也没有关系，回到 DigitalOcean 的控制台在 Account -&gt; Settings -&gt; Security -&gt; SSH keys 中找到你添加的 Key 然后点击编辑就可以看到你添加的公钥了。 把公钥复制一下，粘贴进去保存就可以了。 在粘贴的过程中遇到了粘贴进来的公钥出现转码的情况:这是因为复制的密钥太长了，控制的一下每次粘贴内容长度，分段粘贴过来就好了。 然后就可以使用 SSH 远程连接到服务器上了（具体连接步骤查看下方 附 中查看详细文档）。 以上。 附参考资源链接 使用PuTTY创建Key - Create Keys with PuTTY 使用OpenSSH创建Key - Create Keys with OpenSSH 添加Key到DO账户 - Add Keys to a DO Account 使用SSH连接到服务器 - Connect with SSH 相关类似问题 How do I add a second SSH key to droplet? Additional SSH Key not working","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Server","slug":"Server","permalink":"https://yogwang.site/tags/Server/"},{"name":"DigitalOcean","slug":"DigitalOcean","permalink":"https://yogwang.site/tags/DigitalOcean/"}]},{"title":"Jeecg-boot 开发挖坑日记11 查询过滤器整理","slug":"jeecg-boot-devDiary11","date":"2020-06-02T06:31:26.000Z","updated":"2026-01-05T05:39:58.501Z","comments":true,"path":"2020/jeecg-boot-devDiary11/","permalink":"https://yogwang.site/2020/jeecg-boot-devDiary11/","excerpt":"如果不配置默认查询条件是全匹配，想实现模糊查询需求在查询值的前后加: * Jeecg-boot支持不编码通过配置实现 模糊查询、 匹配查询、 范围查询、 不匹配查询 等规则，但是页面查询字段，需跟后台 Controller 中 Page 的字段对应一致，就可以不需写后台代码自动生成查询条件SQL。 例如：想实现模糊查询需求在查询值的前后加: *","text":"如果不配置默认查询条件是全匹配，想实现模糊查询需求在查询值的前后加: * Jeecg-boot支持不编码通过配置实现 模糊查询、 匹配查询、 范围查询、 不匹配查询 等规则，但是页面查询字段，需跟后台 Controller 中 Page 的字段对应一致，就可以不需写后台代码自动生成查询条件SQL。 例如：想实现模糊查询需求在查询值的前后加: * 查询规则1、全匹配查询：查询数据没有特殊格式，默认为全匹配查询 2、模糊查询：查询数据格式需加星号：{ * } 后模糊匹配： 张* 前模糊匹配： *张 全模糊匹配： *张* 更高级匹配： *张*三* 3、包含查询：查询数据格式采用逗号分隔：{ , } 例如：张三,李四 (含义：In(&#39;张三&#39;,&#39;李四&#39;)) 4、不匹配查询：查询数据格式需要加叹号前缀：{ ! }例如：!张三 （含义：不等于’张三’） 特殊说明： 查询不为Null的语法：!null （大小写没关系）; 查询不为空字符串的方法：! （只有一个叹号）; 5、范围查询支持数字，时间的范围查询，针对范围查询页面会生成两个查询控件 如果是单一匹配方式，则页面查询控件的 name， 跟实体字段命名一样 如果是范围匹配方式，则页面查询控件需要变成两个分别名 &#123;*&#125;_begin，&#123;*&#125;_end &#123;*&#125;_begin 表示查询范围开始值 &#123;*&#125;_end 表示查询范围结束值 举例： 字段名称 orderDate 查询开始时间 : orderDate_begin 查询结束时间 : orderDate_end 注意部分 数值类型不支持此种 取非查询 ,可以将数值字段定义为字符串类型的在查询； 数字类型字段多值查询，需要将字段加上后缀 _MultiString，其他规则同理； 因为后端的实体字段也需要增加后缀，例如：实体类中为： tableType，页面接受参数字段就是 tableType_MultiString 高级值规则 小于查询：查询内容值规则：”lt+ 空格 + 内容”; 🌰：输入值：lt 100 小于等于查询： 查询内容值规则：”le+ 空格+ 内容”; 🌰：输入值：le 100 大于查询：查询内容值规则：”gt+ 空格+ 内容”; 🌰：输入值：gt 100 大于等于查询： 查询内容值规则：”ge+ 空格+ 内容”; 🌰：输入值：ge 100 高级规则暂时发现不能在 integer 类型中使用，加上 _MultiString 虽然不会报错了，但是返回的数据错误。 后端小哥和我说虽然你这边不报错并且又返回值，但是他那边报错了。 自定义排序额外传入两个字段即可： column: 排序依据字段 order: 排序方式 [asc|desc] (默认asc) 文章所使用后端框架版本 v2.2.0 (发布日期：2020-05-06）不知道后续开发团队会不会更新说明文档。 附 查询过滤器用法 · Jeecg-boot 开发文档 Online报表排序 · Jeecg-boot 开发文档 因为查询过滤器已经重构多次，版本最好选择 2.2.x 以上，1.x 版本只有全匹配&#x2F;模糊查询&#x2F;包含查询&#x2F;不匹配查询。","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"挖坑","slug":"挖坑","permalink":"https://yogwang.site/tags/%E6%8C%96%E5%9D%91/"},{"name":"Jeecg-boot","slug":"Jeecg-boot","permalink":"https://yogwang.site/tags/Jeecg-boot/"}]},{"title":"关于 ES6 Class 继承中 Constructor 的整理","slug":"JS-class-constructor","date":"2020-05-26T03:14:27.000Z","updated":"2026-01-05T05:39:58.473Z","comments":true,"path":"2020/JS-class-constructor/","permalink":"https://yogwang.site/2020/JS-class-constructor/","excerpt":"今天在和小伙伴聊天时, 发现对于 ES6 中的 Class 继承的理解我其实还是只是一个模棱两可的状态, 其实也不只是 constructor 有问题其它的部分其实也有问题, 这次先写类的继承之后再看有没有其它没理解的地方 整篇文章搭配食用 阮一峰老师的 ECMAScript 6 入门 - Class的继承 更佳 Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。","text":"今天在和小伙伴聊天时, 发现对于 ES6 中的 Class 继承的理解我其实还是只是一个模棱两可的状态, 其实也不只是 constructor 有问题其它的部分其实也有问题, 这次先写类的继承之后再看有没有其它没理解的地方 整篇文章搭配食用 阮一峰老师的 ECMAScript 6 入门 - Class的继承 更佳 Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。 Constructor 方法首先, 在继承的类中 constructor 可以省略不写(会被默认添加) class A &#123; echo () &#123; console.log(&#x27;Hi!&#x27;) &#125; &#125; class B extends A &#123; &#125; let b = new B b.echo() // Hi! 但是如果写了 constructor 就必须要在内部调用 super() , 否则在创建实例的过程中会报错 class A &#123; echo () &#123; console.log(&#x27;Hi!&#x27;) &#125; &#125; class B extends A &#123; constructor() &#123; &#125; &#125; let b = new B b.echo() // ReferenceError: Must call super constructor in derived class before accessing &#x27;this&#x27; or returning from derived constructor 从提示中就能看到, 必须调用 super() 才能完成塑造 阮一峰: 这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。 从阮一峰老师的解释中也可以得出, 如果要在继承类中使用 this 就必须要先使用 super(), 那么对应的属性声明也需要放到 super() 之后才行: class A &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; &#125; class B extends A &#123; constructor(x, y, z) &#123; this.z = z; // ReferenceError super(x, y); this.z = z; // Success &#125; &#125; let b = new B 注意，super() 虽然代表了父类A的构造函数，但是返回的是子类B的实例，即 super() 内部的 this 指的是B的实例，因此 super() 在这里相当于 A.prototype.constructor.call(this)。 super 关键字除了在 constructor 中被当作父类的构造函数使用( super() ),也可以当成对象( super )使用, 指向父类的原型对象, 相当于 A.prototype, 但是在静态方法中 super 之中指向于父类 class A &#123;&#125; A.prototype.x = 2; class B extends A &#123; constructor() &#123; super(); console.log(super.x) // 2 &#125; &#125; let b = new B(); 这里需要注意，由于 super 指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过 super 调用的。class A &#123; constructor() &#123; this.x = 1; &#125; &#125; class B extends A &#123; constructor() &#123; super(); this.x = 2; super.x = 3; console.log(super.x); // undefined console.log(this.x); // 3 &#125; &#125; let b = new B(); 另外 ES6 规定，在子类普通方法中通过 super 调用父类的方法时，方法内部的 this 指向当前的子类实例。 所以通过 super 修改的是当前子类实例的属性,父类的属性并不会被修改 class A &#123; &#125; A.prototype.x = 2; class B extends A &#123; constructor() &#123; super(); super.x = 3; console.log(super.x); // 2 console.log(this.x); // 3 &#125; &#125; let b = new B(); console.log(A.prototype.x) // 2 静态方法中的 super虽然静态方法中的 super 就是按照字面的理解就行, 但是可能对于不是特别熟悉 Class 的朋友来说, 还是会有一点迷糊.那么就还是用阮一峰老师的例子来说 如果对于静态方法还不是特别清楚的, 请先阅读阮一峰老师的 ES6 入门 - Class 章节 class Parent &#123; static myMethod(msg) &#123; console.log(&#x27;static&#x27;, msg); &#125; myMethod(msg) &#123; console.log(&#x27;instance&#x27;, msg); &#125; &#125; class Child extends Parent &#123; static myMethod(msg) &#123; super.myMethod(msg); &#125; myMethod(msg) &#123; super.myMethod(msg); &#125; &#125; Child.myMethod(1); // static 1 let child = new Child(); child.myMethod(2); // instance 2 以上这个例子中, Child.myMethod(1) 是调用的调用的是 Child 类的静态方法 static, 在静态方法中 super 指向于父类 Parent 并不是父类原型, 故输出的是 static 1 另外，在子类的静态方法中通过 super 调用父类的方法时，方法内部的this指向当前的子类，而不是子类的实例。 class A &#123; constructor() &#123; this.x = 1; &#125; static print() &#123; console.log(this.x); &#125; &#125; class B extends A &#123; constructor() &#123; super(); this.x = 2; &#125; static m() &#123; super.print(); &#125; &#125; B.x = 3; B.m() // 3 个人觉得这个例子还是好的, 如果不这样写, 可能就会有朋友会误以为会输出 2, 其实并不是, 这里的 this 指向的是 子类, 并不是 子类实例 🌰 举个对于初学者容易摸不着头脑的例子 我先把已知定义列出来: 在 constructor 函数中, 可以当作父类的构造函数使用 可以把 super 当成对象使用 普通方法 中 super 指向 父类的原型对象 静态方法 中 super 指向 父类 静态方法 的 this 指向 当前子类 Example #1为什么可以赋值,但是读取的时候是 undefined class A &#123; constructor() &#123; this.x = 1; &#125; &#125; class B extends A &#123; constructor() &#123; super(); this.x = 2; super.x = 3; console.log(super.x); // undefined console.log(this.x); // 3 &#125; &#125; let b = new B(); super 作为对象使用时提到过, 普通方法中 super 指向父类的原型对象,那么可以知道: 在输出 super.x 时, 读取到的其实是 A.rototype.x, 但是在父类原型链上并没有 x 这个属性, 所以输出 undefined ; 那为什么可以赋值呢? 我们先来看一下之前我故意跳过然后在这里讲的例子 👇 Example #2class A &#123; constructor() &#123; this.x = 1; &#125; print() &#123; console.log(this.x); &#125; &#125; class B extends A &#123; constructor() &#123; super(); this.x = 2; &#125; m_print() &#123; super.print(); &#125; &#125; let b = new B(); b.m() // 2 super.print() 虽然调用的是 A.prototype.print(), 但是 A.prototype.print() 内部的 this 指向 子类B 的实例，导致输出的是 2 , 而不是 1 . 也就是说, 实际上执行的是 super.print.call(this) 所以在 Example #2 中, 由于 this 指向子类实例，赋值操作的时候属性会变成子类实例的属性, 所以修改的其实是 this.x. 番外在讨论的过程中我与小伙伴都有几个问题 constructor 中传递的参数是怎么决定的; 可以把 constructor 理解为调用父类构造函数, 这里传入的就是父类所需要的参数 如果只需要使用父类的几个方法呢; 继承的原意就是从父类的所有属性和方法, 如果不需要使用, 直接忽视就行了","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"}]},{"title":"「 ReactJS 笔记 」 L01 井字棋","slug":"react-learning-01","date":"2020-05-25T00:48:12.000Z","updated":"2026-01-05T05:39:58.513Z","comments":true,"path":"2020/react-learning-01/","permalink":"https://yogwang.site/2020/react-learning-01/","excerpt":"学习新东西的时候只看肯定是不够的, 所以既然 ReactJS 官方提供了一个学习的案例, 那么就一边写Demo, 一边读文档. Tips: 我是直接看案例然后按照自己的理解去写的, 并没有按照官方案例亦步亦趋, 所以可能流程会不一样. 井字棋这个 demo 主要分为两部分: 棋盘 点击棋盘空白格子可以落子, 落子之后交换棋手. 棋格已经落子 &#x2F; 有棋手获胜时不可落子","text":"学习新东西的时候只看肯定是不够的, 所以既然 ReactJS 官方提供了一个学习的案例, 那么就一边写Demo, 一边读文档. Tips: 我是直接看案例然后按照自己的理解去写的, 并没有按照官方案例亦步亦趋, 所以可能流程会不一样. 井字棋这个 demo 主要分为两部分: 棋盘 点击棋盘空白格子可以落子, 落子之后交换棋手. 棋格已经落子 &#x2F; 有棋手获胜时不可落子 游戏信息 棋手信息 提示当前落子的棋手信息 棋手获得胜利后, 显示胜利方 对局历史记录 展示对局历史信息 点击历史信息进行操作回溯 先从棋盘开始, 一共有9个格子, 每个格子有 3 个状态 (空, X, O)我想到的就直接用 flex 布局了, 不需要考虑 row 和 col, 这样也可以直接用循环直接输出 9 个棋格, 同时也可以从循环里边取出棋格的状态 所以首先是造棋盘: // App.js import React, &#123; Component &#125; from &#x27;react&#x27;; // 引入 React 以及React下的 Component 类 import &#x27;./App.styl&#x27;; // 引入样式文件 class App extends Component &#123; // 声明棋盘状态 state = &#123; squares: [0, 1, 2, 3, 4, 5, 6, 7, 8] // 这里是棋盘9个格子的状态 &#125; // /* * 当然你也可以使用 constructor, * 如果不理解 ES6 类的继承可以阅读 https://yogwang.github.io/2020/JS-class-constructor/ constructor()&#123; super() this.state=&#123; squares: [0, 1, 2, 3, 4, 5, 6, 7, 8] &#125; &#125; */ render () &#123; const &#123; squares &#125; = this.state return ( &lt;div id=&#x27;app&#x27;&gt; &lt;div className=&#x27;game-bar&#x27;&gt; // 棋盘 &lt;div className=&#x27;board&#x27;&gt; // 循环遍历棋格状态 并且返回单元格, 记得添加key, 这点于Vue一样 &#123;squares.map((info, index) =&gt; ( &lt;div className=&#x27;square&#x27; key=&#123;index&#125;&gt;&#123;info&#125;&lt;/div&gt; ))&#125; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ) &#125; &#125; export default App; 样式这边我用的预编译是 Stylus, 省略了括号, 冒号以及分号, 其它和 SCSS 基本一样.如果不了解大概看一下就行 // App.styl $square = 60px /* 定义一个格子的宽度 */ // 棋盘样式 .board width $square * 3 /* 一行3个格子的宽度 */ border 1px solid black display flex /* flex 布局 */ flex-wrap wrap /* 超出宽度可换行 */ // 棋格样式 .square width $square height @width /* 高度同宽度 */ line-height @height /* 文字行高同容器高度 这里应该要减去 border 的高度, 但是不碍事 */ font-size 25px text-align center border 1px solid black box-sizing border-box /* 修改盒模型 */ cursor pointer 完成之后大概是这样的一个样子 然后是游戏信息的展示, 因为是交替落子, 所以单数步数是 棋手X 落子的话, 双数步数就一定是 棋手O 落子.顺便给棋格绑定上点击事件, 棋盘的组件大概可以这样初步完成 // App.js import React, &#123; Component &#125; from &#x27;react&#x27;; import &#x27;./App.styl&#x27;; class App extends Component &#123; state = &#123; squares: [0, 1, 2, 3, 4, 5, 6, 7, 8], step:0, // 增加计步器 &#125; // 获取当前Player getCurPlayer () &#123; const &#123; step &#125; = this.state // 获取当前步数 return step % 2 ? &quot;O&quot; : &quot;X&quot; // 按照步数奇偶返回棋手 &#125; // 方块被点击 handleSquareClick (position, player) &#123; const &#123; squares, step &#125; = this.state // 获取当前棋盘信息以及步数 // 既然获取到了棋格信息那么就顺便输出一下当前信息 console.log(`当前步数: $&#123;step&#125;, 棋手: $&#123;player&#125;, 点击位置: $&#123;position&#125;`) const newStep = step + 1 // 步数 +1 const newSquares = squares newSquares[position] = player // 修改对应棋格信息 // 修改State, 并且触发渲染 this.setState(&#123; squares: newSquares, step: newStep &#125;) &#125; render () &#123; const &#123; squares &#125; = this.state const player = this.getCurPlayer() return ( &lt;div id=&#x27;app&#x27;&gt; &lt;div className=&#x27;game-bar&#x27;&gt; &lt;div className=&#x27;board&#x27;&gt; &#123;squares.map((info, index) =&gt; ( /* * 增加onClick事件, 这里和Vue不一样, 需要使用箭头函数, 或者使用 .bind(this) 绑定this * 具体原因请看上一篇 [React L00 起步] */ &lt;div className=&#x27;square&#x27; key=&#123;index&#125; onClick=&#123;() =&gt; this.handleSquareClick(index,player)&#125;&gt;&#123;info&#125;&lt;/div&gt; ))&#125; &lt;/div&gt; &lt;/div&gt; &lt;div className=&#x27;game-info&#x27;&gt; // 棋手信息 &lt;div className=&#x27;player-info&#x27;&gt;Current player: &#123;player&#125;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ) &#125; &#125; export default App; // App.styl // ...接上一部分样式 .game-info width 400px height 600px max-height 100vh margin-left 60px .player-info font-size 22px 现在棋盘可以被修改了, 棋手信息也有了, 同样也可以获取到每次操作的落子信息. 那么就可以先把历史记录加上, 并且展示 // App.js import React, &#123; Component &#125; from &#x27;react&#x27;; import &#x27;./App.styl&#x27;; class App extends Component &#123; state = &#123; squares: [0, 1, 2, 3, 4, 5, 6, 7, 8], step:0, history:[], // 增加历史记录 &#125; // 获取当前Player getCurPlayer () &#123; const &#123; step &#125; = this.state return step % 2 ? &quot;O&quot; : &quot;X&quot; &#125; // 方块被点击 handleSquareClick (position, player) &#123; const &#123; squares, step, history &#125; = this.state const newStep = step + 1 const newSquares = squares newSquares[position] = player const newHistory = history.concat([&#123; step:step, player:player, position:position &#125;]) this.setState(&#123; squares: newSquares, step: newStep, history: newHistory &#125;) &#125; render () &#123; const &#123; squares,history &#125; = this.state const player = this.getCurPlayer() return ( &lt;div id=&#x27;app&#x27;&gt; &lt;div className=&#x27;game-bar&#x27;&gt; &lt;div className=&#x27;board&#x27;&gt; &#123;squares.map((info, index) =&gt; ( &lt;div className=&#x27;square&#x27; key=&#123;index&#125; onClick=&#123;() =&gt; this.handleSquareClick(index,player)&#125;&gt;&#123;info&#125;&lt;/div&gt; ))&#125; &lt;/div&gt; &lt;/div&gt; &lt;div className=&#x27;game-info&#x27;&gt; &lt;div className=&#x27;player-info&#x27;&gt;Current player: &#123;player&#125;&lt;/div&gt; // 历史信息 &lt;ol className=&#x27;history&#x27;&gt; // 遍历循环历史信息记录 &#123;history.map((record, index) =&gt; ( &lt;li key=&#123;index&#125;&gt;Player_&#123;record.player&#125; to &#123;record.position&#125;&lt;/li&gt; ))&#125; &lt;/ol&gt; &lt;/div&gt; &lt;/div&gt; ) &#125; &#125; export default App; 现在的游戏界面应该如下 这个时候呢, 就会有几个问题: 棋格可以重复落子 没有获胜判断 棋盘默认显示数字, 很不美观 其实还有一个问题, 在历史回溯的时候会很麻烦, 这个我实在游戏基本都完成了之后才发现的. 这个之后再说 所以在落子的时候增加当前棋格不为空 的判断, 并且以 null 填充数组; 代码修改如下 // App.js import React, &#123; Component &#125; from &#x27;react&#x27;; import &#x27;./App.styl&#x27;; class App extends Component &#123; state = &#123; squares: new Array(9).fill(null), // 创建一个长度为 9 的数组,并且填充 null step:0, history:[], &#125; // 获取当前Player getCurPlayer () &#123; const &#123; step &#125; = this.state return step % 2 ? &quot;O&quot; : &quot;X&quot; &#125; // 方块被点击 handleSquareClick (position, player) &#123; const &#123; squares, step, history &#125; = this.state if (squares[position]) return // 增加棋格不会空的判断 const newStep = step + 1 const newSquares = squares newSquares[position] = player const newHistory = history.concat([&#123; step:step, player:player, position:position &#125;]) this.setState(&#123; squares: newSquares, step: newStep, history: newHistory &#125;) &#125; render () &#123; const &#123; squares, history &#125; = this.state const player = this.getCurPlayer() return ( &lt;div id=&#x27;app&#x27;&gt; &lt;div className=&#x27;game-bar&#x27;&gt; &lt;div className=&#x27;board&#x27;&gt; &#123;squares.map((info, index) =&gt; ( &lt;div className=&#x27;square&#x27; key=&#123;index&#125; onClick=&#123;() =&gt; this.handleSquareClick(index,player)&#125;&gt;&#123;info&#125;&lt;/div&gt; ))&#125; &lt;/div&gt; &lt;/div&gt; &lt;div className=&#x27;game-info&#x27;&gt; &lt;div className=&#x27;player-info&#x27;&gt;Current player: &#123;player&#125;&lt;/div&gt; // 历史信息 &lt;ol className=&#x27;history&#x27;&gt; // 遍历循环历史信息记录 &#123;history.map((record, index) =&gt; ( &lt;li key=&#123;index&#125;&gt;Player_&#123;record.player&#125; to &#123;record.position&#125;&lt;/li&gt; ))&#125; &lt;/ol&gt; &lt;/div&gt; &lt;/div&gt; ) &#125; &#125; export default App; 好了, 棋盘的大致都完成了, 现在来写获胜判断.因为我想者是每次循环一次所有棋格, 然后找出获胜的玩家, 但是这里循环有点傻,所以我是看了一下官方的demo, 是这样的一个思路, 把所有的胜利条件都所列了出来, 然后去循环胜利条件, 如果所有胜利条件都循环结束, 没有出现胜利的玩家则继续游戏. // 计算赢家 calculateWinner () &#123; // 获胜条件 const lines = [ [0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6], ]; const &#123; squares &#125; = this.state // 取得所有棋盘数据 // 循环判断胜利条件 for (let i = 0; i &lt; lines.length; i++) &#123; const [a, b, c] = lines[i]; // 取出获胜坐标 // 判断对应坐标是否有值 并且 三个坐标内的值是否相等 if (squares[a] &amp;&amp; squares[a] === squares[b] &amp;&amp; squares[a] === squares[c]) &#123; return squares[a]; // 返回胜利者 &#125; &#125; return null; &#125; 然后补完一下棋盘, 胜利时在当前玩家信息提示获胜玩家. // App.js import React, &#123; Component &#125; from &#x27;react&#x27;; import &#x27;./App.styl&#x27;; // 获胜条件 const lines = [ [0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6], ]; class App extends Component &#123; state = &#123; squares: new Array(9).fill(null), step:0, history:[], &#125; // 获取当前Player getCurPlayer () &#123; const &#123; step &#125; = this.state return step % 2 ? &quot;O&quot; : &quot;X&quot; &#125; // 方块被点击 handleSquareClick (position, player) &#123; const &#123; squares, step, history &#125; = this.state if (this.calculateWinner() || squares[position]) return // 增加是否有赢家的判断 const newStep = step + 1 const newSquares = squares newSquares[position] = player const newHistory = history.concat([&#123; step:step, player:player, position:position &#125;]) this.setState(&#123; squares: newSquares, step: newStep, history: newHistory &#125;) &#125; // 计算赢家 calculateWinner () &#123; const &#123; squares &#125; = this.state for (let i = 0; i &lt; lines.length; i++) &#123; const [a, b, c] = lines[i]; if (squares[a] &amp;&amp; squares[a] === squares[b] &amp;&amp; squares[a] === squares[c]) &#123; return squares[a]; &#125; &#125; return null; &#125; render () &#123; const &#123; squares,history &#125; = this.state const player = this.getCurPlayer() const winner = this.calculateWinner() // 获取赢家 return ( &lt;div id=&#x27;app&#x27;&gt; &lt;div className=&#x27;game-bar&#x27;&gt; &lt;div className=&#x27;board&#x27;&gt; &#123;squares.map((info, index) =&gt; ( &lt;div className=&#x27;square&#x27; key=&#123;index&#125; onClick=&#123;() =&gt; this.handleSquareClick(index,player)&#125;&gt;&#123;info&#125;&lt;/div&gt; ))&#125; &lt;/div&gt; &lt;/div&gt; &lt;div className=&#x27;game-info&#x27;&gt; &lt;div className=&#x27;player-info&#x27;&gt; &#123;winner ? `Player_$&#123;winner&#125; is Winner!!!` : `Current player: $&#123;player&#125;`&#125; // 判断是否有玩家获胜, 如果有则输出获胜信息, 没有则输出当前玩家信息 &lt;/div&gt; &lt;ol className=&#x27;history&#x27;&gt; &#123;history.map((record, index) =&gt; ( &lt;li key=&#123;index&#125;&gt;Player_&#123;record.player&#125; to &#123;record.position&#125;&lt;/li&gt; ))&#125; &lt;/ol&gt; &lt;/div&gt; &lt;/div&gt; ) &#125; &#125; export default App; 整个游戏流程到现在基本就完成了, 但是点击历史记录回溯操作的功能还没有加上来.这个时候我就有点卡壳了, 不知道在当前逻辑下怎么回退操作. 就去看了官方的案例,它是每一步在历史记录内插入当前棋盘数据, 然后回退的时候直接读取历史棋盘数据, 并且没有在历史记录中展示每一步的具体操作内容. 所以想了想还是继续原先的历史记录, 并且按照历史记录来生成棋盘数据(这边参考了山地人老师的思路),那这样的话, 就不需要手动去修改棋盘数据了, 只要调用一下生成棋盘的函数就可以了. 具体代码修改如下 // App.js import React, &#123; Component &#125; from &#x27;react&#x27;; import &#x27;./App.styl&#x27;; const lines = [ [0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6], ]; class App extends Component &#123; state = &#123; squares: new Array(9).fill(null), step: 0, history: [], &#125; // 获取当前Player getCurPlayer () &#123; const &#123; step &#125; = this.state return step % 2 ? &quot;O&quot; : &quot;X&quot; &#125; // 方块被点击 handleSquareClick (position, player) &#123; const &#123; squares, step, history &#125; = this.state if (this.calculateWinner() || squares[position]) return const newStep = step + 1 // 移除了棋盘数据操作, const newHistory = [ ...history.slice(0, step), &#123; step: step, player: player, position: position &#125; ] this.setState(&#123; step: newStep, history: newHistory, squares: this.calculateSquares(newHistory, newStep), // 调用 calculateSquares 产生数据 &#125;) &#125; // 计算赢家 calculateWinner () &#123; const &#123; squares &#125; = this.state for (let i = 0; i &lt; lines.length; i++) &#123; const [a, b, c] = lines[i]; if (squares[a] &amp;&amp; squares[a] === squares[b] &amp;&amp; squares[a] === squares[c]) &#123; return squares[a]; &#125; &#125; return null; &#125; // 生成棋盘数据 calculateSquares (history, step) &#123; const newSquares = new Array(9).fill(null) // 创建空棋盘数组 // 循环插入历史数据 for (let i = 0; i &lt; step; i += 1) &#123; const tempHistory = history[i] newSquares[tempHistory.position] = tempHistory.player &#125; return newSquares // 返回棋盘数据 &#125; // 回退历史步骤 handleGoBack (step) &#123; const &#123; history &#125; = this.state const tempHistory = history.slice(0, step) // 根据传入步数截取历史记录 this.setState(&#123; step: step, // 重设步数 squares: this.calculateSquares(tempHistory, step), // 生成棋盘数据 &#125;) &#125; render () &#123; const &#123; squares, history &#125; = this.state const player = this.getCurPlayer() const winner = this.calculateWinner() return ( &lt;div id=&#x27;app&#x27;&gt; &lt;div className=&#x27;game-bar&#x27;&gt; &lt;div className=&#x27;board&#x27;&gt; &#123;squares.map((info, index) =&gt; ( &lt;div className=&#x27;square&#x27; key=&#123;index&#125; onClick=&#123;() =&gt; this.handleSquareClick(index, player)&#125;&gt;&#123;info&#125;&lt;/div&gt; ))&#125; &lt;/div&gt; &lt;/div&gt; &lt;div className=&#x27;game-info&#x27;&gt; &lt;div className=&#x27;player-info&#x27;&gt; &#123;winner ? `Player_$&#123;winner&#125; is Winner!!!` : `Current player: $&#123;player&#125;`&#125; &lt;/div&gt; &lt;ol className=&#x27;history&#x27;&gt; &#123;history.map((record, index) =&gt; ( &lt;li key=&#123;index&#125; onClick=&#123;() =&gt; this.handleGoBack(record.step + 1)&#125;&gt;Player_&#123;record.player&#125; to &#123;record.position&#125;&lt;/li&gt; ))&#125; &lt;/ol&gt; &lt;/div&gt; &lt;/div&gt; ) &#125; &#125; export default App; 至此为止, 基本的游戏功能都完成了, 只不过整个项目都是写在一个文件中的, 并没有进行组件化操作.你们可以自行决定怎么拆分, 也可以继续阅读下去. 组件化我认为可以把棋盘和游戏信息展示进行拆分; 棋盘这部分我觉得单独一个组件就可以了, 不用继续分解了, 因为单个棋格就一个 div 元素 加上 onClick 事件, 组件化的结果并没有简化代码, 反而增加代码量和不方便阅读. 游戏信息可以继续拆分成玩家信息和历史记录, 然后再对应组件内进行状态维护和样式的编辑. 拆分后的 App.js 文件如下 // App.js import React, &#123; Component &#125; from &#x27;react&#x27;; import Board from &#x27;./components/Board&#x27; import GameInfo from &#x27;./components/GameInfo&#x27; import &#x27;./App.styl&#x27;; // 获胜条件 const lines = [ [0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6], ]; class App extends Component &#123; // 定义属性 state = &#123; squares: new Array(9).fill(null), player: &quot;&quot;, history: [], step: 0, &#125; // 计算当前Player getCurPlayer () &#123; const &#123; step &#125; = this.state return step % 2 ? &quot;O&quot; : &quot;X&quot; // 能否被2整除 &#125; // 生成棋盘数据 calculateSquares (history, step) &#123; // 创建新数组 const newSquares = new Array(9).fill(null) // 循环插入历史数据 for (let i = 0; i &lt; step; i += 1) &#123; const tempHistory = history[i] newSquares[tempHistory.position] = tempHistory.player &#125; return newSquares &#125; // 计算赢家 calculateWinner () &#123; const &#123; squares &#125; = this.state // 循环判断胜利条件 for (let i = 0; i &lt; lines.length; i++) &#123; const [a, b, c] = lines[i]; if (squares[a] &amp;&amp; squares[a] === squares[b] &amp;&amp; squares[a] === squares[c]) &#123; return squares[a]; &#125; &#125; return null; &#125; // 方块被点击 handleSquareClick (position, player) &#123; const &#123; squares, step, history &#125; = this.state // 如果已经获胜或棋格不为空则跳出 if (this.calculateWinner() || squares[position]) return const newStep = step + 1 // 新步数 // 插入新历史记录 const newHistory = [ ...history.slice(0, step), &#123; step: step, player: player, position: position &#125; ] this.setState(&#123; step: newStep, history: newHistory, squares: this.calculateSquares(newHistory, newStep), // 生成棋盘数据 &#125;) &#125; // 回退历史步骤 handleGoBack (step = 0) &#123; const &#123; history &#125; = this.state const tempHistory = history.slice(0, step) this.setState(&#123; step: step, squares: this.calculateSquares(tempHistory, step), // 生成棋盘数据 &#125;) &#125; // 重新开始 handleRestart () &#123; this.setState(&#123; history: [] &#125;) this.handleGoBack() &#125; render () &#123; const &#123; squares, history &#125; = this.state const player = this.getCurPlayer() const winner = this.calculateWinner() return ( &lt;div id=&#x27;app&#x27;&gt; &lt;div className=&#x27;game-bar&#x27;&gt; &lt;Board squares=&#123;squares&#125; onClick=&#123;i =&gt; this.handleSquareClick(i, player)&#125; /&gt; &lt;/div&gt; &lt;GameInfo player=&#123;player&#125; winner=&#123;winner&#125; history=&#123;history&#125; goBack=&#123;step =&gt; this.handleGoBack(step)&#125; /&gt; &lt;/div&gt; ) &#125; &#125; export default App; 棋盘组件// Board.js import React, &#123; Component &#125; from &#x27;react&#x27;; import &#x27;./Board.styl&#x27;; class Board extends Component &#123; // 生成棋格 renderSquare (status, index) &#123; return (&lt;div className=&#x27;square&#x27; onClick=&#123;() =&gt; this.props.onClick(index)&#125; key=&#123;index&#125;&gt;&#123;status&#125;&lt;/div&gt;) &#125; render () &#123; const &#123; squares &#125; = this.props // 获取棋盘数据 return ( &lt;div className=&#x27;board&#x27;&gt; // 循环棋盘数据生成棋格 &#123;squares.map((status, index) =&gt; this.renderSquare(status, index))&#125; &lt;/div&gt; ) &#125; &#125; export default Board 游戏信息组件// GameInfo.js import React, &#123; Component &#125; from &#x27;react&#x27; import History from &#x27;./History&#x27; class GameInfo extends Component &#123; render () &#123; const &#123; player, winner, history &#125; = this.props // 从父组件获取棋手, 胜利方, 历史记录数据 // 当前棋手信息, 如果已经有棋手胜利 返回胜利信息 const playerInfo = winner ? `Player_$&#123;winner&#125; is Winner!!!` : `Current player: $&#123;player&#125;` return ( &lt;div className=&#x27;game-info&#x27;&gt; &lt;div className=&#x27;player-info&#x27;&gt;&#123;playerInfo&#125;&lt;/div&gt; &lt;History history=&#123;history&#125; onClick=&#123;step =&gt; this.props.goBack(step)&#125;&gt;&lt;/History&gt; &lt;/div&gt; ) &#125; &#125; export default GameInfo 操作历史组件// History.js import React, &#123; Component &#125; from &#x27;react&#x27;; import Record from &#x27;./Record&#x27; import &#x27;./History.styl&#x27;; class History extends Component &#123; render () &#123; const &#123; history &#125; = this.props return ( &lt;ol className=&#x27;history&#x27;&gt; &lt;li onClick=&#123;() =&gt; this.props.onClick(0)&#125;&gt;Go to game start&lt;/li&gt; // 回到游戏开始 &#123; history.map((record, index) =&gt; ( &lt;Record info=&#123;record&#125; key=&#123;index&#125; onClick=&#123;() =&gt; this.props.onClick(record.step + 1)&#125;&gt;&lt;/Record&gt; )) &#125; &lt;/ol&gt; ) &#125; &#125; export default History 单条历史记录import React, &#123; Component &#125; from &#x27;react&#x27; class Record extends Component &#123; // 计算坐标 返回二维坐标 [0,0] calculatePosition (position) &#123; const posY = (position / 3 &gt;&gt; 0) + 1 // 取行号 const posX = position % 3 + 1 // 取列号 return `[$&#123;posY&#125;,$&#123;posX&#125;]` &#125; render () &#123; const &#123; info &#125; = this.props // 继承历史记录 return ( &lt;li onClick=&#123;() =&gt; this.props.onClick()&#125;&gt; Player_&#123;info.player&#125; to &#123;this.calculatePosition(info.position)&#125; &lt;/li&gt; ) &#125; &#125; export default Record 样式文件如下: // App.styl body font-family consolas margin 0 #app width 100vw height 100vh display flex justify-content center align-items center .game-bar height 600px max-height 100vh .game-info width 400px height 600px max-height 100vh .player-info font-size 22px // Board.styl $square = 60px .board width $square * 3 border 1px solid black margin-right 50px display flex flex-wrap wrap .square width $square height $square line-height @height font-size 25px text-align center border 1px solid black box-sizing border-box cursor pointer &amp;:hover background #ddd // History.styl .history padding 0 counter-reset number -1 li margin 5px 0 counter-increment number list-style-type none cursor pointer &amp;:before content counter(number) &#x27;.&#x27; margin-right 10px display inline-bloack &amp;:hover color red text-decoration underline 以上 附录一些卡壳的地方 如何创建 State 状态 Constructor 是怎么一回事 组件化后子组件如何触发父组件事件 为何 onClick 中的事件会自动执行 React中怎么使用 Stylus 组件多层嵌套的情况下怎么获取其它的属性状态，类似 Vuex 的Store","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://yogwang.site/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"ReactJS","slug":"ReactJS","permalink":"https://yogwang.site/tags/ReactJS/"}]},{"title":"「 ReactJS 笔记 」 L00 起步","slug":"react-learning-00","date":"2020-05-22T03:47:43.000Z","updated":"2026-01-05T05:39:58.513Z","comments":true,"path":"2020/react-learning-00/","permalink":"https://yogwang.site/2020/react-learning-00/","excerpt":"Vue 3.0 Beta版本已经更新很久了,不出意外正式的 Release 应该如约在第三季度发布,然而我还没有开始学习 TypeScript 以及 Composition API,趁着这几天项目还没开始,就抓紧了解了一下 React","text":"Vue 3.0 Beta版本已经更新很久了,不出意外正式的 Release 应该如约在第三季度发布,然而我还没有开始学习 TypeScript 以及 Composition API,趁着这几天项目还没开始,就抓紧了解了一下 React ReactJS现存的一些疑问 ReactJS 与 VueJS 的区别 ReactJS 有什么好的? 为什么 ReactJS 是单向数据流 create-react-app 创建的项目依赖为什么都在dependencies 绑定函数时为什么要使用箭头函数或者.bind() onClick会渲染成功会自动执行 怎么不使用constructor的情况下定义state react是否有生命周期 如果有生命周期钩子是否和vue差不多? 加上Typescript之后的问题 Props怎么定义interface 如果需要手动定义接口岂不是太傻?","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"未完成","slug":"未完成","permalink":"https://yogwang.site/tags/%E6%9C%AA%E5%AE%8C%E6%88%90/"},{"name":"学习","slug":"学习","permalink":"https://yogwang.site/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"ReactJS","slug":"ReactJS","permalink":"https://yogwang.site/tags/ReactJS/"}]},{"title":"Jeecg-boot 开发挖坑日记10 升级AntD依赖后按钮组件配色出现异常","slug":"jeecg-boot-devDiary10","date":"2020-04-24T06:02:57.000Z","updated":"2026-01-05T05:39:58.500Z","comments":true,"path":"2020/jeecg-boot-devDiary10/","permalink":"https://yogwang.site/2020/jeecg-boot-devDiary10/","excerpt":"昨天项目有新需求用到了，Ant Design Vue 1.5.0+ 的新组件 Descriptions，所以就单独升级了一下UI库依赖，从 v1.3.9 升到了 v1.5.3，然后新组件是可以用了，但是按钮组件出现问题了；当type 为 danger 时，背景会变成白色，同时文字也是白色的，就会如下图一样的情况。","text":"昨天项目有新需求用到了，Ant Design Vue 1.5.0+ 的新组件 Descriptions，所以就单独升级了一下UI库依赖，从 v1.3.9 升到了 v1.5.3，然后新组件是可以用了，但是按钮组件出现问题了；当type 为 danger 时，背景会变成白色，同时文字也是白色的，就会如下图一样的情况。 然后审查模式下边看到是有一个样式覆盖了组件库的样式 然后我自己就没有定义过组件库的全局样式，正常我自己覆盖组件库内样式的时候都是私有样式，就郁闷了一个早上，在视图层到处找哪个组件里没有加样式私有化，结果一个上午都没有找到。然后午休完了之后就突然想起来是不是 Jeecg-boot 自己定义了一个全局样式，在入口文件中引入了，所以导致样式被覆盖了。结果就真的是这个问题。 第22行引入的 OnlineForm.css中就重定义了 .ant-btn-danger 的背景色为白色，把 AntD 的样式文件在这个之后引入就不会被覆盖了，我大概看了一下，这个样式表中重写了 AntD 的 169 个样式 这个意思就是说，不只是按钮的样式会出现问题，如果其它的样式没有做好覆盖，也会导致显示异常… 有一些还是加了私有作用域，不知道是怎么一个情况…反正我不用在线报表就先注释了，之后看开发团队会不会修复这个问题吧。 附 本文所使用的 Jeecg-boot 版本为 v2.1.0 v2.2.0 版本也有这个问题，已经提交了 issue 等开发团队回复吧。","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Ant-Design-Vue","slug":"Ant-Design-Vue","permalink":"https://yogwang.site/tags/Ant-Design-Vue/"},{"name":"Jeecg-boot","slug":"Jeecg-boot","permalink":"https://yogwang.site/tags/Jeecg-boot/"}]},{"title":"export { x as x } 中的 as 是什么？","slug":"what-the-export-x-as-x","date":"2020-04-13T06:38:59.000Z","updated":"2026-01-05T05:39:58.523Z","comments":true,"path":"2020/what-the-export-x-as-x/","permalink":"https://yogwang.site/2020/what-the-export-x-as-x/","excerpt":"今天在读一个开源框架的时候看到了一行 export &#123; installer as VueAxios, service as axios &#125;; 然后我就 ? ? ?，以前一直都不知道这个 as，然后就赶紧百度，结果没有一个匹配的结果。 然后就只能从阮一峰老师的ES6入门里边找…","text":"今天在读一个开源框架的时候看到了一行 export &#123; installer as VueAxios, service as axios &#125;; 然后我就 ? ? ?，以前一直都不知道这个 as，然后就赶紧百度，结果没有一个匹配的结果。 然后就只能从阮一峰老师的ES6入门里边找… 通常情况下，export 输出的变量就是本来的名字，但是可以使用 as 关键字重命名。 示例代码：function v1() &#123; ... &#125; function v2() &#123; ... &#125; export &#123; v1 as streamV1, v2 as streamV2, v2 as streamLatestVersion &#125;; 上面代码使用 as 关键字，重命名了函数 v1 和 v2 的对外接口。重命名后，v2 可以用不同的名字输出两次。 所以其实 as 关键词的作用就是重命名导出的关键词，来起一个更加语义化的名称，或者隐藏模块里边的变量名称。然后再重新查阅其它博客的文章的时候发现，有一部分的博客把重命名写在了 as 关键词前边，我就又奇怪了，难不成两边都可以嘛？我就自己写了个demo，然而只能写在后边…. 好了，Demo 也写了，也闹明白了，其实就是一个关键字重命名，所以用到的太少了，看到就蒙了，以后记着就好。","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"}]},{"title":"使用 Webpack 的 Proxy 解决跨域问题","slug":"webpack-dev-server-proxy-note","date":"2020-03-27T07:20:58.000Z","updated":"2026-01-05T05:39:58.523Z","comments":true,"path":"2020/webpack-dev-server-proxy-note/","permalink":"https://yogwang.site/2020/webpack-dev-server-proxy-note/","excerpt":"在这次的项目中，遇到了后端配置了允许跨域，但是我这边请求的时候还是提示跨域，后端折腾了会，我说算了，我这边本地做一下代里还快一点，你继续整接口吧。 所以就用到了 webpack-dev-server 的 proxy，但是有一些部分我并没有整明白，所以写一篇文章梳理一下。 最简单的就是直接在 webpack 的配置文件中启用 proxy 就可以了，","text":"在这次的项目中，遇到了后端配置了允许跨域，但是我这边请求的时候还是提示跨域，后端折腾了会，我说算了，我这边本地做一下代里还快一点，你继续整接口吧。 所以就用到了 webpack-dev-server 的 proxy，但是有一些部分我并没有整明白，所以写一篇文章梳理一下。 最简单的就是直接在 webpack 的配置文件中启用 proxy 就可以了， module.exports = &#123; publicPath: &quot;./&quot;, outputDir: &quot;./dist&quot;, lintOnSave: true, css: &#123; loaderOptions: &#123; .... &#125;, &#125;, devServer: &#123; proxy: &#123; &quot;/api&quot;: &#123; // 这里的api可以是 / 也可以是具体的path也可以配置多个 target: &quot;http://www.domain.com/&quot;, //对应自己的api接口 changeOrigin: true, // 如果接口跨域，需要配置这个参数 secure: false, // 如果是https接口，需要配置这个参数 &#125;, &#125;, &#125;, &#125;; 然后再请求的配置文件中修改地址为启动的服务地址就可以初步实现了。改编成生产环境的时候就需要去修改配置文件，我就觉得很麻烦，一点也不优雅，所以就需要用到环境变量来配置代里。 VueCLI 4x中通过为 .env 文件增加后缀来设置某个模式下特有的环境变量，例如在项目根目录创建一个名为 .env.development 的文件，那么在这个文件里声明过的变量就只会在 development 模式下被载入。 development 模式用于 vue-cli-service serveproduction 模式用于 vue-cli-service build 和 vue-cli-service test:e2etest 模式用于 vue-cli-service test:unit 所以默认你不需要配就可以在 run serve 时读取 .env.development 的配置，同理 build 时会读取 .env.production 的配置。 附只有以 VUE_APP_ 开头的变量会被 webpack.DefinePlugin 静态嵌入到客户端侧的包中。你可以在应用的代码中这样访问它们： console.log(process.env.VUE_APP_SECRET) 在构建过程中，process.env.VUE_APP_SECRET 将会被相应的值所取代。在 VUE_APP_SECRET=secret 的情况下，它会被替换为 “secret”。 除了 VUE_APP_* 变量之外，在你的应用代码中始终可用的还有两个特殊的变量： NODE_ENV - 会是 &quot;development&quot;、&quot;production&quot; 或 &quot;test&quot; 中的一个。具体的值取决于应用运行的模式。BASE_URL - 会和 vue.config.js 中的 publicPath 选项相符，即你的应用会部署到的基础路径。 环境变量和模式 | Vue CLI","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"https://yogwang.site/tags/Webpack/"}]},{"title":"使用VueJS的计算属性监听DOM元素属性的问题","slug":"vue-computed-DOM-element-attributes","date":"2020-03-16T06:18:59.000Z","updated":"2026-01-05T05:39:58.521Z","comments":true,"path":"2020/vue-computed-DOM-element-attributes/","permalink":"https://yogwang.site/2020/vue-computed-DOM-element-attributes/","excerpt":"今天在写一个模拟微信的聊天组件的时候，需要获取消息列表的滚动条高度，来实现每次发送接受消息数据时，自动滚动到列表末尾。当然就想到了用 Computed 属性来计算容器的 scrollHeight。然后就发现一开始滚动条会定位到列表最后，但是测着测着就发现怎么超出了一定高度范围之后就不会滚动到列表末尾了，而是固定在了一个值。","text":"今天在写一个模拟微信的聊天组件的时候，需要获取消息列表的滚动条高度，来实现每次发送接受消息数据时，自动滚动到列表末尾。当然就想到了用 Computed 属性来计算容器的 scrollHeight。然后就发现一开始滚动条会定位到列表最后，但是测着测着就发现怎么超出了一定高度范围之后就不会滚动到列表末尾了，而是固定在了一个值。 所以在我在控制台输出了一下获取到的值:就觉得是不是因为这里拿到的是容器可视部分的值 offsetHeight，检查后发现我并没有取错属性。 接着我就把之前填充默认填充的假数据给去掉了，再一次获取了计算出来的属性：嗯？为啥都是一个值，这个值不应该是会随内容的增加变化的吗？为什么就一直是初始的值呢。 想了想会不会是计算属性缓存了 scrollHeight，然后就在滚动方法里同样输出了容器的scrollHeight，确实是被缓存了。 然后就去查阅了一下资料，也询问了群内的大佬回答是： 计算属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。注意，如果某个依赖 (比如非响应式属性) 在该实例范畴之外，则计算属性是不会被更新的。 然后翻了翻Vue的文档关于 Computed 部分的介绍： 计算属性的结果会被缓存，除非依赖的响应式 property 变化才会重新计算。注意，如果某个依赖 (比如非响应式 property) 在该实例范畴之外，则计算属性是不会被更新的。 确实 DOM 元素相关的属性不能被 Computed 计算，DOM 元素不具有响应式依赖，所以会被计算属性缓存。","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"VueJS","slug":"VueJS","permalink":"https://yogwang.site/tags/VueJS/"}]},{"title":"什么是 [Arguments] 隐式参数？","slug":"JS-whats-arguments","date":"2020-03-14T01:01:27.000Z","updated":"2026-01-05T05:39:58.477Z","comments":true,"path":"2020/JS-whats-arguments/","permalink":"https://yogwang.site/2020/JS-whats-arguments/","excerpt":"这段时间总是看到有人提到 arguments 隐式参数, 并且在 方方老师 的面试经中也提到了这个词，但是好像很多人不知道怎么一回事。确实在 ES6 普及之后，有了 ... 展开运算符之后就很少有用到 arguments 了，并且我在写这篇文章之前还总是拼错单词，因为我喜欢自己定义 parameter 形参…","text":"这段时间总是看到有人提到 arguments 隐式参数, 并且在 方方老师 的面试经中也提到了这个词，但是好像很多人不知道怎么一回事。确实在 ES6 普及之后，有了 ... 展开运算符之后就很少有用到 arguments 了，并且我在写这篇文章之前还总是拼错单词，因为我喜欢自己定义 parameter 形参… arguments 是一个对应于传递给函数的参数的类数组对象（并不是 Array，除了 length 属性和索引元素之外没有任何 Array 属性） arguments 对象是所有（非箭头）函数中都可用的局部变量。你可以使用 arguments 对象在函数中引用函数的参数。此对象包含传递给函数的每个参数，第一个参数在索引 0 处。 使用方式例如，如果一个函数传递了三个参数，你可以以如下方式引用他们： function test() &#123; console.log(arguments[0]); console.log(arguments[1]); console.log(arguments[2]); &#125; test(1, 2, 3); // =&gt; 1 // =&gt; 2 // =&gt; 3 同样也可以进行赋值操作 arguments[1] = &quot;new value&quot;; console.log(arguments[1]); // =&gt; new value 再重复一遍，arguments 不是数组它只能在函数内使用，类似于 Array，但除了 length 属性和索引元素之外没有任何 Array 属性。但是它可以被转换为一个真正的 Array：上一组 demo console.log(typeof arguments); // arguments 对象只能在函数内使用 function test() &#123; console.log(typeof arguments); console.log(arguments[0]); &#125; test(1); // =&gt; undefined // =&gt; object // =&gt; 1 拓展 1当然也可以通过以下方法转变成 Js 数组： var args = Array.prototype.slice.call(arguments); var args = [].slice.call(arguments); // ES6 const args = Array.from(arguments); const args = [...arguments]; 拓展 2在严格模式与非严格模式下进行赋值操作会出现不一样的结果 // 严格模式 function test(a) &#123; &quot;use strict&quot;; console.log(a, arguments[0]); a = 50; console.log(a, arguments[0]); arguments[0] = 100; console.log(a, arguments[0]); &#125; test(10); // =&gt; 10 10 // =&gt; 50 10 // =&gt; 50 100 // 非严格模式 function test(a) &#123; console.log(a, arguments[0]); a = 50; console.log(a, arguments[0]); arguments[0] = 100; console.log(a, arguments[0]); &#125; test(10); // =&gt; 10 10 // =&gt; 50 50 // =&gt; 100 100 当然这些看看就好 拓展 3一些专业名词： Parameters 函数显式参数 function test(parameter1, parameter2, parameter3) Arguments 隐式参数 ( 我就不写伪代码了… ) 参考资料 Arguments 对象 - MDN","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"}]},{"title":"map() 和 forEach() 的区别","slug":"JS-map-and-forEach","date":"2020-03-12T03:27:13.000Z","updated":"2026-01-05T05:39:58.473Z","comments":true,"path":"2020/JS-map-and-forEach/","permalink":"https://yogwang.site/2020/JS-map-and-forEach/","excerpt":"一直以来没有整理查阅过数组的原生方法，所以对什么时候用 map, 什么时候用 forEach 并不是很明确，完全看心情。只是知道 map有返回值而 forEach 没有需要自己操作，所以今天准备好好梳理一下记录下来。","text":"一直以来没有整理查阅过数组的原生方法，所以对什么时候用 map, 什么时候用 forEach 并不是很明确，完全看心情。只是知道 map有返回值而 forEach 没有需要自己操作，所以今天准备好好梳理一下记录下来。 两个操作都有相同的部分 都只能遍历数组 都可以循环遍历数组中的每一项 第一个参数都是 callback 函数，且该函数接收三个参数（ item, index, array ） 都有可选的第二个参数 thisArg 可改变 callback 中 this 的值（这个可以忽略基本用不到） 不同的是： map 有返回值，而 forEach 没有 map 的运行速度更快 map 可以被链式调用（ forEach 因为没有返回值不能被链式调用） 所以哪个更好？如果你想改变数组并且返回一个新数组时候推荐使用 .map()，不光是因为它会返回一个新数组和速度快，而且可以被链式调用继续操作返回的数组。 如果只是单纯想操作数据但是不想返回一个数组时，使用 .forEach() 就可以省略多余的步骤。 拓展 如果已访问的元素在迭代时被删除了（ 例如使用 .shift() 操作了原数组 ），之后的元素将被跳过 var words = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;]; words.forEach(function(word) &#123; console.log(word); if (word === &quot;two&quot;) &#123; words.shift(); &#125; &#125;); // =&gt; one // =&gt; two // =&gt; four // 这里的 three 被跳过了 为什么都说 map 和 forEach 不会改变原数组？因为不管是 map 还是 forEach，当中的 item 都是拷贝的对象，你去直接修改他不会影响原数组，但是你去修改其内部的属性，就会影响。类似于深浅拷贝的问题，所以说不能修改原数组也不是绝对的，看你怎么修改操作数据的。 最近真的时间很紧张，都没有空闲的时间好好的去整理，等有时间了准备梳理一下被 VueJS 改写的 7 个数组原生方法：push, pop, shift, unshift, splice, sort, reverse 参考 Array.prototype.forEach() Array.prototype.map() JS 中 map 和 forEach 的区别","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"},{"name":"挖坑","slug":"挖坑","permalink":"https://yogwang.site/tags/%E6%8C%96%E5%9D%91/"}]},{"title":"「 TypeScript 笔记 」 楔子","slug":"TypeScript-learning-00","date":"2020-02-27T02:03:51.000Z","updated":"2026-01-05T05:39:58.479Z","comments":true,"path":"2020/TypeScript-learning-00/","permalink":"https://yogwang.site/2020/TypeScript-learning-00/","excerpt":"这两天同时写 3 个项目，脑子有点乱，每天白天写一个晚上另外写一个，第二天可能就是第三个项目，所以每天上午到公司之后有大概 1 个多小时就处于梦游的状态，就等着群里有谁提问题，然后我解决的时候可以把脑回路给转换过来，但是这段时间可能因为疫情的原因吧，活跃的人越来越少了，还是自己写写 demo 把今年要学的 TS 给学起来吧。 本来是想等到 Vue 更新 3.0 的时候再学的，但是感觉可能等到 3.0 出来了应该要是下半年了，如果上半年就只学习 React，不配合 TS 的就有点太浪费了，好多小伙伴就是用 TS 在开发 React 项目。","text":"这两天同时写 3 个项目，脑子有点乱，每天白天写一个晚上另外写一个，第二天可能就是第三个项目，所以每天上午到公司之后有大概 1 个多小时就处于梦游的状态，就等着群里有谁提问题，然后我解决的时候可以把脑回路给转换过来，但是这段时间可能因为疫情的原因吧，活跃的人越来越少了，还是自己写写 demo 把今年要学的 TS 给学起来吧。 本来是想等到 Vue 更新 3.0 的时候再学的，但是感觉可能等到 3.0 出来了应该要是下半年了，如果上半年就只学习 React，不配合 TS 的就有点太浪费了，好多小伙伴就是用 TS 在开发 React 项目。 此文是一篇引子，大概讲述一下为什么要学习 TypeScript、TypeScript 的优点等，可能要等到我全部学习完成之后才能把整篇文章整理写完，可能进度会很慢，因为要同时学习 ReactJS。现在我的对 TS 的了解知之甚少，只知道 TS 是一种强类型的脚本语言， 可以让编写的代码避免一些基础的 Bug，来提高自己的开发效率，并且可以增强项目的可维护性。 ❓ 现存的一些疑问 [update:2024-08-28]💬 为什么要学 TS首先就是类型安全，有了类型检查之后我们在开发过程中会自动捕获错误并即使提示，减少运行时错误和绝大多数的低级、白痴问题。 比如说经典的 Uncaught TypeError: xxx is undefined 和 Uncaught TypeError: xxx is not a function 两个异常抛出。 更好的开发体验，有了类型声明之后现代IDE可以提供良好的类型推导和代码提示、补全功能。在长期维护的项目中也可以提高项目代码的可读性和可维护性。团队协作时即使没有文档，相互之间也可以通过IDE的类型提示，了解各个变量的数据结构、函数入参和返回值。减少大量阅读相关代码理解代码逻辑的成本。 在后期可能的业务重构中也会提高安全性。静态类型检查器可以捕获一些潜在的逻辑错误，确保所有变量、函数参数和返回值的类型保持一致。如果改变了某个函数，类型检查器会在编译时捕获所有受影响的业务。 另外，如果是开源项目使用TS也会增加使用者的开发体验。可以说在开源项目中使用TS是一种负责任的体现。即使不使用TS开发，最好也需要提供类型声明文件（.d.ts 文件） 💬 为什么能避免低级 BUG因为第一个问题提到的 静态类型检查 可以发现潜在的逻辑错误。在开发过程中会需要我们提供变量、函数的明确类型信息。那么如果在声明的类型中并没有对应的属性和方法。那么自然无法通过类型检查器在控制台抛出异常。 💬 TS 有什么好的，为什么 React,Vue,Ng 都开始使用 TS使用TS的好处已经第一个问题中回答了。在 React 和 Vue 中使用TS是可选的，而在 Angular 中是强制开启的。 Angular: Why TypeScript?. Victor Savkin is a co-founder of… | by Victor Savkin | Angular 💬 三大框架哪一个更适合 TS如上一个问题的回答，Angular 是强制使用TS开发的，所以天生就对于TS有非常好的支持。React 也是对TS有良好的支持，TS 也有提供 .tsx 这样的文件后缀类型，来支持在 TS 中书写 JSX 语法。 而 Vue 则需要区分 Vue2 和 Vue3。在 Vue3 中因为使用了 TS 重构了项目，所以现在也如同 React 一样有良好的 TS 支持。但是在 Vue2 中对于 TS 的支持并不友好，如果要选择使用 TS 并不建议你使用 Vue2（虽然可以使用，但是开发体验并不友好）。 💬 TS 除了类型约束还和 JS 有什么区别可能在更早期的JS版本中，TS会提供比JS更多的新特性。但是现在其实JS已经吸收并实现了了很多TS中的新特性。我个人是觉得在实际工作中的业务开发上面，除了类型声明和在此之后提供的衍生功能之外（类型检查、推导功能），并没有更多的优势了。 其它的一些杂物 TS -&gt; JS 的超集 一门静态语言 现阶段可能搭配 React 学习更好，搭配 Vue 2.x 可能有点尴尬 参考 typescript - 一种思维方式 现在还是一篇草稿要整理过，暂时先把一些想法写下来，等学习全部完成了再重新编辑发布，期间应该会有很多版的调整，最终版应该会面目全非","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"未完成","slug":"未完成","permalink":"https://yogwang.site/tags/%E6%9C%AA%E5%AE%8C%E6%88%90/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://yogwang.site/tags/TypeScript/"},{"name":"学习","slug":"学习","permalink":"https://yogwang.site/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"ESlint的格式化风格有很多种，选择哪一种作为自己的代码格式化风格呢？","slug":"choose-the-ESLint-formatting-rule-that-suits-you","date":"2020-02-20T06:04:37.000Z","updated":"2026-01-05T05:39:58.481Z","comments":true,"path":"2020/choose-the-ESLint-formatting-rule-that-suits-you/","permalink":"https://yogwang.site/2020/choose-the-ESLint-formatting-rule-that-suits-you/","excerpt":"这段时间刚刚复工，年前的我负责的一个年会大屏系统公司准备重新整理制作成为商城可售卖版本，然后又来了一个公司服务器租赁的 WebAPP 的项目，我春节期间的外包项目也没有做完。那么给我自身 CodeReview 的时间就不够了，所以需要一个 ESLint 的通配规则来减少我编写的时候小失误，虽然有自己的代码书写习惯，但是并没有强制要求自己，一直以来自己的 ESLint 配置仅具有错误预防功能，并没有使用一个通用的格式化风格，一直考虑的是使用 Airbnb config。 趁着 CLI 在创建项目下载依赖的时间，我想选择一个规则作为我自己的以后的编码风格，根据 CLI 给出的提示，默认可以配置的有三种： ESLint + Airbnb configdetail ESLint + Standard config detail ESLint + Prettier detail","text":"这段时间刚刚复工，年前的我负责的一个年会大屏系统公司准备重新整理制作成为商城可售卖版本，然后又来了一个公司服务器租赁的 WebAPP 的项目，我春节期间的外包项目也没有做完。那么给我自身 CodeReview 的时间就不够了，所以需要一个 ESLint 的通配规则来减少我编写的时候小失误，虽然有自己的代码书写习惯，但是并没有强制要求自己，一直以来自己的 ESLint 配置仅具有错误预防功能，并没有使用一个通用的格式化风格，一直考虑的是使用 Airbnb config。 趁着 CLI 在创建项目下载依赖的时间，我想选择一个规则作为我自己的以后的编码风格，根据 CLI 给出的提示，默认可以配置的有三种： ESLint + Airbnb configdetail ESLint + Standard config detail ESLint + Prettier detail 第一个 Airbnb 我是知道的，后边两个我并不了解，所以去搜索了一下，但是并没有找到一篇详细说明每个规则各自的风格特点，我就只能一个一个的去找，然后整理选择一个自己更喜欢的风格,并且保持下去。 但是我并没有找到一个简短代码片段可以展示它们各自的风格特点，所以就只能大概说一下： 如果使用 Airbnb 和 Standard 的风格那么就是以他人的书写风格来限制自己的书写习惯，并不自由但是强制代码风格统一，多人开发的时候让所有人代码风格感觉像是一个人写出来的，我觉得挺好的而且不需要考虑规则编辑，开箱即用慢慢适应就可以了。 如果使用 prettier 虽然会默认一种风格，但是是可以修改配置文件来达到最偏好的 lint 规则，但是多人开发时要不就选择默认要不就要大家一起讨论制定出一个规则来。如果每个人都配置了文件但是没有上传，或者上传了其他人修改了就会出现意外的警告。 所以我觉得个人开发会适合 prettier 一些，当然多人开发选择也不是不行，只是需要提前规范好，选择 Airbnb 和 Standard 的话就不需要考虑配置，安装了之后直接使用就可以了，适合多人开发以及喜欢开箱即用的人。 附eslint 在线规则配置","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"},{"name":"挖坑","slug":"挖坑","permalink":"https://yogwang.site/tags/%E6%8C%96%E5%9D%91/"},{"name":"ESlint","slug":"ESlint","permalink":"https://yogwang.site/tags/ESlint/"},{"name":"Coding","slug":"Coding","permalink":"https://yogwang.site/tags/Coding/"}]},{"title":"使用 npm-check-updates 更新全局依赖提示 No dependencies","slug":"update-global-dependencies-with-npm-check-updates","date":"2020-02-14T09:20:40.000Z","updated":"2026-01-05T05:39:58.517Z","comments":true,"path":"2020/update-global-dependencies-with-npm-check-updates/","permalink":"https://yogwang.site/2020/update-global-dependencies-with-npm-check-updates/","excerpt":"今天想起自己一直依赖没有更新全局依赖，就直接在 bash 里边输入 ncu -g 居然提示 No dependencies.我就纳闷了，打错命令了吗，为啥提示没有依赖？项目内依赖检查更新是没问题的，但是检测全局依赖就显示没有依赖，换了几个终端还是这个问题。我怀疑是我全局以来的路径设置错了(我是使用 npm 来安装全局依赖，yarn 安装项目依赖)查看了 npm 的全局依赖路径发现没错啊。","text":"今天想起自己一直依赖没有更新全局依赖，就直接在 bash 里边输入 ncu -g 居然提示 No dependencies.我就纳闷了，打错命令了吗，为啥提示没有依赖？项目内依赖检查更新是没问题的，但是检测全局依赖就显示没有依赖，换了几个终端还是这个问题。我怀疑是我全局以来的路径设置错了(我是使用 npm 来安装全局依赖，yarn 安装项目依赖)查看了 npm 的全局依赖路径发现没错啊。 然后去到了 npm-check-updates 的 Github 上找 Issues 看，是不是有解决办法了，但是相关的问题都被关闭了，然后提到的 Issue 里边答的也不一样， 最后在 Issue#146 上边看到了一个回答的思路，所以我就自己去查看源码了。 然后找到了一个问题所在 libs/package-managers/npm.js 中，有一个 defaultPrefix 函数，其中返回了全局依赖的路径，最后返回的数据是错误的。 function defaultPrefix(options) &#123; if (options.prefix) &#123; return Promise.resolve(options.prefix); &#125; const cmd = process.platform === &quot;win32&quot; ? &quot;npm.cmd&quot; : &quot;npm&quot;; return spawn(cmd, [&quot;config&quot;, &quot;get&quot;, &quot;prefix&quot;]).then(prefix =&gt; &#123; // FIX: for ncu -g doesn&#x27;t work on homebrew or windows #146 // https://github.com/tjunnone/npm-check-updates/issues/146 return options.global &amp;&amp; prefix.match(&quot;Cellar&quot;) ? &quot;/usr/local&quot; : // Workaround: get prefix on windows for global packages // Only needed when using npm api directly process.platform === &quot;win32&quot; &amp;&amp; options.global &amp;&amp; !process.env.prefix ? `$&#123;process.env.AppData&#125;\\\\npm` : null; &#125;); &#125; 这个函数查询了一个 prefix 的环境变量，但是在项目的 README 中并没有提到，可能是因为我修改全局依赖的安装目录的时候没有正确的在环境变量中添加新的全局依赖路径，所以他直接获取了默认的 AppData 地址。 解决方法 1.在系统的环境变量中添加名为 prefix 值为你的自定义全局路径即可。(PS.记得重启电脑) 2.修改 npm.js 的 169 行，把 process.env 替换为 npmConfig 也可以，就不需要重启电脑了… 以上","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"},{"name":"Node.js","slug":"Node-js","permalink":"https://yogwang.site/tags/Node-js/"}]},{"title":"一年结束，回顾2019","slug":"summary-at-the-end-of-2019","date":"2020-01-25T12:59:58.000Z","updated":"2026-01-05T05:39:58.514Z","comments":true,"path":"2020/summary-at-the-end-of-2019/","permalink":"https://yogwang.site/2020/summary-at-the-end-of-2019/","excerpt":"前言很快啊，2019 结束了，本来是不想写总结的，因为也没有啥可以总结的，毕竟中间离开了前端圈子一段时间，再回来基本都是接触的新东西。 按照我今年的认知来说，其实我从 16 年实习开始，一直在原地踏步，并没有成长多少，而且学的东西乱七八糟，基本都是业务用到了什么就学什么。 从 接触客户了解需求 到 前端 再到 后端 最后 运维，基本上都沾了点，然后除了 CSS 部分玩出了花，其他都是半瓶子水到处乱晃。 从学校离职之后去到成都就还是找的外包公司去作企业网站模板（当时自己也就这个拿手了，投的也大多都是这个类型的公司），所以技术栈就是 16 年学的那些东西。","text":"前言很快啊，2019 结束了，本来是不想写总结的，因为也没有啥可以总结的，毕竟中间离开了前端圈子一段时间，再回来基本都是接触的新东西。 按照我今年的认知来说，其实我从 16 年实习开始，一直在原地踏步，并没有成长多少，而且学的东西乱七八糟，基本都是业务用到了什么就学什么。 从 接触客户了解需求 到 前端 再到 后端 最后 运维，基本上都沾了点，然后除了 CSS 部分玩出了花，其他都是半瓶子水到处乱晃。 从学校离职之后去到成都就还是找的外包公司去作企业网站模板（当时自己也就这个拿手了，投的也大多都是这个类型的公司），所以技术栈就是 16 年学的那些东西。 然后离开成都到重庆帮女朋友做蛋糕，其实说是帮不如说是打下手，并没有帮到什么忙，多半顶个小工的作用。中间也去面试了一些公司，但是因为自己并没有实际的 Vue/React 项目所以并不如意，结果就是有大概将近 4 个月没有收入，欠下的信用卡也基本在这个时间段刷出来的。 好了废话就那么多，以下是 19 年的回顾。 📃 回顾 20194 月末离开重庆回到嘉兴面试，倒是挺顺利劳动节过了就入职（4 月 30 日拿到 Offer），然后开始学习 VueJS 这大半年下来，全家桶也学的七七八八， 从一开始的这是啥？为啥要这样写？不是绕圈子嘛。到后来 “哎嘛，真香。“ 当初给自己定的目标还算达标了，当初定的也算简单。 学习 Vue 全家桶 Vue.js Vue CLI（还只是处于会用阶段没有仔细看过文档） Vue Router Axios Vuex 使用全家桶做一个项目 拓展学习的部分 项目的包管理技术（npm、yarn 和 npx） 项目打包及编译（webpack 与 babel） WebSocket 长连接的使用（仿微信的客服聊天系统、后端远程控制） ElectronJS 打包成桌面应用 Git 和 SVN 的使用（自己使用 Git,公司项目使用 SVN） Jeecg-boot（VueJs 与 Ant Design of Vue） ThreeJS（年会活动的 WebGL 部分） 前端社区的活跃以及 Github 的使用 从学习到的东西来看，2019 年基本是我从初级前端向中级前端转变的一年。 5 月 正如开头写的一样，从最开始的只会使用 html + css 配合一些 js 或者 jQuery 来写一些企业站模板，到一个组件化的 SPA 项目。 其实回过头来看可能变化的并不多，只是了解一些以前并不清楚的概念，就比如 17 年我看 MeatHill 老师的 尬聊会，视频中提到的一些名词当初听的时候并不知道在说什么，可能一个小时下来听过也就听过了，直到今年再回过头来看才顺利整场听下来。 然后今年最感谢的一位就是 山地人 老师，通俗易懂的讲解了 Vue 全家桶，我最开始学习 VueJS 的思维屏障就是因为 【跟山地人学 Vue.js 系列教程】 打破的，到后边的 webpack 以及 babel 的学习都是一边看文档一边听老师的视频学习的。 当然光看教程不自己动手写 Demo 是不行的，一定要自己动手写 Demo 然后进行调试才能掌握。 6 月 接着就是自己入职之后的第一个项目，用 Vue 去写一个仿微信的客服聊天系统的前端部分，并使用 Electron 打包成桌面应用。那个时候刚刚里明白怎么用 Vue 去写一个单页面应用，怎么安装依赖都没有搞清楚，然后就直接上，还有自己看都没看的 WebSocket 和 瞄了一眼的 Electron。一开始进度很慢，还没有自己的一个书写习惯，然后想自己实例化 axios 也苦难重重，基本都是一边看别人的代码一边自己写。而且第三天，后端就在问 “你写的怎么样了，我这边都好了就等你接对口了”，然后和我说你是用 http 还是 TCP，我有点懵只能硬着头皮说随你，心想说啥我就百度啥呗。大概用了一周的时间出了测试版，然后开始调试，第二周打包上线。（开始整理 Electron 笔记的时间点） 后边就开始写公司的一个模块化商城，应该算是重构之前的一个项目，然后模块化出售。说是要 1 个月左右的时间开始内部测试，但是实际写了超过 2 个月，还没有写完，现在也没有后文了，（中间插进来了一个其它项目要做）现在回过头来看感觉想可能是自己之前动作太慢了，然后正好那个时候公司的安卓端开始测试 Flutter 的可行性，就当成了一个练手项目。Vue 全家桶就是在这个时期学习并运用起来的。 7 月 再就是不断的 3 天左右的小项目进来，一些小的系统查询单页面应用，基本第一天了解完需求之后，第二、第三天就要出结果。（这些项目反复强化自己的掌握程度） 接着就是这个 Blog 的开始，从今年 7 月开始，我把之前整理的笔记用写博客的方式重新整理了一遍，起初是想发布在 segmentfault 上的，但是总会觉得有点麻烦，而且没有文章分类的功能，不知道现在有没有这个功能了。 强迫自己复习学到的知识，查阅大量文档来巩固，确保自己的想法没有摸棱两可或者有错误的理解，也方便之后自己能够回过头来查阅。 然后也可以学习新的东西，比如现在 blog 所使用的 Hexo，就需要搭配 Github Pages ，因为我不想再去买 VPS 来放而且没有在 Github 托管来的方便。也可以顺带的使用 Git 的命令，不至于太久不用而忘记了。然后就遇到了百度不收录的问题，然后去做镜像来解决。 🚩 关于 2020 的小目标 学习 ReactJS 了解并开始使用单元测试 学习 VueJS 3.0 （如果更新 3.0 的话） 学习 TypeScript 了解 Svelte 阅读 《Code Complete》 阅读 《Clean Code》 学习了解 React Native 或 Flutter（如果有时间） 😝 2020 一起加油！ 王阳阳 庚子年 正月初一江南梅里","categories":[{"name":"代码之外","slug":"代码之外","permalink":"https://yogwang.site/categories/%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96/"}],"tags":[{"name":"总结","slug":"总结","permalink":"https://yogwang.site/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"被忽略的两个 Background 新属性(CSS3)","slug":"CSS-neglected-background-attributes","date":"2020-01-18T07:04:16.000Z","updated":"2026-01-05T05:39:58.457Z","comments":true,"path":"2020/CSS-neglected-background-attributes/","permalink":"https://yogwang.site/2020/CSS-neglected-background-attributes/","excerpt":"之前在看一个文章的时候有提到过，background 的这两个属性，确实不常用到，以至于没有几个人知道这两个新属性。和他们同时期出的 background-size 因为经常用到所以被大众所熟知。 对的，这次我要说的是background-origin 和 background-clip 两兄弟","text":"之前在看一个文章的时候有提到过，background 的这两个属性，确实不常用到，以至于没有几个人知道这两个新属性。和他们同时期出的 background-size 因为经常用到所以被大众所熟知。 对的，这次我要说的是background-origin 和 background-clip 两兄弟 background-origin 规定背景的绘制区域。 background-clip 规定背景图片的定位区域。 可选值都是一样的三种： padding-box （相对于内边距框来定位&#x2F;裁剪,background-origin 默认值） border-box （相对于边框盒来定位&#x2F;裁剪，background-clip 默认值） content-box （相对于内容框来定位&#x2F;裁剪） 哥俩好的 DEMObackground-origin background-clip 乍一看两兄弟的作用还是挺像的，可选值也是一样 啥？你问 background-clip 不是多了一个 text？还是草案没确定呢，经常会有草案被废弃的事发生，所以等什么时候通过了再说吧（ 虽然兼容性还行主流浏览器都兼容 查看兼容性 ） background-origin 是把背景图定位的起点修改成为设置的值得盒模型右上角，而 background-clip 则直接粗暴的把背景图按照盒模型进行了裁剪。 所以这俩可以做到什么？暂时还没有想好到底有啥应用场景，看以后会不会用到吧，怪不得会被人遗忘… 怪不得会有 text 这个属性的出现啊","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://yogwang.site/tags/CSS/"}]},{"title":"鼠标移出时颠倒元素过度效果","slug":"CSS-reverse-hover-transition","date":"2020-01-14T03:35:05.000Z","updated":"2026-01-05T05:39:58.460Z","comments":true,"path":"2020/CSS-reverse-hover-transition/","permalink":"https://yogwang.site/2020/CSS-reverse-hover-transition/","excerpt":"今天有一个小伙伴在群里问，怎么让鼠标经过的移出效果和移入效果相反。 比如说移入的时候先让元素增加宽度，接着增加高度，最后显示内部元素，鼠标移出的时候，先收缩高度隐藏元素，最后还原宽度。 看了一些回复有些答非所问，或者推荐用 Js 的。最开始想的是，animation 是不是有一个 direction 属性可以设置反向么，就想看 transition 是不是也有，但是并没有。CSS transition - MDN所以就想着用 :hover 来覆盖原先的 transition","text":"今天有一个小伙伴在群里问，怎么让鼠标经过的移出效果和移入效果相反。 比如说移入的时候先让元素增加宽度，接着增加高度，最后显示内部元素，鼠标移出的时候，先收缩高度隐藏元素，最后还原宽度。 看了一些回复有些答非所问，或者推荐用 Js 的。最开始想的是，animation 是不是有一个 direction 属性可以设置反向么，就想看 transition 是不是也有，但是并没有。CSS transition - MDN所以就想着用 :hover 来覆盖原先的 transition 精简后的 CSS 片段/* 导航元素 */ .nav-item &#123; width: 125px; height: 45px; /* 默认鼠标移出的补间 width 延迟.5s height 延时.3s */ transition: width 0.4s 0.5s, height 0.4s 0.3s; &#125; .nav-item:hover &#123; width: 200px; height: 83px; /* 鼠标移入的补间 width 无延迟 height 延时.3s*/ transition: width 0.4s, height 0.4s 0.3s; &#125; /* 子元素 */ .nav-item a &#123; opacity: 0; /* 默认的补间 opacity 无延迟 */ transition: opacity 0.4s; &#125; .nav-item:hover a &#123; opacity: 1; /* 鼠标移入的补间 opacity 延迟.5s */ transition: opacity 0.4s 0.5s; &#125; :hover 内的是鼠标移入补间，默认的是鼠标移出的补间，并且配合 transition-delay 来达成补间动画执行的顺序。 当鼠标移入 nav-item 时 :hover 内的 transition 会覆盖原先的补间，所以先是 无延时 的宽度改变，然后是 .3s 延时的高度改变，最后是 .5s 延时的子元素透明度补间。 等鼠标离开 nav-item 时 transition 就恢复成默认的，先改变 无延时 的子元素透明度，然后是 .3s 的高度改变，最后是 .5s 延时的宽度改变。 当然可以随意修改 transition-delay 来达到不同的补间动画执行顺序。 来看一下完成之后的 DEMO 吧！ 附transition CSS 属性是 transition-property，transition-duration，transition-timing-function 和 transition-delay 的一个简写属性。 所以使用时尽量按照此顺序书写 .tween &#123; transition: margin-right 2s ease-in-out 0.5s; /* 依次为:需要过渡的属性,持续时间,变化曲线,开始之前的等待时间 */ &#125; /* 等同于 */ .tween &#123; transition-property: margin-right; /* 需要过渡的属性 */ transition-duration: 2s; /* 持续时间 */ transition-timing-function: ease-in-out; /* 变化曲线 可以忽略不写 默认为 ease */ transition-delay: 0.5s; /* 开始之前的等待时间 可以忽略不写 默认为 0 */ &#125; 如果需要用到多个过度属性可以使用 all 来设置 transition-property，但是如果过度效果是不同的需要单独设置并且使用 , 来分割。 /* 设置多个不同过度属性 */ .tween &#123; transition: width 0.4s, height 1s 0.3s; &#125;","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://yogwang.site/tags/CSS/"}]},{"title":"使用 webpack 打包时去除注释和控制台日志","slug":"webpack-ignore-comments-logs","date":"2020-01-13T03:14:17.000Z","updated":"2026-01-05T05:39:58.523Z","comments":true,"path":"2020/webpack-ignore-comments-logs/","permalink":"https://yogwang.site/2020/webpack-ignore-comments-logs/","excerpt":"","text":"开一个坑，今天怎么尝试也都只能在打包的时候去除 console 但是注释还是不会被去除掉。","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"未完成","slug":"未完成","permalink":"https://yogwang.site/tags/%E6%9C%AA%E5%AE%8C%E6%88%90/"},{"name":"Webpack","slug":"Webpack","permalink":"https://yogwang.site/tags/Webpack/"}]},{"title":"Jeecg-boot 开发挖坑日记09 AntD 表单校验","slug":"jeecg-boot-devDiary09","date":"2020-01-09T03:20:11.000Z","updated":"2026-01-05T05:39:58.500Z","comments":true,"path":"2020/jeecg-boot-devDiary09/","permalink":"https://yogwang.site/2020/jeecg-boot-devDiary09/","excerpt":"之前开发的时间比较赶，所以在某些还没弄明白的地方我直接使用了 v-model 来绑定数据，没并没有使用 v-decorator，所以表单验证需要自己手动去写，异常提示也是需要单独的去做， 现在空下来了，重新整理了一下业务代码，总的来说大部分的表单元素都有demo可以对照着看，复杂的部分也只是上传组件或者一些联动的部分。","text":"之前开发的时间比较赶，所以在某些还没弄明白的地方我直接使用了 v-model 来绑定数据，没并没有使用 v-decorator，所以表单验证需要自己手动去写，异常提示也是需要单独的去做， 现在空下来了，重新整理了一下业务代码，总的来说大部分的表单元素都有demo可以对照着看，复杂的部分也只是上传组件或者一些联动的部分。 表单验证使用 this.$form.createForm() 创建的收集器，可以通过 validateFields 和 validateFieldsAndScroll 这两个api对收集器进行数据校验，当然需要提前在 form-item 中配置校验规则。 配置校验规则&lt;a-form-item&gt; &lt;a-input v-decorator=&quot;[&#x27;email&#x27;,&#123; rules: [ &#123; required: true, message: &#x27;请输入您的电子邮箱!&#x27; &#125;, &#123; type: &#x27;email&#x27;, message: &#x27;请输入正确的电子邮箱号!&#x27; &#125;, ], &#125;]&quot; placeholder=&quot;您的电子邮箱 &gt; &lt;a-icon slot=&quot;prefix&quot; type=&quot;mail&quot; /&gt; &lt;/a-input&gt; &lt;/a-form-item&gt; 表单校验methods:&#123; // 保存 handleSubmit() &#123; // 触发表单验证 this.form.validateFields([&#x27;email&#x27;, &#x27;password&#x27;],(err, values) =&gt; &#123; // [&#x27;email&#x27;, &#x27;password&#x27;] 是需要校验的字段名 ... &#125;) &#125;, // 保存 handleSubmit() &#123; // 触发表单验证 this.form.validateFields(,(err, values) =&gt; &#123; // 也可以直接省略 [fieldNames] 校验全部数据 ... &#125;) &#125;, &#125; 这样每次在提交表单时就会触发数据校验，并且在 err 中会返回错误信息，values中返回校验过的数据，搭配 if(!err) 就可以完成业务操作了。 头像上传组件使用 Upload 组件的 picture-card 模式来作为头像上传组件，在@change事件中对 form 进行 setFieldsValue 来赋值给 a-input:hidden 这样就可以进行校验和返回值了。 &lt;template&gt; &lt;a-form :form=&quot;form&quot; @submit.prevent=&quot;handleSubmit&quot;&gt; &lt;a-form-item&gt; &lt;a-upload listType=&quot;picture-card&quot; class=&quot;avatar-uploader&quot; :headers=&quot;headers&quot; :showUploadList=&quot;false&quot; :action=&quot;uploadURL&quot; :beforeUpload=&quot;beforeUpload&quot; @change=&quot;handleChange&quot; &gt; &lt;img v-if=&quot;avatar&quot; :src=&quot;avatar&quot; alt=&quot;avatar&quot; style=&quot;width:100%;&quot; /&gt; &lt;div v-else&gt; &lt;a-icon :type=&quot;loading ? &#x27;loading&#x27; : &#x27;plus&#x27;&quot; /&gt; &lt;div class=&quot;ant-upload-text&quot;&gt;Upload&lt;/div&gt; &lt;/div&gt; &lt;/a-upload&gt; &lt;a-input type=&quot;hidden&quot; v-decorator=&quot;[&#x27;avatar&#x27;, validatorRules.avatar]&quot; /&gt; &lt;/a-form-item&gt; &lt;a-form-item&gt; &lt;a-button type=&quot;primary&quot; html-type=&quot;submit&quot; block&gt;保存&lt;/a-button&gt; &lt;/a-form-item&gt; &lt;/a-form&gt; &lt;/template&gt; &lt;script&gt; export default &#123; name: &#x27;UserInfoEdit&#x27;, data() &#123; return &#123; avatar: &#x27;&#x27;, loading: false, validatorRules: &#123; avatar: &#123; rules: [&#123; required: true, message: &#x27;请上传头像!&#x27; &#125;] &#125;, &#125;, form: this.$form.createForm(this), &#125; &#125;, methods:&#123; // 头像上传前检查 beforeUpload(file) &#123; const isLt2M = file.size / 1024 / 1024 &lt; 2 if (!isLt2M) &#123; this.$message.error(&#x27;图片最大限制为2MB！&#x27;) &#125; return isLt2M &#125;, // 头像修改 handleChange(info) &#123; if (info.file.status === &#x27;uploading&#x27;) &#123; this.loading = true return &#125; if (info.file.status === &#x27;done&#x27;) &#123; this.form.setFieldsValue(&#123; avatar: info.file.response.url &#125;) // 短链接提交给后端的数据 this.avatar = info.file.response.thumbUrl // 赋值给展示链接展示链接 this.loading = false &#125; &#125;, // 保存 handleSubmit() &#123; // 触发表单验证 this.form.validateFields((err, values) =&gt; &#123; if (!err) &#123; // 具体业务代码 &#125; &#125;) &#125;, &#125; &#125; &lt;/script&gt; 当然也可以直接绑定在 Upload 组件上，我只是偷个懒不想再在验证之后去修改数据了。 动态校验规则比如说，可以修改上传数量限制。这个时候直接修改规则并不会直接重新验证，需要重新修改数据之后才会再次校验。 如果动态校验，需要校验的时候在 option 中加上 &#123; force: true &#125; // 伪代码片段 methods:&#123; // 保存 handleSubmit() &#123; // 触发表单验证 this.form.validateFields(&#123; force: true &#125;,(err, values) =&gt; &#123; ... &#125;) &#125;, &#125; 一个FormItem中多个被装饰过的表单元素有时候会遇到这样的的情况，在一个FormItem中有多个Input或者Select联动。 如果只是使用 v-decorator 来装饰会有警告提示： Warning: [antdv: Form.Item] Cannot generate `validateStatus` and `help` automatically, while there are more than one `getFieldDecorator` in it.` 反正就是 一个 Form.Item 建议只放一个被 getFieldDecorator 或 v-decorator 装饰过的 child如果存在多个就需要自己配置 help, required, validateStatus，这点可以在 API文档 中看到。 如何配置呢？附一个伪代码例子 &lt;template&gt; &lt;a-form :form=&quot;form&quot;&gt; &lt;a-form-item :labelCol=&quot;labelCol&quot; :wrapperCol=&quot;wrapperCol&quot; label=&quot;地址&quot; :help=&quot;help&quot; :validateStatus=&quot;validateStatus&quot; &gt; &lt;a-input-group compact&gt; &lt;a-select style=&quot;width:33%&quot; placeholder=&quot; - &quot; v-decorator=&quot;[&#x27;provinceId&#x27;, validatorRules.provinceId]&quot; @change=&quot;handleCityChange&quot; &gt; &lt;a-spin v-if=&quot;regionList.province.fetch&quot; slot=&quot;notFoundContent&quot; size=&quot;small&quot; /&gt; &lt;a-select-option v-for=&quot;i in regionList.province.list&quot; :key=&quot;i.id&quot; :title=&quot;i.regionName&quot; &gt;&#123;&#123; i.regionName &#125;&#125;&lt;/a-select-option&gt; &lt;/a-select&gt; &lt;a-select style=&quot;width:33%&quot; placeholder=&quot; - &quot; v-decorator=&quot;[&#x27;cityId&#x27;,validatorRules.cityId]&quot; @change=&quot;handleCityChange&quot; &gt; &lt;a-spin v-if=&quot;regionList.city.fetch&quot; slot=&quot;notFoundContent&quot; size=&quot;small&quot; /&gt; &lt;a-select-option v-for=&quot;i in regionList.city.list&quot; :key=&quot;i.id&quot; :title=&quot;i.regionName&quot; &gt;&#123;&#123; i.regionName &#125;&#125;&lt;/a-select-option&gt; &lt;/a-select&gt; &lt;a-select style=&quot;width:33%&quot; placeholder=&quot; - &quot; v-decorator=&quot;[&#x27;areaId&#x27;, validatorRules.areaId]&quot; &gt; &lt;a-spin v-if=&quot;regionList.area.fetch&quot; slot=&quot;notFoundContent&quot; size=&quot;small&quot; /&gt; &lt;a-select-option v-for=&quot;i in regionList.area.list&quot; :key=&quot;i.id&quot; :title=&quot;i.regionName&quot; &gt;&#123;&#123; i.regionName &#125;&#125;&lt;/a-select-option&gt; &lt;/a-select&gt; &lt;/a-input-group&gt; &lt;/a-form-item&gt; &lt;a-form-item :wrapperCol=&quot;offsetWrapperCol&quot;&gt; &lt;a-button type=&#x27;primary&#x27; @click=&quot;handleSubmit&quot;&gt;提交&lt;/a-button&gt; &lt;/a-form-item&gt; &lt;/a-form&gt; &lt;/template&gt; &lt;script&gt; export default &#123; name: &#x27;address-modal&#x27;, data() &#123; return &#123; // 自定义校验信息 validateStatus: &#x27;&#x27;, help: &#x27;&#x27;, form: this.$form.createForm(this), confirmLoading:false, // 校验规则 validatorRules: &#123; provinceId: &#123; rules: [&#123; required: true, message: &#x27;请选择省份&#x27; &#125;] &#125;, cityId: &#123; rules: [&#123; required: true, message: &#x27;请选择城市&#x27; &#125;] &#125;, areaId: &#123; rules: [&#123; required: true, message: &#x27;请选择地区&#x27; &#125;] &#125;, &#125;, // 城市列表数据 regionList: &#123; province: &#123; list: [], fetch: false &#125;, city: &#123; list: [], fetch: false &#125;, area: &#123; list: [], fetch: false &#125; &#125;, // 表单栅格 labelCol: &#123; xs: &#123; span: 24 &#125;, sm: &#123; span: 5 &#125; &#125;, wrapperCol: &#123; xs: &#123; span: 24 &#125;, sm: &#123; span: 16 &#125; &#125;, offsetWrapperCol: &#123; xs: &#123; span: 24 &#125;, sm: &#123; span: 16, offset: 5 &#125; &#125;, &#125; &#125;, methods: &#123; handleSubmit() &#123; // 监听表单提交事件，触发表单验证 this.form.validateFields((err, values) =&gt; &#123; if (!err) &#123; // 这里是验证通过之后的操作 &#125; else &#123; // 校验失败，自定义校验信息 // 这边三个值依次取值，返回第一个有错误信息的属性 const onErr = err.provinceId || err.cityId || err.areaId if (onErr &amp;&amp; onErr.errors) &#123; // 如果有错误信息，设置错误状态 this.validateStatus = &#x27;error&#x27; // 一个错误信息内部是校验内容是以数组的形式返回的，可以在data.validatorRules中的rules中看到顺序 this.help = onErr.errors[0].message &#125; else &#123; // 如果没有报错的情况 this.validateStatus = &#x27;success&#x27; this.help = &#x27;&#x27; &#125; &#125; &#125;) &#125;, handleCityChange(value, option) &#123; // 这里是监听改变的业务逻辑，比如获取下级地址列表 &#125;, &#125; &#125; &lt;/script&gt; 两种提交方式（存为草稿和保存发布）保存数据分委两种，一种是存为草稿，另一种是保存并发布； 存为草稿则只需要验证一部分必填字段，其它字段如果填写就校验，并且收集所有已经填写的字段。 保存校验所有字段，并且需要匹配所有规则。 暂时还没有想好，现阶段分开两个函数，存为草稿是在 validateFields 中的规则内填写需要校验的字段，并且在if(!err) 中，使用 getFieldsValue 获取整个表单数据 遇到问题#1. 在表单中使用 &lt;a-switch /&gt; 组件时控制台出现警告Warning: [antd: Checkbox] `value` is not validate prop, do you mean `checked`? 其原因是，没有设置 valuePropName 属性，直接使用 v-decorator 进行绑定时，就会出现这个问题。为其设置 valuePropName 属性为 checked 即可。 &lt;template&gt; &lt;a-form :form=&quot;form&quot;&gt; &lt;a-form-item label=&quot;Switch&quot;&gt; &lt;a-switch v-decorator=&quot;[ &#x27;switch&#x27;, &#123; rules: [], valuePropName: &#x27;checked&#x27;, // 增加此项 initialValue: false &#125; ]&quot; /&gt; &lt;/a-form-item&gt; &lt;/a-form&gt; &lt;/template&gt; 具体可以查看 AntD Vue 的文档 此处 附： AntD Vue 1.5.0+ 增加了新组件FormModel 表单 可以通过 v-model 绑定收集数据，并且校验数据了","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"挖坑","slug":"挖坑","permalink":"https://yogwang.site/tags/%E6%8C%96%E5%9D%91/"},{"name":"Ant-Design-Vue","slug":"Ant-Design-Vue","permalink":"https://yogwang.site/tags/Ant-Design-Vue/"},{"name":"Jeecg-boot","slug":"Jeecg-boot","permalink":"https://yogwang.site/tags/Jeecg-boot/"}]},{"title":"如何让百度收录自己的Github Pages","slug":"How-to-make-GithubPage-included-by-Baidu","date":"2020-01-03T05:59:53.000Z","updated":"2026-01-05T05:39:58.470Z","comments":true,"path":"2020/How-to-make-GithubPage-included-by-Baidu/","permalink":"https://yogwang.site/2020/How-to-make-GithubPage-included-by-Baidu/","excerpt":"为何百度不收录 Github Pages ??? 起初还以为是应为自己写的文章很少关键词检索量不够所以没有被百度收录。等了有几个月，Google 和 Bing 都收录了，百度还是没有动静，就查了下为啥不会被收录… 结果最后发现因为早些年百度统计被劫持然后 DDos 攻击了 Github…对 Github 用户造成了可用性的问题，然后被 Github Ban 掉了，对百度 UA 直接 403。 所以只能靠自己来做一些工作让百度蜘蛛可以收录自己的 Github Pages 具体方式有几种，我选择在国内搭建一个镜像（成本最低，Hexo 支持多个 Git 地址）针对百度蜘蛛，解析到镜像服务器上以此来达到收录 Github Pages 的效果","text":"为何百度不收录 Github Pages ??? 起初还以为是应为自己写的文章很少关键词检索量不够所以没有被百度收录。等了有几个月，Google 和 Bing 都收录了，百度还是没有动静，就查了下为啥不会被收录… 结果最后发现因为早些年百度统计被劫持然后 DDos 攻击了 Github…对 Github 用户造成了可用性的问题，然后被 Github Ban 掉了，对百度 UA 直接 403。 所以只能靠自己来做一些工作让百度蜘蛛可以收录自己的 Github Pages 具体方式有几种，我选择在国内搭建一个镜像（成本最低，Hexo 支持多个 Git 地址）针对百度蜘蛛，解析到镜像服务器上以此来达到收录 Github Pages 的效果 ❗ 重要 ❗Coding.net 的静态托管服务已经于 2021年12月30日 下线，请不要再尝试该本方案。并且现在百度已经可以正常收录 Github Pages 托管的内容了，已经不再需要使用国内镜像的方式来达成被百度收录的目的了。 尊敬的 CODING 用户：因 CODING 产品战略调整，您的 XXX 团队正在使用的 CODING 网站托管服务（旧版），将于 2021 年 12 月 30 日停止服务，届时您项目下的网站将无法访问。项目源码依然保留在您的 CODING 代码仓库中，可部署于其他第三方服务，请尽快迁移您的网站以免受到影响。 不过现在百度收录的机制比较奇怪，快一些的一个月内就能收录，慢一些的长达半年才会被收录。如果不着急的话可以耐心慢慢等收录。着急的话可以考虑各平台的 Serverless 服务来托管静态页面（是收费的）。 国内代码托管平台有很多，这次尝试了两个，一个是 码云，一个是 Coding.net别问我为什么不用 vps，没钱！！！ 码云操作一同之后发现自定义域名需要会员，Coding 不需要。 就选择了 Coding，但是需要实名认证 1、注册 这个都不需要多说了吧….直接上链接吧。Coding.net SignUp 2、创建代码托管仓库 注册好了之后和使用 Github 一样，创建一个项目，选择 代码托管项目 。 项目名称随便填写，我直接填写的用户名因为 Github Pages 是这样要求的，但是 Coding 并没有这个要求；项目标识是你的 Git 仓库标识，起一个自己好记得就行。我输入的 blog，其实填写了项目名称会自动填写进去的。（这个是可以修改的，相应的也要修改本地 Git 的 Origin Url） 然后选择 Git仓库项目描述就随便填咯，反正也就自己用，后边不满意了也可以在项目设置里边修改。 3、绑定 SSH 公钥 创建完成之后在个人设置里边添加自己的 SSH 公钥，如果已经配置 Github Pages 的话这个也不用多说了吧 Coding.net 官方的 配置文档 我之前写的 Git 关联到 GigHub 配置完成之后在本地的 Git Bash 内执行 ssh -T git@e.coding.net，加入信任主机 途中遇到了 Permission denied (publickey). 这个问题 😂原因是自己本地 Git 配置的默认 Keygen 是另外一个，然后忘记自己用的是哪个 Keygen 了，尴尬一直在反复添加我觉得对的那个到 Coding 上，我说怎么一直被拒绝… 4、在 Hexo 内添加 Coding.net 上的仓库 打开自己本地的 Hexo 项目目录，找到根目录下的 _config.yml 文件，在最底部找到 deploy 项，修改 repo deploy: type: git repo: github: https://github.com/&#123;username&#125;/&#123;repositoryname&#125;.github.io coding: https://e.coding.net//&#123;repositoryname&#125;/&#123;gitname&#125;.git Hexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。 然后直接使用 hexo deploy&#x2F;hexo d 就可以自动部署到两个远程仓库中了。 5、部署 Coding Pages 回到 Coding.net 项目中 找到项目左侧菜单中的 构建与部署 下的 静态网站项 点击立即发布静态网站 网站名称不重要，随便填自己能看明白就好；部署来源选择 本项目仓库；触发机制 自动部署；勾选 代码更新时自动部署，选择默认的 推送到 Master 时触发构建 这个是看你需要部署的是主线还是分支了，选择自己用的就好。 点击保存，完成创建。 这时候在页面中会显示你的 Coding Pages 访问地址，点击立即部署，这时候正常的话就会部署成功了。 然后点击在右上角的设置，进入 Coding Pages 设置后滑动到底部，将自己的域名添加到自定义域名列表中。 6、解析域名到 Coding Pages 在自己域名服务商的控制台添加解析记录，类型为 CNAME 这些应该都不用多说了吧。对应之前的解析记录增加不同的解析路线。 要注意的是如果只是想让百度蜘蛛爬取 Coding Pages，正常访问还是走的 Github Pages 的话，解析线路要设置成 百度。（如果想要国内访问 Coding Pages，海外 Github Pages 的话，Coding 的解析路径设置成默认，Github 设置成海外） 等待解析生效就可以在百度的 站长平台 提交 sitemap 让百度收录了 完成 问题申请 SSL&#x2F;TLS 证书失败 Coding Pages 是免费提供 ssl&#x2F;tls 证书的，这样以来部署的博客就支持 https 访问，证书到期前一周，系统自动续签。 但是按照我的这个流程下来申请证书会失败，原因是域名解析的问题，我的默认解析是到 Coding Pages 的，但是海外线路是解析到 Github Pages 上，先停用 Github Pages 的解析再申请，等证书申请成功后再恢复解析即可。 部署失败 EvilType: 21000：综合在最初的 Coding Pages 部署成功之后我在百度站长平台提交了 sitemap.xml， 但是我重新提交了新的文章之后，部署就出现了问题，原因是 Coding Pages 部署接入了腾讯云的 TMS 文本内容安全系统，TMS 识别到我的文章内有违规内容，从而部署失败，导致百度蜘蛛爬取 404（站点都没起来怎么爬取…） 但是我检查了好几遍并没有发现违规的内容,所以邮件联系了 Coding.net，官方回复是： 您好，由于相关政策因素，目前 Pages 的部署接入了系统级的自动审核，系统对于 Pages 的内容进行非常严格的排查，若是部署网站中出现涉政，涉黄，广告，链接 等内容，系统会自动判别为违规，无法部署成功，具体的违规内容涉及方向您可以参考 T-Sec 天御文本内容安全判别标准进行修正：https://cloud.tencent.com/product/tms ，给您造成的不便非常抱歉。 我加粗了问题出现的部分，不知道这个 TMS 管控是怎么识别链接的，现阶段的日志文件看只要我的文章内出现了一些引用链接，就会提示 EvilType: 21000：综合 ，Coding Pages 的自动部署就会失败： 2020/01/16 15:44:21 Fetching depot archive: Ref: refs/heads/master CommitSHA: 974e01660df7063b4d703d7286ae1e8f7dbd9538 2020/01/16 15:44:23 Extracting depot archive. 2020/01/16 15:44:24 The following file contains offending content: 2020/01/16 15:44:24 - Path: 2019/CSS-text_truncation/index.html 2020/01/16 15:44:24 - EvilType: 21000：综合 再次询问客服，回复： 目前是第三方做的检测，我们也在和第三方沟通，还请你耐心等待。 头疼，等一段时间再看吧。如果可以我应该会在之后更新文章，实在不行的话，在看看其它的代码托管平台。 2020.01.16 15:52 尊敬的 CODING 用户：关于 pages 部署时提示文件内容违规问题，我们这边已经联系开发进行定位，目前为了不影响用户使用，我们暂时下线该审查功能，您只需要重新部署一下 pages 即可。 23333，刚刚把文章编辑完，就收到 Coding.net 的通知，现在可以正常部署了，百度收录完成。但是不知道等审查重新上线还会不会被提示违规。 2020.01.16 16:47 2020 年 2 月 18 日更新尝试了几种方法，一直都是链接提交成功了，但是百度抓取网页，查看抓取频率一直都是 0，但是抓取诊断一直都是成功的。不知道什么原因，后边在尝试一下。 添加 robots.txt 无效 修改 DNS 解析 无效 2020 年 6 月 15 日更新突然被百度收录了，也不知道是为啥….因为 CodingNet 的自动部署服务关闭了，所以我国内镜像被我取消了，但是这次突然被收录了。 附 为什么 Github Pages 禁用了百度爬虫？ Github Pages 不被百度蜘蛛抓取的问题 T-Sec 天御 文本内容安全","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://yogwang.site/tags/Hexo/"},{"name":"Github","slug":"Github","permalink":"https://yogwang.site/tags/Github/"}]},{"title":"Js对象 调整属性排序是否有意义","slug":"JS-Object-attribute-sort","date":"2020-01-03T04:36:41.000Z","updated":"2026-01-05T05:39:58.472Z","comments":true,"path":"2020/JS-Object-attribute-sort/","permalink":"https://yogwang.site/2020/JS-Object-attribute-sort/","excerpt":"年会终于结束了，忙了一个月，终于可以开始填坑了。 昨天把之前写了一半的 滚动侦测导航 给写完了。 写的途中就有在思考 对象属性的排序问题， 最开始我是直接用数组的下标作为年份，输出的时候会出现一堆空白 item， 然后改成赋值给一个 timeline 对象，以年为属性名，月份为内部数组元素 但是循环输出内容的时候就发现会按照正序的方式去输出属性。比如我整理好的数据为","text":"年会终于结束了，忙了一个月，终于可以开始填坑了。 昨天把之前写了一半的 滚动侦测导航 给写完了。 写的途中就有在思考 对象属性的排序问题， 最开始我是直接用数组的下标作为年份，输出的时候会出现一堆空白 item， 然后改成赋值给一个 timeline 对象，以年为属性名，月份为内部数组元素 但是循环输出内容的时候就发现会按照正序的方式去输出属性。比如我整理好的数据为 const timeline = &#123; &quot;2020&quot;: [&quot;01&quot;], &quot;2019&quot;: [&quot;12&quot;, &quot;11&quot;, &quot;10&quot;, &quot;09&quot;, &quot;08&quot;, &quot;07&quot;, &quot;06&quot;, &quot;05&quot;, &quot;04&quot;, &quot;03&quot;, &quot;02&quot;, &quot;01&quot;], &quot;2018&quot;: [&quot;12&quot;, &quot;11&quot;, &quot;10&quot;, &quot;09&quot;] &#125;; 那么我使用 Vue 的 v-for 循环输出的时候，其实是从 2018 开始的，配合 flex 布局是达到了效果，但是使用 Js 去滚动的时候出现了问题。自己也思考了很久，最后还是用数组的方式去实现了。 const timeline = [ &#123; year: &quot;2020&quot;, months: [&quot;01&quot;] &#125;, &#123; year: &quot;2019&quot;, months: [&quot;12&quot;, &quot;11&quot;, &quot;10&quot;, &quot;09&quot;, &quot;08&quot;, &quot;07&quot;, &quot;06&quot;, &quot;05&quot;, &quot;04&quot;, &quot;03&quot;, &quot;02&quot;, &quot;01&quot;]&#125;, &#123; year: &quot;2020&quot;, months: [&quot;12&quot;, &quot;11&quot;, &quot;10&quot;, &quot;09&quot;] &#125; ]; 方式二 const timeline = [ [&quot;2020&quot;, [&quot;01&quot;]], [&quot;2019&quot;, [&quot;12&quot;, &quot;11&quot;, &quot;10&quot;, &quot;09&quot;, &quot;08&quot;, &quot;07&quot;, &quot;06&quot;, &quot;05&quot;, &quot;04&quot;, &quot;03&quot;, &quot;02&quot;, &quot;01&quot;]], [&quot;2020&quot;, [&quot;12&quot;, &quot;11&quot;, &quot;10&quot;, &quot;09&quot;]] ]; 这种方式也行，而且代码更简洁，判断是否是新的一年时也方便很多。但是我觉得写 demo 这样可能不够明了还是用了数组包对象的方式来做。 然后昨天夜里刚填完坑，今天上午就有人在群里问对象的属性排序的问题。 正巧别人也有这个疑问，我就接着琢磨了。 然后在 segmentfault 上找到了一样的问题 Js 中如何调换对象属性的位置。 里边直接就有人提到了 意义何在 详细的回答 dablwow80：object 是无序的，看起来像添加顺序也不是稳定的，所以你改变 key 的“顺序”，以及利用这个“顺序”执行一些逻辑，都是不稳定的 具体原因我在大佬群里问了一下。 object 作为 javascript 的一种数据存储格式，采用哈希表的存取方式，而 hashmap 是不保证属性顺序的 基本可以理解为 object 数据存储是没有顺序的 所以，在对有数据顺序有要求的场景下，应该避免使用 object 来存取数据，尽量用 array 来替代。如果可以运用 Map 结构 来存储就可以自定义的顺序来使用。","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"}]},{"title":"CSS 实现条纹背景","slug":"CSS-striped-background","date":"2019-12-20T20:23:40.000Z","updated":"2026-01-05T05:39:58.461Z","comments":true,"path":"2019/CSS-striped-background/","permalink":"https://yogwang.site/2019/CSS-striped-background/","excerpt":"刚刚写年会红包雨的时候用到了 linear-gradient 来实现条纹背景，但是突然卡壳想不起来怎么写了。就去百度一下，所以现在把它记下来，方便以后查阅。","text":"刚刚写年会红包雨的时候用到了 linear-gradient 来实现条纹背景，但是突然卡壳想不起来怎么写了。就去百度一下，所以现在把它记下来，方便以后查阅。 基础部分使用 linear-gradient 实现没有渐变的色块 .color-block &#123; background: linear-gradient(#c498bc 50%, #81a2cf 0); &#125; 横向条纹再上一个基础之上增加 background-size 属性进行 repeat .stripe &#123; background: linear-gradient(#c498bc 50%, #81a2cf 0); background-size: 100% 30px; // 宽度100%, 高度30px 如果没有no-repeat的话他会一直铺满整个div &#125; 竖直条纹再在上一个的基础之上增加 linear-gradient 的朝向，然后交换 background-size 的宽高 .stripe &#123; // 向右填色 如果是 &#x27;to left&#x27; 就是向左填色 background: linear-gradient(to right, #c498bc 50%, #81a2cf 0); background-size: 30px 100%; // 宽度30px, 高度100% &#125; 倾斜条纹倾斜条纹的话就相对麻烦一点了，如果只修改 linear-gradient 的朝向为角度那么就会出现下边这个情况： .stripe1 &#123; background: linear-gradient(45deg, #c498bc 50%, #81a2cf 0); background-size: 30px 100%; &#125; 所以要修改 background-size ,但是只是这样也会有问题： .stripe2 &#123; background: linear-gradient(45deg, #c498bc 50%, #81a2cf 0); background-size: 30px 30px; &#125; 结果是会形成一小块一小块的斜线色块，而不是整个倾斜条纹 所以按照现象修改 linear-gradient 之后为： .stripe3 &#123; background: linear-gradient(45deg, #c498bc 25%, #81a2cf 0, #81a2cf 50%, #c498bc 0, #c498bc 75%, #81a2cf 0 ); background-size: 30px 30px; &#125; 简单的实现时没问题了，但是感觉太长了。如果要简化的话，需要使用的是 repeating-linear-gradient .stripe4 &#123; background: repeating-linear-gradient( 45deg, #81a2cf, #81a2cf 15px, #c498bc 0, #c498bc 30px ); &#125; 这样的话只需要一行就可以实现 .stripe3 的效果了。 以上2019&#x2F;12&#x2F;21 05:00 Update 2024&#x2F;09&#x2F;13时隔将近2000天，我又来更新了。主要是正对于 倾斜条纹 部分的补充。之前对于 linear-gradient 属性的理解还是太粗糙了。 .stripe-new-1 &#123; width: 130px; height: 130px; background:linear-gradient( 45deg, // 旋转角度 #81a2cf 0 50%, // 颜色1 起始位置 结束位置 #c498bc 50% 100% // 颜色2 起始位置 结束位置 ) &#125; 所以在这个理解的基础上，使用 repeating-linear-gradient 就可以实现倾斜的斑马条纹了。其实实现起来是非常简单 👇 .stripe-new-2 &#123; width: 130px; height: 130px; background: repeating-linear-gradient(45deg, #81a2cf 0 15px, #c498bc 15px 30px); &#125; 实现多个颜色的条纹效果，就是在多添加几个颜色： .stripe-new-3 &#123; width: 130px; height: 130px; background: repeating-linear-gradient( 45deg, #81a2cf 0 15px, #c498bc 15px 30px, #9d69d6 30px 45px, #f56e8d 45px 60px ); &#125; 当然其中某一块条纹的颜色也可以设置为透明： .stripe-new-4 &#123; width: 130px; height: 130px; background: // 斑马条纹 repeating-linear-gradient( 45deg, #81a2cf 0 15px, #c498bc 15px 30px, transparent 30px 45px, #f56e8d 45px 60px ), // 叠加渐变底色 linear-gradient(to right, red, blue); &#125; 相关资源linear-gradient() - CSS | MDNrepeating-linear-gradient() - CSS | MDNCSS3如何实现这样的渐变背景? - SegmentFault 思否","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://yogwang.site/tags/CSS/"}]},{"title":"年会开发日记03 - WebSocket长连接获取微信签到用户信息","slug":"AnnualParty-devDiay03","date":"2019-12-20T11:35:24.000Z","updated":"2026-01-05T05:39:58.447Z","comments":true,"path":"2019/AnnualParty-devDiay03/","permalink":"https://yogwang.site/2019/AnnualParty-devDiay03/","excerpt":"接着 年会开发日记 01 的签到墙，里边用到了 WebSocket 来实现用户微信扫码签到，然后后端推送签到用户信息到前端，前端收到数据之后创建元素添加到 3D 墙中。 本来是想直接自己写的，但是有后来又加入了礼品活跃气氛，就要用到用户列表的展示和抽取过程中的随机效果，虽然哪些人获奖是后台返回给我的。所以这些用户信息需要在多组件内共用，那我就懒得自己写了，就去找了 Vue 的组件库了。","text":"接着 年会开发日记 01 的签到墙，里边用到了 WebSocket 来实现用户微信扫码签到，然后后端推送签到用户信息到前端，前端收到数据之后创建元素添加到 3D 墙中。 本来是想直接自己写的，但是有后来又加入了礼品活跃气氛，就要用到用户列表的展示和抽取过程中的随机效果，虽然哪些人获奖是后台返回给我的。所以这些用户信息需要在多组件内共用，那我就懒得自己写了，就去找了 Vue 的组件库了。 参与用户 抽奖效果 所以在 Awesome Vue 中了找了一些关于 Websocket 的插件 vue-socket.io vue-websocket vue-native-websocket 其中 vue-socket.io 和 vue-websocket 是基于 socket.io 的所以需要后端也是 Socket.io 遂放弃，不然会连接上之后会请求服务端的 login 方法，如果服务端不是的话，会不断轮询。 vue-native-websocket顾名思义，就是原生的 WebSocket，并且可以使用 Vuex native websocket implementation for Vuejs 2 and Vuex 安装依赖以后，简单配置一下就可以使用了。 import VueNativeSock from &quot;vue-native-websocket&quot;; Vue.use(VueNativeSock, &quot;ws://localhost:9090&quot;); 也可以启动 Vuex import VueNativeSock from &quot;vue-native-websocket&quot;; import store from &quot;./store&quot;; Vue.use(VueNativeSock, &quot;ws://localhost:9090&quot;, &#123; store: store &#125;); 具体可以看作者写的说明文档，怎么在 Vue 实例中使用和怎么配合 Vuex 和一些基础事件函数","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"年会开发日记","slug":"年会开发日记","permalink":"https://yogwang.site/tags/%E5%B9%B4%E4%BC%9A%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"},{"name":"WebSocket","slug":"WebSocket","permalink":"https://yogwang.site/tags/WebSocket/"}]},{"title":"年会开发日记02 - 红包雨","slug":"AnnualParty-devDiay02","date":"2019-12-17T13:12:50.000Z","updated":"2026-01-05T05:39:58.445Z","comments":true,"path":"2019/AnnualParty-devDiay02/","permalink":"https://yogwang.site/2019/AnnualParty-devDiay02/","excerpt":"鸽了6个月了，终于想起来这篇还没有写完… 年会预备了一个红包雨的活动，虽然到最后也没有用上，但是笔记还是要写的。整个流程是关注公众号，然后回复 抢红包 返回一个授权地址获取用户授权信息，然后跳转到活动h5页面，抢红包的同时会在大荧幕上实时展示排名数据。","text":"鸽了6个月了，终于想起来这篇还没有写完… 年会预备了一个红包雨的活动，虽然到最后也没有用上，但是笔记还是要写的。整个流程是关注公众号，然后回复 抢红包 返回一个授权地址获取用户授权信息，然后跳转到活动h5页面，抢红包的同时会在大荧幕上实时展示排名数据。 📱 先说说手机端部分 手机端的部分其实很简单，从url上边获取用户的 openID,然后请求接口返回用户信息，这个时候也会返回活动是否开始的状态 活动并没有开始，那么就进入手动进入的页面，用户手动点击按钮进入 活动入口页； 活动已经开始则直接进入 预开始页； 缺失openID，提示授权失败返回授权页面重新获取授权。 参与用等待大荧幕指令，在大银幕倒数时就可以点击开始按钮进入同步的倒计时页面，同时会请求后端数据，这个时候后端会返回给我该用户被分配到的金额（哈，你没看错，后台已经按照设置的总金额给每个用户分配好了红包金额），然后按照分配到的金额数来判断是否会刷出 188、88 等大红包，怕用户错过这个大红包还做了特殊的样式（金色红包），剩下的金额则按照设置的持续时间数来生成具体的红包雨，一般来说会在收到数据的同时生成完红包雨数据，倒计时结束之后就开始下落。 生成红包金额代码片段// 红包金额分配 rainBuild() &#123; let total = this.info.amount; // 总金额 let lucky = []; // 红包雨数组 // 分配188红包 if (total &gt; 18800) &#123; total -= 18800; lucky.push(&#123; amount: 18800 &#125;); &#125; // 分配88红包 if (total &gt; 8800) &#123; total -= 8800; lucky.push(&#123; amount: 8800 &#125;); &#125; const timer = 10; // 拆分成10组 let data = []; // 临时红包数据 // 红包雨数量限制 const length = Math.max( Math.ceil(((this.info.duration / 1000) * 4) / timer), 1 ); // 平均每组金额 const amount = total / timer; // 循环生成每组红包数据 for (let i = 0; i &lt; timer; i++) &#123; let temp = this.randomAlloc(amount, length, 0, amount); // 传入数据为 金额，数量，最小金额，最大金额 data.push(...temp); &#125; // 打乱红包数据 if (lucky.length) &#123; lucky.forEach(item =&gt; &#123; let random = Math.floor(Math.random() * (data.length - 10)); data.splice(random, 0, item); &#125;); &#125; this.data = data; &#125; // 金额生成 randomAlloc(total, length, min, max) &#123; // 首先要判断是否符合 min 和 max 条件 if (min * length &gt; total || max * length &lt; total) &#123; throw Error(`没法满足最最少 $&#123;min&#125; 最大 $&#123;max&#125; 的条件`); &#125; const result = []; let restValue = total; let restLength = length; for (let i = 1; i &lt; length; i++) &#123; restLength--; // 这一次要发的数量必须保证剩下的要足最小量 // 同进要保证剩下的不能大于需要的最大量 const restMin = restLength * min; const restMax = restLength * max; // 可发的量 const usable = restValue - restMin; // 最少要发的量 const minValue = Math.max(min, restValue - restMax); // 以 minValue 为最左，max 为中线来进行随机，即随机范围是 (max - minValue) * 2 // 如果这个范围大于 usable - minValue，取 usable - minValue const limit = Math.min(usable - minValue, (max - minValue) * 2); // 随机部分加上最少要发的部分就是应该发的，但是如果大于 max，最大取到 max const amount = Math.min( max, minValue + Math.floor(limit * Math.random()) ); result.push(&#123; amount: amount &#125;); restValue -= amount; &#125; result[length - 1] = &#123; amount: Math.floor(restValue) &#125;; return result; &#125;, 下落的具体代码我从Github上找了一个开源的红包下落的构造函数，然后按照公司的需求改写了一下，直接贴上来吧： function luckyMoney(options) &#123; this.el = options.el; // 容器对象 this.rain = []; // 红包雨数组 this.speed = options.speed; // 红包落下的速度 this.density = options.density; // 红包下落的密度 this.callback = options.callback; // 回调 &#125; // 创建红包 luckyMoney.prototype.create = function(id, amount) &#123; const el = this.el, // 容器 lucky = document.createElement(&quot;span&quot;); // 创建一个span元素 let flag = true; // 标志为true lucky.setAttribute(&quot;amount&quot;, amount); // 设置红包金额 lucky.setAttribute(&quot;title&quot;, (amount / 100).toFixed(2)); // 设置红包金额 lucky.className = &quot;luckyMoney&quot;; // 设置类名 luckyMoney if (amount &gt; 1000) lucky.setAttribute(&quot;lucky&quot;, &quot;lucky&quot;); lucky.style.left = Math.random() * (el.clientWidth * 0.5) + el.clientWidth * 0.2 + &quot;px&quot;; // 设置 left 初始位置 lucky.style.top = -el.clientHeight / 10 + &quot;px&quot;; // 设置 top 初始位置 el.appendChild(lucky); // 把虚拟节点添加到容器内 this.rain.push(lucky); // 把红包元素添加到红包雨数组内 this.move(lucky); // 开始移动红包元素 // 打开红包 var handler = e =&gt; &#123; // 如果flag为真 -&gt; 红包未点开过 if (flag === true) &#123; e.target.className = &quot;luckyMoney opened&quot;; // 添加已打开类名 opened this.callback(e); // 回调 flag = false; // 标志改为false &#125; else &#123; return; // 跳出 &#125; &#125;; // 添加触摸事件 document.addEventListener(&quot;touchstart&quot;, function(e) &#123; // 如果被点击的元素类名为 luckyMoney if (e.target.className === &quot;luckyMoney&quot;) &#123; handler(e); // 触发红包打开事件 &#125; else if (e.target.getAttribute(&quot;amount&quot;) === &quot;0&quot;) &#123; e.target.className = &quot;luckyMoney luckyMoneyNone&quot;; // 如果红包金额为 0修改类名为 luckyMoneyNone &#125; else &#123; return false; // 其它直接返回 &#125; &#125;); &#125;; // 红包开始下落 luckyMoney.prototype.start = function(data) &#123; let i = 0; // 计数器 // 按照红包密度时间创建红包 this.timer = setInterval(() =&gt; &#123; // 如果没有超过红包总数 if (i &lt; data.length) &#123; const id = data[i].id, // 红包ID amount = data[i].amount; // 包红金额 this.create(id, amount); // 创建红包对象 i++; // 计数器+1 &#125; &#125;, this.density); &#125;; // 红包下落停止 luckyMoney.prototype.stop = function() &#123; clearInterval(this.timer); // 清除计时器 // 清除所有红包的移动计时器 this.rain.forEach(rain =&gt; &#123; clearInterval(rain.timer); &#125;); &#125;; // 红包移动 luckyMoney.prototype.move = function(rain) &#123; const el = this.el; // 容器 let diffY = Math.random() / 2 + 0.4, // 垂直上的轻微偏移 diffX = Math.random() / 2; // 水平上的轻微偏移 const amount = rain.getAttribute(&quot;amount&quot;); // 特殊红包大于10元重置为缓落 if (amount &gt; 1000) &#123; diffY = 0.4; diffX = Math.random() / 10; &#125; // 红包移动按照设置的速率 rain.timer = setInterval(() =&gt; &#123; // 如果y轴偏移吵过1.5 if (diffY &gt; 1.5) &#123; // 设置红包雨的 left 值 rain.style.left = parseInt(rain.style.left) + parseInt((diffX * rain.clientHeight) / 30) + &quot;px&quot;; &#125; else &#123; // 设置红包雨的 left 值 rain.style.left = parseInt(rain.style.left) - parseInt((diffX * rain.clientHeight) / 30) + &quot;px&quot;; &#125; // 设置红包雨的 top 值 rain.style.top = parseInt(rain.style.top) + parseInt((diffY * rain.clientHeight) / 20) + &quot;px&quot;; const position = &#123; top: parseInt(rain.style.top), left: parseInt(rain.style.left) &#125;; if ( position.top &gt; el.clientHeight || position.left &gt; el.clientWidth || position.left &lt; -100 ) &#123; // 超出屏幕过后，清除定时器，删除红包 clearInterval(rain.timer); el.removeChild(rain); &#125; &#125;, this.speed); &#125;; // 时间停止时清除剩余红包 luckyMoney.prototype.clear = function() &#123; const el = this.el, // 容器 redItem = el.childNodes; for (let i = redItem.length - 1; i &gt; -1; i--) &#123; el.removeChild(redItem[i]); &#125; &#125;; export default luckyMoney; 每次点开红包之后会收集金额到 tempMoney 和 totalMoney中，并且提交到后台然后清空 tempMoney（这边做了1秒的节流操作），这样大银幕就能展示当前轮次的 Top5 用户。 手机端的大部分内容就是这样了，主要是下落这块比较麻烦，其它的都是一些样式的问题，稍微调试一下就行了。 🏮大荧幕部分 大银幕这块的话就容易很多了，本来是考虑用 WebSocket 来实时传输红包排名的，但是发现还不如轮询简单，所以还是我这边做了1秒间隔的轮询。获取到数据之后跟新排名数据，界面就会实时刷新了，这边在展示用户排名时做了动画，每次用户新进和排名更替都会进行左右移动，并不只是简单的修改了展示的数据。 用到了transform的偏移量来修改展示的位置，这样就可以通过修改元素次序来打到用户排名更替补间动画了 Stylus片段.rank-box width 90% height 300px max-width 1600px display flex justify-content space-around position absolute left 50% bottom 5vh z-index 5 transform translateX(-50%) .lucky-box width 180px height 260px line-height 25px font-size 18px background url(&#x27;~assets/img/luckyBox.png&#x27;) center no-repeat background-size 100% 100% padding 20px border-radius 15px border #d5b06e 3px solid box-shadow 10px 10px 32px rgba(black, 0.45) display flex justify-content center align-items center flex-direction column position absolute left 50% bottom 0 transform translateX(800px) opacity 1 transition all 0.5s box-sizing border-box &amp;:nth-child(1) transform translateX(-350%) z-index 10 &amp;:nth-child(2) transform translateX(-200%) z-index 9 &amp;:nth-child(3) transform translateX(-50%) z-index 8 &amp;:nth-child(4) transform translateX(100%) z-index 7 &amp;:nth-child(5) transform translateX(250%) z-index 6 &amp;:nth-child(5)~.lucky-box transform translateX(800px) z-index 5 opacity 0 .avatar width (@width / 2) height @width border #d5b06e 4px solid border-radius 50% margin 0 auto 10px display block","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"年会开发日记","slug":"年会开发日记","permalink":"https://yogwang.site/tags/%E5%B9%B4%E4%BC%9A%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"}]},{"title":"Javascript 滚动侦测导航","slug":"JS-navigation-detection","date":"2019-12-09T15:40:07.000Z","updated":"2026-01-05T05:39:58.474Z","comments":true,"path":"2019/JS-navigation-detection/","permalink":"https://yogwang.site/2019/JS-navigation-detection/","excerpt":"一个以前的小项目要改，新增一个根据时间线显示不同月份绩效的需求。没有设计稿，想了下怎么做出来好看。就有了以下这个想法 左侧显示时间线，滑动会显示不同的年份和月份，右侧显示不同月份的统计数据。","text":"一个以前的小项目要改，新增一个根据时间线显示不同月份绩效的需求。没有设计稿，想了下怎么做出来好看。就有了以下这个想法 左侧显示时间线，滑动会显示不同的年份和月份，右侧显示不同月份的统计数据。 为了显示这个想法不是很蠢，所以需要做的很 酷炫 ，其实就是交互友好些，左右块都有相应的交互动作。 预想的效果设想的是，点击左侧月份之后右侧会快速滚动到相应的月份，方便用户操作。当然右侧下滑操作的时候左侧的时间线也会对应的滚动。 那么就要用到滚动侦测了，以前都是用的 UI 框架里边的，所以这次也是直接去翻阅了这个项目所用到的 UI，MuseUI 的文档，当然里边没有这个组件，不然也不会有这篇笔记了 去翻阅了一下 BootStrap 的 Scrollspy 源码，其实就是用到了内容元素的 offsetTop 和滚动条的监听 后端给的数据格式是类似这样的 &#123; date:&#x27;2020-01&#x27;, detail:&#123; a:100, b:78, total:178, machines:967 &#125;, note:&#x27;some text of 2020-01&#x27; &#125;, 所以可以直接使用 computed 返回所有的月份，对，我使用的 Vue 作为框架。 computed: &#123; timeline() &#123; let list = []; const data = this.sourceData; if (!data) return list; data.forEach(item =&gt; &#123; const date = item.date.split(&quot;-&quot;); const year = list.find(item =&gt; item.year === date[0]); if (year) &#123; year.months.push(date[1]); &#125; else &#123; list.push(&#123; year: date[0], months: [date[1]] &#125;); &#125; &#125;); return list; &#125;, &#125;, 尝试过直接使用对象，用年份作为字段名，但是使用 v-for 循环的时候会按照升序打印出来，折腾了有一会放弃了，还是使用数组，记不得前段时间自己是怎么直接用对象实现的时间分组的了 😂 -&gt; Js 对象 调整属性排序是否有意义其实差不多只是匹配的时候稍微麻烦点需要用到 find() 方法。 然后也根据后台返回的数据来计算右侧内容部分每一个月份的 offsetTop computed:&#123; offsetList() &#123; const list = this.$refs[&quot;month-detail&quot;]; let data = list.map(el =&gt; &#123; return &#123; date: el.getAttribute(&quot;date&quot;), offset: el.offsetTop - 100 &#125;; &#125;); return data; &#125; &#125; 这块其实很简单，直接在循环输出的时候注册 ref 即可，然后直接遍历 DOM 元素数组保存 offsetTop 。（但是如果是动态改变的DOM就不能使用 computed 来计算了，具体查看 使用VueJS的计算属性监听DOM元素属性的问题） 然后是点击左侧时间轴右侧内容部分滚动到对应的月份， methods:&#123; // 跳转到对应月份 toMonth(year, month) &#123; this.currTime = `$&#123;year&#125;-$&#123;month&#125;`; const detailItem = this.offsetList.find( item =&gt; item.date === this.currTime ); this.$refs[&quot;wrap&quot;].scrollTo(&#123; top: detailItem.offset, behavior: &quot;smooth&quot; &#125;); &#125;, &#125; 这里有一个 Js 的新东西 behavior: &quot;smooth&quot; 是原生滚动的一个新 API，应该是新 API 哈，以前都没有见到过，这次才发现有这个 Option，也可以考虑使用 CSS 来实现，但是听说兼容性堪忧。最后加上右侧内容的滚动事件绑定 &lt;div class=&quot;wrap&quot; ref=&quot;wrap&quot; @scroll=&quot;scrollSpyNav&quot;&gt; watch: &#123; currTime() &#123; this.scrollTimeline(); &#125; &#125;, methods:&#123; // 滚动侦测导航 scrollSpyNav(e) &#123; clearTimeout(this.timer); const offsetTop = e.target.scrollTop; const curr = this.offsetList.find(item =&gt; item.offset &gt;= offsetTop); this.timer = window.setTimeout(() =&gt; &#123; this.currTime = curr.date; &#125;, 300); &#125;, // 滚动左侧时间线 scrollTimeline() &#123; const el = this.$refs[&quot;month-block&quot;].find( item =&gt; item.getAttribute(&quot;date&quot;) === this.currTime ); this.$refs[&quot;timeline&quot;].scrollTo(&#123; top: el.offsetTop - 50, behavior: &quot;smooth&quot; &#125;); &#125;, &#125; 直接使用了 watch 来侦听的了日期的改变，来触发左侧时间线的滚动，也实现了点击时间轴自动置顶当前月份的效果。顺带写了个计时器，防止抖动…. 🌰 DEMO 兼容 JavaScript - scrollTo [MDN] CSS - scroll-behavior:smooth [Can I use]","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"}]},{"title":"PHPOK 不能创建项目和修改项目信息","slug":"phpok-create-project-failed","date":"2019-12-04T16:10:29.000Z","updated":"2026-01-05T05:39:58.511Z","comments":true,"path":"2019/phpok-create-project-failed/","permalink":"https://yogwang.site/2019/phpok-create-project-failed/","excerpt":"今天写网站的时候直接用了以前的 CMS 框架，并没有在官网下载最新版的。 安装完成之后发现项目不能创建和修改，想起之前做的时候也遇到过这个问题，但是之前的网站，整体的项目总数比初始填充数据少，直接在数据库里边修改了，并且在讨论群和开发团队提了一下。 这次又遇到了在这个问题，就想着开发团队应该解决了这个问题吧，就把程序更新到了最新的 version 5.4，结果还是不行。 去看了下更新日志，就没有提这茬，估计忙忘记了。 好吧，自己动手丰衣足食，自己改吧。","text":"今天写网站的时候直接用了以前的 CMS 框架，并没有在官网下载最新版的。 安装完成之后发现项目不能创建和修改，想起之前做的时候也遇到过这个问题，但是之前的网站，整体的项目总数比初始填充数据少，直接在数据库里边修改了，并且在讨论群和开发团队提了一下。 这次又遇到了在这个问题，就想着开发团队应该解决了这个问题吧，就把程序更新到了最新的 version 5.4，结果还是不行。 去看了下更新日志，就没有提这茬，估计忙忘记了。 好吧，自己动手丰衣足食，自己改吧。 打开控制台查看 Network 请求，发现 Response 里边直接提示了 SQL 执行失败，请检查。 打开 SQL 的调试模式后，详细的报错信息是： 随即找到 control 文件， framework\\admin\\project_control.php 并且在第 326 行找到了 is_api 的赋值语句，把它注释掉。 返回项目管理界面，提交保存 完事，顺便在群里又提了一下，也在论坛发了帖子，这次应该会解决这个问题了吧…","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://yogwang.site/tags/PHP/"},{"name":"PHPOK","slug":"PHPOK","permalink":"https://yogwang.site/tags/PHPOK/"}]},{"title":"年会开发日记01 - 3D签到墙","slug":"AnnualParty-devDiay01","date":"2019-12-03T02:01:35.000Z","updated":"2026-01-05T05:39:58.444Z","comments":true,"path":"2019/AnnualParty-devDiay01/","permalink":"https://yogwang.site/2019/AnnualParty-devDiay01/","excerpt":"年会签到做到最后特效实现的部分，使用 Js 来不断绘制 Canvas 会出现擦除背景图的情况，而且并不流畅，所以又考虑了下 CSS3 的动画属性，可是 Javascript 并不能控制 CSS3 动画。 昨天折腾到晚上 10 点还没怎么好的思路，今天看到一个开源 WebGL Js 库 👉 ThreeJs.org","text":"年会签到做到最后特效实现的部分，使用 Js 来不断绘制 Canvas 会出现擦除背景图的情况，而且并不流畅，所以又考虑了下 CSS3 的动画属性，可是 Javascript 并不能控制 CSS3 动画。 昨天折腾到晚上 10 点还没怎么好的思路，今天看到一个开源 WebGL Js 库 👉 ThreeJs.org 前置文章 Canvas 识别图片内容并使用用户头像拼接 中间不断重写和踩坑的过程就省略了，主要自己也记不得了…. ThreeJS 的 examples 中有一个 Demo 和需求简直一摸一样 👉 CSS3D - Periodic Table 读了一下源码并且添加了释。 import * as THREE from &#x27;../build/three.module.js&#x27;; import &#123; TWEEN &#125; from &#x27;./jsm/libs/tween.module.min.js&#x27;; import &#123; TrackballControls &#125; from &#x27;./jsm/controls/TrackballControls.js&#x27;; import &#123; CSS3DRenderer, CSS3DObject &#125; from &#x27;./jsm/renderers/CSS3DRenderer.js&#x27;; var table = [...]; var camera, scene, renderer; var controls; var objects = []; var targets = &#123; table: [], sphere: [], helix: [], grid: [] &#125;; init(); animate(); function init() &#123; // 创建一个透视相机 视角40，宽高比窗口内宽度/高度，近场1，远场1000 camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 10000 ); camera.position.z = 3000; // 相机置于 z - 3000 scene = new THREE.Scene(); // 创建场景对象 // table 元素周期表 // 循环创建所有数据 for ( var i = 0; i &lt; table.length; i += 5 ) &#123; // 创建一个新的div元素 var element = document.createElement( &#x27;div&#x27; ); element.className = &#x27;element&#x27;; // 设置类名为 element element.style.backgroundColor = &#x27;rgba(0,127,127,&#x27; + ( Math.random() * 0.5 + 0.25 ) + &#x27;)&#x27;; // div.element 设置背景色 rgba // 创建一个新的div元素 var number = document.createElement( &#x27;div&#x27; ); number.className = &#x27;number&#x27;; // 设置类名为 number number.textContent = ( i / 5 ) + 1; // div.number 设置文本内容为 i/5 +1 element.appendChild( number ); // 把 div.number 添加到 div.element 内 // 创建一个新的div元素 var symbol = document.createElement( &#x27;div&#x27; ); symbol.className = &#x27;symbol&#x27;; // div.symbol 设置类名为symbol symbol.textContent = table[ i ]; // div.symbol 的文本内容为 table[i]的内容 element.appendChild( symbol ); // 把 div.symbol 添加到 div.element 内 // 创建一个新的div元素 var details = document.createElement( &#x27;div&#x27; ); details.className = &#x27;details&#x27;; // 设置类名为 details // div.details 的 html 赋值为 table[ i + 1 ] + &#x27;&lt;br&gt;&#x27; + table[ i + 2 ] details.innerHTML = table[ i + 1 ] + &#x27;&lt;br&gt;&#x27; + table[ i + 2 ]; element.appendChild( details ); // 把 div.details 添加到 div.element 内 // 创建一个新的 CSS3D 对象 var object = new CSS3DObject( element ); object.position.x = Math.random() * 4000 - 2000; // 设置 3D对象的 x轴 位置 区间 -2000 ~ 2000 object.position.y = Math.random() * 4000 - 2000; // 设置 3D对象的 y轴 位置 object.position.z = Math.random() * 4000 - 2000; // 设置 3D对象的 z轴 位置 scene.add( object ); // CSS3D 添加对象到场景中 objects.push( object ); // 把 CSS3D 填加到 objects 中 // Object3D // New一个新的三维对象 var object = new THREE.Object3D(); object.position.x = ( table[ i + 3 ] * 140 ) - 1330; // 设置物体的 x轴 位置 object.position.y = - ( table[ i + 4 ] * 180 ) + 990; // 设置物体的 y轴 位置 targets.table.push( object ); // 把object添加到 targets.table 中 &#125; // sphere 球形数据 var vector = new THREE.Vector3(); // 创建一个新的三维向量 // 循环创建所有数据 for ( var i = 0, l = objects.length; i &lt; l; i ++ ) &#123; var phi = Math.acos( - 1 + ( 2 * i ) / l ); // 设置 分割比/phi var theta = Math.sqrt( l * Math.PI ) * phi; // 设置 半径/l 角度/theta // 创建一个新的三维对象 var object = new THREE.Object3D(); object.position.setFromSphericalCoords( 800, phi, theta ); // 设置向量 在球体坐标中 vector.copy( object.position ).multiplyScalar( 2 ); // 复制向量给 object，将该向量与 2 相乘。 object.lookAt( vector ); // 将 object 朝向三维向量的方向 targets.sphere.push( object ); // 把 object 添加到 targets.sphere 中 &#125; // helix 螺旋圆柱的数据 var vector = new THREE.Vector3(); // 创建一个新的三维向量 // 循环创建所有数据 for ( var i = 0, l = objects.length; i &lt; l; i ++ ) &#123; var theta = i * 0.175 + Math.PI; // 设置 角度 theta var y = - ( i * 8 ) + 450; // 设置 y 这边我修改成了 y = i * 1 - (l * 1) / 2 按对象数量去修改y值 // 创建一个新的三维对象 var object = new THREE.Object3D(); object.position.setFromCylindricalCoords( 900, theta, y ); // 设置向量 在圆柱体中 900为半径 y为x-z平面以上的高度 vector.x = object.position.x * 2; // 设置 x轴 位置 vector.y = object.position.y; // 设置 y轴 位置 vector.z = object.position.z * 2; // 设置 z轴 位置 object.lookAt( vector ); // 将object朝向三维向量的方向 targets.helix.push( object ); // 把object添加到 targets.helix 中 &#125; // grid 栅格的数据 // 循环创建所有数据 for ( var i = 0; i &lt; objects.length; i ++ ) &#123; // 创建一个新的三维对象 var object = new THREE.Object3D(); object.position.x = ( ( i % 5 ) * 400 ) - 800; // 设置 x轴 位置 %5为行数 400为间隔 object.position.y = ( - ( Math.floor( i / 5 ) % 5 ) * 400 ) + 800; // 设置 y轴 位置 %5为列数 400为间隔 object.position.z = ( Math.floor( i / 25 ) ) * 1000 - 2000; // 设置 z轴 位置 25为一个平面的元素数量 /* * @description 如果要自己修改行列数，可以修改成 * @param &#123;Integer&#125; row - 行数. * @param &#123;Integer&#125; col - 列数. * @param &#123;Integer&#125; interval - 间隔. * const row = 4 * const col = 8 * const interval = 40 * object.position.x = (i % row) * interval - (row * interval) / 2 + interval / 2; * object.position.y = (Math.floor(i / row) % col) * interval - (col * interval) / 2 + interval / 2; * object.position.z = -Math.floor(i / row / col) * interval; * */ targets.grid.push( object ); // 把object添加到 targets.grid 中 &#125; // renderer renderer = new CSS3DRenderer(); // 创建一个新的CSS 3D渲染器 renderer.setSize( window.innerWidth, window.innerHeight ); // 将渲染器尺寸重新调整为 innerWidth innerHeight document.getElementById( &#x27;container&#x27; ).appendChild( renderer.domElement ); // 将渲染器添加到容器.container 中 // controls controls = new TrackballControls( camera, renderer.domElement ); // 创建一个新的轨迹球控件 controls.minDistance = 500; // 设置最小缩放数 controls.maxDistance = 6000; // 设置最大缩放数 controls.addEventListener( &#x27;change&#x27;, render ); // 添加 change 事件监听，触发render事件 var button = document.getElementById( &#x27;table&#x27; ); // 把 #table 赋值给 button 变量 button.addEventListener( &#x27;click&#x27;, function () &#123; // 给 button 添加点击事件监听，点击后 触发 transform 事件 transform( targets.table, 2000 ); &#125;, false ); var button = document.getElementById( &#x27;sphere&#x27; ); // 把 #sphere 赋值给 button 变量 button.addEventListener( &#x27;click&#x27;, function () &#123; // 给 button 添加点击事件监听，点击后 触发 transform 事件 transform( targets.sphere, 2000 ); &#125;, false ); var button = document.getElementById( &#x27;helix&#x27; ); // 把 #sphere 赋值给 button 变量 button.addEventListener( &#x27;click&#x27;, function () &#123; // 给 button 添加点击事件监听，点击后 触发 transform 事件 transform( targets.helix, 2000 ); &#125;, false ); var button = document.getElementById( &#x27;grid&#x27; ); // 把 #grid 赋值给 button 变量 button.addEventListener( &#x27;click&#x27;, function () &#123; // 给 button 添加点击事件监听，点击后 触发 transform 事件 transform( targets.grid, 2000 ); &#125;, false ); transform( targets.table, 2000 ); // 切换到 table 效果，动作时间为 2000 ms // window.addEventListener( &#x27;resize&#x27;, onWindowResize, false ); // 监听视窗的 resize 事件，每次改变窗口大小是触发 onWindowResize 事件 &#125; // transform function transform( targets, duration ) &#123; TWEEN.removeAll(); // 移除所有补间数据 // 循环所有数据 for ( var i = 0; i &lt; objects.length; i ++ ) &#123; var object = objects[ i ]; // 获取当前对象 var target = targets[ i ]; // 获取当前对象对应形状的数据 // 创建坐标轴移动补间动画，to(目标坐标，动画持续时间) easing(弹性值) start()开始 new TWEEN.Tween( object.position ) .to( &#123; x: target.position.x, y: target.position.y, z: target.position.z &#125;, Math.random() * duration + duration ) .easing( TWEEN.Easing.Exponential.InOut ) .start(); // 创建旋转角度补间动画，to(目标坐标，动画持续时间) easing(弹性值) start()开始 new TWEEN.Tween( object.rotation ) .to( &#123; x: target.rotation.x, y: target.rotation.y, z: target.rotation.z &#125;, Math.random() * duration + duration ) .easing( TWEEN.Easing.Exponential.InOut ) .start(); &#125; // 设置数据更新时render事件，优化render 这里其实我没有怎么明白。 new TWEEN.Tween( this ) .to( &#123;&#125;, duration * 2 ) .onUpdate( render ) .start(); &#125; // 窗口大小改变时 function onWindowResize() &#123; camera.aspect = window.innerWidth / window.innerHeight; // 重新设置相机宽高比 camera.updateProjectionMatrix(); // 更新投影矩阵 renderer.setSize( window.innerWidth, window.innerHeight ); // 重新设置场景渲染器大小 render(); // 触发渲染更新 &#125; // 动画事件触发渲染更新 function animate() &#123; // 每次帧动画更新是触发本身 requestAnimationFrame( animate ); // 补间动画刷新 TWEEN.update(); // 控制器刷新 controls.update(); &#125; // 渲染函数 function render() &#123; // 渲染当前场景 renderer.render( scene, camera ); &#125; 感觉都不用怎么说了。稍微修改一下 element 元素内的内容就可以了。 但是元素不宜多，不然元素移动的时候严重掉帧。 尽量使用元素的组合去作整体的运动 -&gt; Group, 组合之后也可以单独移动内部的元素。 移动镜头来进行元素移动也可以节省一部分的性能消耗 -&gt; Camera 移动 Demo 隔了太久了，先写这么多，等想起来什么了在补全 2020 年 1 月 6 日 17 点 03 分","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Canvas","slug":"Canvas","permalink":"https://yogwang.site/tags/Canvas/"},{"name":"Three.js","slug":"Three-js","permalink":"https://yogwang.site/tags/Three-js/"},{"name":"年会开发日记","slug":"年会开发日记","permalink":"https://yogwang.site/tags/%E5%B9%B4%E4%BC%9A%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0/"}]},{"title":"Canvas识别图片内容并使用用户头像拼接","slug":"html5-canvas-identify-content","date":"2019-12-01T08:27:10.000Z","updated":"2026-01-05T05:39:58.490Z","comments":true,"path":"2019/html5-canvas-identify-content/","permalink":"https://yogwang.site/2019/html5-canvas-identify-content/","excerpt":"今天 12 月了，本来应该开始做外包的项目，但是好歹不好的长智齿了,下午去拔了牙之后看着电脑发呆了一个下午，看来真的麻药影响 🧠 脑子。所以，先写篇文章醒醒脑…. 前天初步实现了下使用 canvas 来识别图片内容，今天就把它记录下来。毕竟 canvas 这部分的内容是真的不懂，现学现卖，欢迎吐槽。📧 MailTo","text":"今天 12 月了，本来应该开始做外包的项目，但是好歹不好的长智齿了,下午去拔了牙之后看着电脑发呆了一个下午，看来真的麻药影响 🧠 脑子。所以，先写篇文章醒醒脑…. 前天初步实现了下使用 canvas 来识别图片内容，今天就把它记录下来。毕竟 canvas 这部分的内容是真的不懂，现学现卖，欢迎吐槽。📧 MailTo 前几天，领导和我说要制作一个年会的活动页面，需要有用户签到展示、企业形象展示、抽奖小游戏。 其中一个需求如下： Logo 签到墙年会的签到墙，使用微信扫码签到，然后后台拿到微信授权之后传给我用户的头像昵称，然后我就在前台展示并且完成一些特效。 需要用头像图片拼接组成图形以及文字内容。这个图形和文字是用户上传的一个纯色内容+透明&#x2F;白色底的图片。👇 我就直接想到用 canvas 来识别图片内容， 前天晚上初步实现了需求，直接暴力的按照设置的 size 大小从左上角不断循环识别到右下角，然后保存有内容的坐标点，再按照坐标来绘制矩形和图片填充。 这边是我实现的效果 👇 识别成栅格用户头像填充 识别内容:const maxWidth = document.body.clientWidth; // 获取视窗宽度 const maxHeight = document.body.clientHeight; // 获取视窗高度 const size = 10; // 设置栅格大小 const points = []; // 坐标数组 const canvas = document.querySelector(&quot;canvas&quot;); // 拿到canvas实例 canvas.width = maxWidth; // 设置canvas宽度 不能使用canvas.style.width来设置，会造成内容拉伸 canvas.height = maxHeight; // 设置canvas高度 const ctx = canvas.getContext(&quot;2d&quot;); // 获取canvas上下文，这边获取的是二维绘图，还有一个3D内容 &quot;webgl&quot; let img = new Image(); // 创建图片实例 img.src = require(&quot;assets/img/text.jpg&quot;); // 获取设置图片url let w = maxWidth; // 设置临时宽度，后边给绘制图片的时候会用到 let h = 0; // 设置临时高度 img.onload = () =&gt; &#123; // img 设置 url 后会立即加载，加载完成后触发 onload 事件 // 图片加载完成 h = (w / img.width) * img.height; // 计算图片高度 ctx.drawImage(img, 0, 0, w, h); // 绘制图片从(0,0)坐标，w为绘制的图片高度，h为绘制的图片高度 // 开始识别 for (let x = 0; x &lt;= w - 10; x += size + 1) &#123; // x轴开始循环 因为我需要有1像素的间隙所以是 size+1 ，如果不需要间隙则 +=size 即可 for (let y = 0; y &lt;= h - 10; y += size + 1) &#123; // y轴开始循环 let color = ctx.getImageData(x, y, size, size).data; // 识别区块内容会 一个像素内返回RGBA四个参数 let count = 0; // 设置计数器 // 以4个一组开始循环 for (let i = 0; i &lt; color.length; i += 4) &#123; // 如果区块中有颜色内容则 count++，我这边识别的是黑色内容 if (color[i] &lt;= 100 || color[i + 1] &lt;= 100 || color[i + 2] &lt;= 100) &#123; count++; &#125; &#125; // 颜色比例超过10%则记录，其实50%也可以，但是会出现 特殊情况1 的问题，下边会提到，但是内容会相对粗一些 if (count &gt;= size * size * 0.1) &#123; points.push(&#123; x: x, y: y &#125;); // 添加到坐标数组 &#125; &#125; &#125; ctx.clearRect(0, 0, maxWidth, maxHeight); // 清除绘制的图片 &#125;; 绘制栅格图ctx.fillStyle = &quot;rgba(255,0,0,.55)&quot;; // 设置填充色 // 遍历坐标数组内的所有数据 points.forEach(piont =&gt; &#123; ctx.fillRect(piont.x, piont.y, size, size); // 绘制矩形 &#125;); 填充图片填充图片和绘制矩形的原理相似所以就不举例了。 考虑到签到的人数有可能达不到坐标的数量，所以在最后可以重新循环用户头像列表来填充满整个栅格区 以上是简单的使用 canvas 试别图片内容，并且栅格化且使用图片填充。 🎈 尾声可能遇到的一些问题 打印points一直是空数组 因为时机不正确，图片加载是异步的，你写的同步代码会先执行，需要把绘制栅格的部分代码放到图片 onload 之后。 栅格没有绘制 #1 因为异步加载的问题，points 数组为空，没有没办法绘制。#2 因为 canvas 容器的高度不够，识别之后绘制的内容不够显示。#3 我用的 Vue.js 写的 Demo，写笔记的时候忘记去掉 this 了，所以 this.size 会有问题，已经修改了。 加载微信头像或者其他来源的头像出现跨域&#x2F;403的情况 尝试在绘制图片的时候为 new Image() 出来的图片实例 增加 img.crossOrigin = &quot;Anonymous&quot;; 属性 识别之后底部、右侧出现一整排&#x2F;列的栅格 尝试调整栅格大小，一般这种情况是因为，识别的栅格太大，最后一排、一列超出的绘制范围拾取不到颜色，各项颜色值都会是0，会被认为是黑色 考虑把笔记重新整理 感觉上每年的年底都会收到邮件来询问这篇笔记的，可能真的要抽时间来完整梳理成文章，而不只是笔记记录一下思路，并且提供一些可预览的DEMO，便于各位学习。P.S. 去年就这样和小伙伴说过了，但是还是一拖再拖，真的自己是拖延症晚期没救了 😂 📌 附 特殊情况 1：如果识别超过 50% 时，笔画交汇时折角会超过 50%，但是没有处在交汇处的内容可能并没有超过 50%调小栅格尺寸会避免大多数的这类情况","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Canvas","slug":"Canvas","permalink":"https://yogwang.site/tags/Canvas/"},{"name":"年会开发日记","slug":"年会开发日记","permalink":"https://yogwang.site/tags/%E5%B9%B4%E4%BC%9A%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0/"},{"name":"HTML","slug":"HTML","permalink":"https://yogwang.site/tags/HTML/"}]},{"title":"记Web端唤起QQ聊天的两种方法","slug":"web-arouse-qq","date":"2019-11-28T01:26:56.000Z","updated":"2026-01-05T05:39:58.523Z","comments":true,"path":"2019/web-arouse-qq/","permalink":"https://yogwang.site/2019/web-arouse-qq/","excerpt":"以前一直使用的 tencent://message/?Menu=yes&amp;uin=&#123;YourQQCode&#125;&amp;Site=&#123;SiteDomain&#125; 来做的 web 端唤起 QQ 在线聊天。这次接了一个外包是自适应的 Web 页面，在手机端点击会提示 Safari 浏览器打不开该网页，应为网址无效。 👇","text":"以前一直使用的 tencent://message/?Menu=yes&amp;uin=&#123;YourQQCode&#125;&amp;Site=&#123;SiteDomain&#125; 来做的 web 端唤起 QQ 在线聊天。这次接了一个外包是自适应的 Web 页面，在手机端点击会提示 Safari 浏览器打不开该网页，应为网址无效。 👇 搜了搜。腾讯的 Tencent://Message 协议，借助的是注册表 （ Windows 操作系统允许我们为自己的应用程序注册为一个协议处理者 详情 ），所以在手机端并不能使用。 手机端唤起 QQ在手机端唤起 QQ，腾讯给了另外一种链接：mqqwpa://im/chat?chat_type=wpa&amp;uin=&#123;YourQQCode&#125;&amp;version=1&amp;src_type=web&amp;web_src=&#123;SiteDomain&#125; 使用的 URL Scheme 的方式来在不同 App 之间传递消息。 然后搭配 Js 来控制不同的设备之间输出不同的链接，就可以。电脑端使用Tencent://Message，手机端使用 mqqwpa://","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"web","slug":"web","permalink":"https://yogwang.site/tags/web/"}]},{"title":"一直以来记错的CSS属性：Position 元素定位","slug":"CSS-position","date":"2019-11-20T03:40:09.000Z","updated":"2026-01-05T05:39:58.460Z","comments":true,"path":"2019/CSS-position/","permalink":"https://yogwang.site/2019/CSS-position/","excerpt":"我一直记忆的是 position:relative 是相对于父级元素定位的，今天才发现原来自己记错了。也想明白了绝对定位的元素使用 margin:auto 为什么可以实现垂直居中 今天早上心有点静不下来，就去 SegmentFault 上看了看文章，有一篇文章 【“寒冬”三年经验前端面试总结之 CSS 篇】，里边的 垂直居中的方法四 我觉得挺奇怪的。","text":"我一直记忆的是 position:relative 是相对于父级元素定位的，今天才发现原来自己记错了。也想明白了绝对定位的元素使用 margin:auto 为什么可以实现垂直居中 今天早上心有点静不下来，就去 SegmentFault 上看了看文章，有一篇文章 【“寒冬”三年经验前端面试总结之 CSS 篇】，里边的 垂直居中的方法四 我觉得挺奇怪的。 .outer &#123; position: relative; &#125; .inner &#123; width: 100px; height: 100px; position: absolute; top: 0; right: 0; bottom: 0; left: 0; margin: auto; &#125; 为什么在 position:absolute 时，top,right,bottom,left 都为 0 时，使用 margin:auto 可以实现垂直居中。 是因为脱离文档流了还是因为别的？然后在群里讨论了下。 有些人说，absolute 之后变成行内块元素了，有些人说因为 margin。 然后我又试了下 relative 、 fixed 和 sticky。 只有 absolute 和 fixed 这种脱离文档流的可以使用 margin:auto来居中。 设置了 left，right为 0 所以可以水平居中，top，bottom为 0 可以使其垂直居中 归根结底是因为 margin:auto 填充了外部空间，然后定位是按照合模型最边界开始定位，即从 margin 开始。 另外还把自己一直以来记错的给掰了回来： position:relative 是相对未定位前的元素自身来定位的。 我一直记忆的是相对于父级做定位。 以上 2019 年 11 月 20 日 2021年7月31日更新：今天在写 数据大屏 “炫酷” 容器边框实现 的时候，突然发现 position:absolute 的定位起始点其实不是从定位祖先的左上角开始的，而是去除 border-width 的，小伙伴们请留意哦。 演示例子 🌰 CodePen link 顺便在补充一下，如果定位的值是百分比，那么这个百分比值是通过其 定位祖先 的 content + padding 值来计算得出的，比如说： .father&#123; width: 1000px; height: 1000px; padding: 50px; border: 50px solid red; position: relative; box-sizing: content-box; /* 默认盒模型 */ &#125; .sub&#123; width: 100px; height: 100px; position: absolute; left: 10%; /* 等同于 left:110px */ &#125; 为什么等于 left:20px？因为父级容器的 width 被 border-area 和 padding-area 撑开了，但是不计算 border-area，所以 left = (contentWidth + paddingWidth*2) * 10% = (1000px + 50px*2) * 10% = 110px 如果把上边的例子的 .father 的盒模型改成 border-box 那么：left: 10% 就等于 left: 90px 了。 为何？ 因为把和模型修改成 border-box 之后，CSS中设置的 width 就等于 border-area + padding-area + content-area 的总和，而因为 width、border-width 和 padding-width 是固定值，所以 content-area 就会被压缩。所以在计算 left 百分比值时需要减去边框所占用的宽度，既是 left = (width - borderWidth*2) * 10% = (1000px - 50px*2) * 10% = 90px 参考position - CSS（层叠样式表） | MDNCSS 基础框盒模型介绍 - CSS（层叠样式表） | MDN","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://yogwang.site/tags/CSS/"}]},{"title":"Jeecg-boot 开发挖坑日记08 Vue 中使用百度地图获取坐标点","slug":"jeecg-boot-devDiary08","date":"2019-11-07T08:22:53.000Z","updated":"2026-01-05T05:39:58.498Z","comments":true,"path":"2019/jeecg-boot-devDiary08/","permalink":"https://yogwang.site/2019/jeecg-boot-devDiary08/","excerpt":"突然想起来项目里边的一个需求，在用户申请称为公司账户的时候需要附加公司地址的百度地图坐标点，以便在 APP 中显示。所以需要用到百度地图的坐标拾取，反正总不可能让用户自己去拾取然后输入到 &lt;input&gt; 中去。 这篇文章就是简单说一下如何在 Vue 项目中使用百度地图。 使用到的组件: Vue-baidu-map 👉 开发手册","text":"突然想起来项目里边的一个需求，在用户申请称为公司账户的时候需要附加公司地址的百度地图坐标点，以便在 APP 中显示。所以需要用到百度地图的坐标拾取，反正总不可能让用户自己去拾取然后输入到 &lt;input&gt; 中去。 这篇文章就是简单说一下如何在 Vue 项目中使用百度地图。 使用到的组件: Vue-baidu-map 👉 开发手册 安装安装依赖总不用说了把，不管你用那种，反正包名没错就对了。 NPM$ npm install vue-baidu-map --save CDN&lt;script src=&quot;https://unpkg.com/vue-baidu-map&quot;&gt;&lt;/script&gt; 快速使用全局注册import Vue from &quot;vue&quot;; import BaiduMap from &quot;vue-baidu-map&quot;; Vue.use(BaiduMap, &#123; ak: &quot;YOUR_APP_KEY&quot; // ak 是在百度地图开发者平台申请的密钥 &#125;); &lt;template&gt; &lt;baidu-map class=&quot;bm-view&quot;&gt; &lt;/baidu-map&gt; &lt;/template&gt; &lt;style&gt; .bm-view &#123; width: 100%; height: 300px; &#125; &lt;/style&gt; 局部调用 如果有按需引入组件的需要，可以选择局部注册百度地图组件，这将减少工程打包后的容量尺寸。局部注册的 BaiduMap 组件必须声明 ak 属性。所有的独立组件均存放在 vue-baidu-map&#x2F;components 文件夹下，按需引用即可。 由于未编译的 ES 模块不能在大多数浏览器中直接运行，如果引入组件时发生运行时错误，请检查 webpack 的 loader 配置，确认 include 和 exclude 选项命中了组件库。 &lt;template&gt; &lt;baidu-map class=&quot;bm-view&quot; ak=&quot;YOUR_APP_KEY&quot;&gt; &lt;/baidu-map&gt; &lt;/template&gt; &lt;script&gt; import BaiduMap from &quot;vue-baidu-map/components/map/Map.vue&quot;; export default &#123; components: &#123; BaiduMap &#125; &#125;; &lt;/script&gt; &lt;style&gt; .bm-view &#123; width: 100%; height: 300px; &#125; &lt;/style&gt; 好，安装完成，让我们 Run 起来。卧槽，怎么是白的？地图呢？ 👇 好，继续查看文档…. 没有设置 center 和 zoom 属性的地图组件是不进行地图渲染的。当 center 属性为合法地名字符串时例外，因为百度地图会根据地名自动调整 zoom 的值。 所以按照例子，在 &lt;baidu-map&gt; 加上 center=&quot;北京&quot; ： ok，跑起来了， 让我们试试另外一种方法，单独设置 center 和 zoom ： 好，快速启动已经没有问题了。 扩展应用时间有限，先把链接放上来，不能同步测试写文档的了。项目完成之后开始写 自动定位https://dafrok.github.io/vue-baidu-map/#/zh/control/geolocation 地区检索https://dafrok.github.io/vue-baidu-map/#/zh/search/local-search 跟随中心点自动赋值https://dafrok.github.io/vue-baidu-map/#/zh/map/baidu-map 自动填充https://dafrok.github.io/vue-baidu-map/#/zh/other/auto-complete 需要配合 &lt;bm-local-search&gt; ,如果需要点选自动切换到对应地区 :auto-viewport=&quot;true&quot; 遇到的问题1. 组件化的时候会造成死循环 组件化的时候 name 和 Vue-baidu-map 的组件重了，换一个就是了。","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"VueJS","slug":"VueJS","permalink":"https://yogwang.site/tags/VueJS/"},{"name":"Jeecg-boot","slug":"Jeecg-boot","permalink":"https://yogwang.site/tags/Jeecg-boot/"}]},{"title":"Jeecg-boot 开发挖坑日记07 多登陆入口","slug":"jeecg-boot-devDiary07","date":"2019-11-07T05:57:06.000Z","updated":"2026-01-05T05:39:58.498Z","comments":true,"path":"2019/jeecg-boot-devDiary07/","permalink":"https://yogwang.site/2019/jeecg-boot-devDiary07/","excerpt":"项目结尾了，但是需要根据用户和管理员设置不同的登陆入口界面， 所以就想着直接在 @/config/router.config.js 中修改基础路由，但是因为不知名原因，路由并没有生效。 感觉像是有设置路由守卫全部都跳转回了 #/user/login","text":"项目结尾了，但是需要根据用户和管理员设置不同的登陆入口界面， 所以就想着直接在 @/config/router.config.js 中修改基础路由，但是因为不知名原因，路由并没有生效。 感觉像是有设置路由守卫全部都跳转回了 #/user/login 在交流群里询问了很久，终于有人回答了，让我去看一下 @/permission.js import ... from &#x27;xxx&#x27; // 一些引入 NProgress.configure(&#123; showSpinner: false &#125;) // NProgress Configuration const whiteList = [&#x27;/user/login&#x27;, &#x27;/user/register&#x27;, &#x27;/user/register-result&#x27;,&#x27;/user/alteration&#x27;] // no redirect whitelist router.beforeEach((to, from, next) =&gt; &#123; NProgress.start() // start progress bar if (Vue.ls.get(ACCESS_TOKEN)) &#123; /* has token */ if (to.path === &#x27;/user/login&#x27;) &#123; next(&#123; path: &#x27;/dashboard/workplace&#x27; &#125;) NProgress.done() &#125; else &#123; if (store.getters.permissionList.length === 0) &#123; store.dispatch(&#x27;GetPermissionList&#x27;).then(res =&gt; &#123; const menuData = res.result.menu; console.log(res.message) if (menuData === null || menuData === &quot;&quot; || menuData === undefined) &#123; return; &#125; let constRoutes = []; constRoutes = generateIndexRouter(menuData); // 添加主界面路由 store.dispatch(&#x27;UpdateAppRouter&#x27;, &#123; constRoutes &#125;).then(() =&gt; &#123; // 根据roles权限生成可访问的路由表 // 动态添加可访问路由表 router.addRoutes(store.getters.addRouters) const redirect = decodeURIComponent(from.query.redirect || to.path) if (to.path === redirect) &#123; // hack方法 确保addRoutes已完成 ,set the replace: true so the navigation will not leave a history record next(&#123; ...to, replace: true &#125;) &#125; else &#123; // 跳转到目的路由 next(&#123; path: redirect &#125;) &#125; &#125;) &#125;) .catch(() =&gt; &#123; /* notification.error(&#123; message: &#x27;系统提示&#x27;, description: &#x27;请求用户信息失败，请重试！&#x27; &#125;)*/ store.dispatch(&#x27;Logout&#x27;).then(() =&gt; &#123; next(&#123; path: &#x27;/user/login&#x27;, query: &#123; redirect: to.fullPath &#125; &#125;) &#125;) &#125;) &#125; else &#123; next() &#125; &#125; &#125; else &#123; if (whiteList.indexOf(to.path) !== -1) &#123; // 在免登录白名单，直接进入 next() &#125; else &#123; next(&#123; path: &#x27;/user/login&#x27;, query: &#123; redirect: to.fullPath &#125; &#125;) NProgress.done() // if current page is login will not trigger afterEach hook, so manually handle it &#125; &#125; &#125;) router.afterEach(() =&gt; &#123; NProgress.done() // finish progress bar &#125;) 一打开我就看到了硕大的几个字 whiteList …. 好吧，原来有设置了白名单，如果不在白名单之内，如果没有权限会直接跳转到 /user/login 然后跳转之前的路径会保存在 query 内的 redirect 中，就出现了路由没有效果的情况 把我们自定义的登陆页 path 放进白名单就好了…..","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"VueJS","slug":"VueJS","permalink":"https://yogwang.site/tags/VueJS/"},{"name":"Jeecg-boot","slug":"Jeecg-boot","permalink":"https://yogwang.site/tags/Jeecg-boot/"},{"name":"Vue-Router","slug":"Vue-Router","permalink":"https://yogwang.site/tags/Vue-Router/"}]},{"title":"Jeecg-boot 开发挖坑日记06 富文本编辑器tinyMCE 图片附件上传","slug":"jeecg-boot-devDiary06","date":"2019-10-31T05:40:20.000Z","updated":"2026-01-05T05:39:58.498Z","comments":true,"path":"2019/jeecg-boot-devDiary06/","permalink":"https://yogwang.site/2019/jeecg-boot-devDiary06/","excerpt":"这个富文本组件本质是 TinyMCE github.com&#x2F;tinymce&#x2F;tinymce，在 Vue 项目中使用的封装库 github.com&#x2F;tinymce&#x2F;tinymce-vue Github 上有一个人回复了，框架是使用的 TinyMCE 这个富文本编辑器的 封装库，所以在其手册里找到了，修改 上传方式的部分","text":"这个富文本组件本质是 TinyMCE github.com&#x2F;tinymce&#x2F;tinymce，在 Vue 项目中使用的封装库 github.com&#x2F;tinymce&#x2F;tinymce-vue Github 上有一个人回复了，框架是使用的 TinyMCE 这个富文本编辑器的 封装库，所以在其手册里找到了，修改 上传方式的部分 内置方法自动上传可以使用内置的 automatic_uploads 方法来上传图片文件，并且使用 images_upload_url 指定上传的 URL 地址，但是对后端返回的数据有要求 #automatic_uploadsEnable or disable automatic upload of images represented by data URLs or blob URIs. Such images get generated, for example, as a result of image manipulation through Image Tools plugin, or after image is drag-n-dropped onto the editor from the desktop.Warning: Note that, this option will do nothing if images_upload_url is not specified. 启用或禁用自动上传由 URL 或 Blob URI 表示的图像。例如，通过 Image Tools 插件的 result，或从本地上传的图片附件。警告：请注意，如果 images_upload_url 未指定，此项将不执行任何操作。 #images_upload_urlThis option lets you specify a URL for the server-side upload handler. Upload will get triggered whenever you call editor.uploadImages() or - automatically, if automatic_uploads option is enabled. Upload handler should return a new location for the uploaded file in the following format: &#123; &quot;location&quot;: &quot;folder/sub-folder/new-location.png&quot; &#125; 此项使您可以指定上传处理的 URL 地址。 每当调用 editor.uploadImages() 或启用了 automatic_uploads 功能，则会自动触发上传。 上传处理程序应以以下格式返回上传文件的新位置： &#123; &quot;location&quot;: &quot;folder/sub-folder/new-location.png&quot; &#125; 例子：tinymce.init(&#123; selector: &quot;textarea&quot;, // change this value according to your HTML automatic_uploads: true, images_upload_url: &quot;postAcceptor.php&quot; &#125;); 自动拼接 base_url 在上传成功返回的图片地址之前 #images_upload_base_pathThis option lets you specify a basepath to prepend to URLs returned from the configured images_upload_url page. 通过此项，可以指定 base_path，并拼接在 images_upload_url 返回的 URL 之前。 例子：tinymce.init(&#123; selector: &quot;textarea&quot;, // change this value according to your HTML automatic_uploads: true, images_upload_url: &quot;postAcceptor.php&quot;, images_upload_base_path: &quot;/some/basepath&quot; &#125;); 自定义上传方法 #images_upload_handlerThe images_upload_handler option allows you to specify a function that is used to replace TinyMCE’s default JavaScript upload handler function with custom logic.The upload handler function takes three arguments: blobInfo, a success callback, and a failure callback. When this option is not set, TinyMCE utilizes an XMLHttpRequest to upload images one at a time to the server and calls the success callback with the location of the remote image. images_upload_handler 可让指定一个函数，该函数用于用自定义逻辑替换 TinyMCE 默认的 JavaScript 上传函数。上传函数采用三个参数：blobInfo, success 回调和 failure 回调，如果此项未设置，则 TinyMCE 会利用 XMLHttpRequest 一次一个将图像上传到服务器，并调用 success 回调 返回的 URL 地址。 Note: Please note that when using this option, no other image uploader options are necessary. Additionally, if you would like TinyMCE to replace the tag’s src attribute with the remote location, please use the success callback defined in the images_upload_handler function with the returned JSON object’s location property. 提示：请注意，使用此项时，不要使用其他图像上传器选项。 此外，如果您希望 TinyMCE 将 &lt;image&gt; 标签的 src 属性替换为远程位置，请使用 images_upload_handler 函数中定义的成功回调 和 返回的 JSON 对象的 location 属性。 例子：tinymce.init(&#123; selector: &quot;textarea&quot;, // change this value according to your HTML images_upload_handler: function(blobInfo, success, failure) &#123; var xhr, formData; xhr = new XMLHttpRequest(); xhr.withCredentials = false; xhr.open(&quot;POST&quot;, &quot;postAcceptor.php&quot;); xhr.onload = function() &#123; var json; if (xhr.status != 200) &#123; failure(&quot;HTTP Error: &quot; + xhr.status); return; &#125; json = JSON.parse(xhr.responseText); if (!json || typeof json.location != &quot;string&quot;) &#123; failure(&quot;Invalid JSON: &quot; + xhr.responseText); return; &#125; success(json.location); &#125;; formData = new FormData(); formData.append(&quot;file&quot;, blobInfo.blob(), blobInfo.filename()); xhr.send(formData); &#125; &#125;); 疑问？1.使用编辑器内置的图片上传方法，为何拼接的是当前的 domain URL,而不是 base_url 使用完整的 URL 地址即可 images_upload_url:&#39;http://www.domain.com/project/Controller/fanction&#39; 2.如按照文档上所说的，使用 images_upload_base_path，是否会自动拼接 URL? 只有在 automatic_uploads: true 时使用的自动上传功能才会拼接 3.如何关闭多媒体附件功能 如在 Jeecg-boot 框架下，注释掉 @/components/jeecg/JEditor.vue 的第 13 行 import &#39;tinymce/plugins/media&#39; MediaPlugin 的引入 去除 tinymce.init() 初始化函数内 plugins 和 toolbar 属性内的 media 即可。 4.为什么会自动替换图片URL为相对路径默认情况下URL会被编辑器自动转化，如果图片URL和当前域名相同的话，如果不希望被自动转换，可以是修改 convert_urls 为 flase。更多内容可以查看官方文档URL handling options | Docs | TinyMCE 附 ISSUES_富文本组件使用方法 #685 TinyMCE github.com&#x2F;tinymce&#x2F;tinymce-vue TinyMCE 使用绝对路径","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Jeecg-boot","slug":"Jeecg-boot","permalink":"https://yogwang.site/tags/Jeecg-boot/"},{"name":"tinyMCE","slug":"tinyMCE","permalink":"https://yogwang.site/tags/tinyMCE/"}]},{"title":"Jeecg-boot 开发挖坑日记05 Axios 异步请求","slug":"jeecg-boot-devDiary05","date":"2019-10-29T07:48:01.000Z","updated":"2026-01-05T05:39:58.498Z","comments":true,"path":"2019/jeecg-boot-devDiary05/","permalink":"https://yogwang.site/2019/jeecg-boot-devDiary05/","excerpt":"一开始以为这里坑很大，结果坑其实并不大，而且内置了很多常用函数，可能是我带有偏见了，所以这篇文章就简短的介绍了一下。 在 @/utils/request.js 中创建了 Axios 实例，并且在 @/api/manage.js 中封装了常用函数只需要在组件内按需导入即可。","text":"一开始以为这里坑很大，结果坑其实并不大，而且内置了很多常用函数，可能是我带有偏见了，所以这篇文章就简短的介绍了一下。 在 @/utils/request.js 中创建了 Axios 实例，并且在 @/api/manage.js 中封装了常用函数只需要在组件内按需导入即可。 Jeecg-boot 封装好了 Axios 的实例，并且导出了可能会用到的一些常用函数： httpAction() putAction() getAction(), 而且内置了一些简单的内置函数： deleteAction() getUserList() getRoleList() getServiceList() getPermissions() saveService() downFile() 只需要在需要使用的组件内 import 即可， 但是封装好了的 Axios 实例默认是 JSON 传输的，所以需要使用 form-data 传输时，需要用 new FormData() 然后 .append() 来传递数据","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Jeecg-boot","slug":"Jeecg-boot","permalink":"https://yogwang.site/tags/Jeecg-boot/"},{"name":"Axios","slug":"Axios","permalink":"https://yogwang.site/tags/Axios/"}]},{"title":"Jeecg-boot 开发挖坑日记04 全局 Vue-AntD 标签页的控制","slug":"jeecg-boot-devDiary04","date":"2019-10-28T05:49:01.000Z","updated":"2026-01-05T05:39:58.498Z","comments":true,"path":"2019/jeecg-boot-devDiary04/","permalink":"https://yogwang.site/2019/jeecg-boot-devDiary04/","excerpt":"开坑 2019 年 10 月 28 日 暂时没有找到好的方法，在不修改原来 layout 框架的情况下。","text":"开坑 2019 年 10 月 28 日 暂时没有找到好的方法，在不修改原来 layout 框架的情况下。 Vue-AntD Tabs 事件名称 说明 回调参数 edit 新增和删除页签的回调，在 type&#x3D;”editable-card” 时有效 (targetKey, action): void 移除 Tab 方法在: @/components/layouts/TabLayout.vue =&gt; remove:117 editPage(key, action) &#123; this[action](key) &#125;, remove(key) &#123; if (key == indexKey) &#123; this.$message.warning(&#x27;首页不能关闭!&#x27;) return &#125; if (this.pageList.length === 1) &#123; this.$message.warning(&#x27;这是最后一页，不能再关闭了啦&#x27;) return &#125; this.pageList = this.pageList.filter(item =&gt; item.fullPath !== key) let index = this.linkList.indexOf(key) this.linkList = this.linkList.filter(item =&gt; item !== key) index = index &gt;= this.linkList.length ? this.linkList.length - 1 : index this.activePage = this.linkList[index] &#125;, 没找到好的解决办法，在考虑直接用 vuex 重写了…","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"未完成","slug":"未完成","permalink":"https://yogwang.site/tags/%E6%9C%AA%E5%AE%8C%E6%88%90/"},{"name":"Ant-Design-Vue","slug":"Ant-Design-Vue","permalink":"https://yogwang.site/tags/Ant-Design-Vue/"},{"name":"VueJS","slug":"VueJS","permalink":"https://yogwang.site/tags/VueJS/"},{"name":"Jeecg-boot","slug":"Jeecg-boot","permalink":"https://yogwang.site/tags/Jeecg-boot/"}]},{"title":"记一个 CSS 伪类的 content 用法","slug":"CSS-pseudo-elements-content","date":"2019-10-28T05:24:26.000Z","updated":"2026-01-05T05:39:58.460Z","comments":true,"path":"2019/CSS-pseudo-elements-content/","permalink":"https://yogwang.site/2019/CSS-pseudo-elements-content/","excerpt":"content: url(&#39;...&#39;); 最近在群里看到一种写伪类 content 的用法，觉得很新奇， 群友一开始使用伪类来显示一个小图标，但是这个小图标比较大，所以他就像设置宽高来显示这个伪类，但是他怎么都设置不了这个伪类的宽高， 我就和他说你设置伪类的宽高不就好了嘛？（我一直以来都是用伪类设置背景图片的形式来做 icon）他说不行，我就看到了这个独特的写法… 他是直接在 content 里边写了图片的 url，然后神奇的是居然可以显示 content 里填写的图片！！！","text":"content: url(&#39;...&#39;); 最近在群里看到一种写伪类 content 的用法，觉得很新奇， 群友一开始使用伪类来显示一个小图标，但是这个小图标比较大，所以他就像设置宽高来显示这个伪类，但是他怎么都设置不了这个伪类的宽高， 我就和他说你设置伪类的宽高不就好了嘛？（我一直以来都是用伪类设置背景图片的形式来做 icon）他说不行，我就看到了这个独特的写法… 他是直接在 content 里边写了图片的 url，然后神奇的是居然可以显示 content 里填写的图片！！！ 我都没有用过,就查阅了一下 MDN 👉 [ content - CSS ] URI 值会指定一个外部资源（比如图片）。如果该资源或图片不能显示，它就会被忽略或显示一些占位（比如无图片标志）。 先来看一下 DEMO 虽然这个方式存在很多问题，但是可以方便很多时候处理图片小图标。 就不需要先设置 content:&#39;&#39; 然后 display:inline-block 再设置宽高在设置背景图片，直接把图片地址放在 content 里边就可以解决问题。很方便，但是这个方式显示的小图标并不能控制它的宽高。不过把图片裁剪成合适大小就可以解决这个问题，而且兼容性还不错。 👉 Can I use 你敢信 IE8 都兼容！","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://yogwang.site/tags/CSS/"}]},{"title":"Jeecg-boot 开发挖坑日记03 动态路由传参","slug":"jeecg-boot-devDiary03","date":"2019-10-24T05:39:50.000Z","updated":"2026-01-05T05:39:58.496Z","comments":true,"path":"2019/jeecg-boot-devDiary03/","permalink":"https://yogwang.site/2019/jeecg-boot-devDiary03/","excerpt":"坑！ @YogWang #2019&#x2F;10&#x2F;24 jeecgboot 针对路由组件的名字做了规则处理，所以默认不是 UserInfo 如果自定义了路由组件名，则采用自定义名； 未定义路由 name (通过 URL 生成路由 name,路由 name 供前端开发，页面跳转使用) @zhangdaiscott #2019&#x2F;10&#x2F;27 Reply 今天写一个带参数页面的时候，怎么样都是 404 然后跳转到 localhost:8080/#/; 显示空白; 看了 Jeecg-Boot 的技术手册完全按照上边来的写也是不行，还是跳转到 /，在 Vue DevTools 中检查又没有问题。就又折腾了好久，又是查文档又是看官方的教学视频。最后真的是烦了，就偷懒了一把，结果成了….原因是啥呢???","text":"坑！ @YogWang #2019&#x2F;10&#x2F;24 jeecgboot 针对路由组件的名字做了规则处理，所以默认不是 UserInfo 如果自定义了路由组件名，则采用自定义名； 未定义路由 name (通过 URL 生成路由 name,路由 name 供前端开发，页面跳转使用) @zhangdaiscott #2019&#x2F;10&#x2F;27 Reply 今天写一个带参数页面的时候，怎么样都是 404 然后跳转到 localhost:8080/#/; 显示空白; 看了 Jeecg-Boot 的技术手册完全按照上边来的写也是不行，还是跳转到 /，在 Vue DevTools 中检查又没有问题。就又折腾了好久，又是查文档又是看官方的教学视频。最后真的是烦了，就偷懒了一把，结果成了….原因是啥呢??? WHY?先来看官方文档： 在菜单管理中如技术文档里边所说，填写 /UserInfo/:id ，并在页面中使用 &lt;router-link :to=&quot;&#123;name:&#39;UserInfo&#39;, params: &#123;id:id&#125;&#125;&quot;&gt;查看&lt;/router-link&gt; 点击按钮跳转会到 / ，不会跳转到 /UserInfo/123456 ，并提示 [vue-router] Route with name &#39;UserInfo&#39; does not exist 。 使用 &lt;router-link :to=&quot;&#39;UserInfo/&#39;+id&quot; /&gt;查看&lt;/router-link&gt; 就可以。在 Vue DevTools 中检查发现，UserInfo 对应的是 Name 是 UserInfo-@id 今天提交了一个 Issues 👉 动态路由的带参 #669，看官方怎么说吧。 先使用偷懒的方法吧 ↓ 2019 年 10 月 25 日已更新↓ 2019 年 10 月 27 日已更新 附&#74;&#x65;&#x65;&#x63;&#x67;&#45;&#98;&#111;&#x6f;&#x74;&#64;&#50;&#x2e;&#x31;&#46;&#x30;（发布日期：20190826）vue@^2.6.10@vue&#x2F;cli@^3.8.0vue-router@^3.0.1 2019 年 10 月 25 日更新使用 :to=&quot;&#39;UserInfo/&#39;+id&quot; 点击多个查看用户后，会创建多个用户资料标签，并且没有激活的方法，来重新获取用户 ID。 👉 修改 : 菜单管理中，最后不添加 /:id ,使用 :to=&quot;&#123;name:&#39;UserInfo&#39;, params: &#123;id:id&#125;&#125;&quot; 直接传参，打开的新标签页可以获得 userID，之后再点击其他用户信息也不会再创建一个新标签，而是直接使用已创建的标签页。 最后 Issues 还没被回复。 2019 年 10 月 27 日更新 zhangdaiscott：jeecgboot 针对路由组件的名字做了规则处理，所以默认不是 UserInfo 如果自定义了路由组件名，则采用自定义名； 未定义路由 name (通过 URL 生成路由 name,路由 name 供前端开发，页面跳转使用)","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Ant-Design-Vue","slug":"Ant-Design-Vue","permalink":"https://yogwang.site/tags/Ant-Design-Vue/"},{"name":"VueJS","slug":"VueJS","permalink":"https://yogwang.site/tags/VueJS/"},{"name":"Jeecg-boot","slug":"Jeecg-boot","permalink":"https://yogwang.site/tags/Jeecg-boot/"}]},{"title":"Hexo 主题开发 -- 代码块颜色高亮","slug":"hexo-theme-development-codeblock","date":"2019-10-19T05:37:18.000Z","updated":"2026-01-05T05:39:58.490Z","comments":true,"path":"2019/hexo-theme-development-codeblock/","permalink":"https://yogwang.site/2019/hexo-theme-development-codeblock/","excerpt":"使用 Hexo 框架，在发布之后会自动给你的代码块进行区分，并没有安装其他依赖。然后根据生成的 html 基础上进行代码高亮。只需要匹配对应类名加上 CSS 样式就可以完成基础的代码高亮。 代码块: HTML Javascript css 代码行 先开坑，慢慢填坑。可能要等到 Jeecg-boot 之后陆陆续续完成，也有可能提前，随缘。","text":"使用 Hexo 框架，在发布之后会自动给你的代码块进行区分，并没有安装其他依赖。然后根据生成的 html 基础上进行代码高亮。只需要匹配对应类名加上 CSS 样式就可以完成基础的代码高亮。 代码块: HTML Javascript css 代码行 先开坑，慢慢填坑。可能要等到 Jeecg-boot 之后陆陆续续完成，也有可能提前，随缘。 HTML 部分&lt;figure class=&#39;.html&#39;&gt; -&gt; html 代码块 .meta -&gt; 源 .line -&gt; 行 .tag -&gt; 标签 .name -&gt; 标签名 .attr -&gt; 属性名 .string -&gt; 字符串 .comment -&gt; 注释 .javascript -&gt; 脚本代码 .function -&gt; 函数 .keyword -&gt; 关键字 .title -&gt; 标题 .params -&gt; 参数 .comment -&gt; 注释 .literal -&gt; 文字 .number -&gt; 数字 .built_in -&gt; 内置方法&#x2F;对象 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot; /&gt; &lt;script src=&quot;http://www.baidu.com/a.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; /* 注释 */ #a &#123; width: 100%; height: auto; border: 1px solid #000; display: block; background: rgb(0, 0, 0); &#125; .b &#123; font-size: 15px; &#125; table input &#123; font-size: 15px; &#125; input[type=&#x27;number&#x27;] &#123; font-size: 15px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;a&quot;&gt;&lt;/div&gt; &lt;div class=&quot;b&quot;&gt;&lt;/div&gt; &lt;form action=&quot;#&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;1&quot; /&gt; &lt;input type=&quot;checkbox&quot; name=&quot;abc&quot; /&gt; &lt;/form&gt; &lt;table border=&quot;1&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;文字&lt;/td&gt; &lt;td&gt;文字&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div style=&quot;border-width:5px;border-style:solid;border-color:red&quot;&gt;&lt;/div&gt; &lt;!-- HTML注释 --&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; function abc() &#123; var num = 120 let abc = &#x27;string&#x27; const setTrue = true for (let i = 0; i &lt;= 10; i++) &#123; console.log(i) &#125; &#125; document.write(&#x27;Hello World!&#x27;) // 单行注释 /* * 多行注释 * */ &lt;/script&gt; &lt;/html&gt; JavaScript 部分import &#123; ERR_OK &#125; from &#x27;base.config.js&#x27; import goodsList from &#x27;components/index/goods/goods_list&#x27; export default &#123; name: &#x27;goods-list&#x27;, data() &#123; return &#123; goods: [], page: 1, size: 10, sort: null, viewMode: &#x27;img&#x27;, allLoaded: false &#125; &#125;, components: &#123; goodsList &#125;, mounted() &#123; this.getGoodsList() Indicator.open() &#125;, methods: &#123; ifelse() &#123; if (type === &#x27;aaa&#x27;) &#123; type = &#x27;bbb&#x27; &#125; else &#123; type = &#x27;aaa&#x27; &#125; &#125;, getGoodsList() &#123; let data = &#123; categoryId: this.categoryId, pageNum: this.page, pageSize: this.size &#125; this.api .getGoodsList(data) .then(res =&gt; &#123; Indicator.close() res = res.data console.log(res) &#125;) .catch(err =&gt; &#123; console.log(err) &#125;) &#125; &#125; &#125; CSS 部分/* 注释 */ #a &#123; width: 100%; height: auto; border: 1px solid #000; display: block; background: rgb(0, 0, 0); &#125; .b &#123; font-size: 15px; &#125; table input &#123; font-size: 15px; &#125; input[type=&#x27;number&#x27;] &#123; font-size: 15px; &#125; @keyframes mymove &#123; from &#123; top: 0px; &#125; to &#123; top: 200px; &#125; &#125; @media (max-width: 650px) &#123; #a &#123; font-size: 12px; &#125; &#125;","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://yogwang.site/tags/Hexo/"},{"name":"未完成","slug":"未完成","permalink":"https://yogwang.site/tags/%E6%9C%AA%E5%AE%8C%E6%88%90/"}]},{"title":"Jeecg-boot 开发挖坑日记02 用户头像上传 / Vue-AntD上传组件","slug":"jeecg-boot-devDiary02","date":"2019-10-17T09:07:24.000Z","updated":"2026-01-05T05:39:58.496Z","comments":true,"path":"2019/jeecg-boot-devDiary02/","permalink":"https://yogwang.site/2019/jeecg-boot-devDiary02/","excerpt":"项目正式开始，第一个功能模块的用户信息编辑就开始卡壳，特别是头像上传组件。 弹出框 a-mdal 的表单值怎么获取到的 ant-design-vue 上传组件的头像上传 使用 ant-design-vue 上传组件的头像上传。在 Jeecg-boot 中头像上传是 antD 的上传组件 listType=&quot;picture-card&quot;，在教程里是直接使用 upload 组件的 defaultFileList API，但他们 DEMO 是 listType=&quot;text&quot;，或 listType=&quot;picture-card&quot; 但绑定的是 fileList，并不是 defaultFileList，就和 ant-design-vue 的文档是一摸一样的照着读了一遍， 然后我直接复制的官方用户头像 DEMO,就出现了问题。","text":"项目正式开始，第一个功能模块的用户信息编辑就开始卡壳，特别是头像上传组件。 弹出框 a-mdal 的表单值怎么获取到的 ant-design-vue 上传组件的头像上传 使用 ant-design-vue 上传组件的头像上传。在 Jeecg-boot 中头像上传是 antD 的上传组件 listType=&quot;picture-card&quot;，在教程里是直接使用 upload 组件的 defaultFileList API，但他们 DEMO 是 listType=&quot;text&quot;，或 listType=&quot;picture-card&quot; 但绑定的是 fileList，并不是 defaultFileList，就和 ant-design-vue 的文档是一摸一样的照着读了一遍， 然后我直接复制的官方用户头像 DEMO,就出现了问题。 AntD 官方 DEMO 点击上传用户头像，并使用 beforeUpload 限制用户上传的图片格式和大小。beforeUpload 的返回值可以是一个 Promise 以支持异步处理，如服务端校验等 &lt;template&gt; &lt;a-upload name=&quot;avatar&quot; listType=&quot;picture-card&quot; class=&quot;avatar-uploader&quot; :showUploadList=&quot;false&quot; action=&quot;https://www.mocky.io/v2/5cc8019d300000980a055e76&quot; :beforeUpload=&quot;beforeUpload&quot; @change=&quot;handleChange&quot; &gt; &lt;img v-if=&quot;imageUrl&quot; :src=&quot;imageUrl&quot; alt=&quot;avatar&quot; /&gt; &lt;div v-else&gt; &lt;a-icon :type=&quot;loading ? &#x27;loading&#x27; : &#x27;plus&#x27;&quot; /&gt; &lt;div class=&quot;ant-upload-text&quot;&gt;Upload&lt;/div&gt; &lt;/div&gt; &lt;/a-upload&gt; &lt;/template&gt; &lt;script&gt; function getBase64(img, callback) &#123; const reader = new FileReader(); reader.addEventListener(&quot;load&quot;, () =&gt; callback(reader.result)); reader.readAsDataURL(img); &#125; export default &#123; data() &#123; return &#123; loading: false, imageUrl: &quot;&quot; &#125;; &#125;, methods: &#123; handleChange(info) &#123; if (info.file.status === &quot;uploading&quot;) &#123; this.loading = true; return; &#125; if (info.file.status === &quot;done&quot;) &#123; // Get this url from response in real world. getBase64(info.file.originFileObj, imageUrl =&gt; &#123; this.imageUrl = imageUrl; this.loading = false; &#125;); &#125; &#125;, beforeUpload(file) &#123; const isJPG = file.type === &quot;image/jpeg&quot;; if (!isJPG) &#123; this.$message.error(&quot;You can only upload JPG file!&quot;); &#125; const isLt2M = file.size / 1024 / 1024 &lt; 2; if (!isLt2M) &#123; this.$message.error(&quot;Image must smaller than 2MB!&quot;); &#125; return isJPG &amp;&amp; isLt2M; &#125; &#125; &#125;; &lt;/script&gt; &lt;style&gt; // css style... &lt;/style&gt; 第一天的时候，我直接复制的 用户头像 DEMO，然后直接使用了 defaultFileList 设置默认头像但是没效果，依然是空白。 找啊找啊找，发现 DEMO 上设置了 :showUploadList=&quot;false&quot;，删之…🙄 还是不行，继续查问题。 发现 defaultFileList 是不能异步设置的，要在组件初始化完成之前就设置好，或者使用 fileList 来设置默认头像 🙃， emmm….怎么还有一个空白头像，原来还有一个 img 标签，删之。 现在的 upload 组件是这样的： &lt;a-upload action=&quot;https://www.mocky.io/v2/5cc8019d300000980a055e76&quot; listType=&quot;picture-card&quot; :defaultFileList=&quot;fileList&quot; @change=&quot;handleChange&quot; &gt; &lt;div v-if=&quot;fileList.length &lt; 1&quot;&gt; &lt;a-icon :type=&quot;loading ? &#x27;loading&#x27; : &#x27;plus&#x27;&quot; /&gt; &lt;div class=&quot;ant-upload-text&quot;&gt;Upload&lt;/div&gt; &lt;/div&gt; &lt;/a-upload&gt; 好，现在基本显示没问题了，但是先要删除原先的头像再上传 等等..删除了头像怎么没出现上传头像按钮？handleChange 事件要修改成： handleChange(&#123; fileList &#125;) &#123; this.fileList = fileList; &#125;, 完事，基本完成。但是… 需求：点击头像就能修改，而不是先要删除原先的头像再上传 所以结合两个官方 DEMO，最后修改如下： &lt;template&gt; // 上下文... &lt;a-upload listType=&quot;picture-card&quot; class=&quot;avatar-uploader&quot; :showUploadList=&quot;false&quot; :action=&quot;uploadURL&quot; :beforeUpload=&quot;beforeUpload&quot; @change=&quot;handleChange&quot; &gt; &lt;img v-if=&quot;imageUrl&quot; :src=&quot;imageUrl&quot; alt=&quot;avatar&quot; style=&quot;width:100%;&quot; /&gt; &lt;div v-else&gt; &lt;a-icon :type=&quot;loading ? &#x27;loading&#x27; : &#x27;plus&#x27;&quot; /&gt; &lt;div class=&quot;ant-upload-text&quot;&gt;Upload&lt;/div&gt; &lt;/div&gt; &lt;/a-upload&gt; // 上下文... &lt;/template&gt; &lt;script&gt; export default &#123; data() &#123; return()&#123; url:&#123; upload: &#x27;/project/upload&#x27; &#125;, imageUrl: &#x27;&#x27;, loading: false &#125; &#125;, computed: &#123; uploadURL() &#123; return `$&#123;window._CONFIG[&#x27;domianURL&#x27;]&#125;$&#123;this.url.upload&#125;` &#125; &#125;, methods:&#123; handleChange(info) &#123; if (info.file.status === &#x27;uploading&#x27;) &#123; this.loading = true return &#125; if (info.file.status === &#x27;done&#x27;) &#123; getBase64(info.file.originFileObj, imageUrl =&gt; &#123; this.imageUrl = imageUrl this.loading = false &#125;) // 这里可以放上传成功后台返回的图片url的表单赋值，使用 form.setFieldsValue 给表单赋值 &#125; &#125;, beforeUpload(file) &#123; const isJPG = file.type === &#x27;image/jpeg&#x27; if (!isJPG) &#123; this.$message.error(&#x27;You can only upload JPG file!&#x27;) &#125; const isLt2M = file.size / 1024 / 1024 &lt; 2 if (!isLt2M) &#123; this.$message.error(&#x27;Image must smaller than 2MB!&#x27;) &#125; return isJPG &amp;&amp; isLt2M &#125; // 初始图片赋值等方法 ... &#125; &lt;/script&gt; &lt;style&gt; // css style... &lt;/style&gt; 弹出框的表单值是怎么设置的？在 edit() 方法中传入了当前对象 record。 AntD 封装了表单域 &lt;Form.Item /&gt; ，需要使用 Form.create 来创建表单实例，而且设置表单的值要用 form.setFieldsValue （有些时候需要确保子组件完成渲染 $nextTick() 后才执行赋值操作） 且使用 pick()[1] 函数从指定的对象中挑选出需要的任意 key 属性。 特殊控件(select,radio,checkbox)需要使用 v-decorator 来绑定数据 [2] 尾声 1,官方 DEMO 的代码差异比较大，特别是 handleChange 部分，需要细看。 2,对后台返回的数据有要求。 3,表单修改需要使用 setFieldsValue 来动态设置其他控件的值。 [ 注 1 ]: pick() 的坑待填，用的 lodash.pick 函数 [ 注 2 ]: 这里的 v-decorator 挖坑，看后边什么时候填上","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"挖坑","slug":"挖坑","permalink":"https://yogwang.site/tags/%E6%8C%96%E5%9D%91/"},{"name":"Ant-Design-Vue","slug":"Ant-Design-Vue","permalink":"https://yogwang.site/tags/Ant-Design-Vue/"},{"name":"VueJS","slug":"VueJS","permalink":"https://yogwang.site/tags/VueJS/"},{"name":"Jeecg-boot","slug":"Jeecg-boot","permalink":"https://yogwang.site/tags/Jeecg-boot/"}]},{"title":"文本开头空格不显示问题","slug":"html-space-display","date":"2019-10-15T03:27:28.000Z","updated":"2026-01-05T05:39:58.490Z","comments":true,"path":"2019/html-space-display/","permalink":"https://yogwang.site/2019/html-space-display/","excerpt":"在 html 中手动输入多个空格，在页面解析的时候都会变成一个空格，如果在开头甚至一个空格都不会显示 但就是一定要求在开头&#x2F;中间显示多个空格，这个问题怎么解决呢？","text":"在 html 中手动输入多个空格，在页面解析的时候都会变成一个空格，如果在开头甚至一个空格都不会显示 但就是一定要求在开头&#x2F;中间显示多个空格，这个问题怎么解决呢？ 1.使用字符实体实体名称 &amp;nbsp; 或者实体编号 &amp;#160; 2.使用全角文字3.使用 CSS 样式控制在容器上添加 white-space:pre CSS 属性 4.使用 &lt;pre&gt; 标签","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://yogwang.site/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"https://yogwang.site/tags/HTML/"}]},{"title":"Jeecg-boot 开发挖坑日记01 Jeecg-Boot是个什么鬼?","slug":"jeecg-boot-devDiary01","date":"2019-10-10T06:37:44.000Z","updated":"2026-01-05T05:39:58.496Z","comments":true,"path":"2019/jeecg-boot-devDiary01/","permalink":"https://yogwang.site/2019/jeecg-boot-devDiary01/","excerpt":"这段时间公司有一个项目是用 Jeecg-Boot 开发的，管理平台部分就分配到我这边了。这段时间看了下他们官方的文档，感觉文档有点少，感觉之后大部分时间都要和这个东西杠上了。 _yogwang 2019.10.10 15:28 what is the fuxk jeecg-boot? Java RAD framework for enterprise web applications 基于代码生成器的 JAVA 快速开发平台,采用前后端分离架构：","text":"这段时间公司有一个项目是用 Jeecg-Boot 开发的，管理平台部分就分配到我这边了。这段时间看了下他们官方的文档，感觉文档有点少，感觉之后大部分时间都要和这个东西杠上了。 _yogwang 2019.10.10 15:28 what is the fuxk jeecg-boot? Java RAD framework for enterprise web applications 基于代码生成器的 JAVA 快速开发平台,采用前后端分离架构： SpringBoot 2.x Ant Design&amp;Vue Mybatis Shiro JWT 代码生成器让前后端代码一键生成，无需写任何代码，绝对是全栈开发福音！！ （现在看来前端开发者的大坑 - yogwang&#x2F;2019.10.17） JeecgBoot 的宗旨是提高 UI 能力的同时,降低前后分离的开发成本，（后端确实是很喜欢） 获取项目git clone https://github.com/zhangdaiscott/jeecg-boot.git cd jeecg-boot/ant-design-jeecg-vue 前端部分基于 Ant Design of Vue 实现的 Ant Design Pro Vue 版 开发环境和依赖 node Ant-Design-Vue 1.x Vue Cli 3.x Vue 2.x Vue router Vuex 3.x Axios Vue-cropper @antv&#x2F;g2 Viser-vue vue-print-nb less eslint webpack 简而言之就是 Java 端生成前台 vue 页面（默认增删改查功能，以及弹出框和抽屉页形式的编辑页）。然后自己把生成的页面移动到 Views 目录下，并在 UI 界面添加路由（vue-router）。 组件库使用的是 Ant-Design-Vue，我觉得最坑的部分就是这里。 Day1：卧槽这是啥？点点看。卧槽..真特么删掉了啊！！老子的测试数据…. 然后 JeecgBoot 自己混入的方式抽取了共通 JS，比如生成 Vue 页面时候的增删改查，在 @/mxins 下的 JeecgListMixin.js 后边会陆陆续续更新一些开发过程中卡壳的问题，有些会很沙雕，有些可能是真的挖坑。… 备注 我现在使用的 Jeecg-bot 在项目 README 文档最后，有这么一段。 @vue&#x2F;cli 升级后，eslint 规则更新了。由于影响到全部 .vue 文件，需要逐个验证。既暂时关闭部分原本不验证的规则，后期维护时，在逐步修正这些 rules 也不知道什么时候会有修复，不过我应该是看不到了。 技术文档 Jeecg-boot 在线演示 开发文档 Jeecg-boot&#x2F;Github Jeecg 社区论坛 附 Ant Design Vue 报表 viser-vue Vue 路由&#x2F;菜单说明 ANTD 默认配置项 待补充…","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Ant-Design-Vue","slug":"Ant-Design-Vue","permalink":"https://yogwang.site/tags/Ant-Design-Vue/"},{"name":"VueJS","slug":"VueJS","permalink":"https://yogwang.site/tags/VueJS/"},{"name":"Jeecg-boot","slug":"Jeecg-boot","permalink":"https://yogwang.site/tags/Jeecg-boot/"}]},{"title":"怎么知道依赖包需要安装到生产还是开发环境或者是安装到全局","slug":"nodejs-npm-save-dev-global","date":"2019-09-22T05:48:39.000Z","updated":"2026-01-05T05:39:58.510Z","comments":true,"path":"2019/nodejs-npm-save-dev-global/","permalink":"https://yogwang.site/2019/nodejs-npm-save-dev-global/","excerpt":"刚开始接触 Node.js (包管理项目) 的时候很多人都会疑惑哪些依赖是可以装在全局的，哪些依赖是安装在项目里的，安装在项目里的依赖又是怎么分辨是否是要安装在开发环境中还是生产环境中？ 小白的时候还不知道怎么搜索关键词，然后就只能看着文档，他们怎么说自己就怎么敲， 上边写的是 npm install vue 就 npm install,如果写的是 npm install -g @vue/cli 那么就 npm install -g,如果是 npm install --save-dev @babel/core 那么就 npm install --save-dev 比如 4 个月前的我就是这样，最近有一些人在群里问，那我就整理了下（原来这不是我笨理解不了，别人也是这样觉得的！）","text":"刚开始接触 Node.js (包管理项目) 的时候很多人都会疑惑哪些依赖是可以装在全局的，哪些依赖是安装在项目里的，安装在项目里的依赖又是怎么分辨是否是要安装在开发环境中还是生产环境中？ 小白的时候还不知道怎么搜索关键词，然后就只能看着文档，他们怎么说自己就怎么敲， 上边写的是 npm install vue 就 npm install,如果写的是 npm install -g @vue/cli 那么就 npm install -g,如果是 npm install --save-dev @babel/core 那么就 npm install --save-dev 比如 4 个月前的我就是这样，最近有一些人在群里问，那我就整理了下（原来这不是我笨理解不了，别人也是这样觉得的！） 其实很简单 先了解下什么是 开发环境 和 生产环境: 开发环境：项目尚且在编码阶段，为了开发调试方便，配置可以比较随意，一般打开全部错误报告。 生产环境: 是指正式提供对外服务了，一般会关掉错误报告，打开错误日志。比如开发企业网站，开发完成之后放在阿里云的服务器上了交付给客户了的时候。 PS: 其实还有一个测试环境，但是现在用不着，就不说了。 怎么分辨依赖安装在开发环境中还是生产环境中？ 如果是你编辑代码的时候用到的辅助工具依赖就安装到 devDependencies 下，也就是 npm install 包名 --save-dev(注意 –save-dev 中间没有空格哦) 例如一些 CSS 预处理器：Less,Sass,Stylus，他们会在你打包项目的时候编译成为正常的 CSS 文件。 ESlint 这样的语法规则检查工具，帮助你检查你语法是否规范，代码风格是否良好，然后提示你需要修改或者直接把代码格式化成未预设的规范格式。 Webpack 这样的打包工具等等 这些帮助你快速开发的工具类依赖包，它们在开发完成之后是不需要存在你项目里边的，所以是安装在开发环境中，在项目打包时就可以忽略这些依赖来达到压缩项目大小的目的。 如果是你项目运行需要的依赖，就安装到 dependencies 下 就是npm install 包名 --save 例如 React、Angular、Vue.js 这样的前端框架 axios 这样的 http 请求库 或者 BootStrap,ElemntUI 这样的 UI 组件库 多了去了不写了 这些必须一直存在在项目里边的依赖包，你的项目运行就依靠这些依赖运行，如果缺少项目就会功能缺失|报错或者直接运行不起来。 比如你的项目是基于 Vue.js 的，那么你的项目运行时 Vue.js 就是必须的，如果缺少了 Vue 项目就运行不起来展示成空白页，所以时安装在生产环境中。 那哪些依赖可以安装在全局呢？像一些快速开发完整系统的项目脚手架。例如: Vue.js 的 Vue CLI,Hexo 的 hexo-cli；对标 npm 的包管理工具 yarn 和一些服务型工具依赖，比如 http-server，npm-check-updates 之类。 不需要在项目里就可能会使用的工具依赖，或者你想写静态 html 文件的时也可以使用 CSS 预处理器那么也可以把它安装在全局（但是如果是基于包管理的项目还是安装在开发环境） 什么？你问 npm 和 yarn 的区别用哪个好？？等下次我什么时候想起来吧，挖个坑先， 简单说下现在 npm 和 yarn 已经没有什么区别了只是命令行的差异 yarn 的某些命令行会精简一些，和安装依赖的时候是不是并行下载的区别了，另外 npm 有一个叫做 npx 的臭弟弟可是很厉害的。","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"},{"name":"挖坑","slug":"挖坑","permalink":"https://yogwang.site/tags/%E6%8C%96%E5%9D%91/"},{"name":"Node.js","slug":"Node-js","permalink":"https://yogwang.site/tags/Node-js/"}]},{"title":"CSS border-radius 制作特殊圆","slug":"CSS-border_radius-semicircle","date":"2019-08-23T02:24:35.000Z","updated":"2026-01-05T05:39:58.450Z","comments":true,"path":"2019/CSS-border_radius-semicircle/","permalink":"https://yogwang.site/2019/CSS-border_radius-semicircle/","excerpt":"以前只知道 border-radius 有一个圆角半径，今天在做一个半圆的时候突然发现，它还有 x 轴和 y 轴属性。 先来看一下 MDN 中 border-radius 说明： CSS 属性 border-radius 允许你设置元素的外边框圆角。当使用一个半径时确定一个圆形，当使用两个半径时确定一个椭圆。这个(椭)圆与边框的交集形成圆角效果。 该属性是一个 简写属性，是为了将这四个属性 border-top-left-radius、border-top-right-radius、border-bottom-right-radius，和 border-bottom-left-radius 简写为一个属性。 也就是说，每个圆角都有 圆角半径、 水平半长轴 和 垂直半长轴 属性值:","text":"以前只知道 border-radius 有一个圆角半径，今天在做一个半圆的时候突然发现，它还有 x 轴和 y 轴属性。 先来看一下 MDN 中 border-radius 说明： CSS 属性 border-radius 允许你设置元素的外边框圆角。当使用一个半径时确定一个圆形，当使用两个半径时确定一个椭圆。这个(椭)圆与边框的交集形成圆角效果。 该属性是一个 简写属性，是为了将这四个属性 border-top-left-radius、border-top-right-radius、border-bottom-right-radius，和 border-bottom-left-radius 简写为一个属性。 也就是说，每个圆角都有 圆角半径、 水平半长轴 和 垂直半长轴 属性值: border-radius: 1em; /* 等价于： */ border-top-left-radius: 1em; border-top-right-radius: 1em; border-bottom-right-radius: 1em; border-bottom-left-radius: 1em; border-radius: 1em/5em; /* 等价于： */ border-top-left-radius: 1em 5em; border-top-right-radius: 1em 5em; border-bottom-right-radius: 1em 5em; border-bottom-left-radius: 1em 5em; 还有一个复杂一些的 demo border-radius: 4px 3px 6px / 2px 4px; /* 等价于： */ border-top-left-radius: 4px 2px; border-top-right-radius: 3px 4px; border-bottom-right-radius: 6px 2px; border-bottom-left-radius: 3px 4px; 按照 MDN 上示例的拓展半圆.semicircle &#123; width: 100px; height: 50px; background: red; border-radius: 50% 50% 0 0 / 100% 100% 0 0; &#125; 气泡.bubble &#123; width: 120px; height: 120px; background: red; border-radius: 60px 60px 0 60px; &#125; 鸡蛋.egg &#123; width: 120px; height: 160px; background: red; border-radius: 60px 60px 60px 60px/100px 100px 60px 60px; &#125; DEMO 在 CodePen.io 参考：MDN : https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-radius","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://yogwang.site/tags/CSS/"}]},{"title":"CSS 中的文字截断","slug":"CSS-text_truncation","date":"2019-08-13T01:54:39.000Z","updated":"2026-01-05T05:39:58.462Z","comments":true,"path":"2019/CSS-text_truncation/","permalink":"https://yogwang.site/2019/CSS-text_truncation/","excerpt":"单行文字的截断非常简单，但多行文字的截断就很麻烦了，经常要配合 JavaScript 或者 其他语言进行字符串截断，然后拼接上 “…” 突然发现 line-clamp 它可以完成以纯 CSS 的多行文本截断，并且配合 text-overflow: ellipsis 就可以在尾部加上省略号，当然 overflow: hidden 并不可缺少","text":"单行文字的截断非常简单，但多行文字的截断就很麻烦了，经常要配合 JavaScript 或者 其他语言进行字符串截断，然后拼接上 “…” 突然发现 line-clamp 它可以完成以纯 CSS 的多行文本截断，并且配合 text-overflow: ellipsis 就可以在尾部加上省略号，当然 overflow: hidden 并不可缺少 单行文字的截断text-truncate &#123; word-wrap: normal; text-overflow: ellipsis; white-space: nowrap; overflow: hidden; &#125; 多行文字的截断text-truncate &#123; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; overflow: hidden; &#125; 在 CodePen 中查看 DEMO Can I use 中查看 兼容性 在本地测试中，Chrome, Firefox 和 Edge 都是没问题的，就是不知道国产的那些奇葩有没有问题。 补充:不同行数，修改 -webkit-line-clamp 即可它仅与 display 设置为 -webkit-box 或 -webkit-inline-box 的容器，并且 -webkit-box-orient 属性为 vertical。 Specifications:CSS Overflow Module Level 3 ( Working Draft ) 以上2019-08-13","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://yogwang.site/tags/CSS/"}]},{"title":"CSS 判断 input 是否为空","slug":"CSS-placeholder-shown","date":"2019-08-09T02:44:11.000Z","updated":"2026-01-05T05:39:58.459Z","comments":true,"path":"2019/CSS-placeholder-shown/","permalink":"https://yogwang.site/2019/CSS-placeholder-shown/","excerpt":"前景：很多情况下，都需要做到这样的一个输入框效果： 很久以前都是使用 :valid 来实现效果 DEMO 01 -&gt; CodePen","text":"前景：很多情况下，都需要做到这样的一个输入框效果： 很久以前都是使用 :valid 来实现效果 DEMO 01 -&gt; CodePen 但是要有 required 属性的必填项才可以使用这个伪类，来实现效果。 :placeholder-shown CSS pseudo-class今天发现了 :placeholder-shown 一个占位符是否显示的伪类，那么就可以配合 :not() 来实现一些效果（不是必须，反过来也可以） DEMO 02 -&gt; CodePen 兼容Chrome,FireFox,Safari 这些主流浏览器都支持, Edge,IE 阵亡… 👉 Can I use… Support","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://yogwang.site/tags/CSS/"}]},{"title":"如何理解 Call, Apply, Bind?","slug":"JS-call-apply-bind","date":"2019-08-06T01:37:07.000Z","updated":"2026-01-05T05:39:58.473Z","comments":true,"path":"2019/JS-call-apply-bind/","permalink":"https://yogwang.site/2019/JS-call-apply-bind/","excerpt":"今天，介绍这两个方法的区别以及一些妙用，还有用法相似的 bind 的方法。 它们最主要的作用，是改变 this 的指向。在平时的工作中，除了在写一些基础类，或者公用库方法的时候会用到它们，其他时候应用场景并不多（ React 我习惯用箭头函数）。","text":"今天，介绍这两个方法的区别以及一些妙用，还有用法相似的 bind 的方法。 它们最主要的作用，是改变 this 的指向。在平时的工作中，除了在写一些基础类，或者公用库方法的时候会用到它们，其他时候应用场景并不多（ React 我习惯用箭头函数）。 基本介绍func.call(thisArg, arg1, arg2, ...) func.apply(thisArg, [argsArray]) func.bind(thisArg[, arg1[, arg2[, ...]]]) 简单来说，他们都是改变函数执行时的上下文，参数形式都是差不多的。 先来看 call() 和 apply()两个方法，乍一看没啥区别，除了参数部分，也都是于JavaScript 1.3 中实现。 var test = &#123; color: &#x27;红色&#x27;, say: function()&#123; console.log(&quot;颜色是&quot;+this.color) &#125; &#125; test.say() // 颜色是红色 var test2 = &#123; color:&quot;黄色&quot; &#125; test.say.call(test2) // 颜色是黄色 test.say.apply(test2) // 颜色是黄色 这样看来确实很容易搞混，具体的区别看以下例子🌰 var test = &#123; color:&#x27;红色&#x27;, say:function(n,graph)&#123; console.log(`$&#123;n&#125;个$&#123;this.color&#125;的$&#123;graph&#125;`) &#125; &#125; test.say.call(&#123;color:&#x27;绿色&#x27;&#125;, 10, &#x27;矩形&#x27;) // 10个绿色的矩形 test.say.apply(&#123;color:&#x27;蓝色&#x27;&#125;, 2, &#x27;三角形&#x27;) // Uncaught TypeError: CreateListFromArrayLike called on non-object test.say.apply(&#123;color:&#x27;蓝色&#x27;&#125;, [2, &#x27;三角形&#x27;]) // 2个蓝色的三角形 昂，差别就是这个了，传入的参数形式不一样，因为现在有了展开符 来 传入&#x2F;接受 参数，所以差异已经不大了，但是在早期的环境中，如果不确定参数的话，一般都会选择用 apply 来一次性传入，并且使用 arguments 来处理。 说完了 apply 和 call ，再来说说 bindbind 方法与 apply 和 call 很相似，也是可以改变函数体内 this 的指向。 bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。 还是举个例子来说吧： var test = &#123; color: &#x27;红色&#x27;, say: function()&#123; console.log(&quot;颜色是&quot;+this.color) &#125; &#125; test.say() // 颜色是红色 var test2 = &#123; color:&quot;黄色&quot; &#125; test.say.call(test2) // 颜色是黄色 test.say.apply(test2) // 颜色是黄色 test.say.bind(test2) // f() &#123;..&#125; // 可以看到bind()并没有输出，需要自执行或者赋值给一个变量然后调用 test.say.bind(test2)() // 颜色是黄色 var bindTest2 = test.say.bind(test2) bindTest2() // 颜色是黄色 简单总结来说 call()&#x2F;apply()&#x2F;bind() 都可以改变函数内的 this 指向； call()&#x2F;apply()会立即执行函数，而bind() 不会立即执行； bind() 会返回一个新得函数，并不会马上执行； apply()，传入的参数需要数组格式； fun.apply(thisArg, [arg1, arg2, ...]) ↔ fun.call(thisArg, arg1, arg2, ...) bind() 传入的参数的方式和 call() 一样。 fun.call(thisArg, arg1, arg2, ...)，fun.bind(thisArg, arg1, arg2, ...) 疑惑部分1.bind() 传入的参数部分是否可以在 bind 的时候不传入，后续使用的时候在传入？可以 function add(a, b) &#123; return a + b; &#125; var add1 = add.bind(null); console.log(add1(1,3)); // 4 var add2 = add.bind(null,10) console.log(add2(5)); // 15 参考Function.prototype.call() - MDNFunction.prototype.apply() - MDNFunction.prototype.bind() - MDN OBKoro1 - js 面试官想了解你有多理解 call,apply,bind?Micherwa - 「干货」细说 call、apply 以及 bind 的区别和用法公子 - 如何理解，javascript bindSchaos - 一次搞懂前端面試最愛問的 apply、bind、call","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"}]},{"title":"PHPOK 5.x 多站点共享留言板","slug":"phpok-Guestbook","date":"2019-08-03T03:06:49.000Z","updated":"2026-01-05T05:39:58.511Z","comments":true,"path":"2019/phpok-Guestbook/","permalink":"https://yogwang.site/2019/phpok-Guestbook/","excerpt":"前景： 要求 中文站 和 英文站 提交的留言内容都收集在中文站的留言板中，方便查看。 之前 3.x 版本直接使用 CateID 就可以了，但是在 5.x 版本中不行。 文档里也没有，所以在尝试多次之后，憋不住就在群里问了作者团队， 答： 在 Ajax 请求地址上加上 SiteID 就可以了。","text":"前景： 要求 中文站 和 英文站 提交的留言内容都收集在中文站的留言板中，方便查看。 之前 3.x 版本直接使用 CateID 就可以了，但是在 5.x 版本中不行。 文档里也没有，所以在尝试多次之后，憋不住就在群里问了作者团队， 答： 在 Ajax 请求地址上加上 SiteID 就可以了。 So: ... $(this).ajaxSubmit(&#123; &#x27;url&#x27;:api_url(&#x27;post&#x27;,&#x27;save&#x27;,&#x27;id=book&#x27;)+&#x27;&amp;siteId=1&#x27;, &#x27;type&#x27;:&#x27;post&#x27;, &#x27;data&#x27;: &#123; &#x27;title&#x27;: name, &#x27;fullname&#x27;: name, &#x27;tel&#x27;: tel &#125;, &#x27;dataType&#x27;:&#x27;json&#x27;, &#x27;success&#x27;:function(res)&#123; // Do sth... &#125; &#125;); api_url 为框架内置方法，所以只能拼接字符串了。 后台查看：","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://yogwang.site/tags/PHP/"},{"name":"PHPOK","slug":"PHPOK","permalink":"https://yogwang.site/tags/PHPOK/"}]},{"title":"Apache 配置虚拟域名","slug":"php-VirtualHost","date":"2019-07-30T07:13:41.000Z","updated":"2026-01-05T05:39:58.510Z","comments":true,"path":"2019/php-VirtualHost/","permalink":"https://yogwang.site/2019/php-VirtualHost/","excerpt":"在本地调试后端项目时候经常会用到虚拟域名的功能； 毕竟项目都放在 WWW 目录下，如果不使用虚拟域名，URL 实在太长，实在不方便调试。 例如：http://localhost/project/public/index.php/sample/test/hello 如果使用虚拟域名就可以简化为 http://p.loc/sample/test/hello 着实方便很多。 但我总是记不住怎么去添加虚拟域名，总不可能一直百度吧,所以就记下笔记了。","text":"在本地调试后端项目时候经常会用到虚拟域名的功能； 毕竟项目都放在 WWW 目录下，如果不使用虚拟域名，URL 实在太长，实在不方便调试。 例如：http://localhost/project/public/index.php/sample/test/hello 如果使用虚拟域名就可以简化为 http://p.loc/sample/test/hello 着实方便很多。 但我总是记不住怎么去添加虚拟域名，总不可能一直百度吧,所以就记下笔记了。 本地使用的 phpStudy 集成环境，所以步骤都是按照 phpStudy 的来，实际也相差不大。 方法 1：针对项目添加虚拟域名Step1： 打开 vhosts-ini 配置文件 或者使用路径打开 ..\\phpStudy\\PHPTutorial\\Apache\\conf\\vhosts.conf Step2： 添加新 VirtualHost&lt;VirtualHost _default_:80&gt; ServerName &quot;p.loc&quot; DocumentRoot &quot;E:/WWW/project/public&quot; &lt;/VirtualHost&gt; Step3： 修改 hosts 文件 或者使用路径打开 C:\\Windows\\System32\\drivers\\etc Step3： 重启 ALache 服务 不用修改其他，因为 phpStudy 启用了 conf/vhosts.conf 在 httpd.conf:486 更加偷懒的方式？想到了一种泛域名解析的方式去配置虚拟域名，然后根据二级域名来指向不同目录。但是在只修改 vhosts-ini 情况还不能办到。可能需要启动 htttpd.conf 里的扩展功能，暂时不研究了，记一下先。 Internal Server Error遇到 Internal Server Error ，在 apache 配置文件 httpd.conf 中开启重写 #LoadModule rewrite_module modules/mod_rewrite.so // 去掉#","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"挖坑","slug":"挖坑","permalink":"https://yogwang.site/tags/%E6%8C%96%E5%9D%91/"},{"name":"PHP","slug":"PHP","permalink":"https://yogwang.site/tags/PHP/"},{"name":"Apache","slug":"Apache","permalink":"https://yogwang.site/tags/Apache/"}]},{"title":"简单设置Video标签的播放倍速","slug":"html5-set_videoSpeed","date":"2019-07-21T08:21:58.000Z","updated":"2026-01-05T05:39:58.492Z","comments":true,"path":"2019/html5-set_videoSpeed/","permalink":"https://yogwang.site/2019/html5-set_videoSpeed/","excerpt":"在 B 站 看视频教学的时候，发现最快只有 2 倍速, 我觉得太慢了，在百度之后发现有 video 标签有 playbackRate 属性可以设置倍速。","text":"在 B 站 看视频教学的时候，发现最快只有 2 倍速, 我觉得太慢了，在百度之后发现有 video 标签有 playbackRate 属性可以设置倍速。 应该适用使用 HTML5 的 video 标签来为播放器的在线视频站。 记一下省的以后再百度 在控制台输入即可： // 获取视频元素 var video = document.querySelector(&quot;video&quot;); // 设置播放倍率 video.playbackRate = 10; // 设置为10倍速 07&#x2F;30&#x2F;2019 补：只有 Google Chrome 和 Safari 支持 playbackRate 属性。[ w3school ]","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://yogwang.site/tags/HTML/"}]},{"title":"Electron:Electron-builder+Electron-updater 完成Electron应用的自升级","slug":"Electron04-ElectronBuilder-ElectronUpdater","date":"2019-07-19T06:25:13.000Z","updated":"2026-01-05T05:39:58.470Z","comments":true,"path":"2019/Electron04-ElectronBuilder-ElectronUpdater/","permalink":"https://yogwang.site/2019/Electron04-ElectronBuilder-ElectronUpdater/","excerpt":"","text":"2019&#x2F;07&#x2F;19 开坑。","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Electron","slug":"Electron","permalink":"https://yogwang.site/tags/Electron/"},{"name":"未完成","slug":"未完成","permalink":"https://yogwang.site/tags/%E6%9C%AA%E5%AE%8C%E6%88%90/"}]},{"title":"万能的 :checked + label","slug":"CSS-checked-label","date":"2019-07-18T06:06:44.000Z","updated":"2026-01-05T05:39:58.450Z","comments":true,"path":"2019/CSS-checked-label/","permalink":"https://yogwang.site/2019/CSS-checked-label/","excerpt":"Meathill：纯 CSS 组件顾名思义，只改变外观，不改变行为。所以它的功能不会因为浏览器变化而变化，即使浏览器支持不完善，即使因为加载速度或者网络关系，导致 CSS、JS 加载失败，它最多样式回归到原始样式，功能是完全一致的。在非标准浏览器环境下，如读屏器，也是如此 前年看肉大直播的时候听到：万能的 :checked + label 当时没有体会到有啥万能，不就是自定义 input 样式吗，直到前段时间看到一个 Demo 虽然不是使用的这种方法，但是我突然就明白了，这个就可以用 :checked + label 来实现。 … 原来很多需要 Js 配合的一些效果点击效果只需要 :checked + label 就可以完成。","text":"Meathill：纯 CSS 组件顾名思义，只改变外观，不改变行为。所以它的功能不会因为浏览器变化而变化，即使浏览器支持不完善，即使因为加载速度或者网络关系，导致 CSS、JS 加载失败，它最多样式回归到原始样式，功能是完全一致的。在非标准浏览器环境下，如读屏器，也是如此 前年看肉大直播的时候听到：万能的 :checked + label 当时没有体会到有啥万能，不就是自定义 input 样式吗，直到前段时间看到一个 Demo 虽然不是使用的这种方法，但是我突然就明白了，这个就可以用 :checked + label 来实现。 … 原来很多需要 Js 配合的一些效果点击效果只需要 :checked + label 就可以完成。 1. 按钮交互 2. 下拉菜单 3. 折叠面板 4. 选项卡 5. 模拟弹出窗口 应该还有其他我没有想到的，以后想到了，再慢慢补全起来。","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://yogwang.site/tags/CSS/"}]},{"title":"BetterScrol 2.x Mouse-whell 没效果","slug":"BetterScrol-mouse-wheel","date":"2019-07-15T03:13:04.000Z","updated":"2026-01-05T05:39:58.449Z","comments":true,"path":"2019/BetterScrol-mouse-wheel/","permalink":"https://yogwang.site/2019/BetterScrol-mouse-wheel/","excerpt":"","text":"安装yarn add @better-scroll/mouse-wheel@next 使用import BScroll from &#x27;@better-scroll/core&#x27; import MouseWheel from &#x27;@better-scroll/mouse-wheel&#x27; BScroll.use(MouseWheel) new BScroll(&#x27;.bs-wrap&#x27;, &#123; //... mouseWheel: &#123; speed: 20, invert: false, easeTime: 300 &#125; &#125;) 但是为什么在原有的基础上这样写没有用呢。官方 Demo查看 Demo 源码在 scroll-wrapper 外多了一层 core-mouse-wheel 加上就可以了。 😂 没仔细看 Demo 源码","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"BetterScrol.js","slug":"BetterScrol-js","permalink":"https://yogwang.site/tags/BetterScrol-js/"},{"name":"问题","slug":"问题","permalink":"https://yogwang.site/tags/%E9%97%AE%E9%A2%98/"}]},{"title":"Hexo 主题开发制作","slug":"hexo_theme","date":"2019-07-11T07:34:10.000Z","updated":"2026-01-05T05:39:58.490Z","comments":true,"path":"2019/hexo_theme/","permalink":"https://yogwang.site/2019/hexo_theme/","excerpt":"前置 Hexo 的安装就不讲了，直接开始我在制作 Hexo 主题遇到的一些问题。 首先在使用 Hexo cli 脚手架创建完 Hexo 项目后会有一个默认官方主题 landscape 在 themes 目录中复制一份出来重命名成自己的名称，例如我的就是改成了 yogwang，并且在根目录中的 _config.yml 中修改主题为自己的主题","text":"前置 Hexo 的安装就不讲了，直接开始我在制作 Hexo 主题遇到的一些问题。 首先在使用 Hexo cli 脚手架创建完 Hexo 项目后会有一个默认官方主题 landscape 在 themes 目录中复制一份出来重命名成自己的名称，例如我的就是改成了 yogwang，并且在根目录中的 _config.yml 中修改主题为自己的主题 # Extensions ## Plugins: https://hexo.io/plugins/ ## Themes: https://hexo.io/themes/ theme: yogwang //这里修改成自己的主题 目录完全展开主题目录：─yogwang ├─languages // 国际化(i18n)让网站以不同语言呈现 │ └─... ├─layout // 布局文件 │ ├─_partial // 局部组件 │ │ ├─post // 文章组件 │ │ └─... │ ├─_widget // 侧边栏部件 │ └─... ├─scripts // 启动时自动载入的Js脚本 ├─source // 资源文件夹 │ ├─css // CSS样式 │ │ ├─fonts // 字体 │ │ ├─images // 图片 │ │ ├─_partial // 局部组件CSS │ │ ├─_util // 分栏&amp;Mixin │ │ └─... │ ├─fancybox // fancybox插件 │ └─js // JS脚本 ├─_config.yml // 主题配置文件 ├─.gitignore // Git忽略配置 ├─Gruntfile.js // Grunt项目文件 ├─LICENSE // 授权条款 ├─package.json // 包管理配置文件 └─README.md // 项目手册 因为我是完全重新创作一个主题，所以需要保留下来的目录如下 保留下来的目录─yogwang ├─layout │ ├─_partial │ │ └─post │ │ └─... │ ├─_widget │ └─... ├─scripts ├─source │ ├─css │ └─js ├─_config.yml ├─.gitignore ├─package.json └─README.md 因为仅自己使用所以 languages、Gruntfile.js 和 LICENSE 没有保留， 保留下了 layout 布局文件夹的全部文件， 清空了 scripts 和 source 目录下文件仅保留目录; README.md 作为备忘录。 制作因为保留下了官方主题的布局文件，所以只需要在原有基础上调整就可以制作一个主题雏形。 调整后的目录：Layout │ archive.ejs // 所有归档文章列表 │ category.ejs // 归档时间来分类的列表 │ index.ejs // 主页 │ layout.ejs // 通用布局模板 │ page.ejs // 单页模板 │ post.ejs // 文章模板 │ tag.ejs // 标签归档列表页 ├─_partial // 私有组件 │ │ archive-post.ejs // 列表页文章预览 │ │ archive.ejs // 文章列表 │ │ article.ejs // 文章详情 │ │ footer.ejs // 尾部模板 │ │ meta.ejs // 页面META部分 │ │ header.ejs // 头部模板 │ │ sidebar.ejs // 侧边栏 │ └─posts // 文章组件 │ category.ejs // 文章分类归档 │ date.ejs // 文章创建时间 │ nav.ejs // 文章分页 │ tag.ejs // 文章Tag │ title.ejs // 文章标题 └─_widget // 侧边栏部件 archive.ejs // 分类列表部件 category.ejs // 时间归档部件 recent_posts.ejs // 最后发布部件 tag.ejs // 标签分类部件 书写样式直接跳过,以下是一些制作完成之后遇到的问题 问题在主题配置文件中添加个人信息并输出到页面打开 thems 目录下对应主题的 _config.yml 文件，参考官方模板中的 Menu 属性同样创建 userinfo # userinfo user: nickname: 王阳阳 bio: &#x27;久之须自见得&#x27; commpany: ODIN.INC address: Jiaxing,China follow: github: https://github.com/yogwang weibo: http://weibo.com/yooooooge 如何在页面中输出？？在页面对应位置 &lt;%= theme.user.nickname %&gt; 即可，也可以循环输出 &lt;% for (var i in theme.follow)&#123; %&gt; &lt;a href=&quot;&lt;%= theme.follow[i] %&gt;&quot; target=&quot;_blank&quot;&gt;&lt;/a&gt; &lt;% &#125; %&gt; 其实也可以在 Hexo 根目录下的 _config.yml 文件配置 输出标签如 &lt;%= config.LABEL %&gt; 不知道怎么生成 ‘关于我’ 单页面在 Layout 中编写完 about.ejs 模板之后,我想使用这个布局来创建关于我的单页面 在 Hexo.io 官方文档中是这样写的 hexo new [layout] &lt;title&gt; 新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。 使用 hexo new 命令，创建关于我单页面 PS E:\\yogwang.github.io&gt; hexo new about aboutme INFO Created: E:\\yogwang.github.io\\source\\_posts\\aboutme.md 这样就会生成一篇使用 about.ejs 来布局的 文章 并生成在_posts 文件夹下。注意哦，生成的是文章会在文章列表中显示。 那么问题来了，我怎么创建一个使用 about.ejs 布局，且不在文章列表中显示的单页面呢 Hexo 有 三种默认布局 ：post、page 和 draft，它们分别对应不同的路径，自定义的其他布局和 post 相同，草稿文件都将储存到 source/_posts 文件夹。 所以在 hexo new 页面的时候先使用 hexo new page about PS E:\\yogwang.github.io&gt; hexo new page about INFO Created: E:\\yogwang.github.io\\source\\about\\index.md 这样会在 source 目录下创建 about 目录，并生成 index.md 文件，打开它在 Front-matter 中添加 layout: about --- title: 我 date: 2019-07-11 15:10:39 layout: about ---","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://yogwang.site/tags/Hexo/"}]},{"title":"纯CSS实现瀑布流布局","slug":"CSS-WaterFull","date":"2019-07-10T09:35:57.000Z","updated":"2026-01-05T05:39:58.449Z","comments":true,"path":"2019/CSS-WaterFull/","permalink":"https://yogwang.site/2019/CSS-WaterFull/","excerpt":"原理： column-count: n 将元素中的文本分为 n 列 break-inside: avoid 避免元素内部断行并产生新列 可以不加，但可能会影响布局效果 Demo:👉 在 CodePen 中打开","text":"原理： column-count: n 将元素中的文本分为 n 列 break-inside: avoid 避免元素内部断行并产生新列 可以不加，但可能会影响布局效果 Demo:👉 在 CodePen 中打开 HTML html5 div#container // 外部容器 ul#waterfall // 瀑布流容器 - for(let i=0;i&lt;12;i++ ) li.item // 内部项目 // 生成随机高度 - let height = Math.ceil(Math.random() *(150+1-500)+500) // 模拟不同高度图片 div(class=&#x27;img&#x27;,style=&#x27;height:&#x27;+height+&#x27;px&#x27;) // 模拟介绍文本 p Lorem ipsum dolor sit amet consectetur adipisicing elit. Necessitatibus culpa cupiditate a aperiam libero aspernatur unde CSS //reset * padding 0 margin 0 // 外部容器 #container width 1200px margin 30px auto // 瀑布流容器 #waterfall column-count 3 list-style-type none // 内部项目 .item padding 10px margin 0 10px 20px break-inside avoid border: 2px solid #000 div.img background red ✨ 更新 2021年11月2日以前一直不知道 break-inside: avoid 如果不加的话，“可能会影响布局效果” 所描述的 影响 是怎么样的，过去了那么多年终于让我遇到了一次，可以很明显的从下图看到第二列的首个元素被截断了。 一开始我一直以为是背景色是白色的缘故，直到我看到了列表最尾部，那段被截掉的头部。那么让我们给子元素加上 break-inside: avoid 看看效果。 记得是给 子元素 这个属性哦，不是瀑布流容器。 我最开始认为是给列表容器加这个属性的，一直都不生效还以为因为兼容性的关系没办法应用呢，直到我尝试着给子元素加上试试看….太尴尬了，hhhhhhh。 文档column-count - CSS（层叠样式表） | MDNbreak-inside - CSS（层叠样式表） | MDN","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://yogwang.site/tags/CSS/"}]},{"title":"Hello Hexo","slug":"hello you","date":"2019-07-09T03:59:16.000Z","updated":"2026-01-05T05:39:58.490Z","comments":true,"path":"2019/hello you/","permalink":"https://yogwang.site/2019/hello%20you/","excerpt":"","text":"Hello Hexo,Hello Github Pages2019.7.9 11:59:16","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://yogwang.site/tags/Hexo/"}]},{"title":"Git 撤销上一次提交 并将暂存区文件重新提交","slug":"git_commit--amend","date":"2019-07-03T09:29:11.000Z","updated":"2026-01-05T05:39:58.487Z","comments":true,"path":"2019/git_commit--amend/","permalink":"https://yogwang.site/2019/git_commit--amend/","excerpt":"把刚刚提交到的版本库的操作撤销掉,并将正确的版本提交 这时我们就需要用到 git commit –-amend 命令 我们把文件修改为正确的，然后 git add 到暂存区 再使用 git commit -–amend 命令这时 Bash 会提示 $ git commit --amend hint: Waiting for your editor to close the file...","text":"把刚刚提交到的版本库的操作撤销掉,并将正确的版本提交 这时我们就需要用到 git commit –-amend 命令 我们把文件修改为正确的，然后 git add 到暂存区 再使用 git commit -–amend 命令这时 Bash 会提示 $ git commit --amend hint: Waiting for your editor to close the file... 并在编辑器弹出 COMMIT_EDITMSG version 0.1.6 # Please enter the commit message for your changes. Lines starting # with &#x27;#&#x27; will be ignored, and an empty message aborts the commit. # # Date: Wed Jul 3 11:00:38 2019 +0800 # # On branch master # Your branch and &#x27;origin/master&#x27; have diverged, # and have 1 and 1 different commits each, respectively. # (use &quot;git pull&quot; to merge the remote branch into yours) # # Changes to be committed: # modified: readme.md # 最上面的 version 0.1.6 是我们上次提交是的备注下面的 modified: readme.md 则表明我们这次重修提交修改了 readme.md 文件如果需要修改备注则修改最上边的备注并保存，不需要直接退出关闭即可提交成功： [master 5df6a16] version 0.1.6 Date: Wed Jul 3 11:00:38 2019 +0800 1 files changed, 1 insertions(+), 1 deletions(-) 再次查看日志 git log --oneline $ git log --oneline 7475748 (HEAD -&gt; master) version 0.1.6 9750475 version 0.1.5 c1dd820 version 0.1.4 b3d104c version 0.1.3 ... 发现只有 1 次 version 0.1.6 提交说明我们刚刚是在修改而不是再次提交 如果需要再 push 到远程库需要加上 --force/-f 参数$ git push --force","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://yogwang.site/tags/Git/"}]},{"title":"Git 编辑历史提交的 Commit","slug":"git_rebase","date":"2019-07-03T08:28:25.000Z","updated":"2026-01-05T05:39:58.490Z","comments":true,"path":"2019/git_rebase/","permalink":"https://yogwang.site/2019/git_rebase/","excerpt":"做一个功能，可能提交了 10 多次，会不会有一些崩溃？单纯这么多次的 commit 就可能出现有无用，或者可以合并的 commit，就很让人不舒服。 基于上面所说问题，不难想到：每一次功能开发， 对多个 commit 进行合并或者删除处理，这时候就需要用到 git rebase 修改提交的历史 Commit Eg:修改最近的 4 次提交纪录 git rebase -i HEAD~4 -i 是 --interactive 的缩写 - 交互的意思； HEAD~4 修改最近的 4 次提交记录；","text":"做一个功能，可能提交了 10 多次，会不会有一些崩溃？单纯这么多次的 commit 就可能出现有无用，或者可以合并的 commit，就很让人不舒服。 基于上面所说问题，不难想到：每一次功能开发， 对多个 commit 进行合并或者删除处理，这时候就需要用到 git rebase 修改提交的历史 Commit Eg:修改最近的 4 次提交纪录 git rebase -i HEAD~4 -i 是 --interactive 的缩写 - 交互的意思； HEAD~4 修改最近的 4 次提交记录； 然后在弹出的编辑器中显示 git-rebase-todo 文件，在 rebase-todo 中修改列表中的 pick 命令。 pick f77a6e7 version 0.1.3 pick 434a2f2 version 0.1.4 pick 094263b version 0.1.5 pick 9135476 version 0.1.5 change XXXX # Rebase 50adf2a..9135476 onto 50adf2a (4 commands) # # Commands: # p, pick &lt;commit&gt; = use commit // 保留该commit # r, reword &lt;commit&gt; = use commit, but edit the commit message // 保留该commit，但修改该commit的注释 # e, edit &lt;commit&gt; = use commit, but stop for amending // 保留该commit, 但我要停下来修改该commit # s, squash &lt;commit&gt; = use commit, but meld into previous commit // 将该commit合并到前一个commit # f, fixup &lt;commit&gt; = like &quot;squash&quot;, but discard this commit&#x27;s log message // 将该commit合并到前一个commit，并不要保留该提交的注释信息 # x, exec &lt;command&gt; = run command (the rest of the line) using shell // 执行后边的shell命令 # b, break = stop here (continue rebase later with &#x27;git rebase --continue&#x27;) //在这里停止，稍后使用 --continue 继续 # d, drop &lt;commit&gt; = remove commit // 清除该commit # l, label &lt;label&gt; = label current HEAD with a name // 使用label标记当前HEAD # t, reset &lt;label&gt; = reset HEAD to a label // 设置HEAD到标记的label # m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;] // 合并分支 # . create a merge commit using the original merge commit&#x27;s # . message (or the oneline, if no original merge commit was # . specified). Use -c &lt;commit&gt; to reword the commit message. # # These lines can be re-ordered; they are executed from top to bottom. # # If you remove a line here THAT COMMIT WILL BE LOST. # # However, if you remove everything, the rebase will be aborted. # # Note that empty commits are commented out Eg:我需要修改第二行和第三行的 Commit，那我将第二行和第三行的 pick 改成 edit 或 e，保存并退出。 git 会依次执行上面的操作，当操作为 pick 时，直接 commit。当操作为 edit 时，会中断，并提示 You can amend the commit now, with // 你可以使用 git commit --amend 来修改此次提交 git commit --amend Once you are satisfied with your changes, run // 修改以后满意了，执行 git rebase --continue 继续剩下的流程 git rebase --continue 全部修改完成以后提示如下： $ git rebase --continue Successfully rebased and updated refs/heads/master. 如果需要把修改的历史 commit push 到远程库中使用 git push -f 命令即可 如果意外关闭了弹出的编辑窗口如果 git 没有执行完操作，git rebase --edit-todo 命令可以返回编辑","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://yogwang.site/tags/Git/"}]},{"title":"Chrome下垂直居中容器内区块改变高度使外层容器被移动","slug":"Chrome-VerticalCentering","date":"2019-07-03T07:37:00.000Z","updated":"2026-01-05T05:39:58.463Z","comments":true,"path":"2019/Chrome-VerticalCentering/","permalink":"https://yogwang.site/2019/Chrome-VerticalCentering/","excerpt":"问题在 Chrome 中，使用 transform 或者 flex 垂直居中内容块，当视窗滚动到容器一半时再经过第一个内容块（之后的都正常），整个容器块都会被移动 内容块高度已经大于文本块高度 内容块垂直居中 视窗滚动到容器一半时 改变文本块高度 Firefox 同样遇到该问题 Edge 正常 IE11 正常","text":"问题在 Chrome 中，使用 transform 或者 flex 垂直居中内容块，当视窗滚动到容器一半时再经过第一个内容块（之后的都正常），整个容器块都会被移动 内容块高度已经大于文本块高度 内容块垂直居中 视窗滚动到容器一半时 改变文本块高度 Firefox 同样遇到该问题 Edge 正常 IE11 正常 前景 要求一般情况下只显示文本前两行，当鼠标悬停时显示全部文本内容 复现👉 CodePen 解决在第一个 li 前创建一个与之等高的伪类就可以解决 ul:before&#123; content : &quot;&quot;; width : 1px; height : 520px display : blcok; position : absolute; &#125; 附： CodePen - https://codepen.io/yooooge/pen/MPNGpY Chrome 版本 Firefox 版本 Edge 版本 IE 版本 yogWang 2019&#x2F;07&#x2F;03","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://yogwang.site/tags/CSS/"},{"name":"问题","slug":"问题","permalink":"https://yogwang.site/tags/%E9%97%AE%E9%A2%98/"},{"name":"Chrome","slug":"Chrome","permalink":"https://yogwang.site/tags/Chrome/"}]},{"title":"Git 遇到的一些问题","slug":"git_question","date":"2019-07-03T06:27:56.000Z","updated":"2026-01-05T05:39:58.489Z","comments":true,"path":"2019/git_question/","permalink":"https://yogwang.site/2019/git_question/","excerpt":"这里是我在日常中遇到的一些 Git 方面的问题。 Error: GH007 不能退出、终止当前命令？ 想要删除提交的历史 Commit? 合并与删除历史提交的 Commit ? 操作失误，退回操作之前的版本库","text":"这里是我在日常中遇到的一些 Git 方面的问题。 Error: GH007 不能退出、终止当前命令？ 想要删除提交的历史 Commit? 合并与删除历史提交的 Commit ? 操作失误，退回操作之前的版本库 Error: GH007推送本地库的内容到远程库上报 error: GH007 时，在 Setting 里把 Email 的 Keep my email address private 勾选去掉即可 不能退出、终止当前命令？尝试按下 Q 键 想要删除提交的历史 Commit?1. 上一次提交的 Commit 有错误需要修改？ 详细git commit --amend // 撤销上一次提交 并将暂存区文件重新提交 2. 合并与删除历史提交的 Commit ? 详细git rebase -i HEAD~n 常用指令： p,pick - 保留 r,reword - 修改注释 e,edit - 停下来修改注释 s,squash - 合并到上一个 commit 并且合并注释 f,fixup - 丢掉备注并且合并到上一个 commit d,drop - 删除 commit 操作失误，退回操作之前的版本库使用 git reflog 查看操作日志，找到误操之前的版本号 再使用 git reset --hard &lt;commit_id&gt; 退回版本","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"问题","slug":"问题","permalink":"https://yogwang.site/tags/%E9%97%AE%E9%A2%98/"},{"name":"Git","slug":"Git","permalink":"https://yogwang.site/tags/Git/"}]},{"title":"Electron_03 - Electron-builder","slug":"Electron03-Electron-builder","date":"2019-06-21T08:41:29.000Z","updated":"2026-01-05T05:39:58.470Z","comments":true,"path":"2019/Electron03-Electron-builder/","permalink":"https://yogwang.site/2019/Electron03-Electron-builder/","excerpt":"安装 Electron-builder$ git clone https://github.com/electron/electron-quick-start $ cd electron-quick-start $ yarn add electron-builder --dev // 官方推荐 or $ npm install elctron-builder --save-dev","text":"安装 Electron-builder$ git clone https://github.com/electron/electron-quick-start $ cd electron-quick-start $ yarn add electron-builder --dev // 官方推荐 or $ npm install elctron-builder --save-dev 配置 Electron-builder在 config.json 配置 build &quot;build&quot;: &#123; &quot;productName&quot;:&quot;xxxx&quot;, // 项目名 这也是生成的exe文件的前缀名 &quot;appId&quot;: &quot;com.xxx.xxxxx&quot;, // 包名 &quot;copyright&quot;:&quot;xxxx&quot;, // 版权信息 &quot;directories&quot;: &#123; // 输出文件夹 &quot;output&quot;: &quot;build&quot; &#125;, // windows相关的配置 &quot;win&quot;: &#123; &quot;icon&quot;: &quot;xxx/icon.ico&quot; // 图标路径 &#125;, &quot;nsis&quot;: &#123; //nsis安装脚本 &quot;oneClick&quot;: false, // 是否一键安装 &quot;allowElevation&quot;: true, // 允许请求提升。 如果为false，则用户必须使用提升的权限重新启动安装程序。 &quot;allowToChangeInstallationDirectory&quot;: true, // 允许修改安装目录 &quot;installerIcon&quot;: &quot;./build/icons/aaa.ico&quot;,// 安装图标 &quot;uninstallerIcon&quot;: &quot;./build/icons/bbb.ico&quot;,//卸载图标 &quot;installerHeaderIcon&quot;: &quot;./build/icons/aaa.ico&quot;, // 安装时头部图标 &quot;createDesktopShortcut&quot;: true, // 创建桌面图标 &quot;createStartMenuShortcut&quot;: true,// 创建开始菜单图标 &quot;shortcutName&quot;: &quot;xxxx&quot;, // 图标名称 &#125;, &#125; 增加 scripts 脚本到 config.json &quot;scripts&quot;: &#123; &quot;pack&quot;: &quot;electron-builder --dir&quot;, &quot;dist&quot;: &quot;electron-builder&quot; &#125; 其他平台 // mac &quot;mac&quot;: &#123; &quot;category&quot;: &quot;your.app.category.type&quot; &#125; // linux &quot;linux&quot;: &#123; &quot;category&quot;: &quot;your.app.category.type&quot; &#125; …..待完成 与 Electron-parkager 的差异…..待完成2019&#x2F;6&#x2F;20","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Electron","slug":"Electron","permalink":"https://yogwang.site/tags/Electron/"}]},{"title":"Electron_02 - Electron-packager","slug":"Electron02-Electron-parkager","date":"2019-06-18T02:58:51.000Z","updated":"2026-01-05T05:39:58.470Z","comments":true,"path":"2019/Electron02-Electron-parkager/","permalink":"https://yogwang.site/2019/Electron02-Electron-parkager/","excerpt":"安装 Electron-packager 需要 Node.js 6.0 或更高版本 npm install electron-packager --save-dev electron-packager API 使用命令行打包electron-packager &lt;sourcedir&gt; &lt;appname&gt; --platform=&lt;platform&gt; --arch=&lt;arch&gt; [optional flags...] 必需参数 sourcedir - 应用程序源","text":"安装 Electron-packager 需要 Node.js 6.0 或更高版本 npm install electron-packager --save-dev electron-packager API 使用命令行打包electron-packager &lt;sourcedir&gt; &lt;appname&gt; --platform=&lt;platform&gt; --arch=&lt;arch&gt; [optional flags...] 必需参数 sourcedir - 应用程序源 选项 appname - 应用名称 electron-version - Electron 版本号 (electron –version) platform - 要构建的平台 all,或者 darwin, linux, mas, win32 arch - 要使用的架构 all,或者 ia32, x64, armv7l, arm64, mips64el out - 输出目录 icon - 自定义图标路径 app-copyright 应用版权 app-version 应用版本 更多选项 添加 packager 脚本方便项目打包 &quot;scripts&quot;: &#123; &quot;packager&quot;: &quot;electron-packager ./ --platform=win32 --electron-version 5.0.3 --out ./dist&quot; &#125;, 极简打包 创建目标平台&#x2F;体系结构的所有有效组合的捆绑包 electron-packager ./ --all","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Electron","slug":"Electron","permalink":"https://yogwang.site/tags/Electron/"}]},{"title":"Git 关联到GigHub","slug":"git_connectToGitHub","date":"2019-06-17T07:36:06.000Z","updated":"2026-01-05T05:39:58.487Z","comments":true,"path":"2019/git_connectToGitHub/","permalink":"https://yogwang.site/2019/git_connectToGitHub/","excerpt":"创建 SSH Keygen使用ssh-keygen生成私钥和公钥 $ ssh-keygen -t rsa Generating public/private rsa key pair. Enter file in which to save the key (/c/Users/yog/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /c/Users/yog/.ssh/id_rsa. Your public key has been saved in /c/Users/yog/.ssh/id_rsa.pub. The key fingerprint is: SHA256:0ZYdnPILyMbV9xpgRE/hWf1MayqhoEYquZTuOMr8EcE yog@YOG-DESKTOP The key&#x27;s randomart image is: +---[RSA 3072]----+ | =+.o.o| | . .oo*=.oo| | E o.o++.o++o| | .. .=o... .o+| | o.o ..S ....oo | | = ..o . .... | |o o.. . | |=o . | |==.. | +----[SHA256]-----+","text":"创建 SSH Keygen使用ssh-keygen生成私钥和公钥 $ ssh-keygen -t rsa Generating public/private rsa key pair. Enter file in which to save the key (/c/Users/yog/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /c/Users/yog/.ssh/id_rsa. Your public key has been saved in /c/Users/yog/.ssh/id_rsa.pub. The key fingerprint is: SHA256:0ZYdnPILyMbV9xpgRE/hWf1MayqhoEYquZTuOMr8EcE yog@YOG-DESKTOP The key&#x27;s randomart image is: +---[RSA 3072]----+ | =+.o.o| | . .oo*=.oo| | E o.o++.o++o| | .. .=o... .o+| | o.o ..S ....oo | | = ..o . .... | |o o.. . | |=o . | |==.. | +----[SHA256]-----+ 找到 SSH 公钥输出内容，也可以用资源管理器打开复制 $ cd ~/.ssh $ pwd /c/Users/yog/.ssh $ cat id_rsa.pub ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDb9FSAEzrtUG9bJFt5oaDieFo6FeqBWB9ppX4VCqBnNxKvpnAZbJMjUjxHAIQEFSK2sD9NUXgyuKguilX6kRVGoTq15Lcf12nfqfjoGMUm3qAgNdZlkHPFk7WxBFquaalWV8OOOZNe45W2YcbzPucQMt54iiGSYzuAQLbMW/5rn2uF4HPrQNeMmduIvNZ8BxK4gS60IyjnEPTZbyG3RfJ0K5FQBN6wudoSWZZCU4UTcOjFhLRQ3I/p5OQTSKXnbBhpoX7nD42Xohijt2xB5GhdLrh42E28AEORchaMJ7OxqenT4U+BDdhQPk87ZBpB254Cv5RCvj60dJv5VjE/kTx4bCKslv9kgtV4INyUNPWlDAPhe6dmW1L+9Cl5QUYPvhjlXLLpcXoqne3OlPcS33UwJE0H/6++TusANaMTAXxPofD9XCgK/ipCNtT+YPxiyWIVJKgVUJ7NKAoieNOqXVN5d09ts/hSM5CtBXFbKnFGrPEr9zGiUhfe7HM0gRpWMV0= yog@YOG-DESKTOP 复制输出的全部公钥内容 开坑多个 SSH_Key 多个 GitHub 账户ssh-keygen -t rsa -C &quot;Exam@email.com&quot; -f ~/.ssh/id_rsa_for_Exam 在 GitHub 上添加 SSH key登陆 GitHub ,点击右上角头像，在弹出的菜单中选择 Settings 进入设置页 在右侧 Personal settings 中选择 SSH and GPG keys 点击 New SSH key，在 Key 中粘贴复制的公钥内容,然后 Add SSH key 完成 SSH key 添加 创建 GitHub 仓库同样点击右上角头像，在弹出的菜单中选择 Your repositories 进入资源库页 在页面中间靠右点击 New 按钮 输入 Repository name 然后点击 Create repository 按钮 Description:可选输入一段描述，仓库选择 Public 和 Private 都可以。 资源库创建完成后，复制页面中的 git remote add 命令，回到 Git Bash 回创建的本地 Git 库中，运行复制的 git remote add 命令，关联本地库到 GitHub 远程库上 $ cd E:/GitLibrary/git_demo $ git remote add origin git@github.com:yogwang/demo_repositories.git 使用 git push 命令把本地库的所有内容推送到远程库上 git push -u origin master 然后刷新 GitHub 库页面就可以看到上传的本地库文件了","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://yogwang.site/tags/Git/"}]},{"title":"Git 查看提交日志","slug":"git_log","date":"2019-06-17T07:33:26.000Z","updated":"2026-01-05T05:39:58.489Z","comments":true,"path":"2019/git_log/","permalink":"https://yogwang.site/2019/git_log/","excerpt":"git log基础查看提交日志 $ git log commit 2c8fcc81f23aa96073250e1d052473337c968d88 (HEAD -&gt; master, origin/master) Author: yogwang &lt;yogwang@yog.red&gt; Date: Mon Jun 17 12:10:01 2019 +0800 wrote a readme file commit 87c9d12bdd979859811fc224c7f9ade7b97b0d13 Author: yogwang &lt;yogwang@yog.red&gt; Date: Mon Jun 17 09:52:50 2019 +0800 add distributed commit 77ac9552a7fb2e8d1f57d324d991de11efa897f2 Author: yogwang &lt;yogwang@yog.red&gt; Date: Mon Jun 17 09:50:33 2019 +0800 wrote a readme file","text":"git log基础查看提交日志 $ git log commit 2c8fcc81f23aa96073250e1d052473337c968d88 (HEAD -&gt; master, origin/master) Author: yogwang &lt;yogwang@yog.red&gt; Date: Mon Jun 17 12:10:01 2019 +0800 wrote a readme file commit 87c9d12bdd979859811fc224c7f9ade7b97b0d13 Author: yogwang &lt;yogwang@yog.red&gt; Date: Mon Jun 17 09:52:50 2019 +0800 add distributed commit 77ac9552a7fb2e8d1f57d324d991de11efa897f2 Author: yogwang &lt;yogwang@yog.red&gt; Date: Mon Jun 17 09:50:33 2019 +0800 wrote a readme file git log --oneline精简模式显示 $ git log --oneline 2c8fcc8 (HEAD -&gt; master, origin/master) wrote a readme file 87c9d12 add distributed 77ac955 wrote a readme file git log --pretty=oneline精简模式并显示完整版本号 $ git log --pretty=oneline 2c8fcc81f23aa96073250e1d052473337c968d88 (HEAD -&gt; master, origin/master) wrote a readme file 87c9d12bdd979859811fc224c7f9ade7b97b0d13 add distributed 77ac9552a7fb2e8d1f57d324d991de11efa897f2 wrote a readme file git log --graph图形模式显示 $ git log --graph * commit 2c8fcc81f23aa96073250e1d052473337c968d88 (HEAD -&gt; master, origin/master) | Author: yogwang &lt;yogwang@yog.red&gt; | Date: Mon Jun 17 12:10:01 2019 +0800 | | wrote a readme file | * commit 87c9d12bdd979859811fc224c7f9ade7b97b0d13 | Author: yogwang &lt;yogwang@yog.red&gt; | Date: Mon Jun 17 09:52:50 2019 +0800 | | add distributed | * commit 77ac9552a7fb2e8d1f57d324d991de11efa897f2 Author: yogwang &lt;yogwang@yog.red&gt; Date: Mon Jun 17 09:50:33 2019 +0800 wrote a readme file git log --stat显示文件更改列表 $ git log --stat commit 2c8fcc81f23aa96073250e1d052473337c968d88 (HEAD -&gt; master, origin/master) Author: yogwang &lt;yogwang@yog.red&gt; Date: Mon Jun 17 12:10:01 2019 +0800 wrote a readme file demo/reademe.txt | 2 ++ 1 file changed, 2 insertions(+) commit 87c9d12bdd979859811fc224c7f9ade7b97b0d13 Author: yogwang &lt;yogwang@yog.red&gt; Date: Mon Jun 17 09:52:50 2019 +0800 add distributed readme.txt | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) commit 77ac9552a7fb2e8d1f57d324d991de11efa897f2 Author: yogwang &lt;yogwang@yog.red&gt; Date: Mon Jun 17 09:50:33 2019 +0800 wrote a readme file readme.txt | 2 ++ 1 file changed, 2 insertions(+) git log --author=_name根据作者筛选 _name：作者名 $ git log --author=yogwang commit 2c8fcc81f23aa96073250e1d052473337c968d88 (HEAD -&gt; master, origin/master) Author: yogwang &lt;yogwang@yog.red&gt; Date: Mon Jun 17 12:10:01 2019 +0800 wrote a readme file commit 87c9d12bdd979859811fc224c7f9ade7b97b0d13 Author: yogwang &lt;yogwang@yog.red&gt; Date: Mon Jun 17 09:52:50 2019 +0800 add distributed commit 77ac9552a7fb2e8d1f57d324d991de11efa897f2 Author: yogwang &lt;yogwang@yog.red&gt; Date: Mon Jun 17 09:50:33 2019 +0800 wrote a readme file git log -p file_name查看某个文件的详细修改 有详细内容 file_name：文件名 $ git log -p readme.txt commit 87c9d12bdd979859811fc224c7f9ade7b97b0d13 Author: yogwang &lt;yogwang@yog.red&gt; Date: Mon Jun 17 09:52:50 2019 +0800 add distributed diff --git a/readme.txt b/readme.txt index d8036c1..013b5bc 100644 --- a/readme.txt +++ b/readme.txt @@ -1,2 +1,2 @@ -Git is a version control system. +Git is a distributed version control system. Git is free software. \\ No newline at end of file commit 77ac9552a7fb2e8d1f57d324d991de11efa897f2 Author: yogwang &lt;yogwang@yog.red&gt; Date: Mon Jun 17 09:50:33 2019 +0800 wrote a readme file diff --git a/readme.txt b/readme.txt new file mode 100644 index 0000000..d8036c1 --- /dev/null +++ b/readme.txt @@ -0,0 +1,2 @@ +Git is a version control system. +Git is free software. \\ No newline at end of file git log -L start,end:file_name查看某个文件某几行范围内的修改记录 start:开始行号 end:结束行号 file_name:文件名 $ git log -L 1,2:readme.txt commit 87c9d12bdd979859811fc224c7f9ade7b97b0d13 Author: yogwang &lt;yogwang@yog.red&gt; Date: Mon Jun 17 09:52:50 2019 +0800 add distributed diff --git a/readme.txt b/readme.txt --- a/readme.txt +++ b/readme.txt @@ -1,2 +1,2 @@ -Git is a version control system. +Git is a distributed version control system. Git is free software. \\ No newline at end of file commit 77ac9552a7fb2e8d1f57d324d991de11efa897f2 Author: yogwang &lt;yogwang@yog.red&gt; Date: Mon Jun 17 09:50:33 2019 +0800 wrote a readme file diff --git a/readme.txt b/readme.txt --- /dev/null +++ b/readme.txt @@ -0,0 +1,2 @@ +Git is a version control system. +Git is free software. \\ No newline at end of file git log --stat commit_id根本版本号查看提交修改列表 commit_id：提交版本号 $ git log --stat 77ac commit 77ac9552a7fb2e8d1f57d324d991de11efa897f2 Author: yogwang &lt;yogwang@yog.red&gt; Date: Mon Jun 17 09:50:33 2019 +0800 wrote a readme file readme.txt | 2 ++ 1 file changed, 2 insertions(+)","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://yogwang.site/tags/Git/"}]},{"title":"Git 操作命令","slug":"git_common","date":"2019-06-17T07:16:51.000Z","updated":"2026-01-05T05:39:58.487Z","comments":true,"path":"2019/git_common/","permalink":"https://yogwang.site/2019/git_common/","excerpt":"添加文件到仓库 git add$ git add * 提交文件到仓库 git commit$ git commit -m &quot;Here is the message&quot; commit 命令可以提交多个之前 add 的文件 $ git add file1.txt $ git add file2.txt file3.txt $ git commit -m &quot;add 3 files.&quot;","text":"添加文件到仓库 git add$ git add * 提交文件到仓库 git commit$ git commit -m &quot;Here is the message&quot; commit 命令可以提交多个之前 add 的文件 $ git add file1.txt $ git add file2.txt file3.txt $ git commit -m &quot;add 3 files.&quot; 查看当前仓库状态 git status没有需要提交的修改 $ git status On branch master nothing to commit, working tree clean 文件有修改 $ git status On branch master Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.txt no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 查看差异 git diff$ git diff readme.txt diff --git a/readme.txt b/readme.txt index 46d49bf..9247db6 100644 --- a/readme.txt +++ b/readme.txt @@ -1,2 +1,2 @@ -Git is a version control system. +Git is a distributed version control system. Git is free software. 查看日志 git log 详细 git log 查看提交日志 git log --oneline 精简模式显示 git log --pretty=oneline 精简模式并显示完整版本号 git log --graph 图形模式显示 git log --stat 显示文件更改列表 git log --author=_name 根据作者筛选 git log -p file_name 查看某个文件的详细修改 git log -L start,end:file_name 查看文件某行范围内的修改记录 git log --stat commit_id 根本版本号查看提交修改列表 版本退回 git reset 详细在 Git 中，用 HEAD 表示当前版本，也就是最新的提交版本 上一个版本就是 HEAD^ 上上一个版本就是 HEAD^^ 当然往上 n 个版本写 n 个^比较容易数不过来，所以写成 HEAD~n ~n 相当于连续的 n 个”^” git reset --hard HEAD^$ git reset --hard HEAD^ HEAD is now at e475afc add distributed git reset --hard commit_id也可以直接切换到某个版本，版本号可以不写全，前 4 位就可以了，Git 会自动去找，也可以 Tab 补全 查看操作日志 git reflog$ git reflog 77ac955 (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to HEAD~2 2c8fcc8 (origin/master) HEAD@&#123;1&#125;: commit: wrote a readme file 87c9d12 HEAD@&#123;2&#125;: commit: add distributed 77ac955 (HEAD -&gt; master) HEAD@&#123;3&#125;: commit (initial): wrote a readme file","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://yogwang.site/tags/Git/"}]},{"title":"Git 创建版本库","slug":"git_create","date":"2019-06-17T03:22:11.000Z","updated":"2026-01-05T05:39:58.489Z","comments":true,"path":"2019/git_create/","permalink":"https://yogwang.site/2019/git_create/","excerpt":"创建一个空目录$ mkdir git_demo $ cd git_demo 创建 Git 仓库进入目录后通过git init命令创建 Git 仓库 $ git init Initialized empty Git repository in E:/GitLibrary/git_demo/.git/","text":"创建一个空目录$ mkdir git_demo $ cd git_demo 创建 Git 仓库进入目录后通过git init命令创建 Git 仓库 $ git init Initialized empty Git repository in E:/GitLibrary/git_demo/.git/","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://yogwang.site/tags/Git/"}]},{"title":"安装 Git in windows","slug":"git_install","date":"2019-06-17T03:03:48.000Z","updated":"2026-01-05T05:39:58.489Z","comments":true,"path":"2019/git_install/","permalink":"https://yogwang.site/2019/git_install/","excerpt":"","text":"Git 官网：https://git-scm.com/ 设置提交时的 NAME 和 EMAIL：$ git config --global user.name &quot;nikename&quot; $ git config --global user.email &quot;example@example.com&quot; 查看设置的 NAME 和 EMAIL：$ git config user.name $ git config user.email","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://yogwang.site/tags/Git/"}]},{"title":"Electron_01 - 快速启动","slug":"Electron01-Electron-quick-start","date":"2019-06-14T09:33:33.000Z","updated":"2026-01-05T05:39:58.470Z","comments":true,"path":"2019/Electron01-Electron-quick-start/","permalink":"https://yogwang.site/2019/Electron01-Electron-quick-start/","excerpt":"自己创建 Electron 应用1. 使用 npm 初始化一个项目$ mkdir my-app $ cd my-app $ npm init --y Wrote to E:\\my-app\\package.json: &#123; &quot;name&quot;: &quot;my-app&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot; &#125; 修改入口文件为 main.js 并且添加 start 脚本引导 Node 来执行 Electron","text":"自己创建 Electron 应用1. 使用 npm 初始化一个项目$ mkdir my-app $ cd my-app $ npm init --y Wrote to E:\\my-app\\package.json: &#123; &quot;name&quot;: &quot;my-app&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot; &#125; 修改入口文件为 main.js 并且添加 start 脚本引导 Node 来执行 Electron 2. 安装 Electron 官方推荐的安装方法是把它作为应用中的开发依赖项，以在不同的应用中使用不同的 Electron 版本。 npm install electron --save-dev 3. 简易的 Electron 主进程1.在 min.js 中引入 Electron 使用所有 API 和功能 const electron = require(&#x27;electron&#x27;) 按需引入 const &#123; app, BrowserWindow &#125; = require(&#x27;electron&#x27;) Electron 模块所提供的功能都是通过命名空间暴露出来的 在应用程序准备就绪后打开一个窗口 function createWindow () &#123; // 创建浏览器窗口 let win = new BrowserWindow(&#123; width: 800, height: 600, webPreferences: &#123; nodeIntegration: true &#125; &#125;) // 加载index.html文件 win.loadFile(&#x27;index.html&#x27;) &#125; app.on(&#x27;ready&#x27;, createWindow) 完善上述例子，完善应用可能遇到的所有系统事件，那么一个简单的 main.js 就像下面这样： const &#123; app, BrowserWindow &#125; = require(&#x27;electron&#x27;) // 保持对window对象的全局引用，如果不这么做的话，当JavaScript对象被 // 垃圾回收的时候，window对象将会自动的关闭 let win function createWindow () &#123; // 创建浏览器窗口。 win = new BrowserWindow(&#123; width: 800, height: 600, webPreferences: &#123; nodeIntegration: true &#125; &#125;) // 加载index.html文件 win.loadFile(&#x27;index.html&#x27;) // 打开开发者工具 win.webContents.openDevTools() // 当 window 被关闭，这个事件会被触发。 win.on(&#x27;closed&#x27;, () =&gt; &#123; // 取消引用 window 对象，如果你的应用支持多窗口的话， // 通常会把多个 window 对象存放在一个数组里面， // 与此同时，你应该删除相应的元素。 win = null &#125;) &#125; // Electron 会在初始化后并准备 // 创建浏览器窗口时，调用这个函数。 // 部分 API 在 ready 事件触发后才能使用。 app.on(&#x27;ready&#x27;, createWindow) // 当全部窗口关闭时退出。 app.on(&#x27;window-all-closed&#x27;, () =&gt; &#123; // 在 macOS 上，除非用户用 Cmd + Q 确定地退出， // 否则绝大部分应用及其菜单栏会保持激活。 if (process.platform !== &#x27;darwin&#x27;) &#123; app.quit() &#125; &#125;) app.on(&#x27;activate&#x27;, () =&gt; &#123; // 在macOS上，当单击dock图标并且没有其他窗口打开时， // 通常在应用程序中重新创建一个窗口。 if (win === null) &#123; createWindow() &#125; &#125;) // 在这个文件中，你可以续写应用剩下主进程代码。 // 也可以拆分成几个文件，然后用 require 导入。 4. 创建想展示的 index.html&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Hello World!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello World!&lt;/h1&gt; We are using node &lt;script&gt;document.write(process.versions.node)&lt;/script&gt;, Chrome &lt;script&gt;document.write(process.versions.chrome)&lt;/script&gt;, and Electron &lt;script&gt;document.write(process.versions.electron)&lt;/script&gt;. &lt;/body&gt; &lt;/html&gt; 5. 启动应用创建并初始化完成 main.js 、 index.html 和 package.json 之后，就可以在当前工程的根目录执行 npm start 命令来启动刚刚编写好的 Electron 应用了。 $ npm start &gt; my-app@1.0.0 start E:\\my-app &gt; electron . 基础结构所以一个最基础的 Electron 应用 应有以下目录结构： my-app/ ├── package.json ├── main.js └── index.html 快速启动官方 DEMO Electron-quick-start# 克隆示例项目的仓库 $ git clone https://github.com/electron/electron-quick-start # 进入这个仓库 $ cd electron-quick-start # 安装依赖并运行 $ npm install &amp;&amp; npm start 使用 Electron-forge 创建项目$ npm i -g @electron-forge/cli $ electron-forge init my-app $ cd my-app $ npm start","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Electron","slug":"Electron","permalink":"https://yogwang.site/tags/Electron/"}]}],"categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://yogwang.site/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"},{"name":"代码之外","slug":"代码之外","permalink":"https://yogwang.site/categories/%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://yogwang.site/tags/HTML/"},{"name":"VueJS","slug":"VueJS","permalink":"https://yogwang.site/tags/VueJS/"},{"name":"VSCode","slug":"VSCode","permalink":"https://yogwang.site/tags/VSCode/"},{"name":"Cursor","slug":"Cursor","permalink":"https://yogwang.site/tags/Cursor/"},{"name":"DevTools","slug":"DevTools","permalink":"https://yogwang.site/tags/DevTools/"},{"name":"CSS","slug":"CSS","permalink":"https://yogwang.site/tags/CSS/"},{"name":"面试","slug":"面试","permalink":"https://yogwang.site/tags/%E9%9D%A2%E8%AF%95/"},{"name":"AI","slug":"AI","permalink":"https://yogwang.site/tags/AI/"},{"name":"总结","slug":"总结","permalink":"https://yogwang.site/tags/%E6%80%BB%E7%BB%93/"},{"name":"V2EX","slug":"V2EX","permalink":"https://yogwang.site/tags/V2EX/"},{"name":"VibeCoding","slug":"VibeCoding","permalink":"https://yogwang.site/tags/VibeCoding/"},{"name":"播客","slug":"播客","permalink":"https://yogwang.site/tags/%E6%92%AD%E5%AE%A2/"},{"name":"挖坑","slug":"挖坑","permalink":"https://yogwang.site/tags/%E6%8C%96%E5%9D%91/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://yogwang.site/tags/TypeScript/"},{"name":"Git","slug":"Git","permalink":"https://yogwang.site/tags/Git/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://yogwang.site/tags/JavaScript/"},{"name":"Day.js","slug":"Day-js","permalink":"https://yogwang.site/tags/Day-js/"},{"name":"ElementUI","slug":"ElementUI","permalink":"https://yogwang.site/tags/ElementUI/"},{"name":"Debug","slug":"Debug","permalink":"https://yogwang.site/tags/Debug/"},{"name":"ExcelJS","slug":"ExcelJS","permalink":"https://yogwang.site/tags/ExcelJS/"},{"name":"uni-app","slug":"uni-app","permalink":"https://yogwang.site/tags/uni-app/"},{"name":"L10n","slug":"L10n","permalink":"https://yogwang.site/tags/L10n/"},{"name":"Nginx","slug":"Nginx","permalink":"https://yogwang.site/tags/Nginx/"},{"name":"SCSS","slug":"SCSS","permalink":"https://yogwang.site/tags/SCSS/"},{"name":"Webpack","slug":"Webpack","permalink":"https://yogwang.site/tags/Webpack/"},{"name":"VueCLI","slug":"VueCLI","permalink":"https://yogwang.site/tags/VueCLI/"},{"name":"AstroJS","slug":"AstroJS","permalink":"https://yogwang.site/tags/AstroJS/"},{"name":"社群分享","slug":"社群分享","permalink":"https://yogwang.site/tags/%E7%A4%BE%E7%BE%A4%E5%88%86%E4%BA%AB/"},{"name":"rrweb","slug":"rrweb","permalink":"https://yogwang.site/tags/rrweb/"},{"name":"VueUse","slug":"VueUse","permalink":"https://yogwang.site/tags/VueUse/"},{"name":"exceljs","slug":"exceljs","permalink":"https://yogwang.site/tags/exceljs/"},{"name":"Coding","slug":"Coding","permalink":"https://yogwang.site/tags/Coding/"},{"name":"i18n","slug":"i18n","permalink":"https://yogwang.site/tags/i18n/"},{"name":"NPM","slug":"NPM","permalink":"https://yogwang.site/tags/NPM/"},{"name":"Chrome","slug":"Chrome","permalink":"https://yogwang.site/tags/Chrome/"},{"name":"Cache","slug":"Cache","permalink":"https://yogwang.site/tags/Cache/"},{"name":"Service Worker","slug":"Service-Worker","permalink":"https://yogwang.site/tags/Service-Worker/"},{"name":"MSEdge","slug":"MSEdge","permalink":"https://yogwang.site/tags/MSEdge/"},{"name":"NVS","slug":"NVS","permalink":"https://yogwang.site/tags/NVS/"},{"name":"Node.js","slug":"Node-js","permalink":"https://yogwang.site/tags/Node-js/"},{"name":"Ant-Design-Vue","slug":"Ant-Design-Vue","permalink":"https://yogwang.site/tags/Ant-Design-Vue/"},{"name":"uViewUI","slug":"uViewUI","permalink":"https://yogwang.site/tags/uViewUI/"},{"name":"ECMAScript 8","slug":"ECMAScript-8","permalink":"https://yogwang.site/tags/ECMAScript-8/"},{"name":"学习","slug":"学习","permalink":"https://yogwang.site/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"小程序","slug":"小程序","permalink":"https://yogwang.site/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"SEO","slug":"SEO","permalink":"https://yogwang.site/tags/SEO/"},{"name":"Hexo","slug":"Hexo","permalink":"https://yogwang.site/tags/Hexo/"},{"name":"未完成","slug":"未完成","permalink":"https://yogwang.site/tags/%E6%9C%AA%E5%AE%8C%E6%88%90/"},{"name":"ECMAScript 6","slug":"ECMAScript-6","permalink":"https://yogwang.site/tags/ECMAScript-6/"},{"name":"Gulp","slug":"Gulp","permalink":"https://yogwang.site/tags/Gulp/"},{"name":"情感","slug":"情感","permalink":"https://yogwang.site/tags/%E6%83%85%E6%84%9F/"},{"name":"设计模式","slug":"设计模式","permalink":"https://yogwang.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"RaspberryPi","slug":"RaspberryPi","permalink":"https://yogwang.site/tags/RaspberryPi/"},{"name":"NVM","slug":"NVM","permalink":"https://yogwang.site/tags/NVM/"},{"name":"Caddy","slug":"Caddy","permalink":"https://yogwang.site/tags/Caddy/"},{"name":"Server","slug":"Server","permalink":"https://yogwang.site/tags/Server/"},{"name":"DigitalOcean","slug":"DigitalOcean","permalink":"https://yogwang.site/tags/DigitalOcean/"},{"name":"Jeecg-boot","slug":"Jeecg-boot","permalink":"https://yogwang.site/tags/Jeecg-boot/"},{"name":"ReactJS","slug":"ReactJS","permalink":"https://yogwang.site/tags/ReactJS/"},{"name":"ESlint","slug":"ESlint","permalink":"https://yogwang.site/tags/ESlint/"},{"name":"Github","slug":"Github","permalink":"https://yogwang.site/tags/Github/"},{"name":"年会开发日记","slug":"年会开发日记","permalink":"https://yogwang.site/tags/%E5%B9%B4%E4%BC%9A%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0/"},{"name":"WebSocket","slug":"WebSocket","permalink":"https://yogwang.site/tags/WebSocket/"},{"name":"PHP","slug":"PHP","permalink":"https://yogwang.site/tags/PHP/"},{"name":"PHPOK","slug":"PHPOK","permalink":"https://yogwang.site/tags/PHPOK/"},{"name":"Canvas","slug":"Canvas","permalink":"https://yogwang.site/tags/Canvas/"},{"name":"Three.js","slug":"Three-js","permalink":"https://yogwang.site/tags/Three-js/"},{"name":"web","slug":"web","permalink":"https://yogwang.site/tags/web/"},{"name":"Vue-Router","slug":"Vue-Router","permalink":"https://yogwang.site/tags/Vue-Router/"},{"name":"tinyMCE","slug":"tinyMCE","permalink":"https://yogwang.site/tags/tinyMCE/"},{"name":"Axios","slug":"Axios","permalink":"https://yogwang.site/tags/Axios/"},{"name":"Apache","slug":"Apache","permalink":"https://yogwang.site/tags/Apache/"},{"name":"Electron","slug":"Electron","permalink":"https://yogwang.site/tags/Electron/"},{"name":"BetterScrol.js","slug":"BetterScrol-js","permalink":"https://yogwang.site/tags/BetterScrol-js/"},{"name":"问题","slug":"问题","permalink":"https://yogwang.site/tags/%E9%97%AE%E9%A2%98/"}]}